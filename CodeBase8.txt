useExport.ts
---------------------------

import { useState, useCallback } from 'react';
import { FileSystemStorageService } from '../services/storage/FileSystemStorageService';
import { PipelineConfiguration } from '../types/framework';
import { CSDateUtils } from '../core/utils/CSDateUtils';
import { CSTextUtils } from '../core/utils/CSTextUtils';
import { CSEncryptionUtils } from '../core/utils/CSEncryptionUtils';

/**
 * Hook for export-related functionality
 */
export const useExport = () => {
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  
  // Create an instance of the storage service
  const storageService = new FileSystemStorageService();
  
  /**
   * Load a template file
   * @param templatePath Path to the template file
   * @returns Template content as a string
   */
  const loadTemplate = useCallback(async (templatePath: string): Promise<string> => {
    setIsLoading(true);
    setError(null);
    
    try {
      // Load template from storage
      const templateContent = await storageService.readFile(`templates/${templatePath}`);
      
      setIsLoading(false);
      return templateContent;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      setError(`Failed to load template: ${errorMessage}`);
      setIsLoading(false);
      throw err;
    }
  }, []);
  
  /**
   * Generate a pipeline configuration file based on the provided configuration
   * @param pipelineConfig Pipeline configuration
   * @returns Generated pipeline content as a string
   */
  const generatePipeline = useCallback(async (pipelineConfig: PipelineConfiguration): Promise<string> => {
    setIsLoading(true);
    setError(null);
    
    try {
      // Get template filename
      const templateFileName = getTemplateFileName(
        pipelineConfig.framework,
        pipelineConfig.language,
        pipelineConfig.testType,
        pipelineConfig.provider
      );
      
      // Load template content
      const templateContent = await loadTemplate(`pipeline/${templateFileName}`);
      
      // Process template with configuration
      const processedContent = processTemplate(templateContent, pipelineConfig);
      
      setIsLoading(false);
      return processedContent;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      setError(`Failed to generate pipeline: ${errorMessage}`);
      setIsLoading(false);
      throw err;
    }
  }, [loadTemplate]);
  
  /**
   * Export a complete project with the given configuration
   * @param projectName Project name
   * @param pipelineConfig Pipeline configuration
   * @returns Path to the exported project
   */
  const exportProject = useCallback(async (
    projectName: string,
    pipelineConfig: PipelineConfiguration
  ): Promise<string> => {
    setIsLoading(true);
    setError(null);
    
    try {
      // Generate project structure based on framework, language, and test type
      const projectTemplatePath = `projects/${pipelineConfig.framework}/${pipelineConfig.language}/${pipelineConfig.testType}`;
      
      // Create project directory
      const sanitizedProjectName = projectName.replace(/\s+/g, '_').toLowerCase();
      const projectPath = `exports/${sanitizedProjectName}_${CSDateUtils.getCurrentTimestamp()}`;
      await storageService.createDirectory(projectPath);
      
      // Get list of template files
      const templateFiles = await storageService.listFiles(projectTemplatePath);
      
      // Process and copy each template file to the project directory
      for (const templateFile of templateFiles) {
        const templateContent = await loadTemplate(`${projectTemplatePath}/${templateFile}`);
        const processedContent = processTemplate(templateContent, pipelineConfig);
        
        // Determine the destination path
        let destPath = templateFile;
        if (templateFile.endsWith('.template')) {
          destPath = templateFile.replace('.template', '');
        }
        
        // Write the processed file to the project directory
        await storageService.writeFile(`${projectPath}/${destPath}`, processedContent);
      }
      
      // Generate pipeline file
      const pipelineContent = await generatePipeline(pipelineConfig);
      
      // Determine pipeline filename
      let pipelineFilename = 'azure-pipelines.yml';
      
      if (pipelineConfig.provider === 'github') {
        pipelineFilename = '.github/workflows/main.yml';
        await storageService.createDirectory(`${projectPath}/.github/workflows`);
      } else if (pipelineConfig.provider === 'jenkins') {
        pipelineFilename = 'Jenkinsfile';
      } else if (pipelineConfig.provider === 'gitlab') {
        pipelineFilename = '.gitlab-ci.yml';
      } else if (pipelineConfig.provider === 'circle') {
        pipelineFilename = '.circleci/config.yml';
        await storageService.createDirectory(`${projectPath}/.circleci`);
      }
      
      // Write pipeline file
      await storageService.writeFile(`${projectPath}/${pipelineFilename}`, pipelineContent);
      
      // Generate README file
      const readmeContent = generateReadme(projectName, pipelineConfig);
      await storageService.writeFile(`${projectPath}/README.md`, readmeContent);
      
      setIsLoading(false);
      return projectPath;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      setError(`Failed to export project: ${errorMessage}`);
      setIsLoading(false);
      throw err;
    }
  }, [loadTemplate, generatePipeline]);
  
  /**
   * Get template filename based on framework, language, test type, and provider
   */
  const getTemplateFileName = (
    framework: string,
    language: string,
    testType: string,
    provider: string
  ): string => {
    if (provider === 'azure') {
      return `${language}_${framework}_${testType}.yml`;
    } else if (provider === 'github') {
      return `github_${language}_${framework}_${testType}.yml`;
    } else if (provider === 'jenkins') {
      return `jenkins_${language}_${framework}_${testType}.Jenkinsfile`;
    } else if (provider === 'gitlab') {
      return `gitlab_${language}_${framework}_${testType}.yml`;
    } else if (provider === 'circle') {
      return `circle_${language}_${framework}_${testType}.yml`;
    } else {
      throw new Error(`Unsupported provider: ${provider}`);
    }
  };
  
  /**
   * Process a template with the provided configuration
   * @param templateContent Template content
   * @param config Pipeline configuration
   * @returns Processed template content
   */
  const processTemplate = (templateContent: string, config: PipelineConfiguration): string => {
    let processedContent = templateContent;
    
    // Replace basic placeholders
    processedContent = processedContent.replace(/\${name}/g, config.name);
    processedContent = processedContent.replace(/\${framework}/g, config.framework);
    processedContent = processedContent.replace(/\${language}/g, config.language);
    processedContent = processedContent.replace(/\${testType}/g, config.testType);
    processedContent = processedContent.replace(/\${projectName}/g, config.name.replace(/\s+/g, '_').toLowerCase());
    processedContent = processedContent.replace(/\${timestamp}/g, CSDateUtils.getCurrentTimestamp());
    
    // Replace branch triggers
    if (config.branches && config.branches.length > 0) {
      if (config.provider === 'azure') {
        const branchesYaml = config.branches.map(branch => `    - ${branch}`).join('\n');
        processedContent = processedContent.replace(/\${branches}/g, branchesYaml);
      } else if (config.provider === 'github') {
        const branchesYaml = config.branches.map(branch => `      - ${branch}`).join('\n');
        processedContent = processedContent.replace(/\${branches}/g, branchesYaml);
      } else if (config.provider === 'gitlab' || config.provider === 'circle') {
        const branchesStr = config.branches.join(' ');
        processedContent = processedContent.replace(/\${branches}/g, branchesStr);
      } else if (config.provider === 'jenkins') {
        const branchesJenkins = config.branches.map(branch => `'${branch}'`).join(', ');
        processedContent = processedContent.replace(/\${branches}/g, branchesJenkins);
      }
    }
    
    // Replace environment variables
    if (config.variables && config.variables.length > 0) {
      if (config.provider === 'azure') {
        const variablesYaml = config.variables.map(variable => {
          if (variable.isSecret) {
            return `  ${variable.name}: ${{ variables.${variable.name} }} # Secret variable, defined in Azure DevOps`;
          } else {
            return `  ${variable.name}: "${variable.value}"`;
          }
        }).join('\n');
        processedContent = processedContent.replace(/\${variables}/g, variablesYaml);
      } else if (config.provider === 'github') {
        const variablesYaml = config.variables.map(variable => {
          if (variable.isSecret) {
            return `      ${variable.name}: ${{ secrets.${variable.name} }}`;
          } else {
            return `      ${variable.name}: "${variable.value}"`;
          }
        }).join('\n');
        processedContent = processedContent.replace(/\${variables}/g, variablesYaml);
      } else if (config.provider === 'gitlab') {
        const variablesYaml = config.variables.map(variable => {
          if (variable.isSecret) {
            return `  ${variable.name}: $${variable.name}`;
          } else {
            return `  ${variable.name}: "${variable.value}"`;
          }
        }).join('\n');
        processedContent = processedContent.replace(/\${variables}/g, variablesYaml);
      } else if (config.provider === 'jenkins') {
        const variablesJenkins = config.variables.map(variable => {
          if (variable.isSecret) {
            return `    ${variable.name} = credentials('${variable.name}')`;
          } else {
            return `    ${variable.name} = "${variable.value}"`;
          }
        }).join('\n');
        processedContent = processedContent.replace(/\${variables}/g, variablesJenkins);
      } else if (config.provider === 'circle') {
        const variablesCircle = config.variables.map(variable => {
          if (variable.isSecret) {
            return `          ${variable.name}: \${${variable.name}}`;
          } else {
            return `          ${variable.name}: "${variable.value}"`;
          }
        }).join('\n');
        processedContent = processedContent.replace(/\${variables}/g, variablesCircle);
      }
    } else {
      // No variables defined, remove the section
      const regexMap = {
        azure: /variables:\n\${variables}/g,
        github: /env:\n\${variables}/g,
        gitlab: /variables:\n\${variables}/g,
        jenkins: /environment {\n\${variables}\n\s+}/g,
        circle: /environment:\n\${variables}/g
      };
      
      const regex = regexMap[config.provider as keyof typeof regexMap];
      if (regex) {
        processedContent = processedContent.replace(regex, '');
      }
    }
    
    // Replace browser configurations
    if (config.browsers && config.browsers.length > 0) {
      const browsersStr = config.browsers.join(',');
      processedContent = processedContent.replace(/\${browsers}/g, browsersStr);
      
      // Generate browser matrix for parallel execution
      if (config.executionMode === 'parallel') {
        if (config.provider === 'azure') {
          const matrixYaml = config.browsers.map(browser => `      ${browser}: { browser: '${browser}' }`).join('\n');
          processedContent = processedContent.replace(/\${browserMatrix}/g, matrixYaml);
        } else if (config.provider === 'github') {
          const matrixJson = `[${config.browsers.map(browser => `"${browser}"`).join(', ')}]`;
          processedContent = processedContent.replace(/\${browserMatrix}/g, matrixJson);
        } else if (config.provider === 'gitlab') {
          const matrixYaml = config.browsers.map(browser => 
            `test:${browser}:\n  extends: .test\n  variables:\n    BROWSER: ${browser}`
          ).join('\n\n');
          processedContent = processedContent.replace(/\${browserMatrix}/g, matrixYaml);
        } else if (config.provider === 'jenkins') {
          const matrixJenkins = `matrix {\n      agent {\n        label 'docker'\n      }\n      axes {\n        values 'browser', ${config.browsers.map(b => `'${b}'`).join(', ')}\n      }\n    }`;
          processedContent = processedContent.replace(/\${browserMatrix}/g, matrixJenkins);
        } else if (config.provider === 'circle') {
          const matrixCircle = config.browsers.map(browser => 
            `      - test-${browser}:\n          matrix:\n            parameters:\n              browser: ["${browser}"]`
          ).join('\n');
          processedContent = processedContent.replace(/\${browserMatrix}/g, matrixCircle);
        }
      } else {
        // Sequential execution, replace matrix placeholders with empty string
        processedContent = processedContent.replace(/\${browserMatrix}/g, '');
      }
    }
    
    // Replace timeout settings
    processedContent = processedContent.replace(/\${timeout}/g, config.timeout.toString());
    
    // Handle reporting options
    if (config.reportingEnabled) {
      processedContent = processedContent.replace(/\${reporting}/g, 'true');
      // Replace reporting specific sections if needed
    } else {
      processedContent = processedContent.replace(/\${reporting}/g, 'false');
      // Remove reporting specific sections if needed
      const regexMap = {
        azure: /# Publish test results[\s\S]*?(?=# End publish test results)/g,
        github: /# Publish test results[\s\S]*?(?=# End publish test results)/g,
        gitlab: /# Publish test results[\s\S]*?(?=# End publish test results)/g,
        jenkins: /\/\/ Publish test results[\s\S]*?(?=\/\/ End publish test results)/g,
        circle: /# Publish test results[\s\S]*?(?=# End publish test results)/g
      };
      
      const regex = regexMap[config.provider as keyof typeof regexMap];
      if (regex) {
        processedContent = processedContent.replace(regex, '');
      }
    }
    
    // Handle notifications
    if (config.notificationsEnabled) {
      processedContent = processedContent.replace(/\${notifications}/g, 'true');
      // Replace notification specific sections if needed
    } else {
      processedContent = processedContent.replace(/\${notifications}/g, 'false');
      // Remove notification specific sections if needed
      const regexMap = {
        azure: /# Send notifications[\s\S]*?(?=# End notifications)/g,
        github: /# Send notifications[\s\S]*?(?=# End notifications)/g,
        gitlab: /# Send notifications[\s\S]*?(?=# End notifications)/g,
        jenkins: /\/\/ Send notifications[\s\S]*?(?=\/\/ End notifications)/g,
        circle: /# Send notifications[\s\S]*?(?=# End notifications)/g
      };
      
      const regex = regexMap[config.provider as keyof typeof regexMap];
      if (regex) {
        processedContent = processedContent.replace(regex, '');
      }
    }
    
    // Handle schedules
    if (config.schedules && config.schedules.length > 0) {
      if (config.provider === 'azure') {
        const schedulesYaml = config.schedules.map(schedule => 
          `  - cron: "${schedule.cron}"\n    displayName: "${schedule.description}"\n    branches:\n      include:${config.branches.map(branch => `\n        - ${branch}`).join('')}\n    always: ${schedule.enabled}`
        ).join('\n');
        processedContent = processedContent.replace(/\${schedules}/g, schedulesYaml);
      } else if (config.provider === 'github') {
        const schedulesYaml = config.schedules.map(schedule => 
          `    - cron: "${schedule.cron}"`
        ).join('\n');
        processedContent = processedContent.replace(/\${schedules}/g, schedulesYaml);
      } else if (config.provider === 'gitlab') {
        // GitLab uses only one schedule in the config
        const firstSchedule = config.schedules[0];
        processedContent = processedContent.replace(/\${schedule}/g, firstSchedule.cron);
      } else if (config.provider === 'jenkins') {
        const schedulesJenkins = config.schedules.map(schedule => 
          `    cron('${schedule.cron}')`
        ).join('\n');
        processedContent = processedContent.replace(/\${schedules}/g, schedulesJenkins);
      } else if (config.provider === 'circle') {
        const schedulesCircle = config.schedules.map(schedule => 
          `      - schedule:\n          cron: "${schedule.cron}"\n          filters:\n            branches:\n              only:${config.branches.map(branch => `\n                - ${branch}`).join('')}`
        ).join('\n');
        processedContent = processedContent.replace(/\${schedules}/g, schedulesCircle);
      }
    } else {
      // No schedules defined, remove the section
      const regexMap = {
        azure: /schedules:[\s\S]*?\${schedules}[\s\S]*?(?=trigger:)/g,
        github: /schedule:[\s\S]*?\${schedules}[\s\S]*?(?=jobs:)/g,
        gitlab: /schedule:[\s\S]*?\${schedule}[\s\S]*?(?=workflow:)/g,
        jenkins: /triggers {\n[\s\S]*?\${schedules}[\s\S]*?}/g,
        circle: /triggers:[\s\S]*?\${schedules}[\s\S]*?(?=jobs:)/g
      };
      
      const regex = regexMap[config.provider as keyof typeof regexMap];
      if (regex) {
        processedContent = processedContent.replace(regex, '');
      }
    }
    
    // Provider-specific customizations
    if (config.provider === 'azure') {
      // Azure DevOps specific settings
      if (config.customSettings?.azureStages) {
        const stagesFilter = Array.isArray(config.customSettings.azureStages) 
          ? config.customSettings.azureStages 
          : [];
          
        // Remove stages that are not selected
        const stagePatterns = [
          { id: 'checkout', pattern: /- stage: Checkout[\s\S]*?(?=- stage:|$)/g },
          { id: 'setup', pattern: /- stage: Setup[\s\S]*?(?=- stage:|$)/g },
          { id: 'build', pattern: /- stage: Build[\s\S]*?(?=- stage:|$)/g },
          { id: 'test', pattern: /- stage: Test[\s\S]*?(?=- stage:|$)/g },
          { id: 'report', pattern: /- stage: Publish[\s\S]*?(?=- stage:|$)/g },
          { id: 'cleanup', pattern: /- stage: Cleanup[\s\S]*?(?=$)/g }
        ];
        
        for (const { id, pattern } of stagePatterns) {
          if (!stagesFilter.includes(id) && !['checkout', 'setup', 'build', 'test'].includes(id)) {
            processedContent = processedContent.replace(pattern, '');
          }
        }
      }
    } else if (config.provider === 'github') {
      // GitHub Actions specific settings
      if (config.customSettings?.githubEvents) {
        const eventsArray = Array.isArray(config.customSettings.githubEvents) 
          ? config.customSettings.githubEvents 
          : ['push', 'pull_request'];
          
        // Build GitHub trigger events
        const eventsYaml = eventsArray.map(event => {
          if (event === 'schedule' && config.customSettings?.githubCron) {
            return `  ${event}:\n    - cron: "${config.customSettings.githubCron}"`;
          } else if (event === 'push' || event === 'pull_request') {
            return `  ${event}:\n    branches:${config.branches.map(branch => `\n      - ${branch}`).join('')}`;
          } else {
            return `  ${event}:`;
          }
        }).join('\n');
        
        processedContent = processedContent.replace(/on:[\s\S]*?(?=jobs:)/g, `on:\n${eventsYaml}\n\n`);
      }
    } else if (config.provider === 'jenkins') {
      // Jenkins specific settings
      if (config.customSettings?.jenkinsAgent) {
        processedContent = processedContent.replace(/agent {[\s\S]*?}/g, `agent {\n    label '${config.customSettings.jenkinsAgent}'\n  }`);
      }
      
      if (config.customSettings?.jenkinsTools) {
        const toolsArray = config.customSettings.jenkinsTools.split(' ').filter(Boolean);
        const toolsSection = toolsArray.map(tool => `    ${tool} '${tool}-latest'`).join('\n');
        processedContent = processedContent.replace(/tools {[\s\S]*?}/g, `tools {\n${toolsSection}\n  }`);
      }
      
      if (config.customSettings?.jenkinsSharedLibrary && config.customSettings?.jenkinsLibraryName) {
        const libraryVersion = config.customSettings.jenkinsLibraryVersion || 'main';
        const librarySection = `@Library('${config.customSettings.jenkinsLibraryName}@${libraryVersion}') _`;
        
        // Add library import at the beginning of the file
        processedContent = `${librarySection}\n\n${processedContent}`;
      }
    } else if (config.provider === 'gitlab') {
      // GitLab CI/CD specific settings
      if (config.customSettings?.gitlabImage) {
        const image = config.customSettings.gitlabImage === 'custom'
          ? config.customSettings.gitlabCustomImage
          : config.customSettings.gitlabImage;
          
        processedContent = processedContent.replace(/image: .*$/m, `image: ${image}`);
      }
      
      if (config.customSettings?.gitlabCache !== false) {
        const cacheSection = `cache:\n  key: ${config.name.replace(/\s+/g, '-').toLowerCase()}-${config.framework}-${config.language}\n  paths:\n    - .m2/repository\n    - node_modules/`;
        
        // Add cache section after image declaration
        processedContent = processedContent.replace(/image: .*$/m, `image: ${image}\n\n${cacheSection}`);
      }
      
      if (config.customSettings?.gitlabArtifactPaths) {
        const artifactExpire = config.customSettings.gitlabArtifactExpire || '1 week';
        const artifactsSection = `  artifacts:\n    paths:\n      - ${config.customSettings.gitlabArtifactPaths.split(',').join('\n      - ')}\n    expire_in: ${artifactExpire}`;
        
        // Add artifacts section to test job
        processedContent = processedContent.replace(/test:[\s\S]*?(?=  script:)/g, `test:\n${artifactsSection}\n`);
      }
    } else if (config.provider === 'circle') {
      // CircleCI specific settings
      if (config.customSettings?.circleExecutor) {
        let executorConfig = '';
        
        if (config.customSettings.circleExecutor === 'docker') {
          const dockerImage = config.customSettings.circleDockerImage || 'cimg/openjdk:17.0';
          executorConfig = `  docker:\n    - image: ${dockerImage}`;
        } else if (config.customSettings.circleExecutor === 'machine') {
          const machineImage = config.customSettings.circleMachineImage || 'ubuntu-2204:current';
          executorConfig = `  machine:\n    image: ${machineImage}`;
        } else if (config.customSettings.circleExecutor === 'macos') {
          executorConfig = `  macos:\n    xcode: 14.3.1`;
        } else if (config.customSettings.circleExecutor === 'windows') {
          executorConfig = `  windows:\n    machine:\n      image: windows-server-2022-gui:current`;
        }
        
        const resourceClass = config.customSettings.circleResourceClass || 'medium';
        executorConfig += `\n  resource_class: ${resourceClass}`;
        
        processedContent = processedContent.replace(/executors:[\s\S]*?(?=jobs:)/g, `executors:\n  ${config.framework}-${config.language}:\n${executorConfig}\n\n`);
      }
      
      if (config.customSettings?.circleWorkflow !== false) {
        const jobs = config.customSettings.circleJobs || ['build', 'test', 'report'];
        let workflowConfig = `workflows:\n  ${config.name.replace(/\s+/g, '-').toLowerCase()}:\n    jobs:`;
        
        for (let i = 0; i < jobs.length; i++) {
          const job = jobs[i];
          const requiresPrevious = i > 0 ? `\n          requires:\n            - ${jobs[i-1]}` : '';
          workflowConfig += `\n      - ${job}:${requiresPrevious}`;
        }
        
        processedContent = processedContent.replace(/workflows:[\s\S]*?(?=$)/g, workflowConfig);
      }
    }
    
    return processedContent;
  };
  
  /**
   * Generate a README file for the exported project
   * @param projectName Project name
   * @param config Pipeline configuration
   * @returns README content
   */
  const generateReadme = (projectName: string, config: PipelineConfiguration): string => {
    const timestamp = CSDateUtils.getCurrentTimestamp();
    const frameworkDisplay = config.framework.charAt(0).toUpperCase() + config.framework.slice(1);
    const languageDisplay = config.language.charAt(0).toUpperCase() + config.language.slice(1);
    const testTypeDisplay = config.testType.toUpperCase();
    
    let cicdInfo = '';
    if (config.provider === 'azure') {
      cicdInfo = `## Azure DevOps Pipeline

This project includes an Azure DevOps Pipeline configuration in \`azure-pipelines.yml\`.

To use this pipeline:
1. In your Azure DevOps project, go to Pipelines
2. Create a new pipeline
3. Select "Azure Repos Git" (or GitHub if your code is hosted there)
4. Select your repository
5. Select "Existing Azure Pipelines YAML file"
6. Choose the \`azure-pipelines.yml\` file
7. Run the pipeline`;
    } else if (config.provider === 'github') {
      cicdInfo = `## GitHub Actions Workflow

This project includes a GitHub Actions workflow configuration in \`.github/workflows/main.yml\`.

To use this workflow:
1. Push the code to your GitHub repository
2. GitHub will automatically detect the workflow file
3. Go to the "Actions" tab in your repository to view the workflow runs`;
    } else if (config.provider === 'jenkins') {
      cicdInfo = `## Jenkins Pipeline

This project includes a Jenkins Pipeline configuration in \`Jenkinsfile\`.

To use this pipeline:
1. In Jenkins, create a new Pipeline job
2. In the job configuration, select "Pipeline script from SCM"
3. Choose your SCM system and repository URL
4. Set the "Script Path" to \`Jenkinsfile\`
5. Save and run the pipeline`;
    } else if (config.provider === 'gitlab') {
      cicdInfo = `## GitLab CI/CD Pipeline

This project includes a GitLab CI/CD configuration in \`.gitlab-ci.yml\`.

To use this pipeline:
1. Push the code to your GitLab repository
2. GitLab will automatically detect the CI/CD configuration
3. Go to the "CI/CD" > "Pipelines" section in your repository to view the pipeline runs`;
    } else if (config.provider === 'circle') {
      cicdInfo = `## CircleCI Pipeline

This project includes a CircleCI configuration in \`.circleci/config.yml\`.

To use this pipeline:
1. Push the code to your GitHub or Bitbucket repository
2. Set up the project in CircleCI
3. CircleCI will automatically detect the configuration file
4. View pipeline runs in the CircleCI dashboard`;
    }
    
    let browserInfo = '';
    if (config.browsers && config.browsers.length > 0) {
      const browsersList = config.browsers.map(b => `- ${b.charAt(0).toUpperCase() + b.slice(1)}`).join('\n');
      browserInfo = `## Browsers

This project is configured to run tests on the following browsers:

${browsersList}`;
    }
    
    let executionModeInfo = '';
    if (config.executionMode) {
      executionModeInfo = `## Test Execution Mode

Tests in this project are configured to run in ${config.executionMode} mode.`;
    }
    
    return `# ${projectName}

${frameworkDisplay} test automation project with ${languageDisplay} and ${testTypeDisplay}.

Generated by CSTestForge on ${CSDateUtils.formatDate(timestamp)}.

## Project Structure

\`\`\`
project/
├── src/
│   ├── main/
│   │   ├── java/       # Source code (Java projects)
│   │   └── resources/  # Resources
│   └── test/
│       ├── java/       # Test code (Java projects)
│       └── resources/  # Test resources
├── node_modules/       # Dependencies (TypeScript projects)
├── package.json        # Project configuration (TypeScript projects)
├── pom.xml             # Project configuration (Java projects)
└── README.md           # Project documentation
\`\`\`

## Getting Started

### Prerequisites

${config.language === 'java' ? '- Java JDK 17 or higher\n- Maven 3.8 or higher' : '- Node.js 18 or higher\n- npm 8 or higher'}

### Installation

1. Clone the repository
2. ${config.language === 'java' ? 'Run `mvn install` to install dependencies' : 'Run `npm install` to install dependencies'}

### Running Tests

\`\`\`shell
${config.language === 'java' 
  ? (config.testType === 'testng' 
    ? 'mvn clean test' 
    : 'mvn clean test -Dcucumber.filter.tags="@smoke"') 
  : (config.testType === 'testng' 
    ? 'npm test' 
    : 'npm run test:cucumber')}
\`\`\`

${browserInfo}

${executionModeInfo}

${cicdInfo}

## Framework Features

- Multi-browser support
- ${config.testType === 'testng' ? 'TestNG test runner' : 'Cucumber BDD framework'}
- Page Object Model pattern
- Reporting with screenshots
- Parallel execution capabilities
- Data-driven testing
- Custom utilities and helpers

## Configuration

Configuration files can be found in:
${config.language === 'java' 
  ? '- `src/test/resources/config.properties`' 
  : '- `config/test-config.ts`'}

## License

This project is licensed under the MIT License.
`;
  };
  
  /**
   * Export a test case to a file
   * @param testCase Test case configuration
   * @returns Path to the exported test file
   */
  const exportTestCase = useCallback(async (
    testCase: any
  ): Promise<string> => {
    setIsLoading(true);
    setError(null);
    
    try {
      // Get template filename based on framework, language, and test type
      const templatePath = `test-cases/${testCase.framework}/${testCase.language}/${testCase.testType}/TestCase.template`;
      
      // Load template content
      const templateContent = await loadTemplate(templatePath);
      
      // Process template with test case data
      let processedContent = templateContent;
      
      // Replace basic placeholders
      processedContent = processedContent.replace(/\${testName}/g, testCase.name);
      processedContent = processedContent.replace(/\${testDescription}/g, testCase.description || '');
      processedContent = processedContent.replace(/\${author}/g, testCase.author || 'CSTestForge');
      processedContent = processedContent.replace(/\${timestamp}/g, CSDateUtils.getCurrentTimestamp());
      
      // Replace test steps
      if (testCase.steps && testCase.steps.length > 0) {
        let stepsContent = '';
        
        if (testCase.testType === 'testng') {
          if (testCase.language === 'java') {
            stepsContent = testCase.steps.map((step: any) => 
              `    // ${step.description}\n    ${step.code}`
            ).join('\n\n');
          } else {
            stepsContent = testCase.steps.map((step: any) => 
              `    // ${step.description}\n    ${step.code}`
            ).join('\n\n');
          }
        } else if (testCase.testType === 'bdd') {
          if (testCase.language === 'java') {
            stepsContent = testCase.steps.map((step: any) => 
              `    @${step.type}("${step.description}")\n    public void ${CSTextUtils.toCamelCase(step.description)}() {\n        ${step.code}\n    }`
            ).join('\n\n');
          } else {
            stepsContent = testCase.steps.map((step: any) => 
              `    @${step.type}("${step.description}")\n    public ${CSTextUtils.toCamelCase(step.description)}(): void {\n        ${step.code}\n    }`
            ).join('\n\n');
          }
        }
        
        processedContent = processedContent.replace(/\${testSteps}/g, stepsContent);
      }
      
      // Determine file extension
      const fileExtension = testCase.language === 'java' ? '.java' : '.ts';
      
      // Determine directory structure
      const baseDir = `exports/test-cases/${testCase.framework}/${testCase.language}/${testCase.testType}`;
      await storageService.createDirectory(baseDir);
      
      // Generate a unique filename
      const fileName = `${CSTextUtils.toTitleCase(testCase.name).replace(/\s+/g, '')}Test${fileExtension}`;
      const filePath = `${baseDir}/${fileName}`;
      
      // Save the file
      await storageService.writeFile(filePath, processedContent);
      
      setIsLoading(false);
      return filePath;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      setError(`Failed to export test case: ${errorMessage}`);
      setIsLoading(false);
      throw err;
    }
  }, [loadTemplate]);
  
  /**
   * Export a page object to a file
   * @param pageObject Page object configuration
   * @returns Path to the exported page object file
   */
  const exportPageObject = useCallback(async (
    pageObject: any
  ): Promise<string> => {
    setIsLoading(true);
    setError(null);
    
    try {
      // Get template filename based on framework, language
      const templatePath = `page-objects/${pageObject.framework}/${pageObject.language}/PageObject.template`;
      
      // Load template content
      const templateContent = await loadTemplate(templatePath);
      
      // Process template with page object data
      let processedContent = templateContent;
      
      // Replace basic placeholders
      processedContent = processedContent.replace(/\${pageName}/g, pageObject.name);
      processedContent = processedContent.replace(/\${pageDescription}/g, pageObject.description || '');
      processedContent = processedContent.replace(/\${author}/g, pageObject.author || 'CSTestForge');
      processedContent = processedContent.replace(/\${timestamp}/g, CSDateUtils.getCurrentTimestamp());
      processedContent = processedContent.replace(/\${url}/g, pageObject.url || '');
      
      // Replace elements
      if (pageObject.elements && pageObject.elements.length > 0) {
        let elementsContent = '';
        let locatorsContent = '';
        let methodsContent = '';
        
        if (pageObject.language === 'java') {
          // Java implementation
          elementsContent = pageObject.elements.map((element: any) => 
            `    // ${element.description}\n    @CSFindBy(${element.locatorType} = "${element.locatorValue}")\n    private CSElement ${element.name};`
          ).join('\n\n');
          
          // Generate methods based on elements
          methodsContent = pageObject.elements
            .filter((element: any) => element.generateMethod)
            .map((element: any) => {
              const methodName = element.methodName || `interact${CSTextUtils.toTitleCase(element.name)}`;
              return `    /**\n     * ${element.description}\n     */\n    public void ${methodName}() {\n        ${element.name}.click();\n    }`;
            }).join('\n\n');
        } else {
          // TypeScript implementation
          locatorsContent = pageObject.elements.map((element: any) => 
            `    // ${element.description}\n    private static readonly ${element.name}Locator = { ${element.locatorType}: "${element.locatorValue}" };`
          ).join('\n\n');
          
          elementsContent = pageObject.elements.map((element: any) => 
            `    private get ${element.name}(): CSElement {\n        return this.findElement(${pageObject.name}Page.${element.name}Locator);\n    }`
          ).join('\n\n');
          
          // Generate methods based on elements
          methodsContent = pageObject.elements
            .filter((element: any) => element.generateMethod)
            .map((element: any) => {
              const methodName = element.methodName || `interact${CSTextUtils.toTitleCase(element.name)}`;
              return `    /**\n     * ${element.description}\n     */\n    public ${methodName}(): void {\n        this.${element.name}.click();\n    }`;
            }).join('\n\n');
        }
        
        processedContent = processedContent.replace(/\${locators}/g, locatorsContent);
        processedContent = processedContent.replace(/\${elements}/g, elementsContent);
        processedContent = processedContent.replace(/\${methods}/g, methodsContent);
      }
      
      // Determine file extension
      const fileExtension = pageObject.language === 'java' ? '.java' : '.ts';
      
      // Determine directory structure
      const baseDir = `exports/page-objects/${pageObject.framework}/${pageObject.language}`;
      await storageService.createDirectory(baseDir);
      
      // Generate a unique filename
      const fileName = `${CSTextUtils.toTitleCase(pageObject.name).replace(/\s+/g, '')}Page${fileExtension}`;
      const filePath = `${baseDir}/${fileName}`;
      
      // Save the file
      await storageService.writeFile(filePath, processedContent);
      
      setIsLoading(false);
      return filePath;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      setError(`Failed to export page object: ${errorMessage}`);
      setIsLoading(false);
      throw err;
    }
  }, [loadTemplate]);
  
  return {
    isLoading,
    error,
    loadTemplate,
    generatePipeline,
    exportProject,
    exportTestCase,
    exportPageObject
  };
};


FileSystemStorageService.ts
-------------------------------------------------

import { CSDateUtils } from '../../core/utils/CSDateUtils';
import { CSEncryptionUtils } from '../../core/utils/CSEncryptionUtils';

/**
 * Interface for file metadata
 */
interface FileMetadata {
  name: string;
  path: string;
  size: number;
  created: string;
  modified: string;
  version: number;
  checksum: string;
  locked?: boolean;
  lockedBy?: string;
  lockedAt?: string;
}

/**
 * Interface for directory metadata
 */
interface DirectoryMetadata {
  name: string;
  path: string;
  created: string;
  modified: string;
  files: string[];
  directories: string[];
}

/**
 * Options for file operations
 */
interface FileOptions {
  createBackup?: boolean;
  encryptContent?: boolean;
  compress?: boolean;
  overwrite?: boolean;
  exclusive?: boolean;
  version?: number;
}

/**
 * Implementation of a client-side file system storage service.
 * This service uses the browser's IndexedDB for persistent storage.
 */
export class FileSystemStorageService {
  private static readonly DB_NAME = 'CSTestForgeStorage';
  private static readonly FILES_STORE = 'files';
  private static readonly METADATA_STORE = 'metadata';
  private static readonly DIRECTORIES_STORE = 'directories';
  private static readonly LOCKS_STORE = 'locks';
  private static readonly BACKUP_STORE = 'backups';
  private static readonly DB_VERSION = 1;
  
  private db: IDBDatabase | null = null;
  private initPromise: Promise<IDBDatabase> | null = null;
  private activeTransactions: Set<IDBTransaction> = new Set();
  
  /**
   * Create a new FileSystemStorageService instance
   */
  constructor() {
    this.initPromise = this.initDatabase();
  }
  
  /**
   * Initialize the IndexedDB database
   * @returns Promise that resolves with the database instance
   */
  private async initDatabase(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      if (this.db) {
        resolve(this.db);
        return;
      }
      
      const request = indexedDB.open(FileSystemStorageService.DB_NAME, FileSystemStorageService.DB_VERSION);
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        
        // Create object stores if they don't exist
        if (!db.objectStoreNames.contains(FileSystemStorageService.FILES_STORE)) {
          db.createObjectStore(FileSystemStorageService.FILES_STORE, { keyPath: 'path' });
        }
        
        if (!db.objectStoreNames.contains(FileSystemStorageService.METADATA_STORE)) {
          db.createObjectStore(FileSystemStorageService.METADATA_STORE, { keyPath: 'path' });
        }
        
        if (!db.objectStoreNames.contains(FileSystemStorageService.DIRECTORIES_STORE)) {
          db.createObjectStore(FileSystemStorageService.DIRECTORIES_STORE, { keyPath: 'path' });
        }
        
        if (!db.objectStoreNames.contains(FileSystemStorageService.LOCKS_STORE)) {
          db.createObjectStore(FileSystemStorageService.LOCKS_STORE, { keyPath: 'path' });
        }
        
        if (!db.objectStoreNames.contains(FileSystemStorageService.BACKUP_STORE)) {
          db.createObjectStore(FileSystemStorageService.BACKUP_STORE, { keyPath: 'path' });
        }
      };
      
      request.onsuccess = (event) => {
        this.db = (event.target as IDBOpenDBRequest).result;
        resolve(this.db);
      };
      
      request.onerror = (event) => {
        reject(new Error(`Failed to open database: ${(event.target as IDBOpenDBRequest).error}`));
      };
    });
  }
  
  /**
   * Get a database transaction
   * @param storeNames Store names to include in the transaction
   * @param mode Transaction mode (readonly or readwrite)
   * @returns The transaction
   */
  private async getTransaction(
    storeNames: string | string[],
    mode: IDBTransactionMode = 'readonly'
  ): Promise<IDBTransaction> {
    const db = await this.initPromise;
    const transaction = db.transaction(storeNames, mode);
    
    // Track active transactions
    this.activeTransactions.add(transaction);
    
    transaction.oncomplete = () => {
      this.activeTransactions.delete(transaction);
    };
    
    transaction.onerror = () => {
      this.activeTransactions.delete(transaction);
    };
    
    transaction.onabort = () => {
      this.activeTransactions.delete(transaction);
    };
    
    return transaction;
  }
  
  /**
   * Get an object store from a transaction
   * @param storeName Store name
   * @param mode Transaction mode
   * @returns The object store
   */
  private async getObjectStore(
    storeName: string,
    mode: IDBTransactionMode = 'readonly'
  ): Promise<IDBObjectStore> {
    const transaction = await this.getTransaction(storeName, mode);
    return transaction.objectStore(storeName);
  }
  
  /**
   * Normalize a file path (convert to absolute path, remove duplicate slashes, etc.)
   * @param path The path to normalize
   * @returns Normalized path
   */
  private normalizePath(path: string): string {
    // Ensure path starts with a slash
    if (!path.startsWith('/')) {
      path = '/' + path;
    }
    
    // Remove duplicate slashes
    path = path.replace(/\/+/g, '/');
    
    // Remove trailing slash (except for root)
    if (path !== '/' && path.endsWith('/')) {
      path = path.slice(0, -1);
    }
    
    return path;
  }
  
  /**
   * Get the directory path from a file path
   * @param path File path
   * @returns Directory path
   */
  private getDirectoryPath(path: string): string {
    const normalizedPath = this.normalizePath(path);
    const lastSlashIndex = normalizedPath.lastIndexOf('/');
    
    if (lastSlashIndex === 0) {
      return '/';
    }
    
    return normalizedPath.substring(0, lastSlashIndex);
  }
  
  /**
   * Get the file name from a path
   * @param path File path
   * @returns File name
   */
  private getFileName(path: string): string {
    const normalizedPath = this.normalizePath(path);
    const lastSlashIndex = normalizedPath.lastIndexOf('/');
    
    return normalizedPath.substring(lastSlashIndex + 1);
  }
  
  /**
   * Calculate checksum for file content
   * @param content File content
   * @returns Checksum string
   */
  private calculateChecksum(content: string | ArrayBuffer): string {
    // Use encryption utils to generate a hash of the content
    return CSEncryptionUtils.hashData(content);
  }
  
  /**
   * Compress file content
   * @param content Content to compress
   * @returns Compressed content
   */
  private async compressContent(content: string): Promise<ArrayBuffer> {
    // Convert string to ArrayBuffer
    const encoder = new TextEncoder();
    const uint8Array = encoder.encode(content);
    
    // Use CompressionStream API for compression
    const cs = new CompressionStream('gzip');
    const writer = cs.writable.getWriter();
    await writer.write(uint8Array);
    await writer.close();
    
    // Read compressed data
    const reader = cs.readable.getReader();
    const chunks: Uint8Array[] = [];
    
    let result = await reader.read();
    while (!result.done) {
      chunks.push(result.value);
      result = await reader.read();
    }
    
    // Combine chunks
    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    const compressed = new Uint8Array(totalLength);
    
    let offset = 0;
    for (const chunk of chunks) {
      compressed.set(chunk, offset);
      offset += chunk.length;
    }
    
    return compressed.buffer;
  }
  
  /**
   * Decompress file content
   * @param content Compressed content
   * @returns Decompressed content as string
   */
  private async decompressContent(content: ArrayBuffer): Promise<string> {
    // Use DecompressionStream API for decompression
    const ds = new DecompressionStream('gzip');
    const writer = ds.writable.getWriter();
    await writer.write(new Uint8Array(content));
    await writer.close();
    
    // Read decompressed data
    const reader = ds.readable.getReader();
    const chunks: Uint8Array[] = [];
    
    let result = await reader.read();
    while (!result.done) {
      chunks.push(result.value);
      result = await reader.read();
    }
    
    // Combine chunks
    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    const decompressed = new Uint8Array(totalLength);
    
    let offset = 0;
    for (const chunk of chunks) {
      decompressed.set(chunk, offset);
      offset += chunk.length;
    }
    
    // Convert ArrayBuffer back to string
    const decoder = new TextDecoder();
    return decoder.decode(decompressed);
  }
  
  /**
   * Encrypt file content
   * @param content Content to encrypt
   * @returns Encrypted content
   */
  private async encryptContent(content: string): Promise<string> {
    // Use encryption utils to encrypt the content
    return CSEncryptionUtils.encryptData(content);
  }
  
  /**
   * Decrypt file content
   * @param content Encrypted content
   * @returns Decrypted content
   */
  private async decryptContent(content: string): Promise<string> {
    // Use encryption utils to decrypt the content
    return CSEncryptionUtils.decryptData(content);
  }
  
  /**
   * Lock a file for exclusive access
   * @param path File path
   * @param lockOwner Owner of the lock
   * @param timeout Lock timeout in milliseconds
   * @returns True if lock was acquired, false otherwise
   */
  public async lockFile(path: string, lockOwner: string, timeout: number = 60000): Promise<boolean> {
    const normalizedPath = this.normalizePath(path);
    
    try {
      // Check if file is already locked
      const store = await this.getObjectStore(FileSystemStorageService.LOCKS_STORE, 'readwrite');
      
      const getLockRequest = store.get(normalizedPath);
      const existingLock = await new Promise<any>((resolve, reject) => {
        getLockRequest.onsuccess = () => resolve(getLockRequest.result);
        getLockRequest.onerror = () => reject(getLockRequest.error);
      });
      
      if (existingLock) {
        // Check if lock has expired
        const lockTime = new Date(existingLock.lockedAt).getTime();
        const currentTime = Date.now();
        
        if (currentTime - lockTime < existingLock.timeout) {
          // Lock is still active
          return false;
        }
      }
      
      // Acquire lock
      const lock = {
        path: normalizedPath,
        lockedBy: lockOwner,
        lockedAt: new Date().toISOString(),
        timeout
      };
      
      const putLockRequest = store.put(lock);
      await new Promise<void>((resolve, reject) => {
        putLockRequest.onsuccess = () => resolve();
        putLockRequest.onerror = () => reject(putLockRequest.error);
      });
      
      return true;
    } catch (error) {
      console.error('Failed to lock file:', error);
      return false;
    }
  }
  
  /**
   * Unlock a file
   * @param path File path
   * @param lockOwner Owner of the lock
   * @returns True if unlock was successful, false otherwise
   */
  public async unlockFile(path: string, lockOwner: string): Promise<boolean> {
    const normalizedPath = this.normalizePath(path);
    
    try {
      // Check if file is locked by the specified owner
      const store = await this.getObjectStore(FileSystemStorageService.LOCKS_STORE, 'readwrite');
      
      const getLockRequest = store.get(normalizedPath);
      const existingLock = await new Promise<any>((resolve, reject) => {
        getLockRequest.onsuccess = () => resolve(getLockRequest.result);
        getLockRequest.onerror = () => reject(getLockRequest.error);
      });
      
      if (!existingLock || existingLock.lockedBy !== lockOwner) {
        // Lock doesn't exist or is owned by someone else
        return false;
      }
      
      // Remove lock
      const deleteLockRequest = store.delete(normalizedPath);
      await new Promise<void>((resolve, reject) => {
        deleteLockRequest.onsuccess = () => resolve();
        deleteLockRequest.onerror = () => reject(deleteLockRequest.error);
      });
      
      return true;
    } catch (error) {
      console.error('Failed to unlock file:', error);
      return false;
    }
  }
  
  /**
   * Create a new directory
   * @param path Directory path
   * @returns True if the directory was created, false if it already exists
   */
  public async createDirectory(path: string): Promise<boolean> {
    const normalizedPath = this.normalizePath(path);
    
    // Root directory always exists
    if (normalizedPath === '/') {
      return true;
    }
    
    try {
      // Check if directory already exists
      const dirStore = await this.getObjectStore(FileSystemStorageService.DIRECTORIES_STORE, 'readwrite');
      
      const getDirRequest = dirStore.get(normalizedPath);
      const existingDir = await new Promise<any>((resolve, reject) => {
        getDirRequest.onsuccess = () => resolve(getDirRequest.result);
        getDirRequest.onerror = () => reject(getDirRequest.error);
      });
      
      if (existingDir) {
        // Directory already exists
        return false;
      }
      
      // Create parent directories if they don't exist
      const parentPath = this.getDirectoryPath(normalizedPath);
      if (parentPath !== normalizedPath) {
        await this.createDirectory(parentPath);
      }
      
      // Create directory
      const timestamp = new Date().toISOString();
      const directory: DirectoryMetadata = {
        name: this.getFileName(normalizedPath),
        path: normalizedPath,
        created: timestamp,
        modified: timestamp,
        files: [],
        directories: []
      };
      
      const putDirRequest = dirStore.put(directory);
      await new Promise<void>((resolve, reject) => {
        putDirRequest.onsuccess = () => resolve();
        putDirRequest.onerror = () => reject(putDirRequest.error);
      });
      
      // Add directory to parent directory's directories list
      if (parentPath !== normalizedPath) {
        const getParentRequest = dirStore.get(parentPath);
        const parentDir = await new Promise<DirectoryMetadata>((resolve, reject) => {
          getParentRequest.onsuccess = () => resolve(getParentRequest.result);
          getParentRequest.onerror = () => reject(getParentRequest.error);
        });
        
        if (parentDir) {
          // Add directory to parent's directories list if not already there
          if (!parentDir.directories.includes(normalizedPath)) {
            parentDir.directories.push(normalizedPath);
            parentDir.modified = timestamp;
            
            const updateParentRequest = dirStore.put(parentDir);
            await new Promise<void>((resolve, reject) => {
              updateParentRequest.onsuccess = () => resolve();
              updateParentRequest.onerror = () => reject(updateParentRequest.error);
            });
          }
        }
      }
      
      return true;
    } catch (error) {
      console.error('Failed to create directory:', error);
      throw new Error(`Failed to create directory '${path}': ${error}`);
    }
  }
  
  /**
   * Check if a directory exists
   * @param path Directory path
   * @returns True if the directory exists, false otherwise
   */
  public async directoryExists(path: string): Promise<boolean> {
    const normalizedPath = this.normalizePath(path);
    
    // Root directory always exists
    if (normalizedPath === '/') {
      return true;
    }
    
    try {
      const store = await this.getObjectStore(FileSystemStorageService.DIRECTORIES_STORE);
      
      const getRequest = store.get(normalizedPath);
      const directory = await new Promise<any>((resolve, reject) => {
        getRequest.onsuccess = () => resolve(getRequest.result);
        getRequest.onerror = () => reject(getRequest.error);
      });
      
      return !!directory;
    } catch (error) {
      console.error('Failed to check if directory exists:', error);
      return false;
    }
  }
  
  /**
   * Delete a directory
   * @param path Directory path
   * @param recursive If true, delete all files and subdirectories recursively
   * @returns True if the directory was deleted, false otherwise
   */
  public async deleteDirectory(path: string, recursive: boolean = false): Promise<boolean> {
    const normalizedPath = this.normalizePath(path);
    
    // Can't delete root directory
    if (normalizedPath === '/') {
      return false;
    }
    
    try {
      const dirStore = await this.getObjectStore(FileSystemStorageService.DIRECTORIES_STORE, 'readwrite');
      const fileStore = await this.getObjectStore(FileSystemStorageService.FILES_STORE, 'readwrite');
      const metaStore = await this.getObjectStore(FileSystemStorageService.METADATA_STORE, 'readwrite');
      
      // Check if directory exists
      const getDirRequest = dirStore.get(normalizedPath);
      const directory = await new Promise<DirectoryMetadata | undefined>((resolve, reject) => {
        getDirRequest.onsuccess = () => resolve(getDirRequest.result);
        getDirRequest.onerror = () => reject(getDirRequest.error);
      });
      
      if (!directory) {
        // Directory doesn't exist
        return false;
      }
      
      // Check if directory is empty or recursive is true
      if (directory.files.length > 0 || directory.directories.length > 0) {
        if (!recursive) {
          // Directory is not empty and recursive is false
          return false;
        }
        
        // Delete all files in the directory
        for (const filePath of directory.files) {
          // Delete file content
          const deleteFileRequest = fileStore.delete(filePath);
          await new Promise<void>((resolve, reject) => {
            deleteFileRequest.onsuccess = () => resolve();
            deleteFileRequest.onerror = () => reject(deleteFileRequest.error);
          });
          
          // Delete file metadata
          const deleteMetaRequest = metaStore.delete(filePath);
          await new Promise<void>((resolve, reject) => {
            deleteMetaRequest.onsuccess = () => resolve();
            deleteMetaRequest.onerror = () => reject(deleteMetaRequest.error);
          });
        }
        
        // Recursively delete all subdirectories
        for (const subdirPath of directory.directories) {
          await this.deleteDirectory(subdirPath, true);
        }
      }
      
      // Remove directory from parent directory's directories list
      const parentPath = this.getDirectoryPath(normalizedPath);
      if (parentPath !== normalizedPath) {
        const getParentRequest = dirStore.get(parentPath);
        const parentDir = await new Promise<DirectoryMetadata | undefined>((resolve, reject) => {
          getParentRequest.onsuccess = () => resolve(getParentRequest.result);
          getParentRequest.onerror = () => reject(getParentRequest.error);
        });
        
        if (parentDir) {
          // Remove directory from parent's directories list
          parentDir.directories = parentDir.directories.filter(dir => dir !== normalizedPath);
          parentDir.modified = new Date().toISOString();
          
          const updateParentRequest = dirStore.put(parentDir);
          await new Promise<void>((resolve, reject) => {
            updateParentRequest.onsuccess = () => resolve();
            updateParentRequest.onerror = () => reject(updateParentRequest.error);
          });
        }
      }
      
      // Delete directory
      const deleteDirRequest = dirStore.delete(normalizedPath);
      await new Promise<void>((resolve, reject) => {
        deleteDirRequest.onsuccess = () => resolve();
        deleteDirRequest.onerror = () => reject(deleteDirRequest.error);
      });
      
      return true;
    } catch (error) {
      console.error('Failed to delete directory:', error);
      throw new Error(`Failed to delete directory '${path}': ${error}`);
    }
  }
  
  /**
   * List all files in a directory
   * @param path Directory path
   * @returns Array of file names
   */
  public async listFiles(path: string): Promise<string[]> {
    const normalizedPath = this.normalizePath(path);
    
    try {
      const store = await this.getObjectStore(FileSystemStorageService.DIRECTORIES_STORE);
      
      const getRequest = store.get(normalizedPath);
      const directory = await new Promise<DirectoryMetadata | undefined>((resolve, reject) => {
        getRequest.onsuccess = () => resolve(getRequest.result);
        getRequest.onerror = () => reject(getRequest.error);
      });
      
      if (!directory) {
        // Directory doesn't exist
        throw new Error(`Directory '${path}' not found`);
      }
      
      // Return array of file names (not full paths)
      return directory.files.map(filePath => this.getFileName(filePath));
    } catch (error) {
      console.error('Failed to list files:', error);
      throw new Error(`Failed to list files in directory '${path}': ${error}`);
    }
  }
  
  /**
   * List all subdirectories in a directory
   * @param path Directory path
   * @returns Array of directory names
   */
  public async listDirectories(path: string): Promise<string[]> {
    const normalizedPath = this.normalizePath(path);
    
    try {
      const store = await this.getObjectStore(FileSystemStorageService.DIRECTORIES_STORE);
      
      const getRequest = store.get(normalizedPath);
      const directory = await new Promise<DirectoryMetadata | undefined>((resolve, reject) => {
        getRequest.onsuccess = () => resolve(getRequest.result);
        getRequest.onerror = () => reject(getRequest.error);
      });
      
      if (!directory) {
        // Directory doesn't exist
        throw new Error(`Directory '${path}' not found`);
      }
      
      // Return array of directory names (not full paths)
      return directory.directories.map(dirPath => this.getFileName(dirPath));
    } catch (error) {
      console.error('Failed to list directories:', error);
      throw new Error(`Failed to list directories in directory '${path}': ${error}`);
    }
  }
  
  /**
   * Write content to a file
   * @param path File path
   * @param content File content
   * @param options File options
   * @returns Metadata of the written file
   */
  public async writeFile(
    path: string, 
    content: string,
    options: FileOptions = {}
  ): Promise<FileMetadata> {
    const normalizedPath = this.normalizePath(path);
    const dirPath = this.getDirectoryPath(normalizedPath);
    const fileName = this.getFileName(normalizedPath);
    
    // Default options
    const defaultOptions: FileOptions = {
      createBackup: true,
      encryptContent: false,
      compress: false,
      overwrite: true,
      exclusive: false,
      version: 1
    };
    
    const mergedOptions = { ...defaultOptions, ...options };
    
    try {
      // Ensure parent directory exists
      const dirExists = await this.directoryExists(dirPath);
      if (!dirExists) {
        await this.createDirectory(dirPath);
      }
      
      // Get necessary object stores
      const fileStore = await this.getObjectStore(FileSystemStorageService.FILES_STORE, 'readwrite');
      const metaStore = await this.getObjectStore(FileSystemStorageService.METADATA_STORE, 'readwrite');
      const dirStore = await this.getObjectStore(FileSystemStorageService.DIRECTORIES_STORE, 'readwrite');
      const backupStore = await this.getObjectStore(FileSystemStorageService.BACKUP_STORE, 'readwrite');
      
      // Check if file exists
      const getFileRequest = fileStore.get(normalizedPath);
      const existingFile = await new Promise<any>((resolve, reject) => {
        getFileRequest.onsuccess = () => resolve(getFileRequest.result);
        getFileRequest.onerror = () => reject(getFileRequest.error);
      });
      
      const getMetaRequest = metaStore.get(normalizedPath);
      const existingMeta = await new Promise<FileMetadata | undefined>((resolve, reject) => {
        getMetaRequest.onsuccess = () => resolve(getMetaRequest.result);
        getMetaRequest.onerror = () => reject(getMetaRequest.error);
      });
      
      // Check file existence constraints
      if (existingFile) {
        if (mergedOptions.exclusive) {
          throw new Error(`File '${path}' already exists and exclusive option is set`);
        }
        
        if (!mergedOptions.overwrite) {
          throw new Error(`File '${path}' already exists and overwrite option is false`);
        }
        
        // Check version constraints
        if (existingMeta && mergedOptions.version && mergedOptions.version !== existingMeta.version + 1) {
          throw new Error(`Version mismatch: expected version ${existingMeta.version + 1}, got ${mergedOptions.version}`);
        }
        
        // Create backup if enabled
        if (mergedOptions.createBackup) {
          const timestamp = CSDateUtils.getCurrentTimestamp();
          const backupPath = `${normalizedPath}.backup_${timestamp}`;
          
          // Save backup
          const backupRequest = backupStore.put({
            path: backupPath,
            originalPath: normalizedPath,
            content: existingFile.content,
            metadata: existingMeta,
            timestamp
          });
          
          await new Promise<void>((resolve, reject) => {
            backupRequest.onsuccess = () => resolve();
            backupRequest.onerror = () => reject(backupRequest.error);
          });
        }
      }
      
      // Process content based on options
      let processedContent: string | ArrayBuffer = content;
      
      // Encrypt content if requested
      if (mergedOptions.encryptContent) {
        processedContent = await this.encryptContent(content);
      }
      
      // Compress content if requested
      if (mergedOptions.compress) {
        processedContent = await this.compressContent(typeof processedContent === 'string' ? processedContent : content);
      }
      
      // Calculate checksum
      const checksum = this.calculateChecksum(processedContent);
      
      // Prepare file metadata
      const timestamp = new Date().toISOString();
      const metadata: FileMetadata = {
        name: fileName,
        path: normalizedPath,
        size: typeof processedContent === 'string' ? processedContent.length : processedContent.byteLength,
        created: existingMeta ? existingMeta.created : timestamp,
        modified: timestamp,
        version: existingMeta ? existingMeta.version + 1 : 1,
        checksum,
        locked: false
      };
      
      // Write file content
      const putFileRequest = fileStore.put({
        path: normalizedPath,
        content: processedContent,
        compressed: mergedOptions.compress,
        encrypted: mergedOptions.encryptContent,
        timestamp
      });
      
      await new Promise<void>((resolve, reject) => {
        putFileRequest.onsuccess = () => resolve();
        putFileRequest.onerror = () => reject(putFileRequest.error);
      });
      
      // Write file metadata
      const putMetaRequest = metaStore.put(metadata);
      await new Promise<void>((resolve, reject) => {
        putMetaRequest.onsuccess = () => resolve();
        putMetaRequest.onerror = () => reject(putMetaRequest.error);
      });
      
      // Add file to parent directory's files list if it's not already there
      const getDirRequest = dirStore.get(dirPath);
      const parentDir = await new Promise<DirectoryMetadata | undefined>((resolve, reject) => {
        getDirRequest.onsuccess = () => resolve(getDirRequest.result);
        getDirRequest.onerror = () => reject(getDirRequest.error);
      });
      
      if (parentDir) {
        // Add file to parent directory's files list if not already there
        if (!parentDir.files.includes(normalizedPath)) {
          parentDir.files.push(normalizedPath);
          parentDir.modified = timestamp;
          
          const updateDirRequest = dirStore.put(parentDir);
          await new Promise<void>((resolve, reject) => {
            updateDirRequest.onsuccess = () => resolve();
            updateDirRequest.onerror = () => reject(updateDirRequest.error);
          });
        }
      }
      
      return metadata;
    } catch (error) {
      console.error('Failed to write file:', error);
      throw new Error(`Failed to write file '${path}': ${error}`);
    }
  }
  
  /**
   * Read a file and return its content
   * @param path File path
   * @returns File content as string
   */
  public async readFile(path: string): Promise<string> {
    const normalizedPath = this.normalizePath(path);
    
    try {
      const fileStore = await this.getObjectStore(FileSystemStorageService.FILES_STORE);
      
      const getRequest = fileStore.get(normalizedPath);
      const file = await new Promise<any>((resolve, reject) => {
        getRequest.onsuccess = () => resolve(getRequest.result);
        getRequest.onerror = () => reject(getRequest.error);
      });
      
      if (!file) {
        throw new Error(`File '${path}' not found`);
      }
      
      let content = file.content;
      
      // Decompress content if it's compressed
      if (file.compressed) {
        content = await this.decompressContent(content);
      }
      
      // Decrypt content if it's encrypted
      if (file.encrypted) {
        content = await this.decryptContent(content);
      }
      
      return content;
    } catch (error) {
      console.error('Failed to read file:', error);
      throw new Error(`Failed to read file '${path}': ${error}`);
    }
  }
  
  /**
   * Get metadata for a file
   * @param path File path
   * @returns File metadata
   */
  public async getFileMetadata(path: string): Promise<FileMetadata> {
    const normalizedPath = this.normalizePath(path);
    
    try {
      const store = await this.getObjectStore(FileSystemStorageService.METADATA_STORE);
      
      const getRequest = store.get(normalizedPath);
      const metadata = await new Promise<FileMetadata | undefined>((resolve, reject) => {
        getRequest.onsuccess = () => resolve(getRequest.result);
        getRequest.onerror = () => reject(getRequest.error);
      });
      
      if (!metadata) {
        throw new Error(`File '${path}' not found`);
      }
      
      return metadata;
    } catch (error) {
      console.error('Failed to get file metadata:', error);
      throw new Error(`Failed to get metadata for file '${path}': ${error}`);
    }
  }
  
  /**
   * Check if a file exists
   * @param path File path
   * @returns True if the file exists, false otherwise
   */
  public async fileExists(path: string): Promise<boolean> {
    const normalizedPath = this.normalizePath(path);
    
    try {
      const store = await this.getObjectStore(FileSystemStorageService.FILES_STORE);
      
      const getRequest = store.get(normalizedPath);
      const file = await new Promise<any>((resolve, reject) => {
        getRequest.onsuccess = () => resolve(getRequest.result);
        getRequest.onerror = () => reject(getRequest.error);
      });
      
      return !!file;
    } catch (error) {
      console.error('Failed to check if file exists:', error);
      return false;
    }
  }
  
  /**
   * Delete a file
   * @param path File path
   * @param createBackup If true, create a backup of the file before deleting
   * @returns True if the file was deleted, false otherwise
   */
  public async deleteFile(path: string, createBackup: boolean = true): Promise<boolean> {
    const normalizedPath = this.normalizePath(path);
    
    try {
      const fileStore = await this.getObjectStore(FileSystemStorageService.FILES_STORE, 'readwrite');
      const metaStore = await this.getObjectStore(FileSystemStorageService.METADATA_STORE, 'readwrite');
      const dirStore = await this.getObjectStore(FileSystemStorageService.DIRECTORIES_STORE, 'readwrite');
      const backupStore = createBackup
        ? await this.getObjectStore(FileSystemStorageService.BACKUP_STORE, 'readwrite')
        : null;
      
      // Check if file exists
      const getFileRequest = fileStore.get(normalizedPath);
      const file = await new Promise<any>((resolve, reject) => {
        getFileRequest.onsuccess = () => resolve(getFileRequest.result);
        getFileRequest.onerror = () => reject(getFileRequest.error);
      });
      
      if (!file) {
        return false;
      }
      
      // Get file metadata
      const getMetaRequest = metaStore.get(normalizedPath);
      const metadata = await new Promise<FileMetadata | undefined>((resolve, reject) => {
        getMetaRequest.onsuccess = () => resolve(getMetaRequest.result);
        getMetaRequest.onerror = () => reject(getMetaRequest.error);
      });
      
      // Create backup if requested
      if (createBackup && backupStore) {
        const timestamp = CSDateUtils.getCurrentTimestamp();
        const backupPath = `${normalizedPath}.backup_${timestamp}`;
        
        // Save backup
        const backupRequest = backupStore.put({
          path: backupPath,
          originalPath: normalizedPath,
          content: file.content,
          metadata,
          timestamp
        });
        
        await new Promise<void>((resolve, reject) => {
          backupRequest.onsuccess = () => resolve();
          backupRequest.onerror = () => reject(backupRequest.error);
        });
      }
      
      // Remove file from parent directory's files list
      const dirPath = this.getDirectoryPath(normalizedPath);
      const getDirRequest = dirStore.get(dirPath);
      const parentDir = await new Promise<DirectoryMetadata | undefined>((resolve, reject) => {
        getDirRequest.onsuccess = () => resolve(getDirRequest.result);
        getDirRequest.onerror = () => reject(getDirRequest.error);
      });
      
      if (parentDir) {
        // Remove file from parent directory's files list
        parentDir.files = parentDir.files.filter(f => f !== normalizedPath);
        parentDir.modified = new Date().toISOString();
        
        const updateDirRequest = dirStore.put(parentDir);
        await new Promise<void>((resolve, reject) => {
          updateDirRequest.onsuccess = () => resolve();
          updateDirRequest.onerror = () => reject(updateDirRequest.error);
        });
      }
      
      // Delete file
      const deleteFileRequest = fileStore.delete(normalizedPath);
      await new Promise<void>((resolve, reject) => {
        deleteFileRequest.onsuccess = () => resolve();
        deleteFileRequest.onerror = () => reject(deleteFileRequest.error);
      });
      
      // Delete file metadata
      const deleteMetaRequest = metaStore.delete(normalizedPath);
      await new Promise<void>((resolve, reject) => {
        deleteMetaRequest.onsuccess = () => resolve();
        deleteMetaRequest.onerror = () => reject(deleteMetaRequest.error);
      });
      
      return true;
    } catch (error) {
      console.error('Failed to delete file:', error);
      throw new Error(`Failed to delete file '${path}': ${error}`);
    }
  }
  
  /**
   * Rename a file
   * @param oldPath Old file path
   * @param newPath New file path
   * @returns Metadata of the renamed file
   */
  public async renameFile(oldPath: string, newPath: string): Promise<FileMetadata> {
    const normalizedOldPath = this.normalizePath(oldPath);
    const normalizedNewPath = this.normalizePath(newPath);
    
    // Check if paths are different
    if (normalizedOldPath === normalizedNewPath) {
      throw new Error('Old and new paths are the same');
    }
    
    try {
      // Read file content
      const content = await this.readFile(normalizedOldPath);
      
      // Get file metadata
      const metadata = await this.getFileMetadata(normalizedOldPath);
      
      // Check if destination file exists
      const destExists = await this.fileExists(normalizedNewPath);
      if (destExists) {
        throw new Error(`Destination file '${newPath}' already exists`);
      }
      
      // Write file to new location
      const newMetadata = await this.writeFile(normalizedNewPath, content, {
        createBackup: false,
        encryptContent: false,
        compress: false,
        overwrite: false,
        exclusive: true,
        version: 1
      });
      
      // Delete old file without creating a backup
      await this.deleteFile(normalizedOldPath, false);
      
      return newMetadata;
    } catch (error) {
      console.error('Failed to rename file:', error);
      throw new Error(`Failed to rename file from '${oldPath}' to '${newPath}': ${error}`);
    }
  }
  
  /**
   * Copy a file
   * @param sourcePath Source file path
   * @param destPath Destination file path
   * @param overwrite If true, overwrite existing file at destination
   * @returns Metadata of the copied file
   */
  public async copyFile(sourcePath: string, destPath: string, overwrite: boolean = false): Promise<FileMetadata> {
    const normalizedSourcePath = this.normalizePath(sourcePath);
    const normalizedDestPath = this.normalizePath(destPath);
    
    // Check if paths are different
    if (normalizedSourcePath === normalizedDestPath) {
      throw new Error('Source and destination paths are the same');
    }
    
    try {
      // Check if source file exists
      const sourceExists = await this.fileExists(normalizedSourcePath);
      if (!sourceExists) {
        throw new Error(`Source file '${sourcePath}' not found`);
      }
      
      // Check if destination file exists
      const destExists = await this.fileExists(normalizedDestPath);
      if (destExists && !overwrite) {
        throw new Error(`Destination file '${destPath}' already exists and overwrite is false`);
      }
      
      // Read source file content
      const content = await this.readFile(normalizedSourcePath);
      
      // Write content to destination file
      const metadata = await this.writeFile(normalizedDestPath, content, {
        createBackup: destExists,
        overwrite
      });
      
      return metadata;
    } catch (error) {
      console.error('Failed to copy file:', error);
      throw new Error(`Failed to copy file from '${sourcePath}' to '${destPath}': ${error}`);
    }
  }
  
  /**
   * Move a file (rename + delete)
   * @param sourcePath Source file path
   * @param destPath Destination file path
   * @param overwrite If true, overwrite existing file at destination
   * @returns Metadata of the moved file
   */
  public async moveFile(sourcePath: string, destPath: string, overwrite: boolean = false): Promise<FileMetadata> {
    const normalizedSourcePath = this.normalizePath(sourcePath);
    const normalizedDestPath = this.normalizePath(destPath);
    
    // Check if paths are different
    if (normalizedSourcePath === normalizedDestPath) {
      throw new Error('Source and destination paths are the same');
    }
    
    try {
      // Check if destination file exists
      const destExists = await this.fileExists(normalizedDestPath);
      if (destExists && !overwrite) {
        throw new Error(`Destination file '${destPath}' already exists and overwrite is false`);
      }
      
      // Copy file to destination
      const metadata = await this.copyFile(normalizedSourcePath, normalizedDestPath, overwrite);
      
      // Delete source file
      await this.deleteFile(normalizedSourcePath, true);
      
      return metadata;
    } catch (error) {
      console.error('Failed to move file:', error);
      throw new Error(`Failed to move file from '${sourcePath}' to '${destPath}': ${error}`);
    }
  }
  
  /**
   * Restore a file from backup
   * @param path File path
   * @param version Version to restore (if not specified, restore the latest backup)
   * @returns Metadata of the restored file
   */
  public async restoreFileFromBackup(path: string, version?: number): Promise<FileMetadata> {
    const normalizedPath = this.normalizePath(path);
    
    try {
      const backupStore = await this.getObjectStore(FileSystemStorageService.BACKUP_STORE);
      
      // Get all backups for the file
      const backups: any[] = [];
      
      const getAllRequest = backupStore.openCursor();
      await new Promise<void>((resolve, reject) => {
        getAllRequest.onsuccess = (event) => {
          const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;
          if (cursor) {
            const backup = cursor.value;
            if (backup.originalPath === normalizedPath) {
              backups.push(backup);
            }
            cursor.continue();
          } else {
            resolve();
          }
        };
        getAllRequest.onerror = () => reject(getAllRequest.error);
      });
      
      if (backups.length === 0) {
        throw new Error(`No backups found for file '${path}'`);
      }
      
      // Sort backups by timestamp (descending)
      backups.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
      
      // Find the backup to restore
      let backupToRestore;
      
      if (version) {
        // Find backup with the specified version
        backupToRestore = backups.find(backup => backup.metadata?.version === version);
        
        if (!backupToRestore) {
          throw new Error(`Backup with version ${version} not found for file '${path}'`);
        }
      } else {
        // Use the latest backup
        backupToRestore = backups[0];
      }
      
      // Restore file content
      let content = backupToRestore.content;
      
      // Decompress content if it's compressed
      if (backupToRestore.compressed) {
        content = await this.decompressContent(content);
      }
      
      // Decrypt content if it's encrypted
      if (backupToRestore.encrypted) {
        content = await this.decryptContent(content);
      }
      
      // Write restored content to file
      const metadata = await this.writeFile(normalizedPath, content, {
        createBackup: true,
        overwrite: true
      });
      
      return metadata;
    } catch (error) {
      console.error('Failed to restore file from backup:', error);
      throw new Error(`Failed to restore file '${path}' from backup: ${error}`);
    }
  }
  
  /**
   * Close all active transactions and the database connection
   */
  public async close(): Promise<void> {
    // Abort all active transactions
    for (const transaction of this.activeTransactions) {
      transaction.abort();
    }
    
    // Close the database connection
    if (this.db) {
      this.db.close();
      this.db = null;
      this.initPromise = null;
    }
  }
}



framework.ts
------------------------------------

/**
 * Framework types for CSTestForge
 */

/**
 * Supported test frameworks
 */
export type FrameworkType = 'selenium' | 'playwright';

/**
 * Supported programming languages
 */
export type LanguageType = 'java' | 'typescript';

/**
 * Supported test types
 */
export type TestType = 'testng' | 'bdd';

/**
 * Supported CI/CD providers
 */
export type PipelineType = 'azure' | 'github' | 'jenkins' | 'gitlab' | 'circle';

/**
 * Framework configuration
 */
export interface FrameworkConfig {
  /** Selected test framework */
  framework: FrameworkType;
  /** Selected programming language */
  language: LanguageType;
  /** Selected test type */
  testType: TestType;
  /** Browser to use for testing */
  browser: string;
  /** Base URL for tests */
  baseUrl: string;
  /** Implicit wait timeout in seconds */
  implicitWait: number;
  /** Explicit wait timeout in seconds */
  explicitWait: number;
  /** Page load timeout in seconds */
  pageLoadTimeout: number;
  /** Script timeout in seconds */
  scriptTimeout: number;
  /** Enable/disable headless mode */
  headless: boolean;
  /** Browser window width */
  windowWidth: number;
  /** Browser window height */
  windowHeight: number;
  /** Enable/disable screenshots on failure */
  screenshotsOnFailure: boolean;
  /** Enable/disable video recording */
  videoRecording: boolean;
  /** Enable/disable network traffic capture */
  networkTrafficCapture: boolean;
  /** Enable/disable console logs capture */
  consoleLogCapture: boolean;
  /** Enable/disable performance metrics capture */
  performanceMetricsCapture: boolean;
  /** Enable/disable parallel execution */
  parallelExecution: boolean;
  /** Maximum number of parallel threads/workers */
  maxParallelInstances: number;
  /** Enable/disable self-healing mechanism */
  selfHealing: boolean;
  /** Custom capabilities/options */
  capabilities: Record<string, any>;
}

/**
 * Page object configuration
 */
export interface PageObjectConfig {
  /** Page name */
  name: string;
  /** Page description */
  description?: string;
  /** Page URL */
  url?: string;
  /** Framework type */
  framework: FrameworkType;
  /** Programming language */
  language: LanguageType;
  /** Page elements */
  elements: PageElement[];
  /** Custom methods */
  methods?: PageMethod[];
  /** Author information */
  author?: string;
  /** Tags for categorization */
  tags?: string[];
}

/**
 * Page element definition
 */
export interface PageElement {
  /** Element name */
  name: string;
  /** Element description */
  description?: string;
  /** Locator type (id, css, xpath, etc.) */
  locatorType: string;
  /** Locator value */
  locatorValue: string;
  /** Is the element required for page validation */
  isRequired?: boolean;
  /** Generate interaction method for this element */
  generateMethod?: boolean;
  /** Custom method name for element interaction */
  methodName?: string;
  /** Element type (button, input, select, etc.) */
  elementType?: string;
  /** Is the element a frame/iframe */
  isFrame?: boolean;
  /** Wait condition for element */
  waitCondition?: string;
  /** Wait timeout for element */
  waitTimeout?: number;
}

/**
 * Page method definition
 */
export interface PageMethod {
  /** Method name */
  name: string;
  /** Method description */
  description?: string;
  /** Method parameters */
  parameters?: MethodParameter[];
  /** Method return type */
  returnType?: string;
  /** Method code */
  code: string;
}

/**
 * Method parameter definition
 */
export interface MethodParameter {
  /** Parameter name */
  name: string;
  /** Parameter type */
  type: string;
  /** Parameter description */
  description?: string;
  /** Default value */
  defaultValue?: any;
}

/**
 * Test case configuration
 */
export interface TestCaseConfig {
  /** Test name */
  name: string;
  /** Test description */
  description?: string;
  /** Framework type */
  framework: FrameworkType;
  /** Programming language */
  language: LanguageType;
  /** Test type */
  testType: TestType;
  /** Test steps */
  steps: TestStep[];
  /** Data provider */
  dataProvider?: DataProvider;
  /** Before/after hooks */
  hooks?: TestHook[];
  /** Test priority */
  priority?: number;
  /** Test groups/categories */
  groups?: string[];
  /** Test dependencies */
  dependencies?: string[];
  /** Author information */
  author?: string;
  /** Tags for categorization */
  tags?: string[];
}

/**
 * Test step definition
 */
export interface TestStep {
  /** Step description */
  description: string;
  /** Step type (for BDD: given, when, then) */
  type?: string;
  /** Step code */
  code: string;
  /** Expected result */
  expectedResult?: string;
  /** Screenshot capture for this step */
  captureScreenshot?: boolean;
  /** Wait after this step (milliseconds) */
  waitAfter?: number;
  /** Retry this step on failure */
  retryOnFailure?: boolean;
  /** Maximum retry attempts */
  maxRetries?: number;
}

/**
 * Data provider definition
 */
export interface DataProvider {
  /** Data provider name */
  name: string;
  /** Data provider type (excel, csv, json, database) */
  type: string;
  /** Data source path or connection string */
  source: string;
  /** Sheet name for Excel */
  sheet?: string;
  /** SQL query for database */
  query?: string;
  /** Data transformer function */
  transformer?: string;
  /** Data parameters */
  parameters: DataParameter[];
}

/**
 * Data parameter definition
 */
export interface DataParameter {
  /** Parameter name */
  name: string;
  /** Parameter type */
  type: string;
  /** Parameter description */
  description?: string;
  /** Column name or JSON path */
  column: string;
}

/**
 * Test hook definition
 */
export interface TestHook {
  /** Hook type (beforeTest, afterTest, beforeClass, afterClass, etc.) */
  type: string;
  /** Hook description */
  description?: string;
  /** Hook code */
  code: string;
  /** Always run this hook (even if test fails) */
  alwaysRun?: boolean;
}

/**
 * Test suite configuration
 */
export interface TestSuiteConfig {
  /** Suite name */
  name: string;
  /** Suite description */
  description?: string;
  /** Framework type */
  framework: FrameworkType;
  /** Programming language */
  language: LanguageType;
  /** Test type */
  testType: TestType;
  /** Test cases in this suite */
  testCases: string[];
  /** Before/after hooks */
  hooks?: TestHook[];
  /** Parallel execution */
  parallel?: boolean;
  /** Thread count for parallel execution */
  threadCount?: number;
  /** Author information */
  author?: string;
  /** Tags for categorization */
  tags?: string[];
}

/**
 * Project configuration
 */
export interface ProjectConfig {
  /** Project name */
  name: string;
  /** Project description */
  description?: string;
  /** Framework type */
  framework: FrameworkType;
  /** Programming language */
  language: LanguageType;
  /** Test type */
  testType: TestType;
  /** Framework configuration */
  frameworkConfig: FrameworkConfig;
  /** Test suites in this project */
  testSuites: string[];
  /** Page objects in this project */
  pageObjects: string[];
  /** Environment configurations */
  environments: EnvironmentConfig[];
  /** Data sources */
  dataSources: DataSourceConfig[];
  /** Reporting configuration */
  reporting: ReportingConfig;
  /** CI/CD configuration */
  cicd: PipelineConfiguration;
  /** Author information */
  author?: string;
  /** Creation date */
  createdAt: string;
  /** Last modified date */
  modifiedAt: string;
  /** Version */
  version: string;
}

/**
 * Environment configuration
 */
export interface EnvironmentConfig {
  /** Environment name */
  name: string;
  /** Environment description */
  description?: string;
  /** Base URL for this environment */
  baseUrl: string;
  /** Environment variables */
  variables: Record<string, string>;
}

/**
 * Data source configuration
 */
export interface DataSourceConfig {
  /** Data source name */
  name: string;
  /** Data source type (excel, csv, json, database) */
  type: string;
  /** Data source path or connection string */
  source: string;
  /** Sheet name for Excel */
  sheet?: string;
  /** Table name for database */
  table?: string;
  /** Database credentials */
  credentials?: {
    username: string;
    password: string;
  };
}

/**
 * Reporting configuration
 */
export interface ReportingConfig {
  /** Enable HTML reports */
  htmlReports: boolean;
  /** Enable XML reports */
  xmlReports: boolean;
  /** Enable JSON reports */
  jsonReports: boolean;
  /** Enable PDF reports */
  pdfReports: boolean;
  /** Enable dashboard */
  dashboard: boolean;
  /** Enable email notifications */
  emailNotifications: boolean;
  /** Email recipients */
  emailRecipients?: string[];
  /** Enable Slack notifications */
  slackNotifications: boolean;
  /** Slack webhook URL */
  slackWebhookUrl?: string;
  /** Slack channel */
  slackChannel?: string;
  /** Enable screenshots on failure */
  screenshotsOnFailure: boolean;
  /** Enable video recording */
  videoRecording: boolean;
  /** Enable history tracking */
  historyTracking: boolean;
  /** Custom report logo URL */
  customLogoUrl?: string;
  /** Custom report title */
  customTitle?: string;
  /** Custom report stylesheet URL */
  customStylesheetUrl?: string;
}

/**
 * Pipeline environment variable
 */
export interface PipelineVariable {
  /** Variable name */
  name: string;
  /** Variable value */
  value: string;
  /** Variable type */
  type: string;
  /** Is this a secret variable */
  isSecret: boolean;
  /** Variable description */
  description?: string;
}

/**
 * Pipeline schedule
 */
export interface PipelineSchedule {
  /** Cron expression */
  cron: string;
  /** Timezone */
  timezone: string;
  /** Is this schedule enabled */
  enabled: boolean;
  /** Schedule description */
  description?: string;
}

/**
 * Pipeline configuration
 */
export interface PipelineConfiguration {
  /** Pipeline name */
  name: string;
  /** CI/CD provider */
  provider: PipelineType;
  /** Framework type */
  framework: FrameworkType;
  /** Programming language */
  language: LanguageType;
  /** Test type */
  testType: TestType;
  /** Target branches */
  branches: string[];
  /** Deployment environments */
  environments: string[];
  /** Test browsers */
  browsers: string[];
  /** Test execution mode */
  executionMode: string;
  /** Enable test reporting */
  reportingEnabled: boolean;
  /** Enable notifications */
  notificationsEnabled: boolean;
  /** Environment variables */
  variables: PipelineVariable[];
  /** Pipeline schedules */
  schedules: PipelineSchedule[];
  /** Pipeline timeout in minutes */
  timeout: number;
  /** Pipeline tags */
  tags: string[];
  /** Provider-specific custom settings */
  customSettings?: Record<string, any>;
}

/**
 * Test execution configuration
 */
export interface TestExecutionConfig {
  /** Test suite to execute */
  testSuite: string;
  /** Framework type */
  framework: FrameworkType;
  /** Programming language */
  language: LanguageType;
  /** Test type */
  testType: TestType;
  /** Environment to use */
  environment: string;
  /** Browser to use */
  browser: string;
  /** Test groups/tags to include */
  includeTags?: string[];
  /** Test groups/tags to exclude */
  excludeTags?: string[];
  /** Enable parallel execution */
  parallel: boolean;
  /** Thread count for parallel execution */
  threadCount?: number;
  /** Retry failed tests */
  retryFailedTests: boolean;
  /** Maximum retry attempts */
  maxRetries?: number;
  /** Enable screenshots on failure */
  screenshotsOnFailure: boolean;
  /** Enable video recording */
  videoRecording: boolean;
  /** Test execution timeout in minutes */
  timeout: number;
  /** Custom capabilities/options */
  capabilities?: Record<string, any>;
  /** Custom properties */
  properties?: Record<string, string>;
}

/**
 * Test result status
 */
export enum TestResultStatus {
  PASSED = 'PASSED',
  FAILED = 'FAILED',
  SKIPPED = 'SKIPPED',
  ERROR = 'ERROR',
  PENDING = 'PENDING'
}

/**
 * Test result
 */
export interface TestResult {
  /** Test name */
  name: string;
  /** Test status */
  status: TestResultStatus;
  /** Test duration in milliseconds */
  duration: number;
  /** Test start time */
  startTime: string;
  /** Test end time */
  endTime: string;
  /** Test steps results */
  steps: TestStepResult[];
  /** Test failure reason */
  failureReason?: string;
  /** Test failure stack trace */
  failureStackTrace?: string;
  /** Screenshot path */
  screenshot?: string;
  /** Video path */
  video?: string;
  /** Test logs */
  logs?: string[];
}

/**
 * Test step result
 */
export interface TestStepResult {
  /** Step description */
  description: string;
  /** Step status */
  status: TestResultStatus;
  /** Step duration in milliseconds */
  duration: number;
  /** Step start time */
  startTime: string;
  /** Step end time */
  endTime: string;
  /** Step failure reason */
  failureReason?: string;
  /** Screenshot path */
  screenshot?: string;
}

/**
 * Test execution result
 */
export interface TestExecutionResult {
  /** Execution ID */
  id: string;
  /** Test suite name */
  testSuite: string;
  /** Environment used */
  environment: string;
  /** Browser used */
  browser: string;
  /** Execution start time */
  startTime: string;
  /** Execution end time */
  endTime: string;
  /** Execution duration in milliseconds */
  duration: number;
  /** Total test count */
  totalTests: number;
  /** Passed test count */
  passedTests: number;
  /** Failed test count */
  failedTests: number;
  /** Skipped test count */
  skippedTests: number;
  /** Error test count */
  errorTests: number;
  /** Test results */
  results: TestResult[];
  /** Execution logs */
  logs?: string[];
}



useFramework.ts
-------------------------------

import { useState, useEffect, useCallback, useContext, createContext, ReactNode } from 'react';
import { FrameworkType, LanguageType, TestType, FrameworkConfig } from '../types/framework';
import { FileSystemStorageService } from '../services/storage/FileSystemStorageService';
import { CSDateUtils } from '../core/utils/CSDateUtils';
import { CSLogger } from '../core/utils/CSLogger';

// Initialize logger
const logger = new CSLogger('useFramework');

/**
 * Default framework configuration
 */
const DEFAULT_FRAMEWORK_CONFIG: FrameworkConfig = {
  framework: 'selenium',
  language: 'java',
  testType: 'testng',
  browser: 'chrome',
  baseUrl: 'https://example.com',
  implicitWait: 10,
  explicitWait: 30,
  pageLoadTimeout: 60,
  scriptTimeout: 30,
  headless: false,
  windowWidth: 1920,
  windowHeight: 1080,
  screenshotsOnFailure: true,
  videoRecording: false,
  networkTrafficCapture: false,
  consoleLogCapture: true,
  performanceMetricsCapture: false,
  parallelExecution: false,
  maxParallelInstances: 5,
  selfHealing: true,
  capabilities: {}
};

/**
 * Framework context interface
 */
interface FrameworkContextType {
  /** Selected framework (Selenium, Playwright) */
  selectedFramework: FrameworkType;
  /** Selected language (Java, TypeScript) */
  selectedLanguage: LanguageType;
  /** Selected test type (TestNG, BDD) */
  selectedTestType: TestType;
  /** Complete framework configuration */
  frameworkConfig: FrameworkConfig;
  /** Change framework */
  changeFramework: (framework: FrameworkType) => void;
  /** Change language */
  changeLanguage: (language: LanguageType) => void;
  /** Change test type */
  changeTestType: (testType: TestType) => void;
  /** Update framework configuration */
  updateFrameworkConfig: (config: Partial<FrameworkConfig>) => void;
  /** Reset framework configuration to defaults */
  resetFrameworkConfig: () => void;
  /** Save framework configuration */
  saveFrameworkConfig: () => Promise<void>;
  /** Load framework configuration */
  loadFrameworkConfig: () => Promise<void>;
  /** Loading status */
  isLoading: boolean;
  /** Error message */
  error: string | null;
}

/**
 * Create framework context with default values
 */
const FrameworkContext = createContext<FrameworkContextType>({
  selectedFramework: DEFAULT_FRAMEWORK_CONFIG.framework,
  selectedLanguage: DEFAULT_FRAMEWORK_CONFIG.language,
  selectedTestType: DEFAULT_FRAMEWORK_CONFIG.testType,
  frameworkConfig: DEFAULT_FRAMEWORK_CONFIG,
  changeFramework: () => {},
  changeLanguage: () => {},
  changeTestType: () => {},
  updateFrameworkConfig: () => {},
  resetFrameworkConfig: () => {},
  saveFrameworkConfig: async () => {},
  loadFrameworkConfig: async () => {},
  isLoading: false,
  error: null
});

/**
 * Framework provider props
 */
interface FrameworkProviderProps {
  children: ReactNode;
  initialFramework?: FrameworkType;
  initialLanguage?: LanguageType;
  initialTestType?: TestType;
}

/**
 * Framework provider component
 */
export const FrameworkProvider: React.FC<FrameworkProviderProps> = ({
  children,
  initialFramework = DEFAULT_FRAMEWORK_CONFIG.framework,
  initialLanguage = DEFAULT_FRAMEWORK_CONFIG.language,
  initialTestType = DEFAULT_FRAMEWORK_CONFIG.testType
}) => {
  // Framework selection state
  const [selectedFramework, setSelectedFramework] = useState<FrameworkType>(initialFramework);
  const [selectedLanguage, setSelectedLanguage] = useState<LanguageType>(initialLanguage);
  const [selectedTestType, setSelectedTestType] = useState<TestType>(initialTestType);
  
  // Framework configuration state
  const [frameworkConfig, setFrameworkConfig] = useState<FrameworkConfig>({
    ...DEFAULT_FRAMEWORK_CONFIG,
    framework: initialFramework,
    language: initialLanguage,
    testType: initialTestType
  });
  
  // Loading and error state
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  
  // Storage service
  const storageService = new FileSystemStorageService();
  
  // Storage path for configuration
  const configStoragePath = '/cstestforge/config/framework-config.json';
  
  /**
   * Change selected framework
   */
  const changeFramework = useCallback((framework: FrameworkType) => {
    logger.info(`Changing framework to ${framework}`);
    setSelectedFramework(framework);
    
    // Update framework configuration
    setFrameworkConfig(prev => ({
      ...prev,
      framework
    }));
  }, []);
  
  /**
   * Change selected language
   */
  const changeLanguage = useCallback((language: LanguageType) => {
    logger.info(`Changing language to ${language}`);
    setSelectedLanguage(language);
    
    // Update framework configuration
    setFrameworkConfig(prev => ({
      ...prev,
      language
    }));
  }, []);
  
  /**
   * Change selected test type
   */
  const changeTestType = useCallback((testType: TestType) => {
    logger.info(`Changing test type to ${testType}`);
    setSelectedTestType(testType);
    
    // Update framework configuration
    setFrameworkConfig(prev => ({
      ...prev,
      testType
    }));
  }, []);
  
  /**
   * Update framework configuration
   */
  const updateFrameworkConfig = useCallback((config: Partial<FrameworkConfig>) => {
    logger.info('Updating framework configuration', config);
    
    setFrameworkConfig(prev => {
      const updated = {
        ...prev,
        ...config
      };
      
      // Update selected framework, language, and test type if they are included in the config
      if (config.framework && config.framework !== selectedFramework) {
        setSelectedFramework(config.framework);
      }
      
      if (config.language && config.language !== selectedLanguage) {
        setSelectedLanguage(config.language);
      }
      
      if (config.testType && config.testType !== selectedTestType) {
        setSelectedTestType(config.testType);
      }
      
      return updated;
    });
  }, [selectedFramework, selectedLanguage, selectedTestType]);
  
  /**
   * Reset framework configuration to defaults
   */
  const resetFrameworkConfig = useCallback(() => {
    logger.info('Resetting framework configuration to defaults');
    
    setFrameworkConfig(DEFAULT_FRAMEWORK_CONFIG);
    setSelectedFramework(DEFAULT_FRAMEWORK_CONFIG.framework);
    setSelectedLanguage(DEFAULT_FRAMEWORK_CONFIG.language);
    setSelectedTestType(DEFAULT_FRAMEWORK_CONFIG.testType);
  }, []);
  
  /**
   * Save framework configuration to storage
   */
  const saveFrameworkConfig = useCallback(async () => {
    logger.info('Saving framework configuration to storage');
    
    setIsLoading(true);
    setError(null);
    
    try {
      // Create parent directory if it doesn't exist
      await storageService.createDirectory('/cstestforge/config');
      
      // Prepare configuration with metadata
      const configToSave = {
        ...frameworkConfig,
        metadata: {
          savedAt: CSDateUtils.getCurrentTimestamp(),
          version: '1.0.0'
        }
      };
      
      // Save configuration to storage
      await storageService.writeFile(configStoragePath, JSON.stringify(configToSave, null, 2));
      
      setIsLoading(false);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error('Failed to save framework configuration', errorMessage);
      setError(`Failed to save framework configuration: ${errorMessage}`);
      setIsLoading(false);
    }
  }, [frameworkConfig]);
  
  /**
   * Load framework configuration from storage
   */
  const loadFrameworkConfig = useCallback(async () => {
    logger.info('Loading framework configuration from storage');
    
    setIsLoading(true);
    setError(null);
    
    try {
      // Check if configuration file exists
      const configExists = await storageService.fileExists(configStoragePath);
      
      if (!configExists) {
        logger.info('Configuration file not found, using defaults');
        setIsLoading(false);
        return;
      }
      
      // Load configuration from storage
      const configJson = await storageService.readFile(configStoragePath);
      const loadedConfig = JSON.parse(configJson) as FrameworkConfig & { metadata?: { savedAt: string, version: string } };
      
      // Remove metadata before setting the configuration
      const { metadata, ...configWithoutMetadata } = loadedConfig;
      
      // Update framework configuration
      setFrameworkConfig(configWithoutMetadata);
      
      // Update selected framework, language, and test type
      setSelectedFramework(configWithoutMetadata.framework);
      setSelectedLanguage(configWithoutMetadata.language);
      setSelectedTestType(configWithoutMetadata.testType);
      
      setIsLoading(false);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error('Failed to load framework configuration', errorMessage);
      setError(`Failed to load framework configuration: ${errorMessage}`);
      setIsLoading(false);
    }
  }, []);
  
  /**
   * Load framework configuration on mount
   */
  useEffect(() => {
    loadFrameworkConfig();
  }, [loadFrameworkConfig]);
  
  const contextValue: FrameworkContextType = {
    selectedFramework,
    selectedLanguage,
    selectedTestType,
    frameworkConfig,
    changeFramework,
    changeLanguage,
    changeTestType,
    updateFrameworkConfig,
    resetFrameworkConfig,
    saveFrameworkConfig,
    loadFrameworkConfig,
    isLoading,
    error
  };
  
  return (
    <FrameworkContext.Provider value={contextValue}>
      {children}
    </FrameworkContext.Provider>
  );
};

/**
 * Hook to use framework context
 */
export const useFramework = (): FrameworkContextType => {
  const context = useContext(FrameworkContext);
  
  if (!context) {
    throw new Error('useFramework must be used within a FrameworkProvider');
  }
  
  return context;
};

/**
 * Get browser capabilities for the selected framework and browser
 * @param framework Selected framework
 * @param browser Selected browser
 * @returns Browser capabilities object
 */
export const getBrowserCapabilities = (framework: FrameworkType, browser: string): Record<string, any> => {
  const commonCapabilities = {
    acceptInsecureCerts: true,
    timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
  };
  
  // Browser-specific capabilities
  const browserCapabilities: Record<string, Record<string, any>> = {
    chrome: {
      browserName: 'chrome',
      'goog:chromeOptions': {
        args: [
          '--no-sandbox',
          '--disable-dev-shm-usage',
          '--disable-gpu',
          '--disable-extensions',
          '--disable-popup-blocking',
          '--disable-infobars'
        ],
        excludeSwitches: ['enable-automation']
      }
    },
    firefox: {
      browserName: 'firefox',
      'moz:firefoxOptions': {
        args: ['-headless'],
        prefs: {
          'dom.webnotifications.enabled': false,
          'dom.push.enabled': false
        }
      }
    },
    edge: {
      browserName: 'MicrosoftEdge',
      'ms:edgeOptions': {
        args: [
          '--no-sandbox',
          '--disable-dev-shm-usage',
          '--disable-gpu',
          '--disable-extensions'
        ]
      }
    },
    safari: {
      browserName: 'safari',
      'safari:options': {
        automaticInspection: false
      }
    }
  };
  
  // Framework-specific capabilities
  const frameworkCapabilities: Record<FrameworkType, Record<string, any>> = {
    selenium: {
      ...commonCapabilities,
      ...browserCapabilities[browser] || {},
      'se:recordVideo': true,
      'se:timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone
    },
    playwright: {
      ...commonCapabilities,
      channel: browser === 'chrome' ? 'chrome' : browser === 'firefox' ? 'firefox' : browser === 'edge' ? 'msedge' : browser,
      recordVideo: {
        dir: 'videos/',
        size: { width: 1280, height: 720 }
      },
      viewport: { width: 1280, height: 720 },
      ignoreHTTPSErrors: true
    }
  };
  
  return frameworkCapabilities[framework];
};

/**
 * Get script imports for the selected framework, language, and test type
 * @param framework Selected framework
 * @param language Selected language
 * @param testType Selected test type
 * @returns Script imports array
 */
export const getFrameworkImports = (
  framework: FrameworkType,
  language: LanguageType,
  testType: TestType
): string[] => {
  // Java imports
  if (language === 'java') {
    if (framework === 'selenium') {
      const seleniumImports = [
        'import org.openqa.selenium.WebDriver;',
        'import org.openqa.selenium.chrome.ChromeDriver;',
        'import org.openqa.selenium.firefox.FirefoxDriver;',
        'import org.openqa.selenium.edge.EdgeDriver;',
        'import org.openqa.selenium.safari.SafariDriver;',
        'import org.openqa.selenium.support.ui.WebDriverWait;',
        'import org.openqa.selenium.support.ui.ExpectedConditions;',
        'import org.openqa.selenium.By;',
        'import org.openqa.selenium.WebElement;',
        'import org.openqa.selenium.interactions.Actions;',
        'import java.time.Duration;',
        'import com.cstestforge.framework.core.config.ConfigurationManager;',
        'import com.cstestforge.framework.selenium.browser.WebDriverManager;',
        'import com.cstestforge.framework.core.utils.CSLogger;',
        'import com.cstestforge.framework.core.utils.CSScreenshotManager;'
      ];
      
      if (testType === 'testng') {
        return [
          ...seleniumImports,
          'import org.testng.annotations.BeforeClass;',
          'import org.testng.annotations.AfterClass;',
          'import org.testng.annotations.BeforeMethod;',
          'import org.testng.annotations.AfterMethod;',
          'import org.testng.annotations.Test;',
          'import org.testng.annotations.Parameters;',
          'import org.testng.Assert;',
          'import com.cstestforge.framework.selenium.java.testng.CSBaseTest;',
          'import com.cstestforge.framework.selenium.java.testng.annotations.CSTest;',
          'import com.cstestforge.framework.core.reporting.listener.CSTestListener;'
        ];
      } else { // BDD
        return [
          ...seleniumImports,
          'import io.cucumber.java.en.Given;',
          'import io.cucumber.java.en.When;',
          'import io.cucumber.java.en.Then;',
          'import io.cucumber.java.Before;',
          'import io.cucumber.java.After;',
          'import io.cucumber.java.Scenario;',
          'import com.cstestforge.framework.selenium.java.bdd.CSBaseStepDef;',
          'import com.cstestforge.framework.selenium.java.bdd.CSHooks;'
        ];
      }
    } else { // Playwright
      const playwrightImports = [
        'import com.microsoft.playwright.Playwright;',
        'import com.microsoft.playwright.Browser;',
        'import com.microsoft.playwright.BrowserContext;',
        'import com.microsoft.playwright.Page;',
        'import com.microsoft.playwright.BrowserType;',
        'import com.microsoft.playwright.options.LoadState;',
        'import com.microsoft.playwright.options.WaitForSelectorState;',
        'import java.nio.file.Paths;',
        'import com.cstestforge.framework.core.config.ConfigurationManager;',
        'import com.cstestforge.framework.playwright.browser.PlaywrightManager;',
        'import com.cstestforge.framework.core.utils.CSLogger;',
        'import com.cstestforge.framework.core.utils.CSScreenshotManager;'
      ];
      
      if (testType === 'testng') {
        return [
          ...playwrightImports,
          'import org.testng.annotations.BeforeClass;',
          'import org.testng.annotations.AfterClass;',
          'import org.testng.annotations.BeforeMethod;',
          'import org.testng.annotations.AfterMethod;',
          'import org.testng.annotations.Test;',
          'import org.testng.annotations.Parameters;',
          'import org.testng.Assert;',
          'import com.cstestforge.framework.playwright.java.testng.CSBaseTest;',
          'import com.cstestforge.framework.playwright.java.testng.annotations.CSTest;',
          'import com.cstestforge.framework.core.reporting.listener.CSTestListener;'
        ];
      } else { // BDD
        return [
          ...playwrightImports,
          'import io.cucumber.java.en.Given;',
          'import io.cucumber.java.en.When;',
          'import io.cucumber.java.en.Then;',
          'import io.cucumber.java.Before;',
          'import io.cucumber.java.After;',
          'import io.cucumber.java.Scenario;',
          'import com.cstestforge.framework.playwright.java.bdd.CSBaseStepDef;',
          'import com.cstestforge.framework.playwright.java.bdd.CSHooks;'
        ];
      }
    }
  } else { // TypeScript imports
    if (framework === 'selenium') {
      const seleniumImports = [
        "import { Builder, WebDriver, WebElement, By, until } from 'selenium-webdriver';",
        "import { Options as ChromeOptions } from 'selenium-webdriver/chrome';",
        "import { Options as FirefoxOptions } from 'selenium-webdriver/firefox';",
        "import { Options as EdgeOptions } from 'selenium-webdriver/edge';",
        "import { Options as SafariOptions } from 'selenium-webdriver/safari';",
        "import { ConfigurationManager } from '../../core/config/ConfigurationManager';",
        "import { WebDriverManager } from '../browser/WebDriverManager';",
        "import { CSLogger } from '../../core/utils/CSLogger';",
        "import { CSScreenshotManager } from '../../core/utils/CSScreenshotManager';"
      ];
      
      if (testType === 'testng') {
        return [
          ...seleniumImports,
          "import { describe, beforeAll, afterAll, beforeEach, afterEach, it, expect } from 'mocha';",
          "import { CSBaseTest } from '../testng/CSBaseTest';",
          "import { CSTest } from '../testng/annotations/CSTest';",
          "import { CSTestListener } from '../../core/reporting/listener/CSTestListener';"
        ];
      } else { // BDD
        return [
          ...seleniumImports,
          "import { Given, When, Then, Before, After, setDefaultTimeout } from '@cucumber/cucumber';",
          "import { CSBaseStepDef } from '../bdd/CSBaseStepDef';",
          "import { CSHooks } from '../bdd/CSHooks';"
        ];
      }
    } else { // Playwright
      const playwrightImports = [
        "import { chromium, firefox, webkit, Browser, BrowserContext, Page, BrowserType } from 'playwright';",
        "import { ConfigurationManager } from '../../core/config/ConfigurationManager';",
        "import { PlaywrightManager } from '../browser/PlaywrightManager';",
        "import { CSLogger } from '../../core/utils/CSLogger';",
        "import { CSScreenshotManager } from '../../core/utils/CSScreenshotManager';"
      ];
      
      if (testType === 'testng') {
        return [
          ...playwrightImports,
          "import { describe, beforeAll, afterAll, beforeEach, afterEach, it, expect } from 'mocha';",
          "import { CSBaseTest } from '../testng/CSBaseTest';",
          "import { CSTest } from '../testng/annotations/CSTest';",
          "import { CSTestListener } from '../../core/reporting/listener/CSTestListener';"
        ];
      } else { // BDD
        return [
          ...playwrightImports,
          "import { Given, When, Then, Before, After, setDefaultTimeout } from '@cucumber/cucumber';",
          "import { CSBaseStepDef } from '../bdd/CSBaseStepDef';",
          "import { CSHooks } from '../bdd/CSHooks';"
        ];
      }
    }
  }
};

/**
 * Get a unique key for a framework configuration
 * @param framework Selected framework
 * @param language Selected language
 * @param testType Selected test type
 * @returns Unique key
 */
export const getFrameworkKey = (
  framework: FrameworkType,
  language: LanguageType,
  testType: TestType
): string => {
  return `${framework}-${language}-${testType}`;
};

export default useFramework;

DataSerializer.ts
----------------------------------------------------
import { CSLogger } from '../../core/utils/CSLogger';
import { CSEncryptionUtils } from '../../core/utils/CSEncryptionUtils';

// Initialize logger
const logger = new CSLogger('DataSerializer');

/**
 * Serialization formats
 */
export enum SerializationFormat {
  JSON = 'json',
  XML = 'xml',
  BINARY = 'binary',
  TEXT = 'text'
}

/**
 * Serialization options
 */
export interface SerializationOptions {
  /** Format to serialize to (default: JSON) */
  format?: SerializationFormat;
  /** Whether to compress the serialized data (default: false) */
  compress?: boolean;
  /** Whether to encrypt the serialized data (default: false) */
  encrypt?: boolean;
  /** Whether to include metadata in the serialized data (default: true) */
  includeMetadata?: boolean;
  /** Pretty print JSON and XML (default: false) */
  prettyPrint?: boolean;
  /** Custom encryption key (default: use built-in key) */
  encryptionKey?: string;
  /** XML root element name (default: 'root') */
  xmlRootElementName?: string;
}

/**
 * Default serialization options
 */
const DEFAULT_SERIALIZATION_OPTIONS: SerializationOptions = {
  format: SerializationFormat.JSON,
  compress: false,
  encrypt: false,
  includeMetadata: true,
  prettyPrint: false,
  xmlRootElementName: 'root'
};

/**
 * Metadata added to serialized data
 */
interface SerializationMetadata {
  /** Timestamp when data was serialized */
  timestamp: string;
  /** Format used for serialization */
  format: SerializationFormat;
  /** Whether data is compressed */
  compressed: boolean;
  /** Whether data is encrypted */
  encrypted: boolean;
  /** Original data type */
  dataType: string;
  /** Serializer version */
  serializerVersion: string;
  /** Checksum for data integrity verification */
  checksum?: string;
}

/**
 * Deserialization options
 */
export interface DeserializationOptions {
  /** Format to deserialize from (if not auto-detected) */
  format?: SerializationFormat;
  /** Whether to decompress the serialized data (default: auto-detect) */
  decompress?: boolean;
  /** Whether to decrypt the serialized data (default: auto-detect) */
  decrypt?: boolean;
  /** Whether to include metadata in the deserialized data (default: false) */
  includeMetadata?: boolean;
  /** Custom decryption key (default: use built-in key) */
  decryptionKey?: string;
  /** Expected data type (for validation) */
  expectedDataType?: string;
  /** Validate checksum (default: true if available) */
  validateChecksum?: boolean;
}

/**
 * Default deserialization options
 */
const DEFAULT_DESERIALIZATION_OPTIONS: DeserializationOptions = {
  decompress: true,
  decrypt: true,
  includeMetadata: false,
  validateChecksum: true
};

/**
 * Serialized data with metadata
 */
interface SerializedData<T> {
  /** The serialized data */
  data: T;
  /** Metadata about the serialization */
  metadata: SerializationMetadata;
}

/**
 * Service for serializing and deserializing data
 */
export class DataSerializer {
  private static readonly SERIALIZER_VERSION = '1.0.0';
  
  /**
   * Serialize data to the specified format
   * @param data Data to serialize
   * @param options Serialization options
   * @returns Serialized data as string or ArrayBuffer
   */
  public static async serialize<T>(
    data: T,
    options: SerializationOptions = {}
  ): Promise<string | ArrayBuffer> {
    // Merge options with defaults
    const mergedOptions: SerializationOptions = {
      ...DEFAULT_SERIALIZATION_OPTIONS,
      ...options
    };
    
    logger.debug(`Serializing data with options: ${JSON.stringify(mergedOptions)}`);
    
    // Create metadata
    const metadata: SerializationMetadata = {
      timestamp: new Date().toISOString(),
      format: mergedOptions.format!,
      compressed: mergedOptions.compress!,
      encrypted: mergedOptions.encrypt!,
      dataType: this.getDataType(data),
      serializerVersion: this.SERIALIZER_VERSION
    };
    
    // Create serialized data with metadata
    const serializedData: SerializedData<T> = {
      data,
      metadata
    };
    
    // Convert to the specified format
    let serialized: string | ArrayBuffer;
    if (mergedOptions.includeMetadata) {
      serialized = await this.convertToFormat(serializedData, mergedOptions);
    } else {
      serialized = await this.convertToFormat(data, mergedOptions);
    }
    
    // Calculate checksum if needed
    if (mergedOptions.includeMetadata) {
      const checksum = await this.calculateChecksum(serialized);
      (serializedData.metadata as SerializationMetadata).checksum = checksum;
      serialized = await this.convertToFormat(serializedData, mergedOptions);
    }
    
    // Compress if needed
    if (mergedOptions.compress) {
      serialized = await this.compress(serialized);
    }
    
    // Encrypt if needed
    if (mergedOptions.encrypt) {
      const encryptionKey = mergedOptions.encryptionKey || undefined;
      serialized = await this.encrypt(serialized, encryptionKey);
    }
    
    return serialized;
  }
  
  /**
   * Deserialize data from the specified format
   * @param serialized Serialized data
   * @param options Deserialization options
   * @returns Deserialized data
   */
  public static async deserialize<T>(
    serialized: string | ArrayBuffer,
    options: DeserializationOptions = {}
  ): Promise<T | SerializedData<T>> {
    // Merge options with defaults
    const mergedOptions: DeserializationOptions = {
      ...DEFAULT_DESERIALIZATION_OPTIONS,
      ...options
    };
    
    logger.debug(`Deserializing data with options: ${JSON.stringify(mergedOptions)}`);
    
    let data: string | ArrayBuffer = serialized;
    let metadata: SerializationMetadata | null = null;
    
    // Try to detect format and metadata if not specified
    if (!mergedOptions.format) {
      try {
        // If it's a string, try to parse it as JSON
        if (typeof data === 'string') {
          const parsed = JSON.parse(data);
          if (parsed.metadata && parsed.data) {
            metadata = parsed.metadata;
            mergedOptions.format = metadata.format;
            mergedOptions.decompress = metadata.compressed;
            mergedOptions.decrypt = metadata.encrypted;
          } else {
            mergedOptions.format = SerializationFormat.JSON;
          }
        } else {
          // For binary data, assume it might be encrypted or compressed
          mergedOptions.format = SerializationFormat.BINARY;
        }
      } catch (err) {
        // If parsing fails, assume it's just a string
        mergedOptions.format = SerializationFormat.TEXT;
      }
    }
    
    // Decrypt if needed
    if (mergedOptions.decrypt) {
      try {
        const decryptionKey = mergedOptions.decryptionKey || undefined;
        data = await this.decrypt(data, decryptionKey);
      } catch (err) {
        logger.warn('Failed to decrypt data, continuing with raw data', err);
      }
    }
    
    // Decompress if needed
    if (mergedOptions.decompress) {
      try {
        data = await this.decompress(data);
      } catch (err) {
        logger.warn('Failed to decompress data, continuing with raw data', err);
      }
    }
    
    // Parse from the specified format
    let deserializedData: T | SerializedData<T>;
    
    try {
      deserializedData = await this.parseFromFormat<T>(data, mergedOptions.format!);
    } catch (err) {
      throw new Error(`Failed to deserialize data: ${err instanceof Error ? err.message : String(err)}`);
    }
    
    // Extract metadata if present
    if (typeof deserializedData === 'object' && deserializedData !== null) {
      const dataObj = deserializedData as any;
      if (dataObj.metadata && dataObj.data) {
        metadata = dataObj.metadata;
        deserializedData = dataObj.data;
      }
    }
    
    // Validate data type if specified
    if (metadata && mergedOptions.expectedDataType && metadata.dataType !== mergedOptions.expectedDataType) {
      throw new Error(`Expected data type ${mergedOptions.expectedDataType}, but got ${metadata.dataType}`);
    }
    
    // Validate checksum if available
    if (metadata && metadata.checksum && mergedOptions.validateChecksum) {
      const calculatedChecksum = await this.calculateChecksum(
        typeof deserializedData === 'object' ? JSON.stringify(deserializedData) : String(deserializedData)
      );
      
      if (calculatedChecksum !== metadata.checksum) {
        throw new Error('Data integrity check failed: checksum does not match');
      }
    }
    
    // Return data with or without metadata
    if (mergedOptions.includeMetadata && metadata) {
      return {
        data: deserializedData as T,
        metadata
      };
    } else {
      return deserializedData as T;
    }
  }
  
  /**
   * Convert data to the specified format
   * @param data Data to convert
   * @param options Serialization options
   * @returns Serialized data as string or ArrayBuffer
   */
  private static async convertToFormat<T>(
    data: T,
    options: SerializationOptions
  ): Promise<string | ArrayBuffer> {
    switch (options.format) {
      case SerializationFormat.JSON:
        return this.toJSON(data, options.prettyPrint);
      case SerializationFormat.XML:
        return this.toXML(data, options.xmlRootElementName, options.prettyPrint);
      case SerializationFormat.BINARY:
        return this.toBinary(data);
      case SerializationFormat.TEXT:
        return this.toText(data);
      default:
        throw new Error(`Unsupported serialization format: ${options.format}`);
    }
  }
  
  /**
   * Parse data from the specified format
   * @param data Serialized data
   * @param format Format to parse from
   * @returns Deserialized data
   */
  private static async parseFromFormat<T>(
    data: string | ArrayBuffer,
    format: SerializationFormat
  ): Promise<T> {
    switch (format) {
      case SerializationFormat.JSON:
        return this.fromJSON<T>(data);
      case SerializationFormat.XML:
        return this.fromXML<T>(data);
      case SerializationFormat.BINARY:
        return this.fromBinary<T>(data);
      case SerializationFormat.TEXT:
        return this.fromText<T>(data);
      default:
        throw new Error(`Unsupported deserialization format: ${format}`);
    }
  }
  
  /**
   * Convert data to JSON
   * @param data Data to convert
   * @param prettyPrint Whether to pretty print the JSON
   * @returns JSON string
   */
  private static toJSON<T>(data: T, prettyPrint: boolean = false): string {
    try {
      return prettyPrint ? JSON.stringify(data, null, 2) : JSON.stringify(data);
    } catch (err) {
      throw new Error(`Failed to convert to JSON: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Parse JSON
   * @param data JSON string or ArrayBuffer
   * @returns Parsed JSON
   */
  private static fromJSON<T>(data: string | ArrayBuffer): T {
    try {
      const jsonString = typeof data === 'string' ? data : this.arrayBufferToString(data);
      return JSON.parse(jsonString);
    } catch (err) {
      throw new Error(`Failed to parse JSON: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Convert data to XML
   * @param data Data to convert
   * @param rootElementName Root element name
   * @param prettyPrint Whether to pretty print the XML
   * @returns XML string
   */
  private static toXML<T>(data: T, rootElementName: string = 'root', prettyPrint: boolean = false): string {
    try {
      let xml = this.objectToXML(data, rootElementName);
      
      if (prettyPrint) {
        xml = this.prettyPrintXML(xml);
      }
      
      return `<?xml version="1.0" encoding="UTF-8"?>\n${xml}`;
    } catch (err) {
      throw new Error(`Failed to convert to XML: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Parse XML
   * @param data XML string or ArrayBuffer
   * @returns Parsed XML as object
   */
  private static fromXML<T>(data: string | ArrayBuffer): T {
    try {
      const xmlString = typeof data === 'string' ? data : this.arrayBufferToString(data);
      
      // Use DOMParser to parse XML string
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
      
      // Check for parsing errors
      const parserError = xmlDoc.querySelector('parsererror');
      if (parserError) {
        throw new Error('XML parsing error: ' + parserError.textContent);
      }
      
      // Convert XML to JavaScript object
      return this.xmlToObject(xmlDoc.documentElement) as T;
    } catch (err) {
      throw new Error(`Failed to parse XML: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Convert data to binary format
   * @param data Data to convert
   * @returns Binary data as ArrayBuffer
   */
  private static toBinary<T>(data: T): ArrayBuffer {
    try {
      // Convert to JSON string first, then to ArrayBuffer
      const jsonString = JSON.stringify(data);
      return this.stringToArrayBuffer(jsonString);
    } catch (err) {
      throw new Error(`Failed to convert to binary: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Parse binary data
   * @param data Binary data as string or ArrayBuffer
   * @returns Parsed binary data
   */
  private static fromBinary<T>(data: string | ArrayBuffer): T {
    try {
      // Convert from ArrayBuffer to JSON string, then parse
      const jsonString = typeof data === 'string' ? data : this.arrayBufferToString(data);
      return JSON.parse(jsonString);
    } catch (err) {
      throw new Error(`Failed to parse binary: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Convert data to text
   * @param data Data to convert
   * @returns Text string
   */
  private static toText<T>(data: T): string {
    try {
      if (typeof data === 'string') {
        return data;
      } else if (data === null || data === undefined) {
        return '';
      } else if (typeof data === 'object') {
        return JSON.stringify(data);
      } else {
        return String(data);
      }
    } catch (err) {
      throw new Error(`Failed to convert to text: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Parse text data
   * @param data Text data as string or ArrayBuffer
   * @returns Parsed text data
   */
  private static fromText<T>(data: string | ArrayBuffer): T {
    try {
      return typeof data === 'string' ? data as unknown as T : this.arrayBufferToString(data) as unknown as T;
    } catch (err) {
      throw new Error(`Failed to parse text: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Compress data
   * @param data Data to compress
   * @returns Compressed data as ArrayBuffer
   */
  private static async compress(data: string | ArrayBuffer): Promise<ArrayBuffer> {
    try {
      // Convert string to ArrayBuffer if needed
      const buffer = typeof data === 'string' ? this.stringToArrayBuffer(data) : data;
      
      // Use CompressionStream API for compression
      const cs = new CompressionStream('gzip');
      const writer = cs.writable.getWriter();
      await writer.write(new Uint8Array(buffer));
      await writer.close();
      
      // Read compressed data
      const reader = cs.readable.getReader();
      const chunks: Uint8Array[] = [];
      
      let result = await reader.read();
      while (!result.done) {
        chunks.push(result.value);
        result = await reader.read();
      }
      
      // Combine chunks
      const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const compressed = new Uint8Array(totalLength);
      
      let offset = 0;
      for (const chunk of chunks) {
        compressed.set(chunk, offset);
        offset += chunk.length;
      }
      
      return compressed.buffer;
    } catch (err) {
      throw new Error(`Failed to compress data: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Decompress data
   * @param data Compressed data as string or ArrayBuffer
   * @returns Decompressed data as string
   */
  private static async decompress(data: string | ArrayBuffer): Promise<string> {
    try {
      // Convert string to ArrayBuffer if needed
      const buffer = typeof data === 'string' ? this.stringToArrayBuffer(data) : data;
      
      // Use DecompressionStream API for decompression
      const ds = new DecompressionStream('gzip');
      const writer = ds.writable.getWriter();
      await writer.write(new Uint8Array(buffer));
      await writer.close();
      
      // Read decompressed data
      const reader = ds.readable.getReader();
      const chunks: Uint8Array[] = [];
      
      let result = await reader.read();
      while (!result.done) {
        chunks.push(result.value);
        result = await reader.read();
      }
      
      // Combine chunks
      const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const decompressed = new Uint8Array(totalLength);
      
      let offset = 0;
      for (const chunk of chunks) {
        decompressed.set(chunk, offset);
        offset += chunk.length;
      }
      
      // Convert back to string
      return this.arrayBufferToString(decompressed.buffer);
    } catch (err) {
      throw new Error(`Failed to decompress data: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Encrypt data
   * @param data Data to encrypt
   * @param key Optional encryption key
   * @returns Encrypted data as string
   */
  private static async encrypt(data: string | ArrayBuffer, key?: string): Promise<string> {
    try {
      // Convert to string if needed
      const dataString = typeof data === 'string' ? data : this.arrayBufferToString(data);
      
      // Use CSEncryptionUtils to encrypt the data
      return await CSEncryptionUtils.encryptData(dataString, key);
    } catch (err) {
      throw new Error(`Failed to encrypt data: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Decrypt data
   * @param data Encrypted data as string or ArrayBuffer
   * @param key Optional decryption key
   * @returns Decrypted data as string
   */
  private static async decrypt(data: string | ArrayBuffer, key?: string): Promise<string> {
    try {
      // Convert to string if needed
      const dataString = typeof data === 'string' ? data : this.arrayBufferToString(data);
      
      // Use CSEncryptionUtils to decrypt the data
      return await CSEncryptionUtils.decryptData(dataString, key);
    } catch (err) {
      throw new Error(`Failed to decrypt data: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Calculate checksum for data
   * @param data Data to calculate checksum for
   * @returns Checksum as string
   */
  private static async calculateChecksum(data: string | ArrayBuffer): Promise<string> {
    try {
      // Convert to string if needed
      const dataString = typeof data === 'string' ? data : this.arrayBufferToString(data);
      
      // Use CSEncryptionUtils to calculate a hash of the data
      return CSEncryptionUtils.hashData(dataString);
    } catch (err) {
      throw new Error(`Failed to calculate checksum: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Convert string to ArrayBuffer
   * @param str String to convert
   * @returns ArrayBuffer
   */
  private static stringToArrayBuffer(str: string): ArrayBuffer {
    const encoder = new TextEncoder();
    return encoder.encode(str).buffer;
  }
  
  /**
   * Convert ArrayBuffer to string
   * @param buffer ArrayBuffer to convert
   * @returns String
   */
  private static arrayBufferToString(buffer: ArrayBuffer): string {
    const decoder = new TextDecoder();
    return decoder.decode(buffer);
  }
  
  /**
   * Get the type of data
   * @param data Data to get type of
   * @returns Type string
   */
  private static getDataType(data: any): string {
    if (data === null) {
      return 'null';
    }
    
    if (Array.isArray(data)) {
      return 'array';
    }
    
    if (data instanceof Date) {
      return 'date';
    }
    
    if (data instanceof Map) {
      return 'map';
    }
    
    if (data instanceof Set) {
      return 'set';
    }
    
    if (typeof data === 'object' && data.constructor && data.constructor.name !== 'Object') {
      return data.constructor.name;
    }
    
    return typeof data;
  }
  
  /**
   * Convert an object to XML
   * @param obj Object to convert
   * @param nodeName Node name
   * @returns XML string
   */
  private static objectToXML(obj: any, nodeName: string): string {
    if (obj === null || obj === undefined) {
      return `<${nodeName} />`;
    }
    
    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {
      return `<${nodeName}>${this.escapeXML(String(obj))}</${nodeName}>`;
    }
    
    if (Array.isArray(obj)) {
      return `<${nodeName} type="array">${obj.map((item, index) => this.objectToXML(item, 'item')).join('')}</${nodeName}>`;
    }
    
    if (obj instanceof Date) {
      return `<${nodeName} type="date">${obj.toISOString()}</${nodeName}>`;
    }
    
    if (typeof obj === 'object') {
      let xml = `<${nodeName}>`;
      
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          // Convert property name to valid XML element name
          const elemName = this.toValidXMLElementName(key);
          xml += this.objectToXML(obj[key], elemName);
        }
      }
      
      xml += `</${nodeName}>`;
      return xml;
    }
    
    // Fallback
    return `<${nodeName}>${this.escapeXML(String(obj))}</${nodeName}>`;
  }
  
  /**
   * Convert XML to object
   * @param node XML node
   * @returns Object
   */
  private static xmlToObject(node: Node): any {
    if (node.nodeType === Node.TEXT_NODE) {
      return node.nodeValue?.trim() || '';
    }
    
    if (node.nodeType === Node.ELEMENT_NODE) {
      const element = node as Element;
      
      // Check if it's an empty element
      if (!element.firstChild) {
        return null;
      }
      
      // Check if it's a simple text element
      if (element.childNodes.length === 1 && element.firstChild?.nodeType === Node.TEXT_NODE) {
        const text = element.firstChild.nodeValue?.trim() || '';
        
        // Check if it's a special type
        const typeAttr = element.getAttribute('type');
        if (typeAttr === 'number') {
          return Number(text);
        } else if (typeAttr === 'boolean') {
          return text.toLowerCase() === 'true';
        } else if (typeAttr === 'date') {
          return new Date(text);
        }
        
        return text;
      }
      
      // Check if it's an array
      if (element.getAttribute('type') === 'array') {
        const array: any[] = [];
        
        for (let i = 0; i < element.childNodes.length; i++) {
          const child = element.childNodes[i];
          if (child.nodeType === Node.ELEMENT_NODE) {
            array.push(this.xmlToObject(child));
          }
        }
        
        return array;
      }
      
      // Otherwise it's an object
      const obj: Record<string, any> = {};
      
      for (let i = 0; i < element.childNodes.length; i++) {
        const child = element.childNodes[i];
        if (child.nodeType === Node.ELEMENT_NODE) {
          const childElement = child as Element;
          const key = childElement.tagName;
          
          // Check if the key already exists (multiple elements with the same name should form an array)
          if (obj[key] !== undefined) {
            if (!Array.isArray(obj[key])) {
              obj[key] = [obj[key]];
            }
            
            obj[key].push(this.xmlToObject(child));
          } else {
            obj[key] = this.xmlToObject(child);
          }
        }
      }
      
      return obj;
    }
    
    return null;
  }
  
  /**
   * Escape XML special characters
   * @param str String to escape
   * @returns Escaped string
   */
  private static escapeXML(str: string): string {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }
  
  /**
   * Convert a string to a valid XML element name
   * @param str String to convert
   * @returns Valid XML element name
   */
  private static toValidXMLElementName(str: string): string {
    // XML element names must start with a letter or underscore
    let validName = /^[a-zA-Z_]/.test(str) ? str : '_' + str;
    
    // Replace invalid characters with underscores
    validName = validName.replace(/[^a-zA-Z0-9_.-]/g, '_');
    
    return validName;
  }
  
  /**
   * Format XML with indentation for better readability
   * @param xml XML string
   * @returns Formatted XML string
   */
  private static prettyPrintXML(xml: string): string {
    let formatted = '';
    let indent = 0;
    const tab = '  '; // 2 spaces
    
    xml = xml.replace(/(>)(<)(\/*)/g, '$1\n$2$3');
    
    const lines = xml.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i].trim();
      
      if (line.match(/<\/.+>/)) {
        indent--;
      }
      
      formatted += tab.repeat(indent) + line + '\n';
      
      if (line.match(/<.+>/) && !line.match(/\/>/) && !line.match(/<\/.+>/)) {
        indent++;
      }
    }
    
    return formatted.trim();
  }
}

StoragePathResolver.ts
---------------------------------------------

import { CSLogger } from '../../core/utils/CSLogger';
import { CSDateUtils } from '../../core/utils/CSDateUtils';
import { CSPathUtils } from '../../core/utils/CSPathUtils';

// Initialize logger
const logger = new CSLogger('StoragePathResolver');

/**
 * Storage path type enum
 */
export enum StoragePathType {
  CONFIG = 'config',
  PROJECT = 'project',
  TEMPLATE = 'template',
  EXPORT = 'export',
  TEST_RESULT = 'test-result',
  SCREENSHOT = 'screenshot',
  VIDEO = 'video',
  LOG = 'log',
  DATA = 'data',
  BACKUP = 'backup',
  TEMP = 'temp',
  CUSTOM = 'custom'
}

/**
 * Storage path options
 */
export interface StoragePathOptions {
  /** Base directory to use (default: /cstestforge) */
  baseDir?: string;
  /** Include timestamp in path (default: false) */
  includeTimestamp?: boolean;
  /** Include date directory structure (default: false) */
  includeDateDirs?: boolean;
  /** Custom subdirectory (default: '') */
  subDir?: string;
  /** File extension (default: derived from filename) */
  extension?: string;
  /** Create parent directories if they don't exist (default: true) */
  createDirs?: boolean;
  /** Framework type (default: null) */
  framework?: string;
  /** Language type (default: null) */
  language?: string;
  /** Test type (default: null) */
  testType?: string;
  /** Project name (default: null) */
  projectName?: string;
  /** Test suite name (default: null) */
  testSuiteName?: string;
  /** Test case name (default: null) */
  testCaseName?: string;
  /** Environment name (default: null) */
  environmentName?: string;
}

/**
 * Default storage path options
 */
const DEFAULT_STORAGE_PATH_OPTIONS: StoragePathOptions = {
  baseDir: '/cstestforge',
  includeTimestamp: false,
  includeDateDirs: false,
  subDir: '',
  createDirs: true
};

/**
 * Path resolution mapping for different path types
 */
const PATH_TYPE_MAPPING: Record<StoragePathType, string> = {
  [StoragePathType.CONFIG]: 'config',
  [StoragePathType.PROJECT]: 'projects',
  [StoragePathType.TEMPLATE]: 'templates',
  [StoragePathType.EXPORT]: 'exports',
  [StoragePathType.TEST_RESULT]: 'results',
  [StoragePathType.SCREENSHOT]: 'screenshots',
  [StoragePathType.VIDEO]: 'videos',
  [StoragePathType.LOG]: 'logs',
  [StoragePathType.DATA]: 'data',
  [StoragePathType.BACKUP]: 'backups',
  [StoragePathType.TEMP]: 'temp',
  [StoragePathType.CUSTOM]: ''
};

/**
 * Service for resolving storage paths
 */
export class StoragePathResolver {
  /**
   * Resolve a storage path based on the specified type and options
   * @param pathType Storage path type
   * @param filename Filename (optional)
   * @param options Storage path options
   * @returns Resolved path
   */
  public static resolvePath(
    pathType: StoragePathType,
    filename?: string,
    options: StoragePathOptions = {}
  ): string {
    // Merge options with defaults
    const mergedOptions: StoragePathOptions = {
      ...DEFAULT_STORAGE_PATH_OPTIONS,
      ...options
    };
    
    logger.debug(`Resolving path for type: ${pathType}, filename: ${filename}, options:`, mergedOptions);
    
    // Start with base directory
    let path = mergedOptions.baseDir!;
    
    // Add path type directory
    const typeDir = PATH_TYPE_MAPPING[pathType];
    if (typeDir) {
      path = CSPathUtils.join(path, typeDir);
    }
    
    // Add framework, language, test type if provided
    if (mergedOptions.framework) {
      path = CSPathUtils.join(path, mergedOptions.framework);
      
      if (mergedOptions.language) {
        path = CSPathUtils.join(path, mergedOptions.language);
        
        if (mergedOptions.testType) {
          path = CSPathUtils.join(path, mergedOptions.testType);
        }
      }
    }
    
    // Add project, test suite, test case directories if provided
    if (mergedOptions.projectName) {
      path = CSPathUtils.join(path, this.sanitizeDirname(mergedOptions.projectName));
      
      if (mergedOptions.testSuiteName) {
        path = CSPathUtils.join(path, this.sanitizeDirname(mergedOptions.testSuiteName));
        
        if (mergedOptions.testCaseName) {
          path = CSPathUtils.join(path, this.sanitizeDirname(mergedOptions.testCaseName));
        }
      }
    }
    
    // Add environment directory if provided
    if (mergedOptions.environmentName) {
      path = CSPathUtils.join(path, this.sanitizeDirname(mergedOptions.environmentName));
    }
    
    // Add custom subdirectory if provided
    if (mergedOptions.subDir) {
      path = CSPathUtils.join(path, mergedOptions.subDir);
    }
    
    // Add date directories if requested
    if (mergedOptions.includeDateDirs) {
      const now = new Date();
      const year = now.getFullYear().toString();
      const month = (now.getMonth() + 1).toString().padStart(2, '0');
      const day = now.getDate().toString().padStart(2, '0');
      
      path = CSPathUtils.join(path, year, month, day);
    }
    
    // Add filename if provided
    if (filename) {
      // Add timestamp if requested
      if (mergedOptions.includeTimestamp) {
        const timestamp = CSDateUtils.getCurrentTimestamp();
        const filenameParts = this.splitFilename(filename);
        
        filename = `${filenameParts.name}_${timestamp}${filenameParts.extension ? '.' + filenameParts.extension : ''}`;
      }
      
      // Override extension if provided
      if (mergedOptions.extension) {
        const filenameParts = this.splitFilename(filename);
        filename = `${filenameParts.name}.${mergedOptions.extension.replace(/^\./, '')}`;
      }
      
      path = CSPathUtils.join(path, filename);
    }
    
    logger.debug(`Resolved path: ${path}`);
    
    return path;
  }
  
  /**
   * Create various standardized paths based on project configuration
   * @param projectName Project name
   * @param framework Framework type
   * @param language Language type
   * @param testType Test type
   * @returns Object with various paths
   */
  public static createProjectPaths(
    projectName: string,
    framework: string,
    language: string,
    testType: string
  ): Record<string, string> {
    const sanitizedProjectName = this.sanitizeDirname(projectName);
    const baseOptions: StoragePathOptions = {
      projectName: sanitizedProjectName,
      framework,
      language,
      testType
    };
    
    return {
      // Project structure
      projectRoot: this.resolvePath(StoragePathType.PROJECT, undefined, baseOptions),
      configDir: this.resolvePath(StoragePathType.CONFIG, undefined, baseOptions),
      srcDir: this.resolvePath(StoragePathType.PROJECT, undefined, { ...baseOptions, subDir: 'src' }),
      testDir: this.resolvePath(StoragePathType.PROJECT, undefined, { ...baseOptions, subDir: 'test' }),
      resourcesDir: this.resolvePath(StoragePathType.PROJECT, undefined, { ...baseOptions, subDir: 'resources' }),
      
      // Result and artifact paths
      resultsDir: this.resolvePath(StoragePathType.TEST_RESULT, undefined, baseOptions),
      screenshotsDir: this.resolvePath(StoragePathType.SCREENSHOT, undefined, baseOptions),
      videosDir: this.resolvePath(StoragePathType.VIDEO, undefined, baseOptions),
      logsDir: this.resolvePath(StoragePathType.LOG, undefined, baseOptions),
      
      // Configuration files
      configFile: this.resolvePath(StoragePathType.CONFIG, 'config.json', baseOptions),
      testngConfigFile: this.resolvePath(StoragePathType.CONFIG, 'testng.xml', baseOptions),
      cucumberConfigFile: this.resolvePath(StoragePathType.CONFIG, 'cucumber.json', baseOptions),
      
      // Export paths
      exportDir: this.resolvePath(StoragePathType.EXPORT, undefined, baseOptions),
      
      // Backup paths
      backupDir: this.resolvePath(StoragePathType.BACKUP, undefined, baseOptions)
    };
  }
  
  /**
   * Create test execution paths
   * @param projectName Project name
   * @param testSuiteName Test suite name
   * @param environmentName Environment name
   * @param options Additional options
   * @returns Object with various paths
   */
  public static createTestExecutionPaths(
    projectName: string,
    testSuiteName: string,
    environmentName: string,
    options: StoragePathOptions = {}
  ): Record<string, string> {
    const timestamp = CSDateUtils.getCurrentTimestamp();
    const baseOptions: StoragePathOptions = {
      ...options,
      projectName: this.sanitizeDirname(projectName),
      testSuiteName: this.sanitizeDirname(testSuiteName),
      environmentName: this.sanitizeDirname(environmentName)
    };
    
    return {
      // Result paths
      resultsDir: this.resolvePath(StoragePathType.TEST_RESULT, undefined, baseOptions),
      resultFile: this.resolvePath(StoragePathType.TEST_RESULT, `result_${timestamp}.json`, baseOptions),
      reportFile: this.resolvePath(StoragePathType.TEST_RESULT, `report_${timestamp}.html`, baseOptions),
      
      // Artifact paths
      screenshotsDir: this.resolvePath(StoragePathType.SCREENSHOT, undefined, baseOptions),
      videosDir: this.resolvePath(StoragePathType.VIDEO, undefined, baseOptions),
      logsDir: this.resolvePath(StoragePathType.LOG, undefined, baseOptions),
      
      // Log files
      logFile: this.resolvePath(StoragePathType.LOG, `execution_${timestamp}.log`, baseOptions),
      errorLogFile: this.resolvePath(StoragePathType.LOG, `error_${timestamp}.log`, baseOptions),
      
      // Temporary paths
      tempDir: this.resolvePath(StoragePathType.TEMP, undefined, { ...baseOptions, includeTimestamp: true })
    };
  }
  
  /**
   * Resolve a backup path for a file
   * @param originalPath Original file path
   * @param options Additional options
   * @returns Backup path
   */
  public static resolveBackupPath(originalPath: string, options: StoragePathOptions = {}): string {
    const timestamp = CSDateUtils.getCurrentTimestamp();
    const filename = CSPathUtils.basename(originalPath);
    const filenameParts = this.splitFilename(filename);
    
    const backupFilename = `${filenameParts.name}_backup_${timestamp}${filenameParts.extension ? '.' + filenameParts.extension : ''}`;
    
    return this.resolvePath(StoragePathType.BACKUP, backupFilename, options);
  }
  
  /**
   * Resolve a temporary file path
   * @param prefix Filename prefix
   * @param extension File extension
   * @param options Additional options
   * @returns Temporary file path
   */
  public static resolveTempPath(prefix: string, extension: string, options: StoragePathOptions = {}): string {
    const timestamp = CSDateUtils.getCurrentTimestamp();
    const randomSuffix = Math.random().toString(36).substring(2, 10);
    
    const tempFilename = `${prefix}_${timestamp}_${randomSuffix}.${extension.replace(/^\./, '')}`;
    
    return this.resolvePath(StoragePathType.TEMP, tempFilename, options);
  }
  
  /**
   * Create a relative path from an absolute path
   * @param absolutePath Absolute path
   * @param basePath Base path
   * @returns Relative path
   */
  public static toRelativePath(absolutePath: string, basePath: string): string {
    // Normalize paths
    const normalizedAbsolutePath = CSPathUtils.normalize(absolutePath);
    const normalizedBasePath = CSPathUtils.normalize(basePath);
    
    // Split paths into segments
    const absoluteSegments = normalizedAbsolutePath.split('/').filter(Boolean);
    const baseSegments = normalizedBasePath.split('/').filter(Boolean);
    
    // Find common prefix
    let commonPrefixLength = 0;
    const minLength = Math.min(absoluteSegments.length, baseSegments.length);
    
    for (let i = 0; i < minLength; i++) {
      if (absoluteSegments[i] === baseSegments[i]) {
        commonPrefixLength++;
      } else {
        break;
      }
    }
    
    // Build relative path
    const upDirs = baseSegments.length - commonPrefixLength;
    const downDirs = absoluteSegments.slice(commonPrefixLength);
    
    const relativePath = [...Array(upDirs).fill('..'), ...downDirs].join('/');
    
    return relativePath || '.';
  }
  
  /**
   * Create an absolute path from a relative path
   * @param relativePath Relative path
   * @param basePath Base path
   * @returns Absolute path
   */
  public static toAbsolutePath(relativePath: string, basePath: string): string {
    // Handle already absolute paths
    if (relativePath.startsWith('/')) {
      return CSPathUtils.normalize(relativePath);
    }
    
    // Normalize base path
    const normalizedBasePath = CSPathUtils.normalize(basePath);
    
    // Split relative path into segments
    const relativeSegments = relativePath.split('/');
    
    // Start with base path segments
    const baseSegments = normalizedBasePath.split('/').filter(Boolean);
    const resultSegments: string[] = [...baseSegments];
    
    // Process relative path segments
    for (const segment of relativeSegments) {
      if (segment === '.') {
        // Current directory, do nothing
      } else if (segment === '..') {
        // Parent directory, remove last segment if possible
        if (resultSegments.length > 0) {
          resultSegments.pop();
        }
      } else if (segment) {
        // Regular segment, add to result
        resultSegments.push(segment);
      }
    }
    
    // Construct absolute path
    return '/' + resultSegments.join('/');
  }
  
  /**
   * Sanitize a directory name for safe usage in paths
   * @param dirname Directory name to sanitize
   * @returns Sanitized directory name
   */
  public static sanitizeDirname(dirname: string): string {
    // Replace spaces with underscores
    let sanitized = dirname.replace(/\s+/g, '_');
    
    // Remove special characters
    sanitized = sanitized.replace(/[^a-zA-Z0-9_.-]/g, '');
    
    // Ensure name is not empty
    if (!sanitized) {
      sanitized = 'unnamed';
    }
    
    return sanitized.toLowerCase();
  }
  
  /**
   * Sanitize a filename for safe usage in paths
   * @param filename Filename to sanitize
   * @returns Sanitized filename
   */
  public static sanitizeFilename(filename: string): string {
    // Split filename into name and extension
    const parts = this.splitFilename(filename);
    
    // Sanitize name part
    let sanitizedName = parts.name.replace(/\s+/g, '_');
    sanitizedName = sanitizedName.replace(/[^a-zA-Z0-9_.-]/g, '');
    
    // Ensure name is not empty
    if (!sanitizedName) {
      sanitizedName = 'unnamed';
    }
    
    // Recombine name and extension
    return parts.extension ? `${sanitizedName}.${parts.extension}` : sanitizedName;
  }
  
  /**
   * Split a filename into name and extension parts
   * @param filename Filename to split
   * @returns Object with name and extension properties
   */
  public static splitFilename(filename: string): { name: string, extension: string } {
    const lastDotIndex = filename.lastIndexOf('.');
    
    if (lastDotIndex === -1 || lastDotIndex === 0) {
      // No extension or filename starts with a dot (hidden file)
      return {
        name: filename,
        extension: ''
      };
    }
    
    return {
      name: filename.substring(0, lastDotIndex),
      extension: filename.substring(lastDotIndex + 1)
    };
  }
  
  /**
   * Generate a unique directory name based on a base name
   * @param baseName Base directory name
   * @param options Additional options
   * @returns Unique directory name
   */
  public static generateUniqueDirname(baseName: string, options: StoragePathOptions = {}): string {
    const timestamp = CSDateUtils.getCurrentTimestamp();
    const sanitizedBaseName = this.sanitizeDirname(baseName);
    
    return `${sanitizedBaseName}_${timestamp}`;
  }
  
  /**
   * Generate a unique filename based on a base name
   * @param baseName Base filename
   * @param extension File extension
   * @param options Additional options
   * @returns Unique filename
   */
  public static generateUniqueFilename(baseName: string, extension: string, options: StoragePathOptions = {}): string {
    const timestamp = CSDateUtils.getCurrentTimestamp();
    const sanitizedBaseName = this.sanitizeDirname(baseName);
    
    return `${sanitizedBaseName}_${timestamp}.${extension.replace(/^\./, '')}`;
  }
}

BackupService.ts
-----------------------------------------------

import { CSLogger } from '../../core/utils/CSLogger';
import { CSDateUtils } from '../../core/utils/CSDateUtils';
import { CSPathUtils } from '../../core/utils/CSPathUtils';
import { FileSystemStorageService } from './FileSystemStorageService';
import { StoragePathResolver, StoragePathType } from './StoragePathResolver';
import { DataSerializer, SerializationFormat } from './DataSerializer';

// Initialize logger
const logger = new CSLogger('BackupService');

/**
 * Backup options
 */
export interface BackupOptions {
  /** Backup name (default: auto-generated) */
  backupName?: string;
  /** Include timestamp in backup name (default: true) */
  includeTimestamp?: boolean;
  /** Compress backup files (default: true) */
  compress?: boolean;
  /** Encrypt backup files (default: false) */
  encrypt?: boolean;
  /** Backup notes/description */
  notes?: string;
  /** Custom metadata to include with backup */
  metadata?: Record<string, any>;
}

/**
 * Default backup options
 */
const DEFAULT_BACKUP_OPTIONS: BackupOptions = {
  includeTimestamp: true,
  compress: true,
  encrypt: false
};

/**
 * Backup metadata
 */
export interface BackupMetadata {
  /** Backup name */
  name: string;
  /** Timestamp when backup was created */
  createdAt: string;
  /** Original path */
  originalPath: string;
  /** Backup path */
  backupPath: string;
  /** Project name (if applicable) */
  projectName?: string;
  /** Framework type (if applicable) */
  framework?: string;
  /** Language type (if applicable) */
  language?: string;
  /** Test type (if applicable) */
  testType?: string;
  /** Compression used */
  compressed: boolean;
  /** Encryption used */
  encrypted: boolean;
  /** Backup notes/description */
  notes?: string;
  /** File size in bytes */
  size: number;
  /** File checksum */
  checksum: string;
  /** Custom metadata */
  metadata?: Record<string, any>;
}

/**
 * Backup catalog entry
 */
export interface BackupCatalogEntry extends BackupMetadata {
  /** Unique backup ID */
  id: string;
}

/**
 * Backup catalog interface
 */
export interface BackupCatalog {
  /** Catalog version */
  version: string;
  /** Last updated timestamp */
  lastUpdated: string;
  /** Backup entries */
  backups: BackupCatalogEntry[];
}

/**
 * Restore options
 */
export interface RestoreOptions {
  /** Destination path (default: original path) */
  destinationPath?: string;
  /** Overwrite existing file (default: false) */
  overwrite?: boolean;
  /** Create backup of current file before restoring (default: true) */
  createBackupBeforeRestore?: boolean;
  /** Specific backup version to restore (default: latest) */
  version?: string;
}

/**
 * Default restore options
 */
const DEFAULT_RESTORE_OPTIONS: RestoreOptions = {
  overwrite: false,
  createBackupBeforeRestore: true
};

/**
 * Service for backup and recovery operations
 */
export class BackupService {
  private static readonly CATALOG_PATH = '/cstestforge/backups/backup-catalog.json';
  private static readonly BACKUP_CATALOG_VERSION = '1.0.0';
  
  private storageService: FileSystemStorageService;
  private catalog: BackupCatalog | null = null;
  
  /**
   * Create a new BackupService instance
   */
  constructor() {
    this.storageService = new FileSystemStorageService();
  }
  
  /**
   * Initialize the backup service
   */
  public async initialize(): Promise<void> {
    try {
      await this.loadCatalog();
    } catch (err) {
      logger.warn('Failed to load backup catalog, creating a new one');
      await this.createCatalog();
    }
  }
  
  /**
   * Load the backup catalog
   */
  private async loadCatalog(): Promise<void> {
    // Check if catalog file exists
    const catalogExists = await this.storageService.fileExists(BackupService.CATALOG_PATH);
    
    if (!catalogExists) {
      await this.createCatalog();
      return;
    }
    
    try {
      // Read catalog from storage
      const catalogContent = await this.storageService.readFile(BackupService.CATALOG_PATH);
      this.catalog = JSON.parse(catalogContent) as BackupCatalog;
      
      // Validate catalog version
      if (!this.catalog || !this.catalog.version) {
        logger.warn('Invalid backup catalog format, creating a new one');
        await this.createCatalog();
      }
    } catch (err) {
      logger.error('Failed to load backup catalog', err);
      await this.createCatalog();
    }
  }
  
  /**
   * Create a new backup catalog
   */
  private async createCatalog(): Promise<void> {
    this.catalog = {
      version: BackupService.BACKUP_CATALOG_VERSION,
      lastUpdated: new Date().toISOString(),
      backups: []
    };
    
    // Create parent directory if it doesn't exist
    const catalogDir = CSPathUtils.dirname(BackupService.CATALOG_PATH);
    await this.storageService.createDirectory(catalogDir);
    
    // Save the catalog
    await this.saveCatalog();
  }
  
  /**
   * Save the backup catalog
   */
  private async saveCatalog(): Promise<void> {
    if (!this.catalog) {
      throw new Error('Backup catalog not initialized');
    }
    
    // Update last updated timestamp
    this.catalog.lastUpdated = new Date().toISOString();
    
    // Save catalog to storage
    await this.storageService.writeFile(
      BackupService.CATALOG_PATH,
      JSON.stringify(this.catalog, null, 2)
    );
  }
  
  /**
   * Create a backup of a file
   * @param filePath Path to the file to backup
   * @param options Backup options
   * @returns Backup metadata
   */
  public async backupFile(filePath: string, options: BackupOptions = {}): Promise<BackupMetadata> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    // Merge options with defaults
    const mergedOptions: BackupOptions = {
      ...DEFAULT_BACKUP_OPTIONS,
      ...options
    };
    
    logger.info(`Creating backup of file: ${filePath}`);
    
    try {
      // Check if file exists
      const fileExists = await this.storageService.fileExists(filePath);
      if (!fileExists) {
        throw new Error(`File not found: ${filePath}`);
      }
      
      // Read file metadata
      const fileMetadata = await this.storageService.getFileMetadata(filePath);
      
      // Generate backup name if not provided
      let backupName = mergedOptions.backupName || CSPathUtils.basename(filePath);
      
      // Add timestamp if requested
      if (mergedOptions.includeTimestamp) {
        const timestamp = CSDateUtils.getCurrentTimestamp();
        const filenameParts = StoragePathResolver.splitFilename(backupName);
        backupName = `${filenameParts.name}_${timestamp}${filenameParts.extension ? '.' + filenameParts.extension : ''}`;
      }
      
      // Resolve backup path
      const backupPath = StoragePathResolver.resolvePath(
        StoragePathType.BACKUP,
        backupName
      );
      
      // Create parent directory if it doesn't exist
      const backupDir = CSPathUtils.dirname(backupPath);
      await this.storageService.createDirectory(backupDir);
      
      // Read file content
      const fileContent = await this.storageService.readFile(filePath);
      
      // Process file content (compression, encryption)
      let processedContent: string | ArrayBuffer = fileContent;
      
      if (mergedOptions.compress || mergedOptions.encrypt) {
        processedContent = await DataSerializer.serialize(fileContent, {
          format: SerializationFormat.TEXT,
          compress: mergedOptions.compress,
          encrypt: mergedOptions.encrypt,
          includeMetadata: true
        });
      }
      
      // Write backup file
      await this.storageService.writeFile(
        backupPath,
        typeof processedContent === 'string' ? processedContent : new Uint8Array(processedContent)
      );
      
      // Create backup metadata
      const backupMetadata: BackupMetadata = {
        name: backupName,
        createdAt: new Date().toISOString(),
        originalPath: filePath,
        backupPath,
        compressed: !!mergedOptions.compress,
        encrypted: !!mergedOptions.encrypt,
        notes: mergedOptions.notes,
        size: fileMetadata.size,
        checksum: fileMetadata.checksum,
        metadata: mergedOptions.metadata
      };
      
      // Add project-related metadata if available
      const pathParts = filePath.split('/').filter(Boolean);
      const projectsIndex = pathParts.indexOf('projects');
      
      if (projectsIndex !== -1 && pathParts.length > projectsIndex + 1) {
        backupMetadata.projectName = pathParts[projectsIndex + 1];
        
        if (pathParts.length > projectsIndex + 2) {
          backupMetadata.framework = pathParts[projectsIndex + 2];
          
          if (pathParts.length > projectsIndex + 3) {
            backupMetadata.language = pathParts[projectsIndex + 3];
            
            if (pathParts.length > projectsIndex + 4) {
              backupMetadata.testType = pathParts[projectsIndex + 4];
            }
          }
        }
      }
      
      // Add backup to catalog
      const backupCatalogEntry: BackupCatalogEntry = {
        ...backupMetadata,
        id: this.generateBackupId()
      };
      
      this.catalog!.backups.push(backupCatalogEntry);
      
      // Save updated catalog
      await this.saveCatalog();
      
      logger.info(`Backup created: ${backupPath}`);
      
      return backupMetadata;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to create backup of file ${filePath}: ${errorMessage}`);
      throw new Error(`Failed to create backup: ${errorMessage}`);
    }
  }
  
  /**
   * Restore a file from backup
   * @param backupId Backup ID to restore
   * @param options Restore options
   * @returns Path to the restored file
   */
  public async restoreFromBackup(backupId: string, options: RestoreOptions = {}): Promise<string> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    // Merge options with defaults
    const mergedOptions: RestoreOptions = {
      ...DEFAULT_RESTORE_OPTIONS,
      ...options
    };
    
    logger.info(`Restoring from backup: ${backupId}`);
    
    try {
      // Find backup in catalog
      const backup = this.catalog!.backups.find(b => b.id === backupId);
      if (!backup) {
        throw new Error(`Backup not found: ${backupId}`);
      }
      
      // Determine destination path
      const destinationPath = mergedOptions.destinationPath || backup.originalPath;
      
      // Check if destination file exists
      const destinationExists = await this.storageService.fileExists(destinationPath);
      
      if (destinationExists) {
        if (!mergedOptions.overwrite) {
          throw new Error(`Destination file already exists: ${destinationPath}`);
        }
        
        // Create backup of current file if requested
        if (mergedOptions.createBackupBeforeRestore) {
          await this.backupFile(destinationPath, {
            backupName: `pre_restore_${CSPathUtils.basename(destinationPath)}`,
            notes: `Auto-backup before restoring from backup ${backupId}`
          });
        }
      }
      
      // Read backup file
      let backupContent = await this.storageService.readFile(backup.backupPath);
      
      // Process backup content (decompression, decryption)
      if (backup.compressed || backup.encrypted) {
        backupContent = await DataSerializer.deserialize<string>(backupContent, {
          decompress: backup.compressed,
          decrypt: backup.encrypted
        });
      }
      
      // Create parent directory if it doesn't exist
      const destinationDir = CSPathUtils.dirname(destinationPath);
      await this.storageService.createDirectory(destinationDir);
      
      // Write restored file
      await this.storageService.writeFile(destinationPath, backupContent);
      
      logger.info(`File restored to: ${destinationPath}`);
      
      return destinationPath;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to restore from backup ${backupId}: ${errorMessage}`);
      throw new Error(`Failed to restore from backup: ${errorMessage}`);
    }
  }
  
  /**
   * Get all backups
   * @returns Array of backup catalog entries
   */
  public async getAllBackups(): Promise<BackupCatalogEntry[]> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    return [...this.catalog!.backups];
  }
  
  /**
   * Find backups by path
   * @param path File path to find backups for
   * @returns Array of matching backup catalog entries
   */
  public async findBackupsByPath(path: string): Promise<BackupCatalogEntry[]> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    return this.catalog!.backups.filter(b => b.originalPath === path);
  }
  
  /**
   * Find backups by project
   * @param projectName Project name to find backups for
   * @returns Array of matching backup catalog entries
   */
  public async findBackupsByProject(projectName: string): Promise<BackupCatalogEntry[]> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    return this.catalog!.backups.filter(b => b.projectName === projectName);
  }
  
  /**
   * Find backups by creation date range
   * @param startDate Start date for the range
   * @param endDate End date for the range
   * @returns Array of matching backup catalog entries
   */
  public async findBackupsByDateRange(startDate: Date, endDate: Date): Promise<BackupCatalogEntry[]> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    return this.catalog!.backups.filter(b => {
      const backupDate = new Date(b.createdAt);
      return backupDate >= startDate && backupDate <= endDate;
    });
  }
  
  /**
   * Delete a backup
   * @param backupId Backup ID to delete
   * @returns True if backup was deleted, false if not found
   */
  public async deleteBackup(backupId: string): Promise<boolean> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    logger.info(`Deleting backup: ${backupId}`);
    
    try {
      // Find backup in catalog
      const backupIndex = this.catalog!.backups.findIndex(b => b.id === backupId);
      
      if (backupIndex === -1) {
        logger.warn(`Backup not found: ${backupId}`);
        return false;
      }
      
      const backup = this.catalog!.backups[backupIndex];
      
      // Delete backup file
      try {
        await this.storageService.deleteFile(backup.backupPath);
      } catch (err) {
        logger.warn(`Failed to delete backup file: ${backup.backupPath}`, err);
      }
      
      // Remove backup from catalog
      this.catalog!.backups.splice(backupIndex, 1);
      
      // Save updated catalog
      await this.saveCatalog();
      
      logger.info(`Backup deleted: ${backupId}`);
      
      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to delete backup ${backupId}: ${errorMessage}`);
      throw new Error(`Failed to delete backup: ${errorMessage}`);
    }
  }
  
  /**
   * Clean up old backups based on retention policy
   * @param maxAge Maximum age of backups to keep (in days)
   * @param maxCount Maximum number of backups to keep
   * @returns Number of backups deleted
   */
  public async cleanupBackups(maxAge?: number, maxCount?: number): Promise<number> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    logger.info(`Cleaning up backups: maxAge=${maxAge}, maxCount=${maxCount}`);
    
    try {
      const now = new Date();
      let backupsToDelete: BackupCatalogEntry[] = [];
      
      // Step 1: Delete backups older than maxAge
      if (maxAge !== undefined && maxAge > 0) {
        const cutoffDate = new Date(now.getTime() - (maxAge * 24 * 60 * 60 * 1000));
        
        backupsToDelete = this.catalog!.backups.filter(b => {
          const backupDate = new Date(b.createdAt);
          return backupDate < cutoffDate;
        });
      }
      
      // Step 2: If we still have too many backups, delete the oldest ones
      if (maxCount !== undefined && maxCount > 0 && this.catalog!.backups.length - backupsToDelete.length > maxCount) {
        // Sort backups by date (oldest first)
        const sortedBackups = [...this.catalog!.backups].sort((a, b) => {
          return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
        });
        
        // Remove the backups we're already deleting
        const remainingBackups = sortedBackups.filter(b => !backupsToDelete.some(bd => bd.id === b.id));
        
        // Add the oldest backups to the deletion list
        const excessCount = remainingBackups.length - maxCount;
        if (excessCount > 0) {
          const additionalBackupsToDelete = remainingBackups.slice(0, excessCount);
          backupsToDelete.push(...additionalBackupsToDelete);
        }
      }
      
      // Delete the backups
      let deletedCount = 0;
      for (const backup of backupsToDelete) {
        try {
          const deleted = await this.deleteBackup(backup.id);
          if (deleted) {
            deletedCount++;
          }
        } catch (err) {
          logger.warn(`Failed to delete backup ${backup.id}`, err);
        }
      }
      
      return deletedCount;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to clean up backups: ${errorMessage}`);
      throw new Error(`Failed to clean up backups: ${errorMessage}`);
    }
  }
  
  /**
   * Create a backup of a project
   * @param projectName Project name
   * @param options Backup options
   * @returns Array of backup metadata for all backed up files
   */
  public async backupProject(projectName: string, options: BackupOptions = {}): Promise<BackupMetadata[]> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    logger.info(`Creating backup of project: ${projectName}`);
    
    try {
      // Resolve project path
      const projectPath = StoragePathResolver.resolvePath(
        StoragePathType.PROJECT,
        undefined,
        { projectName }
      );
      
      // Check if project directory exists
      const projectExists = await this.storageService.directoryExists(projectPath);
      if (!projectExists) {
        throw new Error(`Project not found: ${projectName}`);
      }
      
      // Get all files in the project
      const projectFiles: string[] = [];
      await this.collectFiles(projectPath, projectFiles);
      
      if (projectFiles.length === 0) {
        logger.warn(`No files found in project: ${projectName}`);
        return [];
      }
      
      // Create backup of each file
      const backupMetadataList: BackupMetadata[] = [];
      
      for (const filePath of projectFiles) {
        try {
          const backupMetadata = await this.backupFile(filePath, {
            ...options,
            notes: `Project backup: ${projectName} ${options.notes || ''}`.trim(),
            metadata: {
              ...(options.metadata || {}),
              projectBackup: true,
              projectName
            }
          });
          
          backupMetadataList.push(backupMetadata);
        } catch (err) {
          logger.warn(`Failed to backup file ${filePath}`, err);
        }
      }
      
      logger.info(`Project backup completed: ${projectName}, files: ${backupMetadataList.length}`);
      
      return backupMetadataList;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to backup project ${projectName}: ${errorMessage}`);
      throw new Error(`Failed to backup project: ${errorMessage}`);
    }
  }
  
  /**
   * Restore a project from backups
   * @param projectName Project name
   * @param backupIds Optional specific backup IDs to restore (if not provided, uses latest backups)
   * @param options Restore options
   * @returns Array of paths to restored files
   */
  public async restoreProject(
    projectName: string,
    backupIds?: string[],
    options: RestoreOptions = {}
  ): Promise<string[]> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    logger.info(`Restoring project: ${projectName}`);
    
    try {
      // Find all backups for the project
      const projectBackups = await this.findBackupsByProject(projectName);
      
      if (projectBackups.length === 0) {
        throw new Error(`No backups found for project: ${projectName}`);
      }
      
      // Group backups by original path
      const backupsByPath = new Map<string, BackupCatalogEntry[]>();
      
      for (const backup of projectBackups) {
        if (!backupsByPath.has(backup.originalPath)) {
          backupsByPath.set(backup.originalPath, []);
        }
        
        backupsByPath.get(backup.originalPath)!.push(backup);
      }
      
      // Sort backups by date (newest first)
      for (const [path, backups] of backupsByPath.entries()) {
        backupsByPath.set(
          path,
          backups.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
        );
      }
      
      // Determine which backups to restore
      const backupsToRestore: BackupCatalogEntry[] = [];
      
      if (backupIds && backupIds.length > 0) {
        // Use specified backup IDs
        for (const backupId of backupIds) {
          const backup = projectBackups.find(b => b.id === backupId);
          if (backup) {
            backupsToRestore.push(backup);
          } else {
            logger.warn(`Backup not found: ${backupId}`);
          }
        }
      } else {
        // Use latest backup for each file
        for (const [, backups] of backupsByPath.entries()) {
          if (backups.length > 0) {
            backupsToRestore.push(backups[0]);
          }
        }
      }
      
      if (backupsToRestore.length === 0) {
        throw new Error('No valid backups to restore');
      }
      
      // Restore each backup
      const restoredPaths: string[] = [];
      
      for (const backup of backupsToRestore) {
        try {
          const restoredPath = await this.restoreFromBackup(backup.id, options);
          restoredPaths.push(restoredPath);
        } catch (err) {
          logger.warn(`Failed to restore backup ${backup.id}`, err);
        }
      }
      
      logger.info(`Project restore completed: ${projectName}, files: ${restoredPaths.length}`);
      
      return restoredPaths;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to restore project ${projectName}: ${errorMessage}`);
      throw new Error(`Failed to restore project: ${errorMessage}`);
    }
  }
  
  /**
   * Schedule automatic backups for a project
   * @param projectName Project name
   * @param intervalHours Interval between backups (in hours)
   * @param options Backup options
   * @returns Object with schedule ID and next backup time
   */
  public async scheduleProjectBackups(
    projectName: string,
    intervalHours: number,
    options: BackupOptions = {}
  ): Promise<{ scheduleId: string, nextBackupTime: Date }> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    logger.info(`Scheduling backups for project: ${projectName}, interval: ${intervalHours} hours`);
    
    try {
      // Create the backup schedule
      const scheduleId = this.generateBackupId();
      const nextBackupTime = new Date(Date.now() + intervalHours * 60 * 60 * 1000);
      
      // Create the schedule entry
      const scheduleEntry = {
        id: scheduleId,
        projectName,
        intervalHours,
        lastBackupTime: null,
        nextBackupTime: nextBackupTime.toISOString(),
        options,
        enabled: true
      };
      
      // Store the schedule (in a real implementation, you would use a persistent storage)
      // For this example, we'll store it in localStorage
      const schedules = this.getBackupSchedules();
      schedules.push(scheduleEntry);
      this.saveBackupSchedules(schedules);
      
      // In a real implementation, you would set up a timer or cron job to run the backups
      // For this example, we'll just return the schedule information
      
      return {
        scheduleId,
        nextBackupTime
      };
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to schedule backups for project ${projectName}: ${errorMessage}`);
      throw new Error(`Failed to schedule backups: ${errorMessage}`);
    }
  }
  
  /**
   * Cancel scheduled backups
   * @param scheduleId Schedule ID to cancel
   * @returns True if schedule was canceled, false if not found
   */
  public cancelScheduledBackups(scheduleId: string): boolean {
    logger.info(`Canceling backup schedule: ${scheduleId}`);
    
    try {
      // Get current schedules
      const schedules = this.getBackupSchedules();
      
      // Find and remove the schedule
      const scheduleIndex = schedules.findIndex(s => s.id === scheduleId);
      
      if (scheduleIndex === -1) {
        logger.warn(`Backup schedule not found: ${scheduleId}`);
        return false;
      }
      
      schedules.splice(scheduleIndex, 1);
      
      // Save updated schedules
      this.saveBackupSchedules(schedules);
      
      logger.info(`Backup schedule canceled: ${scheduleId}`);
      
      return true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to cancel backup schedule ${scheduleId}: ${errorMessage}`);
      throw new Error(`Failed to cancel backup schedule: ${errorMessage}`);
    }
  }
  
  /**
   * Get all backup schedules
   */
  private getBackupSchedules(): any[] {
    try {
      const schedulesJson = localStorage.getItem('backup-schedules');
      return schedulesJson ? JSON.parse(schedulesJson) : [];
    } catch (err) {
      logger.error('Failed to get backup schedules', err);
      return [];
    }
  }
  
  /**
   * Save backup schedules
   */
  private saveBackupSchedules(schedules: any[]): void {
    try {
      localStorage.setItem('backup-schedules', JSON.stringify(schedules));
    } catch (err) {
      logger.error('Failed to save backup schedules', err);
    }
  }
  
  /**
   * Generate a unique backup ID
   * @returns Unique backup ID
   */
  private generateBackupId(): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 10);
    return `backup_${timestamp}_${random}`;
  }
  
  /**
   * Recursively collect all files in a directory
   * @param dirPath Directory path
   * @param files Array to collect files into
   */
  private async collectFiles(dirPath: string, files: string[]): Promise<void> {
    try {
      // Get all files in the current directory
      const currentFiles = await this.storageService.listFiles(dirPath);
      
      for (const filename of currentFiles) {
        const filePath = CSPathUtils.join(dirPath, filename);
        files.push(filePath);
      }
      
      // Get all subdirectories
      const directories = await this.storageService.listDirectories(dirPath);
      
      // Recursively process subdirectories
      for (const dirname of directories) {
        const subdirPath = CSPathUtils.join(dirPath, dirname);
        await this.collectFiles(subdirPath, files);
      }
    } catch (err) {
      logger.warn(`Failed to collect files in directory ${dirPath}`, err);
    }
  }
  
  /**
   * Export backups to a zip file
   * @param backupIds Backup IDs to export
   * @param outputPath Output path for the zip file
   * @returns Path to the zip file
   */
  public async exportBackups(backupIds: string[], outputPath?: string): Promise<string> {
    // Ensure catalog is loaded
    if (!this.catalog) {
      await this.initialize();
    }
    
    logger.info(`Exporting backups: ${backupIds.join(', ')}`);
    
    try {
      // Find the backups to export
      const backupsToExport: BackupCatalogEntry[] = [];
      
      for (const backupId of backupIds) {
        const backup = this.catalog!.backups.find(b => b.id === backupId);
        if (backup) {
          backupsToExport.push(backup);
        } else {
          logger.warn(`Backup not found: ${backupId}`);
        }
      }
      
      if (backupsToExport.length === 0) {
        throw new Error('No valid backups to export');
      }
      
      // Determine output path
      const timestamp = CSDateUtils.getCurrentTimestamp();
      const defaultOutputPath = StoragePathResolver.resolvePath(
        StoragePathType.EXPORT,
        `backups_${timestamp}.zip`
      );
      
      const zipPath = outputPath || defaultOutputPath;
      
      // Create parent directory if it doesn't exist
      const zipDir = CSPathUtils.dirname(zipPath);
      await this.storageService.createDirectory(zipDir);
      
      // In a real implementation, you would use a zip library to create the zip file
      // For this example, we'll just create a JSON file with the backup metadata
      
      const exportData = {
        timestamp,
        backups: backupsToExport
      };
      
      await this.storageService.writeFile(
        zipPath,
        JSON.stringify(exportData, null, 2)
      );
      
      logger.info(`Backups exported to: ${zipPath}`);
      
      return zipPath;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to export backups: ${errorMessage}`);
      throw new Error(`Failed to export backups: ${errorMessage}`);
    }
  }
  
  /**
   * Import backups from a zip file
   * @param zipPath Path to the zip file
   * @returns Array of imported backup IDs
   */
  public async importBackups(zipPath: string): Promise<string[]> {
    logger.info(`Importing backups from: ${zipPath}`);
    
    try {
      // Ensure catalog is loaded
      if (!this.catalog) {
        await this.initialize();
      }
      
      // Check if zip file exists
      const zipExists = await this.storageService.fileExists(zipPath);
      if (!zipExists) {
        throw new Error(`Zip file not found: ${zipPath}`);
      }
      
      // In a real implementation, you would use a zip library to extract the zip file
      // For this example, we'll just read the JSON file and simulate importing
      
      const zipContent = await this.storageService.readFile(zipPath);
      const importData = JSON.parse(zipContent) as { timestamp: string, backups: BackupCatalogEntry[] };
      
      if (!importData.backups || !Array.isArray(importData.backups)) {
        throw new Error('Invalid backup export file');
      }
      
      // Import each backup
      const importedBackupIds: string[] = [];
      
      for (const backup of importData.backups) {
        try {
          // Generate a new ID for the imported backup
          const newBackupId = this.generateBackupId();
          
          // Copy backup file to a new location
          const newBackupPath = StoragePathResolver.resolvePath(
            StoragePathType.BACKUP,
            `imported_${CSPathUtils.basename(backup.backupPath)}`
          );
          
          // In a real implementation, you would copy the file from the zip
          // For this example, we'll simulate it with a placeholder file
          await this.storageService.writeFile(
            newBackupPath,
            `Imported backup: ${backup.name}`
          );
          
          // Create a new backup entry
          const newBackup: BackupCatalogEntry = {
            ...backup,
            id: newBackupId,
            backupPath: newBackupPath,
            createdAt: new Date().toISOString(),
            metadata: {
              ...(backup.metadata || {}),
              importedAt: new Date().toISOString(),
              originalBackupId: backup.id
            }
          };
          
          // Add to catalog
          this.catalog!.backups.push(newBackup);
          importedBackupIds.push(newBackupId);
        } catch (err) {
          logger.warn(`Failed to import backup ${backup.id}`, err);
        }
      }
      
      // Save updated catalog
      await this.saveCatalog();
      
      logger.info(`Backups imported: ${importedBackupIds.length}`);
      
      return importedBackupIds;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to import backups: ${errorMessage}`);
      throw new Error(`Failed to import backups: ${errorMessage}`);
    }
  }
}


StorageTypes.ts
--------------------------------------------

/**
 * Storage types for the CSTestForge file system storage implementation
 */

/**
 * Storage operation result
 */
export interface StorageOperationResult {
  /** Operation success status */
  success: boolean;
  /** Error message if operation failed */
  errorMessage?: string;
  /** Additional data returned by the operation */
  data?: any;
}

/**
 * File metadata
 */
export interface FileMetadata {
  /** File name */
  name: string;
  /** File path */
  path: string;
  /** File size in bytes */
  size: number;
  /** Creation timestamp */
  created: string;
  /** Last modification timestamp */
  modified: string;
  /** File version */
  version: number;
  /** File checksum for integrity verification */
  checksum: string;
  /** Whether the file is locked */
  locked?: boolean;
  /** User who locked the file */
  lockedBy?: string;
  /** Timestamp when the file was locked */
  lockedAt?: string;
  /** MIME type */
  mimeType?: string;
  /** Custom metadata */
  metadata?: Record<string, any>;
}

/**
 * Directory metadata
 */
export interface DirectoryMetadata {
  /** Directory name */
  name: string;
  /** Directory path */
  path: string;
  /** Creation timestamp */
  created: string;
  /** Last modification timestamp */
  modified: string;
  /** Files in this directory (full paths) */
  files: string[];
  /** Subdirectories in this directory (full paths) */
  directories: string[];
  /** Custom metadata */
  metadata?: Record<string, any>;
}

/**
 * File lock information
 */
export interface FileLock {
  /** File path */
  path: string;
  /** User who locked the file */
  lockedBy: string;
  /** Timestamp when the file was locked */
  lockedAt: string;
  /** Lock timeout in milliseconds */
  timeout: number;
}

/**
 * File options for operations
 */
export interface FileOptions {
  /** Create a backup before modifying the file */
  createBackup?: boolean;
  /** Encrypt file content */
  encryptContent?: boolean;
  /** Compress file content */
  compress?: boolean;
  /** Overwrite existing file */
  overwrite?: boolean;
  /** Fail if file already exists */
  exclusive?: boolean;
  /** Expected file version (for optimistic locking) */
  version?: number;
  /** Custom metadata to add to the file */
  metadata?: Record<string, any>;
}

/**
 * Directory options for operations
 */
export interface DirectoryOptions {
  /** Create parent directories if they don't exist */
  createParents?: boolean;
  /** Fail if directory already exists */
  exclusive?: boolean;
  /** Custom metadata to add to the directory */
  metadata?: Record<string, any>;
}

/**
 * File query options
 */
export interface FileQueryOptions {
  /** Include subdirectories in search */
  recursive?: boolean;
  /** File name pattern (glob pattern) */
  pattern?: string;
  /** Sort files by field */
  sortBy?: 'name' | 'path' | 'size' | 'created' | 'modified' | 'version';
  /** Sort direction */
  sortDirection?: 'asc' | 'desc';
  /** Limit number of results */
  limit?: number;
  /** Skip first N results */
  skip?: number;
  /** Filter function */
  filter?: (metadata: FileMetadata) => boolean;
}

/**
 * Directory query options
 */
export interface DirectoryQueryOptions {
  /** Include subdirectories in search */
  recursive?: boolean;
  /** Directory name pattern (glob pattern) */
  pattern?: string;
  /** Sort directories by field */
  sortBy?: 'name' | 'path' | 'created' | 'modified';
  /** Sort direction */
  sortDirection?: 'asc' | 'desc';
  /** Limit number of results */
  limit?: number;
  /** Skip first N results */
  skip?: number;
  /** Filter function */
  filter?: (metadata: DirectoryMetadata) => boolean;
}

/**
 * Watch options for file/directory watchers
 */
export interface WatchOptions {
  /** Watch file/directory recursively */
  recursive?: boolean;
  /** Events to watch for */
  events?: WatchEvent[];
  /** Debounce interval in milliseconds */
  debounceInterval?: number;
  /** Filter function */
  filter?: (path: string, event: WatchEvent) => boolean;
}

/**
 * Watch event types
 */
export enum WatchEvent {
  /** File or directory was created */
  CREATED = 'created',
  /** File or directory was modified */
  MODIFIED = 'modified',
  /** File or directory was deleted */
  DELETED = 'deleted',
  /** File or directory was renamed */
  RENAMED = 'renamed',
  /** File was locked */
  LOCKED = 'locked',
  /** File was unlocked */
  UNLOCKED = 'unlocked'
}

/**
 * Storage statistics
 */
export interface StorageStats {
  /** Total number of files */
  totalFiles: number;
  /** Total number of directories */
  totalDirectories: number;
  /** Total storage size in bytes */
  totalSize: number;
  /** Number of locked files */
  lockedFiles: number;
  /** Storage usage by file type (extension) */
  sizeByFileType: Record<string, number>;
  /** Storage usage by directory */
  sizeByDirectory: Record<string, number>;
  /** File count by file type (extension) */
  fileCountByType: Record<string, number>;
  /** Average file size in bytes */
  averageFileSize: number;
  /** Largest file path */
  largestFilePath: string;
  /** Largest file size in bytes */
  largestFileSize: number;
  /** Most recently modified file path */
  mostRecentlyModifiedPath: string;
  /** Most recently modified timestamp */
  mostRecentlyModifiedTime: string;
}

/**
 * File system storage provider interface
 */
export interface IFileSystemStorageProvider {
  /**
   * Create a directory
   * @param path Directory path
   * @param options Directory options
   * @returns Promise resolving to true if directory was created, false if it already exists
   */
  createDirectory(path: string, options?: DirectoryOptions): Promise<boolean>;
  
  /**
   * Check if a directory exists
   * @param path Directory path
   * @returns Promise resolving to true if directory exists, false otherwise
   */
  directoryExists(path: string): Promise<boolean>;
  
  /**
   * Delete a directory
   * @param path Directory path
   * @param recursive Whether to delete contents recursively
   * @returns Promise resolving to true if directory was deleted, false otherwise
   */
  deleteDirectory(path: string, recursive?: boolean): Promise<boolean>;
  
  /**
   * List all files in a directory
   * @param path Directory path
   * @returns Promise resolving to array of file names
   */
  listFiles(path: string): Promise<string[]>;
  
  /**
   * List all subdirectories in a directory
   * @param path Directory path
   * @returns Promise resolving to array of directory names
   */
  listDirectories(path: string): Promise<string[]>;
  
  /**
   * Write content to a file
   * @param path File path
   * @param content File content
   * @param options File options
   * @returns Promise resolving to metadata of the written file
   */
  writeFile(path: string, content: string | ArrayBuffer | Uint8Array, options?: FileOptions): Promise<FileMetadata>;
  
  /**
   * Read a file and return its content
   * @param path File path
   * @returns Promise resolving to file content as string
   */
  readFile(path: string): Promise<string>;
  
  /**
   * Read a file and return its content as ArrayBuffer
   * @param path File path
   * @returns Promise resolving to file content as ArrayBuffer
   */
  readFileAsArrayBuffer(path: string): Promise<ArrayBuffer>;
  
  /**
   * Get metadata for a file
   * @param path File path
   * @returns Promise resolving to file metadata
   */
  getFileMetadata(path: string): Promise<FileMetadata>;
  
  /**
   * Check if a file exists
   * @param path File path
   * @returns Promise resolving to true if file exists, false otherwise
   */
  fileExists(path: string): Promise<boolean>;
  
  /**
   * Delete a file
   * @param path File path
   * @param createBackup Whether to create a backup before deleting
   * @returns Promise resolving to true if file was deleted, false otherwise
   */
  deleteFile(path: string, createBackup?: boolean): Promise<boolean>;
  
  /**
   * Rename a file or directory
   * @param oldPath Old path
   * @param newPath New path
   * @returns Promise resolving to metadata of the renamed file/directory
   */
  rename(oldPath: string, newPath: string): Promise<FileMetadata | DirectoryMetadata>;
  
  /**
   * Copy a file
   * @param sourcePath Source path
   * @param destinationPath Destination path
   * @param overwrite Whether to overwrite existing file
   * @returns Promise resolving to metadata of the copied file
   */
  copyFile(sourcePath: string, destinationPath: string, overwrite?: boolean): Promise<FileMetadata>;
  
  /**
   * Move a file
   * @param sourcePath Source path
   * @param destinationPath Destination path
   * @param overwrite Whether to overwrite existing file
   * @returns Promise resolving to metadata of the moved file
   */
  moveFile(sourcePath: string, destinationPath: string, overwrite?: boolean): Promise<FileMetadata>;
  
  /**
   * Lock a file for exclusive access
   * @param path File path
   * @param lockOwner Owner of the lock
   * @param timeout Lock timeout in milliseconds
   * @returns Promise resolving to true if lock was acquired, false otherwise
   */
  lockFile(path: string, lockOwner: string, timeout?: number): Promise<boolean>;
  
  /**
   * Unlock a file
   * @param path File path
   * @param lockOwner Owner of the lock
   * @returns Promise resolving to true if unlock was successful, false otherwise
   */
  unlockFile(path: string, lockOwner: string): Promise<boolean>;
  
  /**
   * Find files matching criteria
   * @param basePath Base path to start search from
   * @param options Query options
   * @returns Promise resolving to array of matching file metadata
   */
  findFiles(basePath: string, options?: FileQueryOptions): Promise<FileMetadata[]>;
  
  /**
   * Find directories matching criteria
   * @param basePath Base path to start search from
   * @param options Query options
   * @returns Promise resolving to array of matching directory metadata
   */
  findDirectories(basePath: string, options?: DirectoryQueryOptions): Promise<DirectoryMetadata[]>;
  
  /**
   * Get storage statistics
   * @returns Promise resolving to storage statistics
   */
  getStorageStats(): Promise<StorageStats>;
  
  /**
   * Watch a file or directory for changes
   * @param path File or directory path to watch
   * @param callback Callback function to call when changes are detected
   * @param options Watch options
   * @returns Watch ID that can be used to stop watching
   */
  watch(
    path: string,
    callback: (event: WatchEvent, path: string) => void,
    options?: WatchOptions
  ): string;
  
  /**
   * Stop watching a file or directory
   * @param watchId Watch ID returned by watch() method
   * @returns True if watcher was stopped, false if not found
   */
  unwatch(watchId: string): boolean;
  
  /**
   * Close all open file handles and connections
   */
  close(): Promise<void>;
}

/**
 * Storage events for event emitters
 */
export enum StorageEvent {
  /** File was created */
  FILE_CREATED = 'file-created',
  /** File was modified */
  FILE_MODIFIED = 'file-modified',
  /** File was deleted */
  FILE_DELETED = 'file-deleted',
  /** File was renamed */
  FILE_RENAMED = 'file-renamed',
  /** File was locked */
  FILE_LOCKED = 'file-locked',
  /** File was unlocked */
  FILE_UNLOCKED = 'file-unlocked',
  /** Directory was created */
  DIRECTORY_CREATED = 'directory-created',
  /** Directory was modified */
  DIRECTORY_MODIFIED = 'directory-modified',
  /** Directory was deleted */
  DIRECTORY_DELETED = 'directory-deleted',
  /** Directory was renamed */
  DIRECTORY_RENAMED = 'directory-renamed',
  /** Storage was initialized */
  STORAGE_INITIALIZED = 'storage-initialized',
  /** Storage was closed */
  STORAGE_CLOSED = 'storage-closed',
  /** Storage error occurred */
  STORAGE_ERROR = 'storage-error'
}

/**
 * Storage transaction interface
 */
export interface IStorageTransaction {
  /**
   * Get a specific object store from the transaction
   * @param storeName Store name
   * @returns Object store
   */
  getObjectStore(storeName: string): IDBObjectStore;
  
  /**
   * Commit the transaction
   */
  commit(): void;
  
  /**
   * Abort the transaction
   */
  abort(): void;
  
  /**
   * Add a callback to be executed when the transaction completes
   * @param callback Callback function
   */
  onComplete(callback: () => void): void;
  
  /**
   * Add a callback to be executed when the transaction fails
   * @param callback Callback function
   */
  onError(callback: (error: any) => void): void;
  
  /**
   * Add a callback to be executed when the transaction is aborted
   * @param callback Callback function
   */
  onAbort(callback: () => void): void;
}

/**
 * Backup information
 */
export interface BackupInfo {
  /** Backup ID */
  id: string;
  /** Original file path */
  originalPath: string;
  /** Backup file path */
  backupPath: string;
  /** Timestamp when backup was created */
  createdAt: string;
  /** User who created the backup */
  createdBy?: string;
  /** Backup description */
  description?: string;
  /** Whether backup is compressed */
  compressed: boolean;
  /** Whether backup is encrypted */
  encrypted: boolean;
  /** Custom metadata */
  metadata?: Record<string, any>;
}

/**
 * Storage sync status
 */
export interface StorageSyncStatus {
  /** Last sync timestamp */
  lastSyncTime: string;
  /** Sync status */
  status: 'synced' | 'syncing' | 'error' | 'not-synced';
  /** Number of pending changes */
  pendingChanges: number;
  /** Current sync progress (0-100) */
  progress: number;
  /** Error message if sync failed */
  errorMessage?: string;
}

/**
 * Storage quota information
 */
export interface StorageQuotaInfo {
  /** Storage quota in bytes */
  quota: number;
  /** Storage usage in bytes */
  usage: number;
  /** Remaining storage in bytes */
  remaining: number;
  /** Usage percentage (0-100) */
  usagePercentage: number;
  /** Quota warning threshold percentage */
  warningThreshold: number;
  /** Whether usage exceeds warning threshold */
  isNearQuota: boolean;
  /** Whether quota is unlimited */
  isUnlimited: boolean;
}

/**
 * Storage provider capabilities
 */
export interface StorageProviderCapabilities {
  /** Whether provider supports file locking */
  fileLocking: boolean;
  /** Whether provider supports compression */
  compression: boolean;
  /** Whether provider supports encryption */
  encryption: boolean;
  /** Whether provider supports file watching */
  fileWatching: boolean;
  /** Whether provider supports transactions */
  transactions: boolean;
  /** Whether provider supports quotas */
  quotas: boolean;
  /** Whether provider supports sync */
  sync: boolean;
  /** Whether provider is persistent */
  persistence: boolean;
  /** Maximum file size supported (in bytes, null means unlimited) */
  maxFileSize: number | null;
  /** Maximum storage size supported (in bytes, null means unlimited) */
  maxStorageSize: number | null;
  /** Supported serialization formats */
  serializationFormats: string[];
}


WebSocketClient.ts
------------------------------------

import { CSLogger } from '../../core/utils/CSLogger';
import { CSEncryptionUtils } from '../../core/utils/CSEncryptionUtils';
import { RetryHandler } from './RetryHandler';
import { MessageProcessor } from './MessageProcessor';
import { EventDispatcher } from './EventDispatcher';
import { Serializer } from './Serializer';

// Initialize logger
const logger = new CSLogger('WebSocketClient');

/**
 * WebSocket connection state
 */
export enum ConnectionState {
  /** Not connected */
  DISCONNECTED = 'disconnected',
  /** Connecting */
  CONNECTING = 'connecting',
  /** Connected */
  CONNECTED = 'connected',
  /** Connection authenticated */
  AUTHENTICATED = 'authenticated',
  /** Reconnecting after disconnect */
  RECONNECTING = 'reconnecting',
  /** Connection closing */
  CLOSING = 'closing',
  /** Connection failed */
  FAILED = 'failed'
}

/**
 * Authentication method
 */
export enum AuthMethod {
  /** Token-based authentication */
  TOKEN = 'token',
  /** Username/password authentication */
  CREDENTIALS = 'credentials',
  /** API key authentication */
  API_KEY = 'api_key',
  /** No authentication */
  NONE = 'none'
}

/**
 * Message priority levels
 */
export enum MessagePriority {
  /** Highest priority */
  CRITICAL = 0,
  /** High priority */
  HIGH = 1,
  /** Normal priority */
  NORMAL = 2,
  /** Low priority */
  LOW = 3,
  /** Background priority */
  BACKGROUND = 4
}

/**
 * WebSocket client options
 */
export interface WebSocketClientOptions {
  /** WebSocket URL */
  url: string;
  /** Auto connect on initialization */
  autoConnect?: boolean;
  /** Auto reconnect on disconnect */
  autoReconnect?: boolean;
  /** Reconnect delay in milliseconds */
  reconnectDelay?: number;
  /** Maximum reconnect attempts */
  maxReconnectAttempts?: number;
  /** Authentication method */
  authMethod?: AuthMethod;
  /** Authentication token */
  authToken?: string;
  /** Username for credentials authentication */
  username?: string;
  /** Password for credentials authentication */
  password?: string;
  /** API key for API key authentication */
  apiKey?: string;
  /** Enable message encryption */
  encryptMessages?: boolean;
  /** Custom encryption key */
  encryptionKey?: string;
  /** Connection timeout in milliseconds */
  connectionTimeout?: number;
  /** Keep alive interval in milliseconds */
  keepAliveInterval?: number;
  /** Protocol version */
  protocolVersion?: string;
  /** Binary type for binary messages */
  binaryType?: BinaryType;
  /** Disable auto response to ping */
  disableAutoPong?: boolean;
  /** Additional WebSocket protocols */
  protocols?: string[];
  /** When true, uses secure WebSocket (wss://) */
  secure?: boolean;
  /** Client ID (auto-generated if not provided) */
  clientId?: string;
  /** Client name/description */
  clientName?: string;
  /** Custom headers for WebSocket handshake */
  headers?: Record<string, string>;
  /** Debug mode */
  debug?: boolean;
}

/**
 * Default WebSocket client options
 */
const DEFAULT_OPTIONS: WebSocketClientOptions = {
  url: '',
  autoConnect: true,
  autoReconnect: true,
  reconnectDelay: 5000,
  maxReconnectAttempts: 10,
  authMethod: AuthMethod.NONE,
  encryptMessages: false,
  connectionTimeout: 30000,
  keepAliveInterval: 30000,
  protocolVersion: '1.0.0',
  binaryType: 'arraybuffer',
  disableAutoPong: false,
  secure: true,
  debug: false
};

/**
 * Message data
 */
export interface MessageData {
  /** Message type */
  type: string;
  /** Message payload */
  payload: any;
  /** Message ID */
  id?: string;
  /** Correlation ID for request/response correlation */
  correlationId?: string;
  /** Timestamp when message was created */
  timestamp?: string;
  /** Sender client ID */
  senderId?: string;
  /** Target client ID (null means broadcast) */
  targetId?: string | null;
  /** Message priority */
  priority?: MessagePriority;
  /** Custom message headers */
  headers?: Record<string, string>;
}

/**
 * Message metadata
 */
export interface MessageMetadata {
  /** Message ID */
  id: string;
  /** Message status */
  status: 'pending' | 'sent' | 'delivered' | 'failed' | 'timeout';
  /** Timestamp when message was created */
  createdAt: string;
  /** Timestamp when message was sent */
  sentAt?: string;
  /** Timestamp when delivery was acknowledged */
  deliveredAt?: string;
  /** Number of retry attempts */
  retryCount: number;
  /** Error message if send failed */
  errorMessage?: string;
  /** Timeout handle for message expiration */
  timeoutHandle?: any;
  /** Resolve function for promise */
  resolve?: (value: any) => void;
  /** Reject function for promise */
  reject?: (reason?: any) => void;
  /** Message priority */
  priority: MessagePriority;
  /** Original message data */
  messageData: MessageData;
}

/**
 * WebSocket client for bidirectional communication with the backend
 */
export class WebSocketClient {
  /** WebSocket connection */
  private socket: WebSocket | null = null;
  /** WebSocket client options */
  private options: WebSocketClientOptions;
  /** Current connection state */
  private connectionState: ConnectionState = ConnectionState.DISCONNECTED;
  /** Retry handler for connection attempts */
  private retryHandler: RetryHandler;
  /** Message processor for handling incoming messages */
  private messageProcessor: MessageProcessor;
  /** Event dispatcher for publishing events */
  private eventDispatcher: EventDispatcher;
  /** Message serializer/deserializer */
  private serializer: Serializer;
  /** Connection timeout handle */
  private connectionTimeoutHandle: number | null = null;
  /** Keep alive interval handle */
  private keepAliveIntervalHandle: number | null = null;
  /** Connection attempt count */
  private connectionAttempts: number = 0;
  /** Last activity timestamp */
  private lastActivityTimestamp: number = 0;
  /** Client identifier */
  private clientId: string;
  /** Pending messages mapped by message ID */
  private pendingMessages: Map<string, MessageMetadata> = new Map();
  /** Request/response correlation mapped by correlation ID */
  private correlations: Map<string, MessageMetadata> = new Map();
  /** Message queue for sending when connection is established */
  private messageQueue: MessageMetadata[] = [];
  /** Subscription topics */
  private subscriptions: Set<string> = new Set();
  
  /**
   * Create a new WebSocketClient instance
   * @param options WebSocket client options
   */
  constructor(options: WebSocketClientOptions) {
    // Merge options with defaults
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
    
    // Validate URL
    if (!this.options.url) {
      throw new Error('WebSocket URL is required');
    }
    
    // Initialize client ID
    this.clientId = this.options.clientId || this.generateClientId();
    
    // Initialize components
    this.retryHandler = new RetryHandler({
      initialDelay: this.options.reconnectDelay!,
      maxAttempts: this.options.maxReconnectAttempts!,
      onRetry: this.handleRetry.bind(this)
    });
    
    this.messageProcessor = new MessageProcessor({
      onMessage: this.handleIncomingMessage.bind(this),
      onError: this.handleMessageProcessingError.bind(this)
    });
    
    this.eventDispatcher = new EventDispatcher();
    
    this.serializer = new Serializer({
      encrypt: this.options.encryptMessages!,
      encryptionKey: this.options.encryptionKey
    });
    
    // Connect if auto connect is enabled
    if (this.options.autoConnect) {
      this.connect();
    }
  }
  
  /**
   * Connect to the WebSocket server
   * @returns Promise that resolves when connected and authenticated
   */
  public connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      // Check if already connecting or connected
      if (
        this.connectionState === ConnectionState.CONNECTING ||
        this.connectionState === ConnectionState.CONNECTED ||
        this.connectionState === ConnectionState.AUTHENTICATED
      ) {
        logger.warn('Already connecting or connected');
        resolve();
        return;
      }
      
      // Update connection state
      this.setConnectionState(ConnectionState.CONNECTING);
      
      // Increment connection attempts
      this.connectionAttempts++;
      
      logger.info(`Connecting to WebSocket server: ${this.options.url} (attempt ${this.connectionAttempts})`);
      
      try {
        // Close existing socket if any
        this.closeSocket();
        
        // Create a new WebSocket connection
        const fullUrl = this.buildWebSocketUrl();
        this.socket = new WebSocket(fullUrl, this.options.protocols);
        
        // Set binary type
        this.socket.binaryType = this.options.binaryType!;
        
        // Set up event handlers
        this.socket.onopen = (event) => this.handleOpen(event, resolve, reject);
        this.socket.onclose = (event) => this.handleClose(event);
        this.socket.onerror = (event) => this.handleError(event, reject);
        this.socket.onmessage = (event) => this.handleMessage(event);
        
        // Set connection timeout
        if (this.options.connectionTimeout! > 0) {
          this.connectionTimeoutHandle = window.setTimeout(() => {
            if (this.connectionState === ConnectionState.CONNECTING) {
              logger.error('Connection timeout');
              this.closeSocket();
              this.setConnectionState(ConnectionState.FAILED);
              reject(new Error('Connection timeout'));
            }
          }, this.options.connectionTimeout!);
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        logger.error(`Failed to create WebSocket: ${errorMessage}`);
        this.setConnectionState(ConnectionState.FAILED);
        reject(new Error(`Failed to create WebSocket: ${errorMessage}`));
      }
    });
  }
  
  /**
   * Disconnect from the WebSocket server
   * @param code Close code
   * @param reason Close reason
   */
  public disconnect(code: number = 1000, reason: string = 'Client disconnected'): void {
    logger.info(`Disconnecting from WebSocket server: ${reason}`);
    
    // Clear timeouts and intervals
    this.clearTimeouts();
    
    // Reset retry handler
    this.retryHandler.reset();
    
    // Update connection state
    this.setConnectionState(ConnectionState.CLOSING);
    
    // Close the socket
    this.closeSocket(code, reason);
    
    // Update connection state
    this.setConnectionState(ConnectionState.DISCONNECTED);
    
    // Reject all pending messages
    this.rejectAllPendingMessages('Client disconnected');
  }
  
  /**
   * Send a message to the server
   * @param type Message type
   * @param payload Message payload
   * @param options Message options
   * @returns Promise that resolves when message is delivered
   */
  public send(
    type: string,
    payload: any,
    options: {
      priority?: MessagePriority;
      headers?: Record<string, string>;
      timeout?: number;
      correlationId?: string;
      targetId?: string;
    } = {}
  ): Promise<any> {
    return new Promise((resolve, reject) => {
      // Create message data
      const messageData: MessageData = {
        type,
        payload,
        id: this.generateMessageId(),
        correlationId: options.correlationId || undefined,
        timestamp: new Date().toISOString(),
        senderId: this.clientId,
        targetId: options.targetId || null,
        priority: options.priority || MessagePriority.NORMAL,
        headers: options.headers
      };
      
      // Create message metadata
      const metadata: MessageMetadata = {
        id: messageData.id!,
        status: 'pending',
        createdAt: messageData.timestamp!,
        retryCount: 0,
        priority: messageData.priority!,
        messageData,
        resolve,
        reject
      };
      
      // Set timeout if specified
      if (options.timeout && options.timeout > 0) {
        metadata.timeoutHandle = window.setTimeout(() => {
          this.handleMessageTimeout(metadata);
        }, options.timeout);
      }
      
      // Store correlation if correlation ID is provided
      if (messageData.correlationId) {
        this.correlations.set(messageData.correlationId, metadata);
      }
      
      // Store pending message
      this.pendingMessages.set(metadata.id, metadata);
      
      // Send or queue the message
      if (this.isConnected()) {
        this.sendMessage(metadata);
      } else {
        logger.debug(`Queueing message: ${metadata.id} (${type})`);
        this.messageQueue.push(metadata);
        
        // Connect if disconnected
        if (this.connectionState === ConnectionState.DISCONNECTED) {
          this.connect().catch((err) => {
            logger.error(`Failed to connect for sending message: ${err.message}`);
            this.handleMessageError(metadata, err);
          });
        }
      }
    });
  }
  
  /**
   * Send a request and wait for a response
   * @param type Request type
   * @param payload Request payload
   * @param options Request options
   * @returns Promise that resolves with the response
   */
  public request(
    type: string,
    payload: any,
    options: {
      priority?: MessagePriority;
      headers?: Record<string, string>;
      timeout?: number;
      targetId?: string;
    } = {}
  ): Promise<any> {
    // Generate correlation ID for request/response
    const correlationId = this.generateCorrelationId();
    
    // Set default timeout
    const timeout = options.timeout || 30000;
    
    // Send request
    return this.send(type, payload, {
      ...options,
      correlationId,
      timeout
    });
  }
  
  /**
   * Subscribe to a topic
   * @param topic Topic to subscribe to
   * @returns Promise that resolves when subscription is confirmed
   */
  public subscribe(topic: string): Promise<void> {
    logger.debug(`Subscribing to topic: ${topic}`);
    
    // Add to local subscriptions set
    this.subscriptions.add(topic);
    
    // Send subscription request to server
    return this.request('subscribe', { topic })
      .then(() => {
        logger.debug(`Subscribed to topic: ${topic}`);
        this.eventDispatcher.dispatch('subscribed', { topic });
      })
      .catch((err) => {
        logger.error(`Failed to subscribe to topic ${topic}: ${err.message}`);
        // Remove from local subscriptions if failed
        this.subscriptions.delete(topic);
        throw err;
      });
  }
  
  /**
   * Unsubscribe from a topic
   * @param topic Topic to unsubscribe from
   * @returns Promise that resolves when unsubscription is confirmed
   */
  public unsubscribe(topic: string): Promise<void> {
    logger.debug(`Unsubscribing from topic: ${topic}`);
    
    // Send unsubscription request to server
    return this.request('unsubscribe', { topic })
      .then(() => {
        logger.debug(`Unsubscribed from topic: ${topic}`);
        // Remove from local subscriptions
        this.subscriptions.delete(topic);
        this.eventDispatcher.dispatch('unsubscribed', { topic });
      })
      .catch((err) => {
        logger.error(`Failed to unsubscribe from topic ${topic}: ${err.message}`);
        throw err;
      });
  }
  
  /**
   * Publish a message to a topic
   * @param topic Topic to publish to
   * @param data Message data
   * @param options Publish options
   * @returns Promise that resolves when message is published
   */
  public publish(
    topic: string,
    data: any,
    options: {
      priority?: MessagePriority;
      headers?: Record<string, string>;
      timeout?: number;
    } = {}
  ): Promise<void> {
    logger.debug(`Publishing message to topic: ${topic}`);
    
    // Send publish request to server
    return this.send('publish', { topic, data }, options)
      .then(() => {
        logger.debug(`Published message to topic: ${topic}`);
      })
      .catch((err) => {
        logger.error(`Failed to publish message to topic ${topic}: ${err.message}`);
        throw err;
      });
  }
  
  /**
   * Authenticate with the WebSocket server
   * @returns Promise that resolves when authenticated
   */
  public authenticate(): Promise<void> {
    logger.debug('Authenticating with WebSocket server');
    
    // Skip if already authenticated
    if (this.connectionState === ConnectionState.AUTHENTICATED) {
      logger.debug('Already authenticated');
      return Promise.resolve();
    }
    
    // Build authentication payload based on auth method
    const authPayload: any = {
      clientId: this.clientId,
      clientName: this.options.clientName,
      protocolVersion: this.options.protocolVersion
    };
    
    switch (this.options.authMethod) {
      case AuthMethod.TOKEN:
        if (!this.options.authToken) {
          return Promise.reject(new Error('Authentication token is required for token authentication'));
        }
        authPayload.token = this.options.authToken;
        break;
        
      case AuthMethod.CREDENTIALS:
        if (!this.options.username || !this.options.password) {
          return Promise.reject(new Error('Username and password are required for credentials authentication'));
        }
        authPayload.username = this.options.username;
        authPayload.password = this.options.password;
        break;
        
      case AuthMethod.API_KEY:
        if (!this.options.apiKey) {
          return Promise.reject(new Error('API key is required for API key authentication'));
        }
        authPayload.apiKey = this.options.apiKey;
        break;
        
      case AuthMethod.NONE:
        // No additional payload needed
        break;
    }
    
    // Send authentication request
    return this.request('authenticate', authPayload, { priority: MessagePriority.CRITICAL })
      .then((response) => {
        logger.info('Authentication successful');
        
        // Update connection state
        this.setConnectionState(ConnectionState.AUTHENTICATED);
        
        // Dispatch authenticated event
        this.eventDispatcher.dispatch('authenticated', response);
        
        // Restore subscriptions
        this.restoreSubscriptions();
        
        // Send queued messages
        this.sendQueuedMessages();
        
        return response;
      })
      .catch((err) => {
        logger.error(`Authentication failed: ${err.message}`);
        
        // Update connection state
        this.setConnectionState(ConnectionState.FAILED);
        
        // Dispatch authentication failed event
        this.eventDispatcher.dispatch('authentication_failed', { error: err.message });
        
        // Close the connection
        this.closeSocket(4401, 'Authentication failed');
        
        throw err;
      });
  }
  
  /**
   * Add event listener
   * @param event Event name
   * @param listener Event listener function
   * @returns Event listener ID
   */
  public on(event: string, listener: (data: any) => void): string {
    return this.eventDispatcher.on(event, listener);
  }
  
  /**
   * Remove event listener
   * @param id Event listener ID
   * @returns True if listener was removed, false if not found
   */
  public off(id: string): boolean {
    return this.eventDispatcher.off(id);
  }
  
  /**
   * Check if connected
   * @returns True if connected
   */
  public isConnected(): boolean {
    return (
      this.socket !== null &&
      this.socket.readyState === WebSocket.OPEN &&
      (this.connectionState === ConnectionState.CONNECTED ||
       this.connectionState === ConnectionState.AUTHENTICATED)
    );
  }
  
  /**
   * Check if authenticated
   * @returns True if authenticated
   */
  public isAuthenticated(): boolean {
    return this.connectionState === ConnectionState.AUTHENTICATED;
  }
  
  /**
   * Get current connection state
   * @returns Connection state
   */
  public getConnectionState(): ConnectionState {
    return this.connectionState;
  }
  
  /**
   * Get client ID
   * @returns Client ID
   */
  public getClientId(): string {
    return this.clientId;
  }
  
  /**
   * Get subscribed topics
   * @returns Array of subscribed topics
   */
  public getSubscriptions(): string[] {
    return Array.from(this.subscriptions);
  }
  
  /**
   * Get pending message count
   * @returns Number of pending messages
   */
  public getPendingMessageCount(): number {
    return this.pendingMessages.size;
  }
  
  /**
   * Get queued message count
   * @returns Number of queued messages
   */
  public getQueuedMessageCount(): number {
    return this.messageQueue.length;
  }
  
  /**
   * Close the socket
   * @param code Close code
   * @param reason Close reason
   */
  private closeSocket(code: number = 1000, reason: string = 'Client closing connection'): void {
    if (this.socket) {
      try {
        // Remove event listeners
        this.socket.onopen = null;
        this.socket.onclose = null;
        this.socket.onerror = null;
        this.socket.onmessage = null;
        
        // Close the socket
        if (this.socket.readyState === WebSocket.OPEN || this.socket.readyState === WebSocket.CONNECTING) {
          this.socket.close(code, reason);
        }
      } catch (err) {
        logger.error(`Error closing WebSocket: ${err instanceof Error ? err.message : String(err)}`);
      } finally {
        this.socket = null;
      }
    }
  }
  
  /**
   * Clear timeouts and intervals
   */
  private clearTimeouts(): void {
    // Clear connection timeout
    if (this.connectionTimeoutHandle !== null) {
      window.clearTimeout(this.connectionTimeoutHandle);
      this.connectionTimeoutHandle = null;
    }
    
    // Clear keep alive interval
    if (this.keepAliveIntervalHandle !== null) {
      window.clearInterval(this.keepAliveIntervalHandle);
      this.keepAliveIntervalHandle = null;
    }
    
    // Clear message timeouts
    for (const metadata of this.pendingMessages.values()) {
      if (metadata.timeoutHandle) {
        window.clearTimeout(metadata.timeoutHandle);
        metadata.timeoutHandle = undefined;
      }
    }
  }
  
  /**
   * Set connection state
   * @param state New connection state
   */
  private setConnectionState(state: ConnectionState): void {
    if (state !== this.connectionState) {
      logger.debug(`Connection state changed: ${this.connectionState} -> ${state}`);
      
      const previousState = this.connectionState;
      this.connectionState = state;
      
      // Dispatch state change event
      this.eventDispatcher.dispatch('statechange', {
        previous: previousState,
        current: state
      });
      
      // Dispatch specific state event
      this.eventDispatcher.dispatch(state, {
        previous: previousState
      });
    }
  }
  
  /**
   * Handle WebSocket open event
   * @param event Open event
   * @param resolve Promise resolve function
   * @param reject Promise reject function
   */
  private handleOpen(event: Event, resolve: () => void, reject: (reason?: any) => void): void {
    logger.info('WebSocket connection established');
    
    // Clear connection timeout
    if (this.connectionTimeoutHandle !== null) {
      window.clearTimeout(this.connectionTimeoutHandle);
      this.connectionTimeoutHandle = null;
    }
    
    // Update connection state
    this.setConnectionState(ConnectionState.CONNECTED);
    
    // Reset connection attempts
    this.connectionAttempts = 0;
    this.retryHandler.reset();
    
    // Update last activity timestamp
    this.lastActivityTimestamp = Date.now();
    
    // Set up keep alive interval
    if (this.options.keepAliveInterval! > 0) {
      this.keepAliveIntervalHandle = window.setInterval(() => {
        this.sendPing();
      }, this.options.keepAliveInterval!);
    }
    
    // Authenticate if needed
    if (this.options.authMethod !== AuthMethod.NONE) {
      this.authenticate()
        .then(() => resolve())
        .catch((err) => reject(err));
    } else {
      // No authentication needed
      this.setConnectionState(ConnectionState.AUTHENTICATED);
      
      // Restore subscriptions
      this.restoreSubscriptions();
      
      // Send queued messages
      this.sendQueuedMessages();
      
      resolve();
    }
  }
  
  /**
   * Handle WebSocket close event
   * @param event Close event
   */
  private handleClose(event: CloseEvent): void {
    logger.info(`WebSocket connection closed: code=${event.code}, reason=${event.reason || 'No reason'}, wasClean=${event.wasClean}`);
    
    // Clear timeouts and intervals
    this.clearTimeouts();
    
    // Update connection state
    if (this.connectionState !== ConnectionState.FAILED) {
      this.setConnectionState(ConnectionState.DISCONNECTED);
    }
    
    // Dispatch close event
    this.eventDispatcher.dispatch('close', {
      code: event.code,
      reason: event.reason,
      wasClean: event.wasClean
    });
    
    // Reject pending messages for clean closes
    if (event.wasClean) {
      this.rejectAllPendingMessages(`Connection closed: ${event.reason || 'No reason'}`);
    }
    
    // Auto reconnect if enabled
    if (
      this.options.autoReconnect &&
      this.connectionState !== ConnectionState.FAILED &&
      event.code !== 1000 // Normal close
    ) {
      this.retryHandler.retry();
    }
  }
  
  /**
   * Handle WebSocket error event
   * @param event Error event
   * @param reject Promise reject function
   */
  private handleError(event: Event, reject?: (reason?: any) => void): void {
    logger.error('WebSocket error occurred', event);
    
    // Dispatch error event
    this.eventDispatcher.dispatch('error', {
      event: event
    });
    
    // Reject connection promise if provided
    if (reject) {
      reject(new Error('WebSocket error occurred'));
    }
  }
  
  /**
   * Handle WebSocket message event
   * @param event Message event
   */
  private handleMessage(event: MessageEvent): void {
    // Update last activity timestamp
    this.lastActivityTimestamp = Date.now();
    
    // Deserialize message
    try {
      // Handle different message types
      let messageData: MessageData;
      
      if (typeof event.data === 'string') {
        // Text message
        messageData = this.serializer.deserialize(event.data);
      } else if (event.data instanceof ArrayBuffer) {
        // Binary message
        messageData = this.serializer.deserializeBinary(event.data);
      } else {
        logger.error(`Unsupported message format: ${typeof event.data}`);
        return;
      }
      
      // Process message
      this.messageProcessor.processMessage(messageData);
    } catch (err) {
      logger.error(`Failed to deserialize message: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Handle incoming message
   * @param messageData Message data
   */
  private handleIncomingMessage(messageData: MessageData): void {
    logger.debug(`Received message: ${messageData.type}`, messageData);
    
    // Check if message is for this client
    if (messageData.targetId && messageData.targetId !== this.clientId) {
      logger.debug(`Ignoring message for another client: ${messageData.targetId}`);
      return;
    }
    
    // Handle system messages
    if (this.handleSystemMessage(messageData)) {
      return;
    }
    
    // Handle correlation responses
    if (messageData.correlationId && this.correlations.has(messageData.correlationId)) {
      this.handleCorrelationResponse(messageData);
      return;
    }
    
    // Handle delivery acknowledgements
    if (messageData.type === 'ack' && messageData.payload && messageData.payload.messageId) {
      this.handleDeliveryAcknowledgement(messageData.payload.messageId);
      return;
    }
    
    // Dispatch message event
    this.eventDispatcher.dispatch('message', messageData);
    
    // Dispatch specific message type event
    this.eventDispatcher.dispatch(`message:${messageData.type}`, messageData);
    
    // Send acknowledgement if needed
    if (messageData.id && messageData.headers?.requireAck === 'true') {
      this.sendAcknowledgement(messageData.id);
    }
  }
  
  /**
   * Handle message processing error
   * @param error Error
   * @param messageData Message data
   */
  private handleMessageProcessingError(error: Error, messageData?: any): void {
    logger.error(`Message processing error: ${error.message}`, messageData);
    
    // Dispatch error event
    this.eventDispatcher.dispatch('message_error', {
      error: error.message,
      message: messageData
    });
  }
  
  /**
   * Handle system messages
   * @param messageData Message data
   * @returns True if message was handled as a system message
   */
  private handleSystemMessage(messageData: MessageData): boolean {
    switch (messageData.type) {
      case 'ping':
        // Respond to ping
        if (!this.options.disableAutoPong) {
          this.sendPong(messageData.id);
        }
        
        // Dispatch ping event
        this.eventDispatcher.dispatch('ping', messageData.payload);
        return true;
        
      case 'pong':
        // Dispatch pong event
        this.eventDispatcher.dispatch('pong', messageData.payload);
        return true;
        
      case 'authentication_result':
        // Handled by authenticate() method
        return true;
        
      case 'subscription_confirm':
        // Dispatch subscription confirmation event
        this.eventDispatcher.dispatch('subscription_confirmed', messageData.payload);
        return true;
        
      case 'subscription_error':
        // Dispatch subscription error event
        this.eventDispatcher.dispatch('subscription_error', messageData.payload);
        return true;
        
      case 'server_disconnect':
        // Server is requesting disconnect
        logger.info(`Server requested disconnect: ${messageData.payload?.reason || 'No reason'}`);
        
        // Dispatch server disconnect event
        this.eventDispatcher.dispatch('server_disconnect', messageData.payload);
        
        // Disconnect
        this.disconnect(
          messageData.payload?.code || 1000,
          messageData.payload?.reason || 'Server requested disconnect'
        );
        return true;
        
      default:
        return false;
    }
  }
  
  /**
   * Handle correlation response
   * @param messageData Message data
   */
  private handleCorrelationResponse(messageData: MessageData): void {
    // Get correlation
    const correlation = this.correlations.get(messageData.correlationId!);
    
    if (correlation) {
      logger.debug(`Handling correlation response for: ${correlation.id}`, messageData);
      
      // Remove correlation
      this.correlations.delete(messageData.correlationId!);
      
      // Handle error response
      if (messageData.type === 'error') {
        logger.error(`Error response received: ${messageData.payload?.message || 'Unknown error'}`);
        
        // Reject promise
        if (correlation.reject) {
          correlation.reject(new Error(messageData.payload?.message || 'Unknown error'));
        }
      } else {
        // Resolve promise
        if (correlation.resolve) {
          correlation.resolve(messageData.payload);
        }
      }
      
      // Remove pending message
      this.pendingMessages.delete(correlation.id);
      
      // Clear timeout
      if (correlation.timeoutHandle) {
        window.clearTimeout(correlation.timeoutHandle);
      }
    } else {
      logger.warn(`Received response for unknown correlation: ${messageData.correlationId}`);
    }
  }
  
  /**
   * Handle delivery acknowledgement
   * @param messageId Message ID
   */
  private handleDeliveryAcknowledgement(messageId: string): void {
    // Get pending message
    const metadata = this.pendingMessages.get(messageId);
    
    if (metadata) {
      logger.debug(`Handling delivery acknowledgement for: ${messageId}`);
      
      // Update metadata
      metadata.status = 'delivered';
      metadata.deliveredAt = new Date().toISOString();
      
      // Resolve promise
      if (metadata.resolve) {
        metadata.resolve(null);
      }
      
      // Remove pending message
      this.pendingMessages.delete(messageId);
      
      // Clear timeout
      if (metadata.timeoutHandle) {
        window.clearTimeout(metadata.timeoutHandle);
      }
    } else {
      logger.warn(`Received acknowledgement for unknown message: ${messageId}`);
    }
  }
  
  /**
   * Handle retry
   * @param attempt Retry attempt number
   * @param delay Delay before retry in milliseconds
   */
  private handleRetry(attempt: number, delay: number): void {
    logger.info(`Attempting to reconnect (${attempt}/${this.options.maxReconnectAttempts}) in ${delay}ms`);
    
    // Update connection state
    this.setConnectionState(ConnectionState.RECONNECTING);
    
    // Dispatch reconnecting event
    this.eventDispatcher.dispatch('reconnecting', {
      attempt,
      delay,
      maxAttempts: this.options.maxReconnectAttempts
    });
    
    // Connect after delay
    window.setTimeout(() => {
      this.connect().catch((err) => {
        logger.error(`Reconnect attempt ${attempt} failed: ${err.message}`);
      });
    }, delay);
  }
  
  /**
   * Handle message timeout
   * @param metadata Message metadata
   */
  private handleMessageTimeout(metadata: MessageMetadata): void {
    logger.warn(`Message timeout: ${metadata.id}`);
    
    // Update metadata
    metadata.status = 'timeout';
    metadata.timeoutHandle = undefined;
    
    // Reject promise
    if (metadata.reject) {
      metadata.reject(new Error('Message timeout'));
    }
    
    // Remove message from tracking
    this.pendingMessages.delete(metadata.id);
    
    if (metadata.messageData.correlationId) {
      this.correlations.delete(metadata.messageData.correlationId);
    }
    
    // Dispatch timeout event
    this.eventDispatcher.dispatch('message_timeout', {
      id: metadata.id,
      message: metadata.messageData
    });
  }
  
  /**
   * Handle message error
   * @param metadata Message metadata
   * @param error Error
   */
  private handleMessageError(metadata: MessageMetadata, error: Error): void {
    logger.error(`Message error: ${metadata.id}: ${error.message}`);
    
    // Update metadata
    metadata.status = 'failed';
    metadata.errorMessage = error.message;
    
    // Reject promise
    if (metadata.reject) {
      metadata.reject(error);
    }
    
    // Remove message from tracking
    this.pendingMessages.delete(metadata.id);
    
    if (metadata.messageData.correlationId) {
      this.correlations.delete(metadata.messageData.correlationId);
    }
    
    // Clear timeout
    if (metadata.timeoutHandle) {
      window.clearTimeout(metadata.timeoutHandle);
      metadata.timeoutHandle = undefined;
    }
    
    // Dispatch error event
    this.eventDispatcher.dispatch('message_error', {
      id: metadata.id,
      message: metadata.messageData,
      error: error.message
    });
  }
  
  /**
   * Send message
   * @param metadata Message metadata
   */
  private sendMessage(metadata: MessageMetadata): void {
    if (!this.isConnected()) {
      logger.error(`Cannot send message: ${metadata.id} - not connected`);
      this.handleMessageError(metadata, new Error('Not connected'));
      return;
    }
    
    try {
      logger.debug(`Sending message: ${metadata.id} (${metadata.messageData.type})`);
      
      // Update metadata
      metadata.status = 'sent';
      metadata.sentAt = new Date().toISOString();
      metadata.retryCount++;
      
      // Serialize message
      let serializedMessage: string | ArrayBuffer;
      
      if (this.options.binaryType === 'arraybuffer') {
        serializedMessage = this.serializer.serializeBinary(metadata.messageData);
      } else {
        serializedMessage = this.serializer.serialize(metadata.messageData);
      }
      
      // Send message
      this.socket!.send(serializedMessage);
      
      // Update last activity timestamp
      this.lastActivityTimestamp = Date.now();
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to send message: ${metadata.id}: ${errorMessage}`);
      this.handleMessageError(metadata, new Error(`Failed to send: ${errorMessage}`));
    }
  }
  
  /**
   * Send all queued messages
   */
  private sendQueuedMessages(): void {
    if (this.messageQueue.length === 0) {
      return;
    }
    
    logger.debug(`Sending ${this.messageQueue.length} queued messages`);
    
    // Sort messages by priority
    const sortedQueue = [...this.messageQueue].sort((a, b) => a.priority - b.priority);
    
    // Clear queue
    this.messageQueue = [];
    
    // Send messages
    for (const metadata of sortedQueue) {
      this.sendMessage(metadata);
    }
  }
  
  /**
   * Send ping
   */
  private sendPing(): void {
    // Check if connected
    if (!this.isConnected()) {
      return;
    }
    
    // Check if activity is recent
    const now = Date.now();
    const idleTime = now - this.lastActivityTimestamp;
    
    // Only send ping if idle
    if (idleTime >= this.options.keepAliveInterval! / 2) {
      logger.debug('Sending ping');
      
      // Send ping message
      this.send('ping', { timestamp: now }, { priority: MessagePriority.HIGH })
        .catch((err) => {
          logger.error(`Failed to send ping: ${err.message}`);
        });
    }
  }
  
  /**
   * Send pong in response to ping
   * @param pingId Ping message ID
   */
  private sendPong(pingId?: string): void {
    logger.debug('Sending pong');
    
    // Send pong message
    this.send('pong', {
      timestamp: Date.now(),
      pingId
    }, { priority: MessagePriority.HIGH })
      .catch((err) => {
        logger.error(`Failed to send pong: ${err.message}`);
      });
  }
  
  /**
   * Send acknowledgement for a received message
   * @param messageId Message ID
   */
  private sendAcknowledgement(messageId: string): void {
    logger.debug(`Sending acknowledgement for message: ${messageId}`);
    
    // Send acknowledgement message
    this.send('ack', { messageId }, { priority: MessagePriority.HIGH })
      .catch((err) => {
        logger.error(`Failed to send acknowledgement: ${err.message}`);
      });
  }
  
  /**
   * Restore subscriptions after reconnect
   */
  private async restoreSubscriptions(): Promise<void> {
    if (this.subscriptions.size === 0) {
      return;
    }
    
    logger.debug(`Restoring ${this.subscriptions.size} subscriptions`);
    
    const subscriptions = Array.from(this.subscriptions);
    
    // Clear subscriptions
    this.subscriptions.clear();
    
    // Resubscribe to all topics
    for (const topic of subscriptions) {
      try {
        await this.subscribe(topic);
      } catch (err) {
        logger.error(`Failed to restore subscription to ${topic}: ${err.message}`);
      }
    }
  }
  
  /**
   * Reject all pending messages
   * @param reason Rejection reason
   */
  private rejectAllPendingMessages(reason: string): void {
    if (this.pendingMessages.size === 0) {
      return;
    }
    
    logger.debug(`Rejecting ${this.pendingMessages.size} pending messages: ${reason}`);
    
    // Reject all pending messages
    for (const metadata of this.pendingMessages.values()) {
      // Clear timeout
      if (metadata.timeoutHandle) {
        window.clearTimeout(metadata.timeoutHandle);
        metadata.timeoutHandle = undefined;
      }
      
      // Update metadata
      metadata.status = 'failed';
      metadata.errorMessage = reason;
      
      // Reject promise
      if (metadata.reject) {
        metadata.reject(new Error(reason));
      }
    }
    
    // Clear pending messages
    this.pendingMessages.clear();
    
    // Clear correlations
    this.correlations.clear();
  }
  
  /**
   * Build WebSocket URL
   * @returns Complete WebSocket URL
   */
  private buildWebSocketUrl(): string {
    const url = new URL(this.options.url);
    
    // Set protocol
    url.protocol = this.options.secure ? 'wss:' : 'ws:';
    
    // Add client ID
    url.searchParams.set('clientId', this.clientId);
    
    // Add protocol version
    url.searchParams.set('version', this.options.protocolVersion!);
    
    return url.toString();
  }
  
  /**
   * Generate a unique client ID
   * @returns Unique client ID
   */
  private generateClientId(): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 10);
    return `client_${timestamp}_${random}`;
  }
  
  /**
   * Generate a unique message ID
   * @returns Unique message ID
   */
  private generateMessageId(): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 6);
    return `msg_${timestamp}_${random}`;
  }
  
  /**
   * Generate a correlation ID for request/response correlation
   * @returns Unique correlation ID
   */
  private generateCorrelationId(): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 10);
    return `corr_${timestamp}_${random}`;
  }
}


MessageProcessor.ts
-----------------------------------------

import { CSLogger } from '../../core/utils/CSLogger';
import { MessageData, MessagePriority } from './WebSocketClient';

// Initialize logger
const logger = new CSLogger('MessageProcessor');

/**
 * Message processor options
 */
export interface MessageProcessorOptions {
  /** Callback for handling processed messages */
  onMessage: (message: MessageData) => void;
  /** Callback for handling errors */
  onError: (error: Error, messageData?: any) => void;
  /** Maximum message size in bytes (default: 1MB) */
  maxMessageSize?: number;
  /** Maximum messages processed per second (default: 100) */
  maxMessagesPerSecond?: number;
  /** Whether to validate message schemas (default: true) */
  validateSchema?: boolean;
  /** Message schema mapping */
  schemas?: Record<string, any>;
  /** Message type whitelist (if specified, only these message types are processed) */
  allowedMessageTypes?: string[];
  /** Message type blacklist (these message types are not processed) */
  blockedMessageTypes?: string[];
  /** Allow binary messages (default: true) */
  allowBinaryMessages?: boolean;
  /** Custom message validators */
  validators?: Record<string, (message: MessageData) => boolean>;
  /** Custom message transformers */
  transformers?: Record<string, (message: MessageData) => MessageData>;
  /** Debug mode (default: false) */
  debug?: boolean;
}

/**
 * Default message processor options
 */
const DEFAULT_OPTIONS: MessageProcessorOptions = {
  onMessage: () => {},
  onError: () => {},
  maxMessageSize: 1024 * 1024, // 1MB
  maxMessagesPerSecond: 100,
  validateSchema: true,
  allowBinaryMessages: true,
  debug: false
};

/**
 * Processed message info for rate limiting
 */
interface ProcessedMessageInfo {
  /** Timestamp when message was processed */
  timestamp: number;
  /** Message size in bytes */
  size: number;
  /** Message type */
  type: string;
  /** Message ID */
  id?: string;
  /** Message priority */
  priority: MessagePriority;
}

/**
 * Message processor for handling incoming WebSocket messages
 */
export class MessageProcessor {
  /** Message processor options */
  private options: MessageProcessorOptions;
  /** Message rate limiting window (1 second) */
  private rateLimitWindow: number = 1000;
  /** Recently processed messages for rate limiting */
  private recentlyProcessedMessages: ProcessedMessageInfo[] = [];
  /** Total bytes processed in current rate limiting window */
  private bytesProcessedInWindow: number = 0;
  /** Messages processed in current rate limiting window */
  private messagesProcessedInWindow: number = 0;
  /** Last message type for detecting duplicates */
  private lastMessageType: string | null = null;
  /** Last message ID for detecting duplicates */
  private lastMessageId: string | null = null;
  /** Message schema validators */
  private schemaValidators: Map<string, (message: MessageData) => boolean> = new Map();
  /** Message deduplication cache */
  private messageDeduplicationCache: Set<string> = new Set();
  /** Deduplication cache maximum size */
  private maxDeduplicationCacheSize: number = 1000;
  /** Deduplication cache expiration time in milliseconds */
  private deduplicationCacheExpiration: number = 60000; // 1 minute
  
  /**
   * Create a new MessageProcessor instance
   * @param options Message processor options
   */
  constructor(options: MessageProcessorOptions) {
    // Merge options with defaults
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
    
    // Initialize message schemas
    if (this.options.schemas) {
      this.initializeSchemaValidators();
    }
    
    // Start periodic cleanup
    this.startPeriodicCleanup();
  }
  
  /**
   * Process an incoming message
   * @param messageData Message data
   */
  public processMessage(messageData: MessageData): void {
    try {
      // Get message size
      const messageSize = this.getMessageSize(messageData);
      
      // Check message size
      if (messageSize > this.options.maxMessageSize!) {
        throw new Error(`Message too large: ${messageSize} bytes (max: ${this.options.maxMessageSize} bytes)`);
      }
      
      // Apply rate limiting
      this.applyRateLimit(messageData, messageSize);
      
      // Validate message
      this.validateMessage(messageData);
      
      // Check for duplicate message
      if (this.isDuplicateMessage(messageData)) {
        logger.debug(`Ignoring duplicate message: ${messageData.id || '<no id>'} (${messageData.type})`);
        return;
      }
      
      // Apply message transformations
      const transformedMessage = this.transformMessage(messageData);
      
      // Track message for deduplication
      this.trackMessageForDeduplication(transformedMessage);
      
      // Update last message info
      this.lastMessageType = transformedMessage.type;
      this.lastMessageId = transformedMessage.id || null;
      
      // Send message to handler
      this.options.onMessage(transformedMessage);
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      logger.error(`Error processing message: ${error.message}`, messageData);
      this.options.onError(error, messageData);
    }
  }
  
  /**
   * Get message size in bytes
   * @param messageData Message data
   * @returns Message size in bytes
   */
  private getMessageSize(messageData: MessageData): number {
    try {
      // Stringify the message and get its length in bytes
      const messageString = JSON.stringify(messageData);
      return new Blob([messageString]).size;
    } catch (err) {
      logger.error(`Failed to calculate message size: ${err instanceof Error ? err.message : String(err)}`);
      return 0; // Return 0 to avoid size check failure
    }
  }
  
  /**
   * Apply rate limiting to message processing
   * @param messageData Message data
   * @param messageSize Message size in bytes
   */
  private applyRateLimit(messageData: MessageData, messageSize: number): void {
    const now = Date.now();
    
    // Remove old messages from the window
    this.recentlyProcessedMessages = this.recentlyProcessedMessages.filter(
      msg => (now - msg.timestamp) < this.rateLimitWindow
    );
    
    // Recalculate current window metrics
    this.messagesProcessedInWindow = this.recentlyProcessedMessages.length;
    this.bytesProcessedInWindow = this.recentlyProcessedMessages.reduce(
      (sum, msg) => sum + msg.size, 0
    );
    
    // Check rate limits for non-critical messages
    const priority = messageData.priority || MessagePriority.NORMAL;
    
    if (
      priority > MessagePriority.CRITICAL &&
      this.messagesProcessedInWindow >= this.options.maxMessagesPerSecond!
    ) {
      throw new Error(`Rate limit exceeded: ${this.messagesProcessedInWindow} messages processed in the last ${this.rateLimitWindow}ms`);
    }
    
    // Add current message to the window
    this.recentlyProcessedMessages.push({
      timestamp: now,
      size: messageSize,
      type: messageData.type,
      id: messageData.id,
      priority: priority
    });
    
    // Update window metrics
    this.messagesProcessedInWindow++;
    this.bytesProcessedInWindow += messageSize;
  }
  
  /**
   * Validate message
   * @param messageData Message data
   */
  private validateMessage(messageData: MessageData): void {
    // Check required fields
    if (!messageData.type) {
      throw new Error('Invalid message: missing type');
    }
    
    // Check message type whitelist
    if (
      this.options.allowedMessageTypes &&
      this.options.allowedMessageTypes.length > 0 &&
      !this.options.allowedMessageTypes.includes(messageData.type)
    ) {
      throw new Error(`Message type not allowed: ${messageData.type}`);
    }
    
    // Check message type blacklist
    if (
      this.options.blockedMessageTypes &&
      this.options.blockedMessageTypes.includes(messageData.type)
    ) {
      throw new Error(`Message type blocked: ${messageData.type}`);
    }
    
    // Apply schema validation if enabled
    if (this.options.validateSchema && this.schemaValidators.has(messageData.type)) {
      const validator = this.schemaValidators.get(messageData.type)!;
      
      if (!validator(messageData)) {
        throw new Error(`Message schema validation failed for type: ${messageData.type}`);
      }
    }
    
    // Apply custom validator if available
    if (this.options.validators && this.options.validators[messageData.type]) {
      const validator = this.options.validators[messageData.type];
      
      if (!validator(messageData)) {
        throw new Error(`Custom validation failed for message type: ${messageData.type}`);
      }
    }
  }
  
  /**
   * Initialize schema validators
   */
  private initializeSchemaValidators(): void {
    // Clear existing validators
    this.schemaValidators.clear();
    
    // Create validators for each schema
    if (this.options.schemas) {
      for (const [type, schema] of Object.entries(this.options.schemas)) {
        this.schemaValidators.set(type, this.createSchemaValidator(schema));
      }
    }
  }
  
  /**
   * Create a schema validator function
   * @param schema Message schema
   * @returns Validator function
   */
  private createSchemaValidator(schema: any): (message: MessageData) => boolean {
    // This is a simple schema validator that checks required fields and types
    // In a real implementation, you might use a library like ajv or joi
    
    return (message: MessageData): boolean => {
      try {
        // Check if schema has required fields
        if (schema.required && Array.isArray(schema.required)) {
          for (const field of schema.required) {
            // Check if field exists in payload
            if (!(field in message.payload)) {
              logger.debug(`Schema validation failed: missing required field '${field}'`);
              return false;
            }
          }
        }
        
        // Check property types if specified
        if (schema.properties) {
          for (const [prop, propSchema] of Object.entries(schema.properties)) {
            // Skip if property doesn't exist in payload
            if (!(prop in message.payload)) {
              continue;
            }
            
            const value = message.payload[prop];
            const propDef = propSchema as { type?: string };
            
            // Check type if specified
            if (propDef.type) {
              let typeValid = false;
              
              switch (propDef.type) {
                case 'string':
                  typeValid = typeof value === 'string';
                  break;
                case 'number':
                case 'integer':
                  typeValid = typeof value === 'number';
                  break;
                case 'boolean':
                  typeValid = typeof value === 'boolean';
                  break;
                case 'array':
                  typeValid = Array.isArray(value);
                  break;
                case 'object':
                  typeValid = typeof value === 'object' && value !== null && !Array.isArray(value);
                  break;
                case 'null':
                  typeValid = value === null;
                  break;
              }
              
              if (!typeValid) {
                logger.debug(`Schema validation failed: property '${prop}' has invalid type`);
                return false;
              }
            }
          }
        }
        
        return true;
      } catch (err) {
        logger.error(`Error in schema validation: ${err instanceof Error ? err.message : String(err)}`);
        return false;
      }
    };
  }
  
  /**
   * Transform message
   * @param messageData Message data
   * @returns Transformed message
   */
  private transformMessage(messageData: MessageData): MessageData {
    let transformedMessage = messageData;
    
    // Apply custom transformer if available
    if (this.options.transformers && this.options.transformers[messageData.type]) {
      const transformer = this.options.transformers[messageData.type];
      
      try {
        transformedMessage = transformer(messageData);
      } catch (err) {
        logger.error(`Error in message transformation: ${err instanceof Error ? err.message : String(err)}`);
      }
    }
    
    return transformedMessage;
  }
  
  /**
   * Check if message is a duplicate
   * @param messageData Message data
   * @returns True if message is a duplicate
   */
  private isDuplicateMessage(messageData: MessageData): boolean {
    // No duplicate check for messages without ID
    if (!messageData.id) {
      return false;
    }
    
    // Check if message is in deduplication cache
    return this.messageDeduplicationCache.has(messageData.id);
  }
  
  /**
   * Track message for deduplication
   * @param messageData Message data
   */
  private trackMessageForDeduplication(messageData: MessageData): void {
    // Skip tracking for messages without ID
    if (!messageData.id) {
      return;
    }
    
    // Add message ID to deduplication cache
    this.messageDeduplicationCache.add(messageData.id);
    
    // Trim cache if it exceeds maximum size
    if (this.messageDeduplicationCache.size > this.maxDeduplicationCacheSize) {
      // Remove oldest entries (since Sets maintain insertion order)
      const entriesToRemove = this.messageDeduplicationCache.size - this.maxDeduplicationCacheSize;
      let removed = 0;
      
      for (const id of this.messageDeduplicationCache) {
        this.messageDeduplicationCache.delete(id);
        removed++;
        
        if (removed >= entriesToRemove) {
          break;
        }
      }
    }
  }
  
  /**
   * Start periodic cleanup
   */
  private startPeriodicCleanup(): void {
    // Periodically clean up rate limiting window and deduplication cache
    setInterval(() => {
      this.cleanup();
    }, 5000); // Clean up every 5 seconds
  }
  
  /**
   * Clean up resources
   */
  private cleanup(): void {
    const now = Date.now();
    
    // Clean up rate limiting window
    this.recentlyProcessedMessages = this.recentlyProcessedMessages.filter(
      msg => (now - msg.timestamp) < this.rateLimitWindow
    );
    
    // Recalculate window metrics
    this.messagesProcessedInWindow = this.recentlyProcessedMessages.length;
    this.bytesProcessedInWindow = this.recentlyProcessedMessages.reduce(
      (sum, msg) => sum + msg.size, 0
    );
    
    // No need to clean up deduplication cache since it's limited by size
    // This would be relevant if we had a time-based expiration mechanism
  }
}


RetryHandler.ts
------------------------------------------------

import { CSLogger } from '../../core/utils/CSLogger';

// Initialize logger
const logger = new CSLogger('RetryHandler');

/**
 * Retry strategy type
 */
export enum RetryStrategy {
  /** Fixed delay between retries */
  FIXED = 'fixed',
  /** Linear increasing delay between retries */
  LINEAR = 'linear',
  /** Exponential increasing delay between retries */
  EXPONENTIAL = 'exponential',
  /** Exponential with jitter (random variation) delay between retries */
  EXPONENTIAL_JITTER = 'exponential_jitter',
  /** Fibonacci sequence delay between retries */
  FIBONACCI = 'fibonacci',
  /** Custom delay function */
  CUSTOM = 'custom'
}

/**
 * Retry handler options
 */
export interface RetryHandlerOptions {
  /** Initial delay in milliseconds */
  initialDelay: number;
  /** Maximum delay in milliseconds */
  maxDelay?: number;
  /** Maximum number of retry attempts */
  maxAttempts: number;
  /** Retry strategy */
  strategy?: RetryStrategy;
  /** Jitter factor for exponential with jitter strategy (0-1) */
  jitterFactor?: number;
  /** Custom delay function for custom strategy */
  customDelayFn?: (attempt: number, initialDelay: number) => number;
  /** Callback function to execute on retry */
  onRetry?: (attempt: number, delay: number) => void;
  /** Callback function to execute when maximum attempts reached */
  onMaxAttemptsReached?: () => void;
  /** Callback function to execute before each retry attempt */
  beforeRetry?: (attempt: number) => boolean | Promise<boolean>;
  /** Retry factor for exponential strategy */
  factor?: number;
  /** Status codes to retry automatically */
  retryStatusCodes?: number[];
  /** Error types to retry automatically */
  retryErrorTypes?: string[];
  /** Whether to reset attempt counter after successful operation */
  resetOnSuccess?: boolean;
}

/**
 * Default retry handler options
 */
const DEFAULT_OPTIONS: RetryHandlerOptions = {
  initialDelay: 1000,
  maxDelay: 30000,
  maxAttempts: 5,
  strategy: RetryStrategy.EXPONENTIAL_JITTER,
  jitterFactor: 0.3,
  factor: 2,
  resetOnSuccess: true
};

/**
 * Retry handler for implementing various retry strategies
 */
export class RetryHandler {
  /** Retry handler options */
  private options: RetryHandlerOptions;
  /** Current retry attempt */
  private currentAttempt: number = 0;
  /** Retry timer handle */
  private retryTimerHandle: number | null = null;
  /** Error from last failed attempt */
  private lastError: Error | null = null;
  
  /**
   * Create a new RetryHandler instance
   * @param options Retry handler options
   */
  constructor(options: RetryHandlerOptions) {
    // Merge options with defaults
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
    
    // Validate options
    this.validateOptions();
  }
  
  /**
   * Execute an operation with retry logic
   * @param operation Operation to execute
   * @returns Promise that resolves with operation result
   */
  public async execute<T>(operation: () => Promise<T>): Promise<T> {
    // Reset attempt counter
    this.reset();
    
    return this.executeWithRetry(operation);
  }
  
  /**
   * Execute an operation with retry logic
   * @param operation Operation to execute
   * @returns Promise that resolves with operation result
   */
  private async executeWithRetry<T>(operation: () => Promise<T>): Promise<T> {
    try {
      // Execute operation
      const result = await operation();
      
      // Reset attempt counter if configured
      if (this.options.resetOnSuccess) {
        this.reset();
      }
      
      return result;
    } catch (err) {
      // Convert error to Error instance
      const error = err instanceof Error ? err : new Error(String(err));
      
      // Store last error
      this.lastError = error;
      
      // Check if error is retryable
      if (!this.isRetryableError(error)) {
        logger.debug(`Non-retryable error: ${error.message}`);
        throw error;
      }
      
      // Increment attempt counter
      this.currentAttempt++;
      
      // Check if maximum attempts reached
      if (this.currentAttempt >= this.options.maxAttempts) {
        logger.debug(`Maximum retry attempts (${this.options.maxAttempts}) reached`);
        
        // Execute max attempts reached callback
        if (this.options.onMaxAttemptsReached) {
          this.options.onMaxAttemptsReached();
        }
        
        throw error;
      }
      
      // Calculate retry delay
      const delay = this.calculateDelay();
      
      logger.debug(`Retry attempt ${this.currentAttempt} of ${this.options.maxAttempts} in ${delay}ms`);
      
      // Execute before retry callback
      if (this.options.beforeRetry) {
        const shouldRetry = await Promise.resolve(this.options.beforeRetry(this.currentAttempt));
        
        if (!shouldRetry) {
          logger.debug('Retry canceled by beforeRetry callback');
          throw error;
        }
      }
      
      // Execute on retry callback
      if (this.options.onRetry) {
        this.options.onRetry(this.currentAttempt, delay);
      }
      
      // Wait for delay
      await this.wait(delay);
      
      // Retry operation
      return this.executeWithRetry(operation);
    }
  }
  
  /**
   * Retry the last failed operation
   */
  public retry(): void {
    // Clear any existing retry timer
    this.clearRetryTimer();
    
    // Increment attempt counter
    this.currentAttempt++;
    
    // Check if maximum attempts reached
    if (this.currentAttempt >= this.options.maxAttempts) {
      logger.debug(`Maximum retry attempts (${this.options.maxAttempts}) reached`);
      
      // Execute max attempts reached callback
      if (this.options.onMaxAttemptsReached) {
        this.options.onMaxAttemptsReached();
      }
      
      return;
    }
    
    // Calculate retry delay
    const delay = this.calculateDelay();
    
    logger.debug(`Retry attempt ${this.currentAttempt} of ${this.options.maxAttempts} in ${delay}ms`);
    
    // Execute on retry callback
    if (this.options.onRetry) {
      this.options.onRetry(this.currentAttempt, delay);
    }
    
    // Set retry timer
    this.retryTimerHandle = window.setTimeout(() => {
      this.retryTimerHandle = null;
    }, delay);
  }
  
  /**
   * Reset retry state
   */
  public reset(): void {
    // Clear any existing retry timer
    this.clearRetryTimer();
    
    // Reset state
    this.currentAttempt = 0;
    this.lastError = null;
  }
  
  /**
   * Get current retry attempt
   * @returns Current retry attempt
   */
  public getCurrentAttempt(): number {
    return this.currentAttempt;
  }
  
  /**
   * Get last error
   * @returns Last error or null if no error
   */
  public getLastError(): Error | null {
    return this.lastError;
  }
  
  /**
   * Check if operation has reached maximum retry attempts
   * @returns True if maximum retry attempts reached
   */
  public hasReachedMaxAttempts(): boolean {
    return this.currentAttempt >= this.options.maxAttempts;
  }
  
  /**
   * Get remaining retry attempts
   * @returns Number of remaining retry attempts
   */
  public getRemainingAttempts(): number {
    return Math.max(0, this.options.maxAttempts - this.currentAttempt);
  }
  
  /**
   * Calculate next retry delay
   * @returns Delay in milliseconds
   */
  private calculateDelay(): number {
    const { initialDelay, maxDelay, strategy, factor, jitterFactor, customDelayFn } = this.options;
    let delay: number;
    
    switch (strategy) {
      case RetryStrategy.FIXED:
        delay = initialDelay;
        break;
        
      case RetryStrategy.LINEAR:
        delay = initialDelay * this.currentAttempt;
        break;
        
      case RetryStrategy.EXPONENTIAL:
        delay = initialDelay * Math.pow(factor!, this.currentAttempt - 1);
        break;
        
      case RetryStrategy.EXPONENTIAL_JITTER:
        // Calculate base exponential delay
        const baseDelay = initialDelay * Math.pow(factor!, this.currentAttempt - 1);
        
        // Apply jitter
        const jitter = baseDelay * jitterFactor!;
        delay = baseDelay - jitter + (Math.random() * jitter * 2);
        break;
        
      case RetryStrategy.FIBONACCI:
        delay = this.calculateFibonacciDelay(initialDelay, this.currentAttempt);
        break;
        
      case RetryStrategy.CUSTOM:
        if (!customDelayFn) {
          logger.warn('Custom delay function not provided, using exponential with jitter');
          const baseDelay = initialDelay * Math.pow(2, this.currentAttempt - 1);
          const jitter = baseDelay * 0.3;
          delay = baseDelay - jitter + (Math.random() * jitter * 2);
        } else {
          delay = customDelayFn(this.currentAttempt, initialDelay);
        }
        break;
        
      default:
        // Default to exponential with jitter
        const defaultBaseDelay = initialDelay * Math.pow(2, this.currentAttempt - 1);
        const defaultJitter = defaultBaseDelay * 0.3;
        delay = defaultBaseDelay - defaultJitter + (Math.random() * defaultJitter * 2);
    }
    
    // Apply maximum delay
    return Math.min(delay, maxDelay!);
  }
  
  /**
   * Calculate Fibonacci delay
   * @param initialDelay Initial delay
   * @param attempt Retry attempt
   * @returns Fibonacci delay
   */
  private calculateFibonacciDelay(initialDelay: number, attempt: number): number {
    if (attempt <= 0) {
      return 0;
    }
    
    if (attempt === 1) {
      return initialDelay;
    }
    
    let prev = 0;
    let current = 1;
    
    for (let i = 2; i <= attempt; i++) {
      const next = prev + current;
      prev = current;
      current = next;
    }
    
    return initialDelay * current;
  }
  
  /**
   * Check if error is retryable
   * @param error Error to check
   * @returns True if error is retryable
   */
  private isRetryableError(error: Error): boolean {
    // Check retry status codes
    if (this.options.retryStatusCodes && 'status' in error) {
      const status = (error as any).status;
      
      if (typeof status === 'number' && this.options.retryStatusCodes.includes(status)) {
        return true;
      }
    }
    
    // Check retry error types
    if (this.options.retryErrorTypes) {
      const errorType = error.constructor.name;
      
      if (this.options.retryErrorTypes.includes(errorType)) {
        return true;
      }
    }
    
    // Default to retryable
    return true;
  }
  
  /**
   * Wait for specified delay
   * @param delay Delay in milliseconds
   * @returns Promise that resolves after delay
   */
  private wait(delay: number): Promise<void> {
    return new Promise(resolve => {
      setTimeout(resolve, delay);
    });
  }
  
  /**
   * Clear retry timer
   */
  private clearRetryTimer(): void {
    if (this.retryTimerHandle !== null) {
      window.clearTimeout(this.retryTimerHandle);
      this.retryTimerHandle = null;
    }
  }
  
  /**
   * Validate retry handler options
   */
  private validateOptions(): void {
    const { initialDelay, maxDelay, maxAttempts, strategy, customDelayFn } = this.options;
    
    // Check initial delay
    if (initialDelay <= 0) {
      throw new Error('Initial delay must be greater than 0');
    }
    
    // Check maximum delay
    if (maxDelay !== undefined && maxDelay < initialDelay) {
      throw new Error('Maximum delay must be greater than or equal to initial delay');
    }
    
    // Check maximum attempts
    if (maxAttempts <= 0) {
      throw new Error('Maximum attempts must be greater than 0');
    }
    
    // Check custom delay function
    if (strategy === RetryStrategy.CUSTOM && !customDelayFn) {
      throw new Error('Custom delay function must be provided for custom retry strategy');
    }
  }
}


EventDispatcher.ts
-----------------------------------------------------

import { CSLogger } from '../../core/utils/CSLogger';

// Initialize logger
const logger = new CSLogger('EventDispatcher');

/**
 * Event listener function type
 */
export type EventListener = (data: any) => void;

/**
 * Event listener registration
 */
interface EventListenerRegistration {
  /** Unique listener ID */
  id: string;
  /** Event name */
  event: string;
  /** Listener function */
  listener: EventListener;
  /** Whether this is a once listener */
  once: boolean;
}

/**
 * Event dispatcher options
 */
export interface EventDispatcherOptions {
  /** Maximum number of listeners per event (default: 100) */
  maxListenersPerEvent?: number;
  /** Maximum number of events (default: 100) */
  maxEvents?: number;
  /** Whether to log all events (default: false) */
  logEvents?: boolean;
  /** Events to always log even if logEvents is false */
  logEventNames?: string[];
  /** Events to never log even if logEvents is true */
  ignoreEventNames?: string[];
  /** Whether to capture event history (default: false) */
  captureHistory?: boolean;
  /** Maximum event history size (default: 100) */
  maxHistorySize?: number;
}

/**
 * Event history entry
 */
interface EventHistoryEntry {
  /** Event name */
  event: string;
  /** Event data */
  data: any;
  /** Timestamp when event was dispatched */
  timestamp: number;
}

/**
 * Default event dispatcher options
 */
const DEFAULT_OPTIONS: EventDispatcherOptions = {
  maxListenersPerEvent: 100,
  maxEvents: 100,
  logEvents: false,
  captureHistory: false,
  maxHistorySize: 100
};

/**
 * Event dispatcher for managing event listeners and dispatching events
 */
export class EventDispatcher {
  /** Event dispatcher options */
  private options: EventDispatcherOptions;
  /** Event listeners mapped by listener ID */
  private listeners: Map<string, EventListenerRegistration> = new Map();
  /** Event listeners grouped by event name */
  private events: Map<string, Set<string>> = new Map();
  /** Event history */
  private eventHistory: EventHistoryEntry[] = [];
  /** Event counter for generating listener IDs */
  private eventCounter: number = 0;
  
  /**
   * Create a new EventDispatcher instance
   * @param options Event dispatcher options
   */
  constructor(options: EventDispatcherOptions = {}) {
    // Merge options with defaults
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
  }
  
  /**
   * Add event listener
   * @param event Event name
   * @param listener Event listener function
   * @returns Listener ID
   */
  public on(event: string, listener: EventListener): string {
    // Check if event exists
    if (!this.events.has(event)) {
      // Check if maximum events reached
      if (this.events.size >= this.options.maxEvents!) {
        throw new Error(`Maximum events reached: ${this.options.maxEvents}`);
      }
      
      // Create new event
      this.events.set(event, new Set());
    }
    
    // Check if maximum listeners reached
    const eventListeners = this.events.get(event)!;
    if (eventListeners.size >= this.options.maxListenersPerEvent!) {
      throw new Error(`Maximum listeners reached for event '${event}': ${this.options.maxListenersPerEvent}`);
    }
    
    // Generate listener ID
    const id = this.generateListenerId();
    
    // Register listener
    this.listeners.set(id, {
      id,
      event,
      listener,
      once: false
    });
    
    // Add listener ID to event
    eventListeners.add(id);
    
    return id;
  }
  
  /**
   * Add one-time event listener
   * @param event Event name
   * @param listener Event listener function
   * @returns Listener ID
   */
  public once(event: string, listener: EventListener): string {
    // Check if event exists
    if (!this.events.has(event)) {
      // Check if maximum events reached
      if (this.events.size >= this.options.maxEvents!) {
        throw new Error(`Maximum events reached: ${this.options.maxEvents}`);
      }
      
      // Create new event
      this.events.set(event, new Set());
    }
    
    // Check if maximum listeners reached
    const eventListeners = this.events.get(event)!;
    if (eventListeners.size >= this.options.maxListenersPerEvent!) {
      throw new Error(`Maximum listeners reached for event '${event}': ${this.options.maxListenersPerEvent}`);
    }
    
    // Generate listener ID
    const id = this.generateListenerId();
    
    // Register listener
    this.listeners.set(id, {
      id,
      event,
      listener,
      once: true
    });
    
    // Add listener ID to event
    eventListeners.add(id);
    
    return id;
  }
  
  /**
   * Remove event listener
   * @param id Listener ID
   * @returns True if listener was removed, false if not found
   */
  public off(id: string): boolean {
    // Check if listener exists
    if (!this.listeners.has(id)) {
      return false;
    }
    
    // Get listener registration
    const registration = this.listeners.get(id)!;
    
    // Remove listener ID from event
    const eventListeners = this.events.get(registration.event);
    if (eventListeners) {
      eventListeners.delete(id);
      
      // Remove event if no listeners
      if (eventListeners.size === 0) {
        this.events.delete(registration.event);
      }
    }
    
    // Remove listener registration
    this.listeners.delete(id);
    
    return true;
  }
  
  /**
   * Remove all listeners for an event
   * @param event Event name
   * @returns Number of listeners removed
   */
  public removeAllListeners(event: string): number {
    // Check if event exists
    if (!this.events.has(event)) {
      return 0;
    }
    
    // Get listener IDs for event
    const listenerIds = Array.from(this.events.get(event)!);
    
    // Remove listeners
    let removedCount = 0;
    for (const id of listenerIds) {
      if (this.off(id)) {
        removedCount++;
      }
    }
    
    return removedCount;
  }
  
  /**
   * Dispatch an event
   * @param event Event name
   * @param data Event data
   * @returns Number of listeners notified
   */
  public dispatch(event: string, data: any = null): number {
    // Check if event should be logged
    if (this.shouldLogEvent(event)) {
      logger.debug(`Dispatching event: ${event}`, data);
    }
    
    // Capture event history
    if (this.options.captureHistory) {
      this.addToEventHistory(event, data);
    }
    
    // Check if event has listeners
    if (!this.events.has(event)) {
      return 0;
    }
    
    // Get listener IDs for event
    const listenerIds = Array.from(this.events.get(event)!);
    
    // Track listeners to remove (once listeners)
    const listenersToRemove: string[] = [];
    
    // Notify listeners
    let notifiedCount = 0;
    for (const id of listenerIds) {
      // Get listener registration
      const registration = this.listeners.get(id);
      
      if (registration) {
        try {
          // Call listener
          registration.listener(data);
          notifiedCount++;
          
          // Track once listeners for removal
          if (registration.once) {
            listenersToRemove.push(id);
          }
        } catch (err) {
          logger.error(`Error in event listener for event '${event}': ${err instanceof Error ? err.message : String(err)}`);
        }
      }
    }
    
    // Remove once listeners
    for (const id of listenersToRemove) {
      this.off(id);
    }
    
    return notifiedCount;
  }
  
  /**
   * Get event names
   * @returns Array of event names
   */
  public getEventNames(): string[] {
    return Array.from(this.events.keys());
  }
  
  /**
   * Get listener count for an event
   * @param event Event name
   * @returns Number of listeners
   */
  public getListenerCount(event: string): number {
    // Check if event exists
    if (!this.events.has(event)) {
      return 0;
    }
    
    return this.events.get(event)!.size;
  }
  
  /**
   * Get total listener count
   * @returns Total number of listeners
   */
  public getTotalListenerCount(): number {
    return this.listeners.size;
  }
  
  /**
   * Get event history
   * @returns Array of event history entries
   */
  public getEventHistory(): EventHistoryEntry[] {
    if (!this.options.captureHistory) {
      return [];
    }
    
    return [...this.eventHistory];
  }
  
  /**
   * Clear event history
   */
  public clearEventHistory(): void {
    this.eventHistory = [];
  }
  
  /**
   * Check if event has listeners
   * @param event Event name
   * @returns True if event has listeners
   */
  public hasListeners(event: string): boolean {
    return this.events.has(event) && this.events.get(event)!.size > 0;
  }
  
  /**
   * Wait for an event to be dispatched
   * @param event Event name
   * @param timeout Timeout in milliseconds (default: 30000, 0 for no timeout)
   * @returns Promise that resolves with event data
   */
  public waitForEvent(event: string, timeout: number = 30000): Promise<any> {
    return new Promise((resolve, reject) => {
      // Set up timeout
      let timeoutId: number | null = null;
      
      if (timeout > 0) {
        timeoutId = window.setTimeout(() => {
          // Clean up event listener
          if (listenerId) {
            this.off(listenerId);
          }
          
          reject(new Error(`Timeout waiting for event '${event}'`));
        }, timeout);
      }
      
      // Set up event listener
      const listenerId = this.once(event, (data) => {
        // Clear timeout
        if (timeoutId !== null) {
          window.clearTimeout(timeoutId);
        }
        
        resolve(data);
      });
    });
  }
  
  /**
   * Add an event to the history
   * @param event Event name
   * @param data Event data
   */
  private addToEventHistory(event: string, data: any): void {
    // Add event to history
    this.eventHistory.push({
      event,
      data,
      timestamp: Date.now()
    });
    
    // Trim history if needed
    if (this.eventHistory.length > this.options.maxHistorySize!) {
      this.eventHistory = this.eventHistory.slice(-this.options.maxHistorySize!);
    }
  }
  
  /**
   * Check if event should be logged
   * @param event Event name
   * @returns True if event should be logged
   */
  private shouldLogEvent(event: string): boolean {
    // Check if event is explicitly ignored
    if (this.options.ignoreEventNames && this.options.ignoreEventNames.includes(event)) {
      return false;
    }
    
    // Check if event is explicitly logged
    if (this.options.logEventNames && this.options.logEventNames.includes(event)) {
      return true;
    }
    
    // Check global log setting
    return this.options.logEvents === true;
  }
  
  /**
   * Generate a unique listener ID
   * @returns Unique listener ID
   */
  private generateListenerId(): string {
    this.eventCounter++;
    return `listener_${Date.now()}_${this.eventCounter}_${Math.random().toString(36).substring(2, 10)}`;
  }
  
  /**
   * Destroy the event dispatcher
   */
  public destroy(): void {
    // Remove all listeners
    this.listeners.clear();
    this.events.clear();
    
    // Clear event history
    this.eventHistory = [];
  }
}



Serializer.ts
---------------------------------------

import { CSLogger } from '../../core/utils/CSLogger';
import { CSEncryptionUtils } from '../../core/utils/CSEncryptionUtils';
import { MessageData } from './WebSocketClient';

// Initialize logger
const logger = new CSLogger('Serializer');

/**
 * Serializer options
 */
export interface SerializerOptions {
  /** Enable message encryption */
  encrypt?: boolean;
  /** Custom encryption key */
  encryptionKey?: string;
  /** Maximum message size in bytes (default: 1MB) */
  maxMessageSize?: number;
  /** Custom serialization format (default: JSON) */
  format?: 'json' | 'cbor' | 'msgpack';
  /** Compress messages over this size (default: 10KB, 0 to disable) */
  compressThreshold?: number;
  /** Enable binary serialization (default: false) */
  enableBinary?: boolean;
  /** Custom serializer function */
  customSerializer?: (data: any) => string | ArrayBuffer;
  /** Custom deserializer function */
  customDeserializer?: (data: string | ArrayBuffer) => any;
}

/**
 * Default serializer options
 */
const DEFAULT_OPTIONS: SerializerOptions = {
  encrypt: false,
  maxMessageSize: 1024 * 1024, // 1MB
  format: 'json',
  compressThreshold: 10 * 1024, // 10KB
  enableBinary: false
};

/**
 * Message serializer for WebSocket communications
 */
export class Serializer {
  /** Serializer options */
  private options: SerializerOptions;
  /** Text encoder for string to binary conversion */
  private encoder: TextEncoder;
  /** Text decoder for binary to string conversion */
  private decoder: TextDecoder;
  
  /**
   * Create a new Serializer instance
   * @param options Serializer options
   */
  constructor(options: SerializerOptions = {}) {
    // Merge options with defaults
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
    
    // Initialize encoder and decoder
    this.encoder = new TextEncoder();
    this.decoder = new TextDecoder();
  }
  
  /**
   * Serialize a message to string
   * @param message Message to serialize
   * @returns Serialized message
   */
  public serialize(message: MessageData): string {
    try {
      // Convert message to JSON
      const jsonString = JSON.stringify(message);
      
      // Check message size
      const messageSize = new Blob([jsonString]).size;
      if (messageSize > this.options.maxMessageSize!) {
        throw new Error(`Message too large: ${messageSize} bytes (max: ${this.options.maxMessageSize} bytes)`);
      }
      
      // Compress message if needed
      let processedMessage = jsonString;
      let isCompressed = false;
      
      if (this.options.compressThreshold! > 0 && messageSize > this.options.compressThreshold!) {
        // In a real implementation, we would compress the message here
        // For this example, we'll just add a compressed flag
        isCompressed = true;
      }
      
      // Encrypt message if enabled
      if (this.options.encrypt) {
        // Encrypt the message
        processedMessage = CSEncryptionUtils.encryptData(processedMessage, this.options.encryptionKey);
      }
      
      // Add metadata wrapper
      const wrappedMessage = {
        payload: processedMessage,
        meta: {
          compressed: isCompressed,
          encrypted: this.options.encrypt,
          format: this.options.format,
          timestamp: Date.now()
        }
      };
      
      return JSON.stringify(wrappedMessage);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to serialize message: ${errorMessage}`);
      throw new Error(`Serialization failed: ${errorMessage}`);
    }
  }
  
  /**
   * Deserialize a message from string
   * @param data Serialized message
   * @returns Deserialized message
   */
  public deserialize(data: string): MessageData {
    try {
      // Parse the wrapped message
      const wrappedMessage = JSON.parse(data);
      let payload = wrappedMessage.payload;
      const meta = wrappedMessage.meta;
      
      // Check if message is encrypted
      if (meta && meta.encrypted) {
        // Decrypt the message
        payload = CSEncryptionUtils.decryptData(payload, this.options.encryptionKey);
      }
      
      // Check if message is compressed
      if (meta && meta.compressed) {
        // In a real implementation, we would decompress the message here
        // For this example, we assume it's already decompressed
      }
      
      // Parse the message payload
      return JSON.parse(payload);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to deserialize message: ${errorMessage}`);
      throw new Error(`Deserialization failed: ${errorMessage}`);
    }
  }
  
  /**
   * Serialize a message to binary
   * @param message Message to serialize
   * @returns Serialized message as ArrayBuffer
   */
  public serializeBinary(message: MessageData): ArrayBuffer {
    try {
      if (!this.options.enableBinary) {
        // Fall back to string serialization and convert to ArrayBuffer
        const serialized = this.serialize(message);
        return this.encoder.encode(serialized).buffer;
      }
      
      // Custom binary serialization would go here
      // For this example, we'll just convert the JSON to an ArrayBuffer
      
      // Serialize message to JSON
      const jsonString = JSON.stringify(message);
      
      // Check message size
      const messageSize = new Blob([jsonString]).size;
      if (messageSize > this.options.maxMessageSize!) {
        throw new Error(`Message too large: ${messageSize} bytes (max: ${this.options.maxMessageSize} bytes)`);
      }
      
      // Compress if needed
      let processedMessage = jsonString;
      const isCompressed = false;
      
      // Encrypt if enabled
      if (this.options.encrypt) {
        processedMessage = CSEncryptionUtils.encryptData(processedMessage, this.options.encryptionKey);
      }
      
      // Create metadata header (16 bytes)
      const headerBuffer = new ArrayBuffer(16);
      const headerView = new DataView(headerBuffer);
      
      // Set header values
      headerView.setUint32(0, 0x434D5347); // Magic number 'CMSG'
      headerView.setUint8(4, this.options.format === 'json' ? 1 : this.options.format === 'cbor' ? 2 : 3); // Format
      headerView.setUint8(5, isCompressed ? 1 : 0); // Compression flag
      headerView.setUint8(6, this.options.encrypt ? 1 : 0); // Encryption flag
      headerView.setUint8(7, 0); // Reserved
      headerView.setUint32(8, Date.now() / 1000); // Timestamp (seconds)
      headerView.setUint32(12, this.encoder.encode(processedMessage).length); // Payload length
      
      // Combine header and payload
      const messageBuffer = this.encoder.encode(processedMessage).buffer;
      const combinedBuffer = new ArrayBuffer(headerBuffer.byteLength + messageBuffer.byteLength);
      
      new Uint8Array(combinedBuffer).set(new Uint8Array(headerBuffer), 0);
      new Uint8Array(combinedBuffer).set(new Uint8Array(messageBuffer), headerBuffer.byteLength);
      
      return combinedBuffer;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to serialize message to binary: ${errorMessage}`);
      throw new Error(`Binary serialization failed: ${errorMessage}`);
    }
  }
  
  /**
   * Deserialize a message from binary
   * @param data Serialized message as ArrayBuffer
   * @returns Deserialized message
   */
  public deserializeBinary(data: ArrayBuffer): MessageData {
    try {
      if (!this.options.enableBinary) {
        // Fall back to string deserialization
        const dataString = this.decoder.decode(data);
        return this.deserialize(dataString);
      }
      
      // Custom binary deserialization would go here
      // For this example, we'll just convert the ArrayBuffer to a JSON string
      
      // Check if data has the correct header
      if (data.byteLength < 16) {
        throw new Error('Invalid binary message: too short');
      }
      
      const headerView = new DataView(data, 0, 16);
      
      // Check magic number
      const magicNumber = headerView.getUint32(0);
      if (magicNumber !== 0x434D5347) { // 'CMSG'
        // Not a valid message header, try to deserialize as string
        return this.deserialize(this.decoder.decode(data));
      }
      
      // Get header values
      const format = headerView.getUint8(4);
      const isCompressed = headerView.getUint8(5) === 1;
      const isEncrypted = headerView.getUint8(6) === 1;
      const timestamp = headerView.getUint32(8) * 1000; // Convert to milliseconds
      const payloadLength = headerView.getUint32(12);
      
      // Extract payload
      const payloadBuffer = data.slice(16);
      let payload = this.decoder.decode(payloadBuffer);
      
      // Decrypt if encrypted
      if (isEncrypted) {
        payload = CSEncryptionUtils.decryptData(payload, this.options.encryptionKey);
      }
      
      // Decompress if compressed
      if (isCompressed) {
        // In a real implementation, we would decompress the payload here
        // For this example, we assume it's already decompressed
      }
      
      // Parse payload based on format
      if (format === 1) {
        // JSON format
        return JSON.parse(payload);
      } else {
        // Unsupported format, fall back to JSON
        return JSON.parse(payload);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err);
      logger.error(`Failed to deserialize binary message: ${errorMessage}`);
      throw new Error(`Binary deserialization failed: ${errorMessage}`);
    }
  }
  
  /**
   * Set serializer options
   * @param options Options to set
   */
  public setOptions(options: Partial<SerializerOptions>): void {
    this.options = {
      ...this.options,
      ...options
    };
  }
  
  /**
   * Get current serializer options
   * @returns Current options
   */
  public getOptions(): SerializerOptions {
    return { ...this.options };
  }
  
  /**
   * Calculate size of a message in bytes
   * @param message Message to calculate size for
   * @returns Size in bytes
   */
  public calculateMessageSize(message: MessageData): number {
    try {
      const jsonString = JSON.stringify(message);
      return new Blob([jsonString]).size;
    } catch (err) {
      return 0;
    }
  }
  
  /**
   * Check if a message exceeds the maximum size
   * @param message Message to check
   * @returns True if message is too large
   */
  public isMessageTooLarge(message: MessageData): boolean {
    const size = this.calculateMessageSize(message);
    return size > this.options.maxMessageSize!;
  }
}


ConnectionManager.ts
--------------------------------------------

import { CSLogger } from '../../core/utils/CSLogger';
import { WebSocketClient, ConnectionState, AuthMethod } from './WebSocketClient';
import { EventDispatcher } from './EventDispatcher';

// Initialize logger
const logger = new CSLogger('ConnectionManager');

/**
 * Connection configuration
 */
export interface ConnectionConfig {
  /** Connection URL */
  url: string;
  /** Connection name/description */
  name?: string;
  /** Auth token */
  authToken?: string;
  /** Auto connect on initialization */
  autoConnect?: boolean;
  /** Maximum reconnect attempts */
  maxReconnectAttempts?: number;
  /** Authentication method */
  authMethod?: AuthMethod;
  /** Username for credentials authentication */
  username?: string;
  /** Password for credentials authentication */
  password?: string;
  /** API key for API key authentication */
  apiKey?: string;
  /** Whether to use secure connection (wss://) */
  secure?: boolean;
  /** Connection timeout in milliseconds */
  connectionTimeout?: number;
  /** Keep alive interval in milliseconds */
  keepAliveInterval?: number;
  /** Enable message encryption */
  encryptMessages?: boolean;
  /** Custom encryption key */
  encryptionKey?: string;
  /** Whether to validate message schemas */
  validateMessages?: boolean;
  /** Additional WebSocket protocols */
  protocols?: string[];
  /** Custom connection headers */
  headers?: Record<string, string>;
}

/**
 * Connection manager options
 */
export interface ConnectionManagerOptions {
  /** Default connection configuration */
  defaultConfig?: ConnectionConfig;
  /** Default connection ID */
  defaultConnectionId?: string;
  /** Auto connect all connections on initialization */
  autoConnectAll?: boolean;
  /** Maximum number of connections (default: 10) */
  maxConnections?: number;
  /** Whether to use persistent storage for connections (default: true) */
  usePersistentStorage?: boolean;
  /** Debug mode (default: false) */
  debug?: boolean;
}

/**
 * Default connection manager options
 */
const DEFAULT_OPTIONS: ConnectionManagerOptions = {
  defaultConnectionId: 'default',
  autoConnectAll: false,
  maxConnections: 10,
  usePersistentStorage: true,
  debug: false
};

/**
 * Storage key for saving connections
 */
const STORAGE_KEY = 'cstestforge_websocket_connections';

/**
 * Connection manager for managing multiple WebSocket connections
 */
export class ConnectionManager {
  /** Connection manager options */
  private options: ConnectionManagerOptions;
  /** Event dispatcher */
  private eventDispatcher: EventDispatcher;
  /** WebSocket connections mapped by ID */
  private connections: Map<string, WebSocketClient> = new Map();
  /** Connection configurations mapped by ID */
  private connectionConfigs: Map<string, ConnectionConfig> = new Map();
  /** Default connection ID */
  private defaultConnectionId: string;
  /** Currently active connection ID */
  private activeConnectionId: string | null = null;
  
  /**
   * Create a new ConnectionManager instance
   * @param options Connection manager options
   */
  constructor(options: ConnectionManagerOptions = {}) {
    // Merge options with defaults
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
    
    // Set default connection ID
    this.defaultConnectionId = this.options.defaultConnectionId!;
    
    // Create event dispatcher
    this.eventDispatcher = new EventDispatcher();
    
    // Load connections from storage
    if (this.options.usePersistentStorage) {
      this.loadConnectionsFromStorage();
    }
    
    // Create default connection if provided
    if (this.options.defaultConfig) {
      this.createConnection(this.defaultConnectionId, this.options.defaultConfig);
      
      // Set as active connection
      this.activeConnectionId = this.defaultConnectionId;
    }
    
    // Auto connect all connections if enabled
    if (this.options.autoConnectAll) {
      this.connectAll();
    }
  }
  
  /**
   * Create a new WebSocket connection
   * @param connectionId Connection ID
   * @param config Connection configuration
   * @returns Created WebSocket client
   */
  public createConnection(connectionId: string, config: ConnectionConfig): WebSocketClient {
    // Check if connection already exists
    if (this.connections.has(connectionId)) {
      throw new Error(`Connection with ID '${connectionId}' already exists`);
    }
    
    // Check if maximum connections reached
    if (this.connections.size >= this.options.maxConnections!) {
      throw new Error(`Maximum connections reached: ${this.options.maxConnections}`);
    }
    
    logger.info(`Creating connection: ${connectionId}`);
    
    // Create WebSocket client
    const client = new WebSocketClient({
      url: config.url,
      autoConnect: config.autoConnect !== undefined ? config.autoConnect : false,
      autoReconnect: true,
      reconnectDelay: 5000,
      maxReconnectAttempts: config.maxReconnectAttempts || 10,
      authMethod: config.authMethod || AuthMethod.NONE,
      authToken: config.authToken,
      username: config.username,
      password: config.password,
      apiKey: config.apiKey,
      secure: config.secure !== undefined ? config.secure : true,
      connectionTimeout: config.connectionTimeout || 30000,
      keepAliveInterval: config.keepAliveInterval || 30000,
      encryptMessages: config.encryptMessages || false,
      encryptionKey: config.encryptionKey,
      protocols: config.protocols,
      headers: config.headers,
      clientId: connectionId,
      clientName: config.name || connectionId,
      debug: this.options.debug
    });
    
    // Store connection and configuration
    this.connections.set(connectionId, client);
    this.connectionConfigs.set(connectionId, config);
    
    // Set up event listeners
    this.setupEventListeners(client, connectionId);
    
    // Save connections to storage
    if (this.options.usePersistentStorage) {
      this.saveConnectionsToStorage();
    }
    
    // Dispatch connection created event
    this.eventDispatcher.dispatch('connection_created', {
      connectionId,
      config
    });
    
    // If this is the first connection, set as active
    if (this.activeConnectionId === null) {
      this.activeConnectionId = connectionId;
    }
    
    return client;
  }
  
  /**
   * Get a WebSocket connection by ID
   * @param connectionId Connection ID (default: active connection)
   * @returns WebSocket client
   */
  public getConnection(connectionId?: string): WebSocketClient {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connections.has(id)) {
      throw new Error(`Connection with ID '${id}' not found`);
    }
    
    return this.connections.get(id)!;
  }
  
  /**
   * Check if a connection exists
   * @param connectionId Connection ID
   * @returns True if connection exists
   */
  public hasConnection(connectionId: string): boolean {
    return this.connections.has(connectionId);
  }
  
  /**
   * Remove a WebSocket connection
   * @param connectionId Connection ID
   * @returns True if connection was removed
   */
  public removeConnection(connectionId: string): boolean {
    // Check if connection exists
    if (!this.connections.has(connectionId)) {
      return false;
    }
    
    logger.info(`Removing connection: ${connectionId}`);
    
    // Get connection
    const connection = this.connections.get(connectionId)!;
    
    // Disconnect connection
    if (connection.isConnected()) {
      connection.disconnect();
    }
    
    // Remove connection
    this.connections.delete(connectionId);
    this.connectionConfigs.delete(connectionId);
    
    // If this was the active connection, set active to null
    if (this.activeConnectionId === connectionId) {
      this.activeConnectionId = null;
    }
    
    // Save connections to storage
    if (this.options.usePersistentStorage) {
      this.saveConnectionsToStorage();
    }
    
    // Dispatch connection removed event
    this.eventDispatcher.dispatch('connection_removed', {
      connectionId
    });
    
    return true;
  }
  
  /**
   * Connect a WebSocket connection
   * @param connectionId Connection ID (default: active connection)
   * @returns Promise that resolves when connected
   */
  public async connect(connectionId?: string): Promise<void> {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connections.has(id)) {
      throw new Error(`Connection with ID '${id}' not found`);
    }
    
    logger.info(`Connecting: ${id}`);
    
    // Get connection
    const connection = this.connections.get(id)!;
    
    // Connect
    return connection.connect();
  }
  
  /**
   * Disconnect a WebSocket connection
   * @param connectionId Connection ID (default: active connection)
   */
  public disconnect(connectionId?: string): void {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connections.has(id)) {
      throw new Error(`Connection with ID '${id}' not found`);
    }
    
    logger.info(`Disconnecting: ${id}`);
    
    // Get connection
    const connection = this.connections.get(id)!;
    
    // Disconnect
    connection.disconnect();
  }
  
  /**
   * Connect all WebSocket connections
   */
  public async connectAll(): Promise<void> {
    logger.info('Connecting all connections');
    
    // Connect each connection
    const connectionPromises: Promise<void>[] = [];
    
    for (const [id, connection] of this.connections.entries()) {
      try {
        connectionPromises.push(connection.connect());
      } catch (err) {
        logger.error(`Failed to connect '${id}': ${err instanceof Error ? err.message : String(err)}`);
      }
    }
    
    // Wait for all connections to connect
    await Promise.all(connectionPromises);
  }
  
  /**
   * Disconnect all WebSocket connections
   */
  public disconnectAll(): void {
    logger.info('Disconnecting all connections');
    
    // Disconnect each connection
    for (const [id, connection] of this.connections.entries()) {
      try {
        connection.disconnect();
      } catch (err) {
        logger.error(`Failed to disconnect '${id}': ${err instanceof Error ? err.message : String(err)}`);
      }
    }
  }
  
  /**
   * Set active connection
   * @param connectionId Connection ID
   */
  public setActiveConnection(connectionId: string): void {
    // Check if connection exists
    if (!this.connections.has(connectionId)) {
      throw new Error(`Connection with ID '${connectionId}' not found`);
    }
    
    logger.info(`Setting active connection: ${connectionId}`);
    
    // Set active connection
    this.activeConnectionId = connectionId;
    
    // Dispatch active connection changed event
    this.eventDispatcher.dispatch('active_connection_changed', {
      connectionId
    });
  }
  
  /**
   * Get active connection ID
   * @returns Active connection ID
   */
  public getActiveConnectionId(): string | null {
    return this.activeConnectionId;
  }
  
  /**
   * Get all connection IDs
   * @returns Array of connection IDs
   */
  public getConnectionIds(): string[] {
    return Array.from(this.connections.keys());
  }
  
  /**
   * Get connection configuration
   * @param connectionId Connection ID (default: active connection)
   * @returns Connection configuration
   */
  public getConnectionConfig(connectionId?: string): ConnectionConfig {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connectionConfigs.has(id)) {
      throw new Error(`Connection with ID '${id}' not found`);
    }
    
    return { ...this.connectionConfigs.get(id)! };
  }
  
  /**
   * Update connection configuration
   * @param connectionId Connection ID
   * @param config Connection configuration
   * @param reconnect Whether to reconnect after updating
   */
  public updateConnectionConfig(
    connectionId: string,
    config: Partial<ConnectionConfig>,
    reconnect: boolean = false
  ): void {
    // Check if connection exists
    if (!this.connections.has(connectionId)) {
      throw new Error(`Connection with ID '${connectionId}' not found`);
    }
    
    logger.info(`Updating connection config: ${connectionId}`);
    
    // Get current configuration
    const currentConfig = this.connectionConfigs.get(connectionId)!;
    
    // Merge configurations
    const newConfig = {
      ...currentConfig,
      ...config
    };
    
    // Update configuration
    this.connectionConfigs.set(connectionId, newConfig);
    
    // Save connections to storage
    if (this.options.usePersistentStorage) {
      this.saveConnectionsToStorage();
    }
    
    // Dispatch connection updated event
    this.eventDispatcher.dispatch('connection_updated', {
      connectionId,
      config: newConfig
    });
    
    // Reconnect if requested and connection is connected
    if (reconnect && this.connections.get(connectionId)!.isConnected()) {
      // Disconnect first
      this.connections.get(connectionId)!.disconnect();
      
      // Remove old connection
      this.connections.delete(connectionId);
      
      // Create new connection with updated config
      this.createConnection(connectionId, newConfig);
      
      // Connect
      this.connect(connectionId);
    }
  }
  
  /**
   * Send a message using a specific connection
   * @param message Message to send
   * @param connectionId Connection ID (default: active connection)
   * @returns Promise that resolves when message is sent
   */
  public async send(
    type: string,
    payload: any,
    options: any = {},
    connectionId?: string
  ): Promise<any> {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connections.has(id)) {
      throw new Error(`Connection with ID '${id}' not found`);
    }
    
    // Get connection
    const connection = this.connections.get(id)!;
    
    // Check if connected
    if (!connection.isConnected()) {
      throw new Error(`Connection '${id}' is not connected`);
    }
    
    // Send message
    return connection.send(type, payload, options);
  }
  
  /**
   * Send a request using a specific connection
   * @param type Request type
   * @param payload Request payload
   * @param options Request options
   * @param connectionId Connection ID (default: active connection)
   * @returns Promise that resolves with the response
   */
  public async request(
    type: string,
    payload: any,
    options: any = {},
    connectionId?: string
  ): Promise<any> {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connections.has(id)) {
      throw new Error(`Connection with ID '${id}' not found`);
    }
    
    // Get connection
    const connection = this.connections.get(id)!;
    
    // Check if connected
    if (!connection.isConnected()) {
      throw new Error(`Connection '${id}' is not connected`);
    }
    
    // Send request
    return connection.request(type, payload, options);
  }
  
  /**
   * Add event listener
   * @param event Event name
   * @param listener Event listener function
   * @returns Event listener ID
   */
  public on(event: string, listener: (data: any) => void): string {
    return this.eventDispatcher.on(event, listener);
  }
  
  /**
   * Remove event listener
   * @param id Event listener ID
   * @returns True if listener was removed
   */
  public off(id: string): boolean {
    return this.eventDispatcher.off(id);
  }
  
  /**
   * Subscribe to a topic using a specific connection
   * @param topic Topic to subscribe to
   * @param connectionId Connection ID (default: active connection)
   * @returns Promise that resolves when subscription is confirmed
   */
  public async subscribe(topic: string, connectionId?: string): Promise<void> {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connections.has(id)) {
      throw new Error(`Connection with ID '${id}' not found`);
    }
    
    // Get connection
    const connection = this.connections.get(id)!;
    
    // Check if connected
    if (!connection.isConnected()) {
      throw new Error(`Connection '${id}' is not connected`);
    }
    
    // Subscribe to topic
    return connection.subscribe(topic);
  }
  
  /**
   * Unsubscribe from a topic using a specific connection
   * @param topic Topic to unsubscribe from
   * @param connectionId Connection ID (default: active connection)
   * @returns Promise that resolves when unsubscription is confirmed
   */
  public async unsubscribe(topic: string, connectionId?: string): Promise<void> {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connections.has(id)) {
      throw new Error(`Connection with ID '${id}' not found`);
    }
    
    // Get connection
    const connection = this.connections.get(id)!;
    
    // Check if connected
    if (!connection.isConnected()) {
      throw new Error(`Connection '${id}' is not connected`);
    }
    
    // Unsubscribe from topic
    return connection.unsubscribe(topic);
  }
  
  /**
   * Publish a message to a topic using a specific connection
   * @param topic Topic to publish to
   * @param data Message data
   * @param options Publish options
   * @param connectionId Connection ID (default: active connection)
   * @returns Promise that resolves when message is published
   */
  public async publish(
    topic: string,
    data: any,
    options: any = {},
    connectionId?: string
  ): Promise<void> {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connections.has(id)) {
      throw new Error(`Connection with ID '${id}' not found`);
    }
    
    // Get connection
    const connection = this.connections.get(id)!;
    
    // Check if connected
    if (!connection.isConnected()) {
      throw new Error(`Connection '${id}' is not connected`);
    }
    
    // Publish message
    return connection.publish(topic, data, options);
  }
  
  /**
   * Get connection state
   * @param connectionId Connection ID (default: active connection)
   * @returns Connection state
   */
  public getConnectionState(connectionId?: string): ConnectionState {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connections.has(id)) {
      throw new Error(`Connection with ID '${id}' not found`);
    }
    
    // Get connection
    const connection = this.connections.get(id)!;
    
    // Get connection state
    return connection.getConnectionState();
  }
  
  /**
   * Check if connection is connected
   * @param connectionId Connection ID (default: active connection)
   * @returns True if connected
   */
  public isConnected(connectionId?: string): boolean {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connections.has(id)) {
      return false;
    }
    
    // Get connection
    const connection = this.connections.get(id)!;
    
    // Check if connected
    return connection.isConnected();
  }
  
  /**
   * Check if connection is authenticated
   * @param connectionId Connection ID (default: active connection)
   * @returns True if authenticated
   */
  public isAuthenticated(connectionId?: string): boolean {
    const id = connectionId || this.activeConnectionId || this.defaultConnectionId;
    
    // Check if connection exists
    if (!this.connections.has(id)) {
      return false;
    }
    
    // Get connection
    const connection = this.connections.get(id)!;
    
    // Check if authenticated
    return connection.isAuthenticated();
  }
  
  /**
   * Setup event listeners for a connection
   * @param client WebSocket client
   * @param connectionId Connection ID
   */
  private setupEventListeners(client: WebSocketClient, connectionId: string): void {
    // Setup state change listener
    client.on('statechange', (data) => {
      // Dispatch connection state changed event
      this.eventDispatcher.dispatch('connection_state_changed', {
        connectionId,
        previous: data.previous,
        current: data.current
      });
    });
    
    // Setup message listener
    client.on('message', (data) => {
      // Dispatch message received event
      this.eventDispatcher.dispatch('message_received', {
        connectionId,
        message: data
      });
    });
    
    // Setup error listener
    client.on('error', (data) => {
      // Dispatch connection error event
      this.eventDispatcher.dispatch('connection_error', {
        connectionId,
        error: data
      });
    });
    
    // Setup close listener
    client.on('close', (data) => {
      // Dispatch connection closed event
      this.eventDispatcher.dispatch('connection_closed', {
        connectionId,
        code: data.code,
        reason: data.reason,
        wasClean: data.wasClean
      });
    });
    
    // Setup authenticated listener
    client.on('authenticated', (data) => {
      // Dispatch connection authenticated event
      this.eventDispatcher.dispatch('connection_authenticated', {
        connectionId,
        data
      });
    });
    
    // Setup authentication failed listener
    client.on('authentication_failed', (data) => {
      // Dispatch connection authentication failed event
      this.eventDispatcher.dispatch('connection_authentication_failed', {
        connectionId,
        error: data.error
      });
    });
  }
  
  /**
   * Save connections to storage
   */
  private saveConnectionsToStorage(): void {
    try {
      // Convert configurations to object
      const configs: Record<string, ConnectionConfig> = {};
      
      for (const [id, config] of this.connectionConfigs.entries()) {
        configs[id] = config;
      }
      
      // Save to local storage
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        connections: configs,
        defaultConnectionId: this.defaultConnectionId,
        activeConnectionId: this.activeConnectionId
      }));
    } catch (err) {
      logger.error(`Failed to save connections to storage: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Load connections from storage
   */
  private loadConnectionsFromStorage(): void {
    try {
      // Load from local storage
      const storedData = localStorage.getItem(STORAGE_KEY);
      
      if (storedData) {
        const data = JSON.parse(storedData);
        
        // Create connections
        for (const [id, config] of Object.entries(data.connections)) {
          try {
            this.createConnection(id, config as ConnectionConfig);
          } catch (err) {
            logger.error(`Failed to create connection '${id}' from storage: ${err instanceof Error ? err.message : String(err)}`);
          }
        }
        
        // Set default connection ID
        if (data.defaultConnectionId) {
          this.defaultConnectionId = data.defaultConnectionId;
        }
        
        // Set active connection ID
        if (data.activeConnectionId && this.connections.has(data.activeConnectionId)) {
          this.activeConnectionId = data.activeConnectionId;
        }
      }
    } catch (err) {
      logger.error(`Failed to load connections from storage: ${err instanceof Error ? err.message : String(err)}`);
    }
  }
  
  /**
   * Destroy the connection manager
   */
  public destroy(): void {
    logger.info('Destroying connection manager');
    
    // Disconnect all connections
    this.disconnectAll();
    
    // Clear connections
    this.connections.clear();
    this.connectionConfigs.clear();
    
    // Destroy event dispatcher
    this.eventDispatcher.destroy();
  }
}


