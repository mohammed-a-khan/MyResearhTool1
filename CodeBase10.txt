ResourceMonitorService.java
---------------------------------------------------


package com.cstestforge.service.realtime;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.model.websocket.MessageType;
import com.cstestforge.model.websocket.ResourceMetricsMessage;
import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.service.websocket.MessagePublisher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryUsage;
import java.lang.management.ThreadMXBean;
import java.lang.management.OperatingSystemMXBean;
import java.time.Instant;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * Service for real-time monitoring of system resources during test execution.
 * Tracks CPU usage, memory utilization, thread counts, and other system metrics.
 * Publishes metrics to connected clients via WebSocket at configurable intervals.
 * 
 * This implementation uses JMX beans and OS-specific commands to gather accurate
 * system metrics without relying on third-party monitoring libraries.
 */
@Service
public class ResourceMonitorService {

    private static final CSLogger LOGGER = new CSLogger(ResourceMonitorService.class);
    private static final int DEFAULT_SAMPLING_INTERVAL_MS = 2000;
    private static final int METRICS_HISTORY_SIZE = 60; // Store 60 samples (2 mins at default interval)
    private static final int DEFAULT_THROTTLE_THRESHOLD_MS = 20000; // 20 seconds threshold for throttling
    
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
    private final AtomicBoolean isMonitoring = new AtomicBoolean(false);
    private final Map<String, CircularBuffer<Double>> metricsHistory = new ConcurrentHashMap<>();
    private final Map<String, SessionMonitoringState> activeMonitoringSessions = new ConcurrentHashMap<>();
    
    private final MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();
    private final ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
    private final OperatingSystemMXBean osMXBean = ManagementFactory.getOperatingSystemMXBean();
    private final Runtime runtime = Runtime.getRuntime();
    
    // OS type detection
    private final boolean isWindows = System.getProperty("os.name").toLowerCase().contains("win");
    private final boolean isLinux = System.getProperty("os.name").toLowerCase().contains("linux");
    private final boolean isMac = System.getProperty("os.name").toLowerCase().contains("mac");
    
    @Autowired
    private MessagePublisher messagePublisher;
    
    /**
     * Data structure to maintain metrics history as a circular buffer
     */
    private static class CircularBuffer<T> {
        private final Object[] buffer;
        private final int capacity;
        private int writeIndex = 0;
        private int size = 0;
        
        public CircularBuffer(int capacity) {
            this.capacity = capacity;
            this.buffer = new Object[capacity];
        }
        
        public synchronized void add(T value) {
            buffer[writeIndex] = value;
            writeIndex = (writeIndex + 1) % capacity;
            if (size < capacity) {
                size++;
            }
        }
        
        @SuppressWarnings("unchecked")
        public synchronized List<T> getAll() {
            List<T> result = new ArrayList<>(size);
            int readIndex = size < capacity ? 0 : writeIndex;
            
            for (int i = 0; i < size; i++) {
                result.add((T) buffer[readIndex]);
                readIndex = (readIndex + 1) % capacity;
            }
            
            return result;
        }
        
        @SuppressWarnings("unchecked")
        public synchronized T getLatest() {
            if (size == 0) {
                return null;
            }
            int index = (writeIndex - 1 + capacity) % capacity;
            return (T) buffer[index];
        }
        
        public synchronized int size() {
            return size;
        }
        
        public synchronized void clear() {
            for (int i = 0; i < capacity; i++) {
                buffer[i] = null;
            }
            writeIndex = 0;
            size = 0;
        }
    }
    
    /**
     * Data structure to track per-session monitoring state
     */
    private static class SessionMonitoringState {
        private final String sessionId;
        private int samplingIntervalMs;
        private long lastSentTimestamp;
        private long lastCpuTime;
        private long lastSystemTime;
        private boolean throttlingEnabled;
        private int throttleThresholdMs;
        
        public SessionMonitoringState(String sessionId, int samplingIntervalMs, boolean throttlingEnabled, int throttleThresholdMs) {
            this.sessionId = sessionId;
            this.samplingIntervalMs = samplingIntervalMs;
            this.lastSentTimestamp = System.currentTimeMillis();
            this.lastCpuTime = 0;
            this.lastSystemTime = System.nanoTime();
            this.throttlingEnabled = throttlingEnabled;
            this.throttleThresholdMs = throttleThresholdMs;
        }
    }
    
    /**
     * Initialize the monitoring service.
     * Creates circular buffers to store metrics history.
     */
    @PostConstruct
    public void init() {
        metricsHistory.put("cpuUsage", new CircularBuffer<>(METRICS_HISTORY_SIZE));
        metricsHistory.put("memoryUsage", new CircularBuffer<>(METRICS_HISTORY_SIZE));
        metricsHistory.put("threadCount", new CircularBuffer<>(METRICS_HISTORY_SIZE));
        metricsHistory.put("heapUsage", new CircularBuffer<>(METRICS_HISTORY_SIZE));
        metricsHistory.put("nonHeapUsage", new CircularBuffer<>(METRICS_HISTORY_SIZE));
        metricsHistory.put("systemLoad", new CircularBuffer<>(METRICS_HISTORY_SIZE));
        metricsHistory.put("diskIoRead", new CircularBuffer<>(METRICS_HISTORY_SIZE));
        metricsHistory.put("diskIoWrite", new CircularBuffer<>(METRICS_HISTORY_SIZE));
        metricsHistory.put("networkReceived", new CircularBuffer<>(METRICS_HISTORY_SIZE));
        metricsHistory.put("networkSent", new CircularBuffer<>(METRICS_HISTORY_SIZE));
        
        // Start a cleanup task to remove stale sessions
        scheduler.scheduleAtFixedRate(this::cleanupStaleSessions, 30, 30, TimeUnit.SECONDS);
        
        LOGGER.info("ResourceMonitorService initialized");
    }
    
    /**
     * Clean up resources when the service is being destroyed.
     */
    @PreDestroy
    public void shutdown() {
        stopAllMonitoring();
        scheduler.shutdownNow();
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                LOGGER.warn("Scheduler did not terminate in time");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            LOGGER.error("Scheduler shutdown interrupted", e);
        }
        LOGGER.info("ResourceMonitorService shutdown complete");
    }
    
    /**
     * Start monitoring system resources for a specific session.
     * 
     * @param sessionId The WebSocket session ID to send metrics to
     * @param interval Optional sampling interval in milliseconds
     * @return A unique monitoring ID for this session
     */
    public String startMonitoring(String sessionId, Integer interval) {
        return startMonitoring(sessionId, interval, true, DEFAULT_THROTTLE_THRESHOLD_MS);
    }
    
    /**
     * Start monitoring system resources for a specific session with advanced options.
     * 
     * @param sessionId The WebSocket session ID to send metrics to
     * @param interval Optional sampling interval in milliseconds
     * @param enableThrottling Whether to enable adaptive throttling
     * @param throttleThreshold Throttle threshold in milliseconds
     * @return A unique monitoring ID for this session
     */
    public String startMonitoring(String sessionId, Integer interval, boolean enableThrottling, Integer throttleThreshold) {
        int actualInterval = (interval != null && interval > 100) ? interval : DEFAULT_SAMPLING_INTERVAL_MS;
        int actualThreshold = (throttleThreshold != null && throttleThreshold > 1000) ? throttleThreshold : DEFAULT_THROTTLE_THRESHOLD_MS;
        
        String monitoringId = UUID.randomUUID().toString();
        SessionMonitoringState state = new SessionMonitoringState(sessionId, actualInterval, enableThrottling, actualThreshold);
        
        // Initialize baseline for CPU calculation
        state.lastSystemTime = System.nanoTime();
        if (threadMXBean.isThreadCpuTimeSupported() && threadMXBean.isThreadCpuTimeEnabled()) {
            state.lastCpuTime = getTotalThreadCpuTime();
        }
        
        activeMonitoringSessions.put(monitoringId, state);
        
        // Start the monitoring if this is the first session
        if (isMonitoring.compareAndSet(false, true)) {
            scheduler.scheduleAtFixedRate(
                this::collectAndPublishMetrics,
                0,
                Math.min(actualInterval / 2, 500), // Use the minimum interval or 500ms as baseline
                TimeUnit.MILLISECONDS
            );
        }
        
        LOGGER.info("Resource monitoring started for session: " + sessionId + " with ID: " + monitoringId);
        return monitoringId;
    }
    
    /**
     * Stop monitoring for a specific monitoring ID.
     * 
     * @param monitoringId The monitoring ID to stop
     * @return true if successfully stopped, false if the ID was not found
     */
    public boolean stopMonitoring(String monitoringId) {
        SessionMonitoringState removed = activeMonitoringSessions.remove(monitoringId);
        
        if (removed != null) {
            LOGGER.info("Resource monitoring stopped for session: " + removed.sessionId);
            
            // If no more active sessions, stop the scheduler
            if (activeMonitoringSessions.isEmpty() && isMonitoring.compareAndSet(true, false)) {
                // No need to shutdown the scheduler as it's shared, just reset the metrics
                resetMetrics();
            }
            
            return true;
        }
        
        return false;
    }
    
    /**
     * Stop all monitoring sessions.
     */
    public void stopAllMonitoring() {
        if (isMonitoring.compareAndSet(true, false)) {
            activeMonitoringSessions.clear();
            resetMetrics();
            LOGGER.info("All resource monitoring stopped");
        }
    }
    
    /**
     * Update the sampling interval for a specific monitoring session.
     * 
     * @param monitoringId The monitoring ID to update
     * @param newInterval The new sampling interval in milliseconds
     * @return true if successfully updated, false if the ID was not found
     */
    public boolean updateSamplingInterval(String monitoringId, int newInterval) {
        if (newInterval < 100) {
            LOGGER.warn("Sampling interval too small, using minimum of 100ms");
            newInterval = 100;
        }
        
        SessionMonitoringState state = activeMonitoringSessions.get(monitoringId);
        if (state != null) {
            state.samplingIntervalMs = newInterval;
            LOGGER.info("Updated sampling interval to " + newInterval + "ms for session: " + state.sessionId);
            return true;
        }
        
        return false;
    }
    
    /**
     * Enable or disable throttling for a specific monitoring session.
     * 
     * @param monitoringId The monitoring ID to update
     * @param enableThrottling Whether to enable throttling
     * @param throttleThreshold Throttle threshold in milliseconds
     * @return true if successfully updated, false if the ID was not found
     */
    public boolean configureThrottling(String monitoringId, boolean enableThrottling, Integer throttleThreshold) {
        SessionMonitoringState state = activeMonitoringSessions.get(monitoringId);
        if (state != null) {
            state.throttlingEnabled = enableThrottling;
            if (throttleThreshold != null && throttleThreshold >= 1000) {
                state.throttleThresholdMs = throttleThreshold;
            }
            LOGGER.info("Updated throttling settings for session: " + state.sessionId + 
                      ", enabled: " + enableThrottling + ", threshold: " + state.throttleThresholdMs + "ms");
            return true;
        }
        
        return false;
    }
    
    /**
     * Get the latest metrics snapshot for a specific monitoring session.
     * 
     * @param monitoringId The monitoring ID
     * @return A map of metric name to latest value, or null if the ID was not found
     */
    public Map<String, Double> getLatestMetrics(String monitoringId) {
        if (!activeMonitoringSessions.containsKey(monitoringId)) {
            return null;
        }
        
        Map<String, Double> metrics = new HashMap<>();
        for (Map.Entry<String, CircularBuffer<Double>> entry : metricsHistory.entrySet()) {
            metrics.put(entry.getKey(), entry.getValue().getLatest());
        }
        
        return metrics;
    }
    
    /**
     * Get the metrics history for a specific monitoring session.
     * 
     * @param monitoringId The monitoring ID
     * @return A map of metric name to list of historical values, or null if the ID was not found
     */
    public Map<String, List<Double>> getMetricsHistory(String monitoringId) {
        if (!activeMonitoringSessions.containsKey(monitoringId)) {
            return null;
        }
        
        Map<String, List<Double>> metrics = new HashMap<>();
        for (Map.Entry<String, CircularBuffer<Double>> entry : metricsHistory.entrySet()) {
            metrics.put(entry.getKey(), entry.getValue().getAll());
        }
        
        return metrics;
    }
    
    /**
     * Collect and publish metrics to all active monitoring sessions.
     * This method is called periodically by the scheduler.
     */
    private void collectAndPublishMetrics() {
        if (!isMonitoring.get() || activeMonitoringSessions.isEmpty()) {
            return;
        }
        
        try {
            // Collect metrics once for all sessions
            Map<String, Double> currentMetrics = collectMetrics();
            long currentTime = System.currentTimeMillis();
            
            // Update metrics history
            for (Map.Entry<String, Double> entry : currentMetrics.entrySet()) {
                CircularBuffer<Double> buffer = metricsHistory.get(entry.getKey());
                if (buffer != null) {
                    buffer.add(entry.getValue());
                }
            }
            
            // Publish to each session based on its own interval
            for (Map.Entry<String, SessionMonitoringState> entry : activeMonitoringSessions.entrySet()) {
                SessionMonitoringState state = entry.getValue();
                
                // Check if it's time to send metrics to this session
                long timeSinceLastSent = currentTime - state.lastSentTimestamp;
                
                // Apply throttling if enabled and no UI activity for a while
                boolean shouldSend = timeSinceLastSent >= state.samplingIntervalMs;
                if (state.throttlingEnabled && timeSinceLastSent > state.throttleThresholdMs) {
                    // Gradually increase the effective interval based on inactivity time
                    long inactivityFactor = timeSinceLastSent / state.throttleThresholdMs;
                    long effectiveInterval = state.samplingIntervalMs * Math.min(inactivityFactor, 10);
                    shouldSend = timeSinceLastSent >= effectiveInterval;
                }
                
                if (shouldSend) {
                    publishMetricsToSession(entry.getKey(), state, currentMetrics);
                    state.lastSentTimestamp = currentTime;
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error collecting or publishing metrics", e);
        }
    }
    
    /**
     * Publish metrics to a specific session.
     * 
     * @param monitoringId The monitoring ID
     * @param state The session state
     * @param metrics The metrics to publish
     */
    private void publishMetricsToSession(String monitoringId, SessionMonitoringState state, Map<String, Double> metrics) {
        ResourceMetricsMessage metricsMessage = new ResourceMetricsMessage();
        metricsMessage.setMonitoringId(monitoringId);
        metricsMessage.setTimestamp(Instant.now().toEpochMilli());
        metricsMessage.setMetrics(new HashMap<>(metrics));
        
        WebSocketMessage message = new WebSocketMessage();
        message.setType(MessageType.RESOURCE_METRICS);
        message.setData(metricsMessage);
        
        messagePublisher.sendMessageToSession(state.sessionId, message);
    }
    
    /**
     * Collect all system metrics.
     * 
     * @return A map of metric name to current value
     */
    private Map<String, Double> collectMetrics() {
        Map<String, Double> metrics = new HashMap<>();
        
        // CPU usage
        metrics.put("cpuUsage", getCpuUsage());
        
        // Memory metrics
        MemoryUsage heapMemory = memoryMXBean.getHeapMemoryUsage();
        MemoryUsage nonHeapMemory = memoryMXBean.getNonHeapMemoryUsage();
        double totalMemory = runtime.totalMemory();
        double freeMemory = runtime.freeMemory();
        double usedMemory = totalMemory - freeMemory;
        double maxMemory = runtime.maxMemory();
        
        metrics.put("memoryUsage", (usedMemory / maxMemory) * 100.0);
        metrics.put("heapUsage", ((double) heapMemory.getUsed() / heapMemory.getCommitted()) * 100.0);
        metrics.put("nonHeapUsage", ((double) nonHeapMemory.getUsed() / Math.max(nonHeapMemory.getCommitted(), 1)) * 100.0);
        
        // Thread metrics
        metrics.put("threadCount", (double) threadMXBean.getThreadCount());
        
        // System load average
        double systemLoadAverage = osMXBean.getSystemLoadAverage();
        metrics.put("systemLoad", systemLoadAverage >= 0 ? systemLoadAverage : 0.0);
        
        // OS-specific disk and network metrics
        try {
            if (isLinux) {
                collectLinuxDiskAndNetworkMetrics(metrics);
            } else if (isWindows) {
                collectWindowsDiskAndNetworkMetrics(metrics);
            } else if (isMac) {
                collectMacDiskAndNetworkMetrics(metrics);
            } else {
                // Fallback metrics
                metrics.put("diskIoRead", 0.0);
                metrics.put("diskIoWrite", 0.0);
                metrics.put("networkReceived", 0.0);
                metrics.put("networkSent", 0.0);
            }
        } catch (Exception e) {
            LOGGER.error("Error collecting OS-specific metrics", e);
            metrics.put("diskIoRead", 0.0);
            metrics.put("diskIoWrite", 0.0);
            metrics.put("networkReceived", 0.0);
            metrics.put("networkSent", 0.0);
        }
        
        return metrics;
    }
    
    /**
     * Get the CPU usage percentage.
     * 
     * @return The CPU usage as a percentage
     */
    private double getCpuUsage() {
        if (!threadMXBean.isThreadCpuTimeSupported() || !threadMXBean.isThreadCpuTimeEnabled()) {
            return osMXBean.getSystemLoadAverage() * 100.0 / Runtime.getRuntime().availableProcessors();
        }
        
        long currentCpuTime = getTotalThreadCpuTime();
        long currentSystemTime = System.nanoTime();
        
        long cpuTimeDiff = 0;
        long systemTimeDiff = 0;
        
        // Use a snapshot to ensure consistency
        synchronized (this) {
            cpuTimeDiff = currentCpuTime - lastCpuTime;
            systemTimeDiff = currentSystemTime - lastSystemTime;
            lastCpuTime = currentCpuTime;
            lastSystemTime = currentSystemTime;
        }
        
        if (systemTimeDiff == 0) {
            return 0.0;
        }
        
        int processors = Runtime.getRuntime().availableProcessors();
        double cpuUsage = ((double) cpuTimeDiff / systemTimeDiff) * 100.0 / processors;
        
        // Sanity check to handle JVM anomalies
        return Math.min(Math.max(cpuUsage, 0.0), 100.0 * processors);
    }
    
    /**
     * Get the total CPU time used by all threads.
     * 
     * @return The total CPU time in nanoseconds
     */
    private long getTotalThreadCpuTime() {
        long totalCpuTime = 0;
        for (long id : threadMXBean.getAllThreadIds()) {
            long cpuTime = threadMXBean.getThreadCpuTime(id);
            if (cpuTime != -1) {
                totalCpuTime += cpuTime;
            }
        }
        return totalCpuTime;
    }
    
    /**
     * Collect Linux-specific disk and network metrics.
     * 
     * @param metrics The metrics map to update
     */
    private void collectLinuxDiskAndNetworkMetrics(Map<String, Double> metrics) {
        try {
            // Disk I/O
            String diskStats = new String(Files.readAllBytes(Paths.get("/proc/diskstats")));
            String[] diskLines = diskStats.split("\n");
            
            long totalReadSectors = 0;
            long totalWriteSectors = 0;
            
            for (String line : diskLines) {
                String[] parts = line.trim().split("\\s+");
                if (parts.length >= 14 && !parts[2].startsWith("loop") && !parts[2].startsWith("ram")) {
                    totalReadSectors += Long.parseLong(parts[5]);
                    totalWriteSectors += Long.parseLong(parts[9]);
                }
            }
            
            metrics.put("diskIoRead", (double) totalReadSectors * 512 / 1024 / 1024); // MB
            metrics.put("diskIoWrite", (double) totalWriteSectors * 512 / 1024 / 1024); // MB
            
            // Network
            String netStats = new String(Files.readAllBytes(Paths.get("/proc/net/dev")));
            String[] netLines = netStats.split("\n");
            
            long totalReceivedBytes = 0;
            long totalSentBytes = 0;
            
            for (String line : netLines) {
                if (line.contains(":")) {
                    String[] parts = line.trim().split("\\s+");
                    if (parts.length >= 10) {
                        String iface = parts[0].replace(":", "");
                        if (!iface.equals("lo")) { // Skip loopback
                            totalReceivedBytes += Long.parseLong(parts[1]);
                            totalSentBytes += Long.parseLong(parts[9]);
                        }
                    }
                }
            }
            
            metrics.put("networkReceived", (double) totalReceivedBytes / 1024 / 1024); // MB
            metrics.put("networkSent", (double) totalSentBytes / 1024 / 1024); // MB
        } catch (IOException e) {
            LOGGER.error("Error collecting Linux metrics", e);
            metrics.put("diskIoRead", 0.0);
            metrics.put("diskIoWrite", 0.0);
            metrics.put("networkReceived", 0.0);
            metrics.put("networkSent", 0.0);
        }
    }
    
    /**
     * Collect Windows-specific disk and network metrics.
     * 
     * @param metrics The metrics map to update
     */
    private void collectWindowsDiskAndNetworkMetrics(Map<String, Double> metrics) {
        try {
            // Use WMIC for disk and network stats
            ProcessBuilder pbDisk = new ProcessBuilder("wmic", "diskperf", "get", "DiskReadBytesPersec,DiskWriteBytesPersec");
            Process processDisk = pbDisk.start();
            BufferedReader readerDisk = new BufferedReader(new InputStreamReader(processDisk.getInputStream()));
            
            long diskRead = 0;
            long diskWrite = 0;
            String line;
            boolean header = true;
            
            while ((line = readerDisk.readLine()) != null) {
                if (header) {
                    header = false;
                    continue;
                }
                
                String[] parts = line.trim().split("\\s+");
                if (parts.length >= 2) {
                    try {
                        diskRead += Long.parseLong(parts[0]);
                        diskWrite += Long.parseLong(parts[1]);
                    } catch (NumberFormatException e) {
                        // Skip non-numeric lines
                    }
                }
            }
            
            processDisk.waitFor();
            
            // Network stats
            ProcessBuilder pbNet = new ProcessBuilder("wmic", "NIC", "get", "BytesReceivedPersec,BytesSentPersec");
            Process processNet = pbNet.start();
            BufferedReader readerNet = new BufferedReader(new InputStreamReader(processNet.getInputStream()));
            
            long netReceived = 0;
            long netSent = 0;
            header = true;
            
            while ((line = readerNet.readLine()) != null) {
                if (header) {
                    header = false;
                    continue;
                }
                
                String[] parts = line.trim().split("\\s+");
                if (parts.length >= 2) {
                    try {
                        netReceived += Long.parseLong(parts[0]);
                        netSent += Long.parseLong(parts[1]);
                    } catch (NumberFormatException e) {
                        // Skip non-numeric lines
                    }
                }
            }
            
            processNet.waitFor();
            
            metrics.put("diskIoRead", (double) diskRead / 1024 / 1024); // MB
            metrics.put("diskIoWrite", (double) diskWrite / 1024 / 1024); // MB
            metrics.put("networkReceived", (double) netReceived / 1024 / 1024); // MB
            metrics.put("networkSent", (double) netSent / 1024 / 1024); // MB
        } catch (Exception e) {
            LOGGER.error("Error collecting Windows metrics", e);
            metrics.put("diskIoRead", 0.0);
            metrics.put("diskIoWrite", 0.0);
            metrics.put("networkReceived", 0.0);
            metrics.put("networkSent", 0.0);
        }
    }
    
    /**
     * Collect MacOS-specific disk and network metrics.
     * 
     * @param metrics The metrics map to update
     */
    private void collectMacDiskAndNetworkMetrics(Map<String, Double> metrics) {
        try {
            // Disk I/O using iostat
            ProcessBuilder pbDisk = new ProcessBuilder("iostat", "-d", "-c", "2");
            Process processDisk = pbDisk.start();
            BufferedReader readerDisk = new BufferedReader(new InputStreamReader(processDisk.getInputStream()));
            
            double diskRead = 0;
            double diskWrite = 0;
            String line;
            
            // Skip header lines
            for (int i = 0; i < 3; i++) {
                readerDisk.readLine();
            }
            
            while ((line = readerDisk.readLine()) != null) {
                String[] parts = line.trim().split("\\s+");
                if (parts.length >= 3 && !parts[0].equals("disk")) {
                    try {
                        diskRead += Double.parseDouble(parts[1]);
                        diskWrite += Double.parseDouble(parts[2]);
                    } catch (NumberFormatException e) {
                        // Skip non-numeric lines
                    }
                }
            }
            
            processDisk.waitFor();
            
            // Network using netstat
            ProcessBuilder pbNet = new ProcessBuilder("netstat", "-ib");
            Process processNet = pbNet.start();
            BufferedReader readerNet = new BufferedReader(new InputStreamReader(processNet.getInputStream()));
            
            long netReceived = 0;
            long netSent = 0;
            boolean header = true;
            
            while ((line = readerNet.readLine()) != null) {
                if (header) {
                    header = false;
                    continue;
                }
                
                String[] parts = line.trim().split("\\s+");
                if (parts.length >= 10 && !parts[0].equals("lo0")) {
                    try {
                        netReceived += Long.parseLong(parts[6]);
                        netSent += Long.parseLong(parts[9]);
                    } catch (NumberFormatException e) {
                        // Skip non-numeric lines
                    }
                }
            }
            
            processNet.waitFor();
            
            metrics.put("diskIoRead", diskRead); // MB
            metrics.put("diskIoWrite", diskWrite); // MB
            metrics.put("networkReceived", (double) netReceived / 1024 / 1024); // MB
            metrics.put("networkSent", (double) netSent / 1024 / 1024); // MB
        } catch (Exception e) {
            LOGGER.error("Error collecting Mac metrics", e);
            metrics.put("diskIoRead", 0.0);
            metrics.put("diskIoWrite", 0.0);
            metrics.put("networkReceived", 0.0);
            metrics.put("networkSent", 0.0);
        }
    }
    
    /**
     * Reset all metrics history.
     */
    private void resetMetrics() {
        for (CircularBuffer<Double> buffer : metricsHistory.values()) {
            buffer.clear();
        }
    }
    
    /**
     * Clean up sessions that have been inactive for too long.
     */
    private void cleanupStaleSessions() {
        long currentTime = System.currentTimeMillis();
        long maxInactiveTime = 5 * 60 * 1000; // 5 minutes
        
        List<String> sessionsToRemove = new ArrayList<>();
        
        for (Map.Entry<String, SessionMonitoringState> entry : activeMonitoringSessions.entrySet()) {
            SessionMonitoringState state = entry.getValue();
            if (currentTime - state.lastSentTimestamp > maxInactiveTime) {
                sessionsToRemove.add(entry.getKey());
            }
        }
        
        for (String sessionId : sessionsToRemove) {
            stopMonitoring(sessionId);
            LOGGER.info("Removed stale monitoring session: " + sessionId);
        }
    }
}


LiveLogService.java
--------------------------------

package com.cstestforge.service.realtime;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.model.websocket.LogMessage;
import com.cstestforge.model.websocket.MessageType;
import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.service.websocket.MessagePublisher;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

/**
 * Service for real-time streaming of log files to connected clients via WebSocket.
 * Supports multiple log files, filtering, and dynamic log level adjustment.
 * Provides historical log access and tail-like functionality.
 */
@Service
public class LiveLogService {

    private static final CSLogger LOGGER = new CSLogger(LiveLogService.class);
    private static final int DEFAULT_BUFFER_SIZE = 4096;
    private static final int DEFAULT_MAX_LINES = 1000;
    private static final int DEFAULT_BATCH_SIZE = 50;
    private static final int DEFAULT_POLLING_INTERVAL_MS = 500;
    private static final String DEFAULT_LOG_DIR = "logs";
    private static final Pattern LOG_LEVEL_PATTERN = Pattern.compile("\\b(TRACE|DEBUG|INFO|WARN|ERROR|FATAL)\\b");
    private static final Pattern TIMESTAMP_PATTERN = Pattern.compile("(\\d{4}-\\d{2}-\\d{2}[T ]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{3})?)");
    
    private final Map<String, LogStreamingSession> activeSessions = new ConcurrentHashMap<>();
    private final Map<String, LogFileTracker> logFileTrackers = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
    private final ExecutorService executorService = Executors.newCachedThreadPool();
    
    private String logDirectory = DEFAULT_LOG_DIR;
    private AtomicBoolean isRunning = new AtomicBoolean(false);
    
    @Autowired
    private MessagePublisher messagePublisher;
    
    /**
     * Log level enum with ordinals to simplify comparison.
     */
    public enum LogLevel {
        TRACE(0),
        DEBUG(1),
        INFO(2),
        WARN(3),
        ERROR(4),
        FATAL(5),
        OFF(6);
        
        private final int value;
        
        LogLevel(int value) {
            this.value = value;
        }
        
        public int getValue() {
            return value;
        }
        
        public static LogLevel fromString(String level) {
            try {
                return valueOf(level.toUpperCase());
            } catch (Exception e) {
                return INFO;
            }
        }
    }
    
    /**
     * Log entry class to represent a parsed log line.
     */
    public static class LogEntry {
        private final String timestamp;
        private final LogLevel level;
        private final String message;
        private final String source;
        private final String thread;
        private final String rawContent;
        
        public LogEntry(String timestamp, LogLevel level, String message, String source, String thread, String rawContent) {
            this.timestamp = timestamp;
            this.level = level;
            this.message = message;
            this.source = source;
            this.thread = thread;
            this.rawContent = rawContent;
        }
        
        public String getTimestamp() {
            return timestamp;
        }
        
        public LogLevel getLevel() {
            return level;
        }
        
        public String getMessage() {
            return message;
        }
        
        public String getSource() {
            return source;
        }
        
        public String getThread() {
            return thread;
        }
        
        public String getRawContent() {
            return rawContent;
        }
    }
    
    /**
     * Configuration class for log streaming.
     */
    public static class LogStreamingConfig {
        private List<String> logFiles;
        private List<String> includedSources;
        private List<String> excludedSources;
        private LogLevel minLogLevel;
        private String searchPattern;
        private boolean searchCaseSensitive;
        private boolean useRegex;
        private boolean includeHistoricalLogs;
        private int maxLines;
        private int batchSize;
        private long pollingIntervalMs;
        
        public LogStreamingConfig() {
            this.logFiles = new ArrayList<>();
            this.includedSources = new ArrayList<>();
            this.excludedSources = new ArrayList<>();
            this.minLogLevel = LogLevel.INFO;
            this.searchPattern = null;
            this.searchCaseSensitive = false;
            this.useRegex = false;
            this.includeHistoricalLogs = true;
            this.maxLines = DEFAULT_MAX_LINES;
            this.batchSize = DEFAULT_BATCH_SIZE;
            this.pollingIntervalMs = DEFAULT_POLLING_INTERVAL_MS;
        }
        
        public List<String> getLogFiles() {
            return logFiles;
        }
        
        public void setLogFiles(List<String> logFiles) {
            this.logFiles = logFiles;
        }
        
        public List<String> getIncludedSources() {
            return includedSources;
        }
        
        public void setIncludedSources(List<String> includedSources) {
            this.includedSources = includedSources;
        }
        
        public List<String> getExcludedSources() {
            return excludedSources;
        }
        
        public void setExcludedSources(List<String> excludedSources) {
            this.excludedSources = excludedSources;
        }
        
        public LogLevel getMinLogLevel() {
            return minLogLevel;
        }
        
        public void setMinLogLevel(LogLevel minLogLevel) {
            this.minLogLevel = minLogLevel;
        }
        
        public String getSearchPattern() {
            return searchPattern;
        }
        
        public void setSearchPattern(String searchPattern) {
            this.searchPattern = searchPattern;
        }
        
        public boolean isSearchCaseSensitive() {
            return searchCaseSensitive;
        }
        
        public void setSearchCaseSensitive(boolean searchCaseSensitive) {
            this.searchCaseSensitive = searchCaseSensitive;
        }
        
        public boolean isUseRegex() {
            return useRegex;
        }
        
        public void setUseRegex(boolean useRegex) {
            this.useRegex = useRegex;
        }
        
        public boolean isIncludeHistoricalLogs() {
            return includeHistoricalLogs;
        }
        
        public void setIncludeHistoricalLogs(boolean includeHistoricalLogs) {
            this.includeHistoricalLogs = includeHistoricalLogs;
        }
        
        public int getMaxLines() {
            return maxLines;
        }
        
        public void setMaxLines(int maxLines) {
            this.maxLines = maxLines > 0 ? maxLines : DEFAULT_MAX_LINES;
        }
        
        public int getBatchSize() {
            return batchSize;
        }
        
        public void setBatchSize(int batchSize) {
            this.batchSize = batchSize > 0 ? batchSize : DEFAULT_BATCH_SIZE;
        }
        
        public long getPollingIntervalMs() {
            return pollingIntervalMs;
        }
        
        public void setPollingIntervalMs(long pollingIntervalMs) {
            this.pollingIntervalMs = pollingIntervalMs > 0 ? pollingIntervalMs : DEFAULT_POLLING_INTERVAL_MS;
        }
    }
    
    /**
     * Class to track a log file's position and metadata.
     */
    private static class LogFileTracker {
        private final File logFile;
        private long lastPosition = 0;
        private long lastModified = 0;
        private boolean rotation = false;
        
        public LogFileTracker(File logFile) {
            this.logFile = logFile;
            this.lastModified = logFile.lastModified();
            
            // For existing files, start at the end
            if (logFile.length() > 0) {
                this.lastPosition = logFile.length();
            }
        }
        
        public File getLogFile() {
            return logFile;
        }
        
        public long getLastPosition() {
            return lastPosition;
        }
        
        public void setLastPosition(long lastPosition) {
            this.lastPosition = lastPosition;
        }
        
        public long getLastModified() {
            return lastModified;
        }
        
        public void setLastModified(long lastModified) {
            this.lastModified = lastModified;
        }
        
        public boolean isRotation() {
            return rotation;
        }
        
        public void setRotation(boolean rotation) {
            this.rotation = rotation;
        }
        
        public String getFileName() {
            return logFile.getName();
        }
        
        public Path getFilePath() {
            return logFile.toPath();
        }
    }
    
    /**
     * Class to track a streaming session for a specific client.
     */
    private static class LogStreamingSession {
        private final String sessionId;
        private final String streamId;
        private final LogStreamingConfig config;
        private final List<Future<?>> tasks = new ArrayList<>();
        private final LinkedBlockingQueue<LogEntry> messageQueue = new LinkedBlockingQueue<>();
        private final Map<String, LogFileTracker> sessionLogFiles = new HashMap<>();
        private final AtomicBoolean paused = new AtomicBoolean(false);
        
        private long lastActivityTime;
        private Pattern compiledSearchPattern;
        
        public LogStreamingSession(String sessionId, String streamId, LogStreamingConfig config) {
            this.sessionId = sessionId;
            this.streamId = streamId;
            this.config = config;
            this.lastActivityTime = System.currentTimeMillis();
            
            if (config.isUseRegex() && config.getSearchPattern() != null && !config.getSearchPattern().isEmpty()) {
                int flags = config.isSearchCaseSensitive() ? 0 : Pattern.CASE_INSENSITIVE;
                this.compiledSearchPattern = Pattern.compile(config.getSearchPattern(), flags);
            } else {
                this.compiledSearchPattern = null;
            }
        }
        
        public String getSessionId() {
            return sessionId;
        }
        
        public String getStreamId() {
            return streamId;
        }
        
        public LogStreamingConfig getConfig() {
            return config;
        }
        
        public List<Future<?>> getTasks() {
            return tasks;
        }
        
        public LinkedBlockingQueue<LogEntry> getMessageQueue() {
            return messageQueue;
        }
        
        public Map<String, LogFileTracker> getSessionLogFiles() {
            return sessionLogFiles;
        }
        
        public boolean isPaused() {
            return paused.get();
        }
        
        public void setPaused(boolean paused) {
            this.paused.set(paused);
        }
        
        public long getLastActivityTime() {
            return lastActivityTime;
        }
        
        public void updateLastActivityTime() {
            this.lastActivityTime = System.currentTimeMillis();
        }
        
        public Pattern getCompiledSearchPattern() {
            return compiledSearchPattern;
        }
        
        public void addLogFileTracker(LogFileTracker tracker) {
            sessionLogFiles.put(tracker.getFileName(), tracker);
        }
        
        public boolean matchesFilter(LogEntry entry) {
            // Check log level
            if (entry.getLevel().getValue() < config.getMinLogLevel().getValue()) {
                return false;
            }
            
            // Check included sources
            if (!config.getIncludedSources().isEmpty() && !config.getIncludedSources().contains(entry.getSource())) {
                return false;
            }
            
            // Check excluded sources
            if (!config.getExcludedSources().isEmpty() && config.getExcludedSources().contains(entry.getSource())) {
                return false;
            }
            
            // Check search pattern
            if (config.getSearchPattern() != null && !config.getSearchPattern().isEmpty()) {
                if (config.isUseRegex()) {
                    if (compiledSearchPattern != null) {
                        return compiledSearchPattern.matcher(entry.getRawContent()).find();
                    }
                } else {
                    String content = entry.getRawContent();
                    String pattern = config.getSearchPattern();
                    
                    if (!config.isSearchCaseSensitive()) {
                        content = content.toLowerCase();
                        pattern = pattern.toLowerCase();
                    }
                    
                    return content.contains(pattern);
                }
            }
            
            return true;
        }
    }
    
    /**
     * Initialize the log streaming service.
     */
    @PostConstruct
    public void init() {
        String configuredLogDir = System.getProperty("cstestforge.logs.dir");
        if (configuredLogDir != null && !configuredLogDir.isEmpty()) {
            logDirectory = configuredLogDir;
        }
        
        File logDir = new File(logDirectory);
        if (!logDir.exists()) {
            boolean created = logDir.mkdirs();
            if (!created) {
                LOGGER.warn("Failed to create log directory: " + logDirectory);
            }
        }
        
        // Start a cleanup task to remove stale sessions
        scheduler.scheduleAtFixedRate(this::cleanupStaleSessions, 30, 30, TimeUnit.SECONDS);
        
        isRunning.set(true);
        LOGGER.info("LiveLogService initialized with log directory: " + logDirectory);
    }
    
    /**
     * Clean up resources when the service is being destroyed.
     */
    @PreDestroy
    public void shutdown() {
        isRunning.set(false);
        
        // Stop all active streaming sessions
        for (String streamId : new ArrayList<>(activeSessions.keySet())) {
            stopStreaming(streamId);
        }
        
        // Shutdown the schedulers
        scheduler.shutdownNow();
        executorService.shutdownNow();
        
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                LOGGER.warn("Scheduler did not terminate in time");
            }
            
            if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {
                LOGGER.warn("ExecutorService did not terminate in time");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            LOGGER.error("Service shutdown interrupted", e);
        }
        
        LOGGER.info("LiveLogService shutdown complete");
    }
    
    /**
     * Start streaming logs to a WebSocket session.
     * 
     * @param sessionId The WebSocket session ID
     * @param config The log streaming configuration
     * @return A unique stream ID for this streaming session
     */
    public String startStreaming(String sessionId, LogStreamingConfig config) {
        if (!isRunning.get()) {
            throw new IllegalStateException("LiveLogService is not running");
        }
        
        String streamId = UUID.randomUUID().toString();
        LogStreamingSession session = new LogStreamingSession(sessionId, streamId, config);
        
        // Set default log files if none specified
        if (config.getLogFiles().isEmpty()) {
            List<String> defaultLogFiles = findLogFiles();
            config.setLogFiles(defaultLogFiles);
        }
        
        // Setup log file trackers
        for (String logFileName : config.getLogFiles()) {
            File logFile = resolveLogFile(logFileName);
            if (logFile != null && logFile.exists()) {
                LogFileTracker tracker = new LogFileTracker(logFile);
                
                // If historical logs are requested, reset position to beginning
                if (config.isIncludeHistoricalLogs()) {
                    tracker.setLastPosition(0);
                }
                
                session.addLogFileTracker(tracker);
                
                // Keep track globally too
                LogFileTracker existingTracker = logFileTrackers.get(logFile.getName());
                if (existingTracker == null) {
                    logFileTrackers.put(logFile.getName(), tracker);
                }
            } else {
                LOGGER.warn("Log file not found: " + logFileName);
            }
        }
        
        // No valid log files found
        if (session.getSessionLogFiles().isEmpty()) {
            LOGGER.warn("No valid log files found for session: " + sessionId);
            return null;
        }
        
        // Start the log file readers
        for (LogFileTracker tracker : session.getSessionLogFiles().values()) {
            Future<?> readerTask = executorService.submit(() -> readLogFile(session, tracker));
            session.getTasks().add(readerTask);
        }
        
        // Start the message sender
        Future<?> senderTask = executorService.submit(() -> sendLogMessages(session));
        session.getTasks().add(senderTask);
        
        activeSessions.put(streamId, session);
        LOGGER.info("Started log streaming for session: " + sessionId + " with stream ID: " + streamId);
        
        return streamId;
    }
    
    /**
     * Stop streaming logs for a specific stream ID.
     * 
     * @param streamId The stream ID to stop
     * @return true if successfully stopped, false if the stream ID was not found
     */
    public boolean stopStreaming(String streamId) {
        LogStreamingSession session = activeSessions.remove(streamId);
        if (session != null) {
            // Cancel all tasks
            for (Future<?> task : session.getTasks()) {
                task.cancel(true);
            }
            
            LOGGER.info("Stopped log streaming for session: " + session.getSessionId() + " with stream ID: " + streamId);
            return true;
        }
        
        return false;
    }
    
    /**
     * Pause streaming logs for a specific stream ID.
     * 
     * @param streamId The stream ID to pause
     * @return true if successfully paused, false if the stream ID was not found
     */
    public boolean pauseStreaming(String streamId) {
        LogStreamingSession session = activeSessions.get(streamId);
        if (session != null) {
            session.setPaused(true);
            session.updateLastActivityTime();
            LOGGER.info("Paused log streaming for session: " + session.getSessionId() + " with stream ID: " + streamId);
            return true;
        }
        
        return false;
    }
    
    /**
     * Resume streaming logs for a specific stream ID.
     * 
     * @param streamId The stream ID to resume
     * @return true if successfully resumed, false if the stream ID was not found
     */
    public boolean resumeStreaming(String streamId) {
        LogStreamingSession session = activeSessions.get(streamId);
        if (session != null) {
            session.setPaused(false);
            session.updateLastActivityTime();
            LOGGER.info("Resumed log streaming for session: " + session.getSessionId() + " with stream ID: " + streamId);
            return true;
        }
        
        return false;
    }
    
    /**
     * Update the configuration for a specific stream ID.
     * 
     * @param streamId The stream ID to update
     * @param config The new log streaming configuration
     * @return true if successfully updated, false if the stream ID was not found
     */
    public boolean updateStreamingConfig(String streamId, LogStreamingConfig config) {
        // Stop and restart the stream with the new configuration
        LogStreamingSession oldSession = activeSessions.get(streamId);
        if (oldSession != null) {
            String sessionId = oldSession.getSessionId();
            stopStreaming(streamId);
            startStreaming(sessionId, config);
            LOGGER.info("Updated log streaming config for session: " + sessionId + " with stream ID: " + streamId);
            return true;
        }
        
        return false;
    }
    
    /**
     * Get the list of available log files.
     * 
     * @return A list of log file names
     */
    public List<String> getAvailableLogFiles() {
        return findLogFiles();
    }
    
    /**
     * Get log file details.
     * 
     * @param logFileName The log file name
     * @return A map containing log file details, or null if the file was not found
     */
    public Map<String, Object> getLogFileDetails(String logFileName) {
        File logFile = resolveLogFile(logFileName);
        if (logFile != null && logFile.exists()) {
            Map<String, Object> details = new HashMap<>();
            details.put("name", logFile.getName());
            details.put("path", logFile.getAbsolutePath());
            details.put("size", logFile.length());
            details.put("lastModified", logFile.lastModified());
            
            // Extract log levels and sources
            try {
                analyzeLogFile(logFile, details);
            } catch (IOException e) {
                LOGGER.error("Error analyzing log file: " + logFileName, e);
            }
            
            return details;
        }
        
        return null;
    }
    
    /**
     * Search in log files.
     * 
     * @param searchConfig The search configuration
     * @return A list of matching log entries
     */
    public List<LogEntry> searchLogs(LogStreamingConfig searchConfig) {
        List<LogEntry> results = new ArrayList<>();
        
        for (String logFileName : searchConfig.getLogFiles()) {
            File logFile = resolveLogFile(logFileName);
            if (logFile != null && logFile.exists()) {
                try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        LogEntry entry = parseLogEntry(line, logFile.getName());
                        if (entry != null) {
                            LogStreamingSession dummySession = new LogStreamingSession("search", "search", searchConfig);
                            if (dummySession.matchesFilter(entry)) {
                                results.add(entry);
                                
                                // Limit results to avoid memory issues
                                if (results.size() >= searchConfig.getMaxLines()) {
                                    break;
                                }
                            }
                        }
                    }
                } catch (IOException e) {
                    LOGGER.error("Error searching log file: " + logFileName, e);
                }
                
                // Sort results by timestamp
                results.sort(Comparator.comparing(LogEntry::getTimestamp));
            }
        }
        
        return results;
    }
    
    /**
     * Get the last N lines from a log file.
     * 
     * @param logFileName The log file name
     * @param lines The number of lines to get
     * @return A list of the last N lines
     */
    public List<String> getTailLines(String logFileName, int lines) {
        File logFile = resolveLogFile(logFileName);
        if (logFile == null || !logFile.exists()) {
            return Collections.emptyList();
        }
        
        List<String> result = new ArrayList<>();
        try (RandomAccessFile randomAccessFile = new RandomAccessFile(logFile, "r")) {
            long fileLength = randomAccessFile.length();
            if (fileLength == 0) {
                return Collections.emptyList();
            }
            
            // Start from the end of the file
            long position = fileLength - 1;
            int linesFound = 0;
            StringBuilder sb = new StringBuilder();
            
            // Read backward until we find N lines or reach the start of the file
            for (; position >= 0 && linesFound < lines; position--) {
                randomAccessFile.seek(position);
                int c = randomAccessFile.read();
                
                // If we find a line break, store the line
                if (c == '\n' && position < fileLength - 1) {
                    result.add(0, sb.reverse().toString());
                    sb = new StringBuilder();
                    linesFound++;
                } else {
                    sb.append((char) c);
                }
                
                // If we reach the start of the file, add the last line
                if (position == 0) {
                    result.add(0, sb.reverse().toString());
                }
            }
        } catch (IOException e) {
            LOGGER.error("Error getting tail lines from log file: " + logFileName, e);
        }
        
        return result;
    }
    
    /**
     * Find all log files in the log directory.
     * 
     * @return A list of log file names
     */
    private List<String> findLogFiles() {
        File logDir = new File(logDirectory);
        if (!logDir.exists() || !logDir.isDirectory()) {
            return Collections.emptyList();
        }
        
        File[] files = logDir.listFiles((dir, name) -> 
            name.endsWith(".log") || name.endsWith(".txt") || name.endsWith(".out"));
        
        if (files == null) {
            return Collections.emptyList();
        }
        
        return Arrays.stream(files)
                .map(File::getName)
                .collect(Collectors.toList());
    }
    
    /**
     * Resolve a log file name to a File object.
     * 
     * @param logFileName The log file name or path
     * @return The resolved File object, or null if not found
     */
    private File resolveLogFile(String logFileName) {
        // If it's a full path, use it directly
        File direct = new File(logFileName);
        if (direct.exists() && direct.isFile()) {
            return direct;
        }
        
        // Otherwise, look in the log directory
        File inLogDir = new File(logDirectory, logFileName);
        if (inLogDir.exists() && inLogDir.isFile()) {
            return inLogDir;
        }
        
        // If it's just a name without extension, try adding common extensions
        if (!logFileName.contains(".")) {
            for (String ext : new String[] {".log", ".txt", ".out"}) {
                File withExt = new File(logDirectory, logFileName + ext);
                if (withExt.exists() && withExt.isFile()) {
                    return withExt;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Analyze a log file to extract common patterns.
     * 
     * @param logFile The log file to analyze
     * @param details The map to store the analysis results
     * @throws IOException If an I/O error occurs
     */
    private void analyzeLogFile(File logFile, Map<String, Object> details) throws IOException {
        Map<String, Integer> logLevels = new HashMap<>();
        Map<String, Integer> sources = new HashMap<>();
        
        try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
            String line;
            int count = 0;
            int maxSamples = 1000; // Limit the number of lines to analyze
            
            while ((line = reader.readLine()) != null && count < maxSamples) {
                LogEntry entry = parseLogEntry(line, logFile.getName());
                if (entry != null) {
                    // Count log levels
                    logLevels.put(entry.getLevel().toString(), 
                            logLevels.getOrDefault(entry.getLevel().toString(), 0) + 1);
                    
                    // Count sources
                    if (entry.getSource() != null) {
                        sources.put(entry.getSource(), 
                                sources.getOrDefault(entry.getSource(), 0) + 1);
                    }
                    
                    count++;
                }
            }
        }
        
        details.put("logLevels", logLevels);
        details.put("sources", sources);
    }
    
    /**
     * Parse a log entry from a line of text.
     * 
     * @param line The line to parse
     * @param source The source file
     * @return A LogEntry object, or null if the line could not be parsed
     */
    private LogEntry parseLogEntry(String line, String source) {
        if (line == null || line.isEmpty()) {
            return null;
        }
        
        // Extract timestamp
        String timestamp = null;
        Matcher timestampMatcher = TIMESTAMP_PATTERN.matcher(line);
        if (timestampMatcher.find()) {
            timestamp = timestampMatcher.group(1);
        }
        
        // Extract log level
        LogLevel level = LogLevel.INFO; // Default
        Matcher levelMatcher = LOG_LEVEL_PATTERN.matcher(line);
        if (levelMatcher.find()) {
            level = LogLevel.fromString(levelMatcher.group(1));
        }
        
        // Extract thread name (common format: [Thread-1])
        String thread = null;
        int threadStart = line.indexOf('[');
        int threadEnd = (threadStart >= 0) ? line.indexOf(']', threadStart) : -1;
        if (threadStart >= 0 && threadEnd > threadStart) {
            thread = line.substring(threadStart + 1, threadEnd);
        }
        
        // Extract class/source name (common format: com.example.Class)
        String classSource = null;
        int classStart = line.indexOf(' ', threadEnd + 1);
        if (classStart >= 0) {
            int classEnd = line.indexOf(' ', classStart + 1);
            if (classEnd > classStart) {
                String potentialClass = line.substring(classStart + 1, classEnd);
                if (potentialClass.contains(".")) {
                    classSource = potentialClass;
                }
            }
        }
        
        // Extract message (everything after class/source or thread)
        String message = line;
        if (classSource != null) {
            int messageStart = line.indexOf(classSource) + classSource.length();
            if (messageStart < line.length()) {
                message = line.substring(messageStart).trim();
            }
        } else if (thread != null) {
            int messageStart = threadEnd + 1;
            if (messageStart < line.length()) {
                message = line.substring(messageStart).trim();
            }
        }
        
        return new LogEntry(timestamp, level, message, classSource, thread, line);
    }
    
    /**
     * Read from a log file and add entries to the session's message queue.
     * 
     * @param session The streaming session
     * @param tracker The log file tracker
     */
    private void readLogFile(LogStreamingSession session, LogFileTracker tracker) {
        File logFile = tracker.getLogFile();
        String fileName = tracker.getFileName();
        
        try (RandomAccessFile raf = new RandomAccessFile(logFile, "r")) {
            long filePointer = tracker.getLastPosition();
            
            while (isRunning.get() && activeSessions.containsKey(session.getStreamId())) {
                try {
                    long fileLength = logFile.length();
                    
                    // Check if file has been rotated (size decreased)
                    if (fileLength < filePointer) {
                        LOGGER.info("Log file rotation detected for: " + fileName);
                        filePointer = 0;
                        tracker.setRotation(true);
                    }
                    
                    // If file modified and has new content
                    if (fileLength > filePointer) {
                        // Update last modified time
                        tracker.setLastModified(logFile.lastModified());
                        
                        // Read new content
                        raf.seek(filePointer);
                        String line;
                        
                        while ((line = raf.readLine()) != null) {
                            // Convert to UTF-8 string (readLine returns ISO-8859-1)
                            line = new String(line.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);
                            
                            // Parse and filter the log entry
                            LogEntry entry = parseLogEntry(line, fileName);
                            if (entry != null && session.matchesFilter(entry)) {
                                session.getMessageQueue().add(entry);
                            }
                            
                            // Update file pointer
                            filePointer = raf.getFilePointer();
                        }
                        
                        // Update tracker position
                        tracker.setLastPosition(filePointer);
                    }
                    
                    // Small delay to avoid busy-waiting
                    Thread.sleep(session.getConfig().getPollingIntervalMs());
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    LOGGER.debug("Log file reader interrupted for: " + fileName);
                    break;
                } catch (IOException e) {
                    LOGGER.error("Error reading log file: " + fileName, e);
                    
                    // Retry after a delay
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        } catch (IOException e) {
            LOGGER.error("Error opening log file: " + fileName, e);
        }
    }
    
    /**
     * Send log messages from the session's queue to the client.
     * 
     * @param session The streaming session
     */
    private void sendLogMessages(LogStreamingSession session) {
        List<LogEntry> batch = new ArrayList<>(session.getConfig().getBatchSize());
        
        while (isRunning.get() && activeSessions.containsKey(session.getStreamId())) {
            try {
                // Skip if paused
                if (session.isPaused()) {
                    Thread.sleep(session.getConfig().getPollingIntervalMs());
                    continue;
                }
                
                // Drain available messages to a batch
                session.getMessageQueue().drainTo(batch, session.getConfig().getBatchSize());
                
                if (!batch.isEmpty()) {
                    // Update activity time
                    session.updateLastActivityTime();
                    
                    // Convert to message objects
                    List<Map<String, Object>> messages = new ArrayList<>(batch.size());
                    for (LogEntry entry : batch) {
                        Map<String, Object> message = new HashMap<>();
                        message.put("timestamp", entry.getTimestamp());
                        message.put("level", entry.getLevel().toString());
                        message.put("message", entry.getMessage());
                        message.put("source", entry.getSource());
                        message.put("thread", entry.getThread());
                        message.put("content", entry.getRawContent());
                        messages.add(message);
                    }
                    
                    // Create and send a log message
                    LogMessage logMessage = new LogMessage();
                    logMessage.setStreamId(session.getStreamId());
                    logMessage.setTimestamp(Instant.now().toEpochMilli());
                    logMessage.setEntries(messages);
                    
                    WebSocketMessage wsMessage = new WebSocketMessage();
                    wsMessage.setType(MessageType.LOG_MESSAGE);
                    wsMessage.setData(logMessage);
                    
                    messagePublisher.sendMessageToSession(session.getSessionId(), wsMessage);
                    
                    // Clear the batch
                    batch.clear();
                } else {
                    // If no messages, wait a bit
                    Thread.sleep(session.getConfig().getPollingIntervalMs());
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                LOGGER.debug("Log message sender interrupted for session: " + session.getSessionId());
                break;
            } catch (Exception e) {
                LOGGER.error("Error sending log messages for session: " + session.getSessionId(), e);
                
                // Clear the batch to avoid resending the same messages
                batch.clear();
                
                // Retry after a delay
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }
    
    /**
     * Clean up sessions that have been inactive for too long.
     */
    private void cleanupStaleSessions() {
        long currentTime = System.currentTimeMillis();
        long maxInactiveTime = 10 * 60 * 1000; // 10 minutes
        
        List<String> sessionsToRemove = new ArrayList<>();
        
        for (Map.Entry<String, LogStreamingSession> entry : activeSessions.entrySet()) {
            LogStreamingSession session = entry.getValue();
            if (currentTime - session.getLastActivityTime() > maxInactiveTime) {
                sessionsToRemove.add(entry.getKey());
            }
        }
        
        for (String streamId : sessionsToRemove) {
            stopStreaming(streamId);
            LOGGER.info("Removed stale log streaming session: " + streamId);
        }
    }
    
    /**
     * Set the log directory.
     * 
     * @param logDirectory The log directory path
     */
    public void setLogDirectory(String logDirectory) {
        this.logDirectory = logDirectory;
    }
    
    /**
     * Get the log directory.
     * 
     * @return The log directory path
     */
    public String getLogDirectory() {
        return logDirectory;
    }
}


NotificationService.java
---------------------------------------

package com.cstestforge.service.realtime;

import com.cstestforge.framework.core.utils.CSConstants;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.model.websocket.MessageType;
import com.cstestforge.model.websocket.NotificationMessage;
import com.cstestforge.model.websocket.WebSocketMessage;
import com.cstestforge.service.websocket.MessagePublisher;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.DelayQueue;
import java.util.concurrent.Delayed;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Service for sending real-time notifications to WebSocket clients.
 * Supports different notification types, priority levels, persistence,
 * scheduled notifications, and targeted delivery.
 */
@Service
public class NotificationService {

    private static final CSLogger LOGGER = new CSLogger(NotificationService.class);
    private static final int DEFAULT_HISTORY_SIZE = 100;
    private static final int MAX_BATCH_SIZE = 50;
    
    @Autowired
    private MessagePublisher messagePublisher;
    
    private final ExecutorService notificationProcessor = Executors.newSingleThreadExecutor();
    private final ExecutorService scheduledProcessor = Executors.newSingleThreadExecutor();
    private final BlockingQueue<NotificationEvent> notificationQueue = new LinkedBlockingQueue<>();
    private final DelayQueue<ScheduledNotification> scheduledNotifications = new DelayQueue<>();
    private final Map<String, List<NotificationEvent>> notificationHistory = new ConcurrentHashMap<>();
    private final Map<String, List<NotificationSubscription>> subscriptions = new ConcurrentHashMap<>();
    private final ReentrantReadWriteLock historyLock = new ReentrantReadWriteLock();
    private final AtomicBoolean isRunning = new AtomicBoolean(false);
    
    /**
     * Notification type enum representing different categories of notifications.
     */
    public enum NotificationType {
        INFO("info", "Information"),
        SUCCESS("success", "Success"),
        WARNING("warning", "Warning"),
        ERROR("error", "Error"),
        SYSTEM("system", "System"),
        TEST_STATUS("test_status", "Test Status"),
        EXECUTION("execution", "Execution"),
        RESOURCE("resource", "Resource"),
        SECURITY("security", "Security"),
        CUSTOM("custom", "Custom");
        
        private final String code;
        private final String displayName;
        
        NotificationType(String code, String displayName) {
            this.code = code;
            this.displayName = displayName;
        }
        
        public String getCode() {
            return code;
        }
        
        public String getDisplayName() {
            return displayName;
        }
        
        public static NotificationType fromCode(String code) {
            for (NotificationType type : values()) {
                if (type.getCode().equals(code)) {
                    return type;
                }
            }
            return INFO;
        }
    }
    
    /**
     * Priority level enum for notifications.
     */
    public enum PriorityLevel {
        LOW(0),
        MEDIUM(1),
        HIGH(2),
        CRITICAL(3);
        
        private final int value;
        
        PriorityLevel(int value) {
            this.value = value;
        }
        
        public int getValue() {
            return value;
        }
    }
    
    /**
     * Class representing a notification event.
     */
    public static class NotificationEvent {
        private final String id;
        private final String title;
        private final String message;
        private final NotificationType type;
        private final PriorityLevel priority;
        private final long timestamp;
        private final Map<String, Object> data;
        private final List<String> targetSessions;
        private final List<String> targetGroups;
        private final boolean persistent;
        private final String source;
        private final String category;
        private boolean read;
        private boolean acknowledged;
        private long acknowledgedTimestamp;
        private String acknowledgedBy;
        private Map<String, Object> metadata;
        
        private NotificationEvent(Builder builder) {
            this.id = builder.id != null ? builder.id : UUID.randomUUID().toString();
            this.title = builder.title;
            this.message = builder.message;
            this.type = builder.type;
            this.priority = builder.priority;
            this.timestamp = builder.timestamp > 0 ? builder.timestamp : Instant.now().toEpochMilli();
            this.data = builder.data != null ? builder.data : new HashMap<>();
            this.targetSessions = builder.targetSessions;
            this.targetGroups = builder.targetGroups;
            this.persistent = builder.persistent;
            this.source = builder.source;
            this.category = builder.category;
            this.read = false;
            this.acknowledged = false;
            this.acknowledgedTimestamp = 0;
            this.acknowledgedBy = null;
            this.metadata = builder.metadata != null ? builder.metadata : new HashMap<>();
        }
        
        public String getId() {
            return id;
        }
        
        public String getTitle() {
            return title;
        }
        
        public String getMessage() {
            return message;
        }
        
        public NotificationType getType() {
            return type;
        }
        
        public PriorityLevel getPriority() {
            return priority;
        }
        
        public long getTimestamp() {
            return timestamp;
        }
        
        public Map<String, Object> getData() {
            return data;
        }
        
        public List<String> getTargetSessions() {
            return targetSessions;
        }
        
        public List<String> getTargetGroups() {
            return targetGroups;
        }
        
        public boolean isPersistent() {
            return persistent;
        }
        
        public String getSource() {
            return source;
        }
        
        public String getCategory() {
            return category;
        }
        
        public boolean isRead() {
            return read;
        }
        
        public void setRead(boolean read) {
            this.read = read;
        }
        
        public boolean isAcknowledged() {
            return acknowledged;
        }
        
        public void setAcknowledged(boolean acknowledged) {
            this.acknowledged = acknowledged;
        }
        
        public long getAcknowledgedTimestamp() {
            return acknowledgedTimestamp;
        }
        
        public void setAcknowledgedTimestamp(long acknowledgedTimestamp) {
            this.acknowledgedTimestamp = acknowledgedTimestamp;
        }
        
        public String getAcknowledgedBy() {
            return acknowledgedBy;
        }
        
        public void setAcknowledgedBy(String acknowledgedBy) {
            this.acknowledgedBy = acknowledgedBy;
        }
        
        public Map<String, Object> getMetadata() {
            return metadata;
        }
        
        public void setMetadata(Map<String, Object> metadata) {
            this.metadata = metadata;
        }
        
        public Map<String, Object> toMap() {
            Map<String, Object> map = new HashMap<>();
            map.put("id", id);
            map.put("title", title);
            map.put("message", message);
            map.put("type", type.getCode());
            map.put("priority", priority.name());
            map.put("timestamp", timestamp);
            map.put("data", data);
            map.put("persistent", persistent);
            map.put("source", source);
            map.put("category", category);
            map.put("read", read);
            map.put("acknowledged", acknowledged);
            map.put("acknowledgedTimestamp", acknowledgedTimestamp);
            map.put("acknowledgedBy", acknowledgedBy);
            map.put("metadata", metadata);
            return map;
        }
        
        public static class Builder {
            private String id;
            private String title;
            private String message;
            private NotificationType type = NotificationType.INFO;
            private PriorityLevel priority = PriorityLevel.MEDIUM;
            private long timestamp = 0;
            private Map<String, Object> data;
            private List<String> targetSessions = new ArrayList<>();
            private List<String> targetGroups = new ArrayList<>();
            private boolean persistent = false;
            private String source = "system";
            private String category = "general";
            private Map<String, Object> metadata;
            
            public Builder() {
            }
            
            public Builder id(String id) {
                this.id = id;
                return this;
            }
            
            public Builder title(String title) {
                this.title = title;
                return this;
            }
            
            public Builder message(String message) {
                this.message = message;
                return this;
            }
            
            public Builder type(NotificationType type) {
                this.type = type;
                return this;
            }
            
            public Builder priority(PriorityLevel priority) {
                this.priority = priority;
                return this;
            }
            
            public Builder timestamp(long timestamp) {
                this.timestamp = timestamp;
                return this;
            }
            
            public Builder data(Map<String, Object> data) {
                this.data = data;
                return this;
            }
            
            public Builder addData(String key, Object value) {
                if (this.data == null) {
                    this.data = new HashMap<>();
                }
                this.data.put(key, value);
                return this;
            }
            
            public Builder targetSession(String sessionId) {
                this.targetSessions.add(sessionId);
                return this;
            }
            
            public Builder targetSessions(List<String> sessionIds) {
                this.targetSessions.addAll(sessionIds);
                return this;
            }
            
            public Builder targetGroup(String group) {
                this.targetGroups.add(group);
                return this;
            }
            
            public Builder targetGroups(List<String> groups) {
                this.targetGroups.addAll(groups);
                return this;
            }
            
            public Builder persistent(boolean persistent) {
                this.persistent = persistent;
                return this;
            }
            
            public Builder source(String source) {
                this.source = source;
                return this;
            }
            
            public Builder category(String category) {
                this.category = category;
                return this;
            }
            
            public Builder metadata(Map<String, Object> metadata) {
                this.metadata = metadata;
                return this;
            }
            
            public Builder addMetadata(String key, Object value) {
                if (this.metadata == null) {
                    this.metadata = new HashMap<>();
                }
                this.metadata.put(key, value);
                return this;
            }
            
            public NotificationEvent build() {
                if (title == null || title.isEmpty()) {
                    throw new IllegalArgumentException("Notification title cannot be empty");
                }
                
                if (message == null || message.isEmpty()) {
                    throw new IllegalArgumentException("Notification message cannot be empty");
                }
                
                return new NotificationEvent(this);
            }
        }
    }
    
    /**
     * Class representing a scheduled notification.
     */
    private static class ScheduledNotification implements Delayed {
        private final NotificationEvent event;
        private final long scheduledTime;
        
        public ScheduledNotification(NotificationEvent event, long delayMillis) {
            this.event = event;
            this.scheduledTime = System.currentTimeMillis() + delayMillis;
        }
        
        public NotificationEvent getEvent() {
            return event;
        }
        
        public long getScheduledTime() {
            return scheduledTime;
        }
        
        @Override
        public long getDelay(TimeUnit unit) {
            long diff = scheduledTime - System.currentTimeMillis();
            return unit.convert(diff, TimeUnit.MILLISECONDS);
        }
        
        @Override
        public int compareTo(Delayed other) {
            if (other == this) {
                return 0;
            }
            
            if (other instanceof ScheduledNotification) {
                ScheduledNotification otherNotification = (ScheduledNotification) other;
                return Long.compare(scheduledTime, otherNotification.scheduledTime);
            }
            
            return Long.compare(getDelay(TimeUnit.MILLISECONDS), other.getDelay(TimeUnit.MILLISECONDS));
        }
    }
    
    /**
     * Class representing a notification subscription.
     */
    private static class NotificationSubscription {
        private final String subscriptionId;
        private final String sessionId;
        private final List<NotificationType> types;
        private final List<String> categories;
        private final List<String> sources;
        private final PriorityLevel minPriority;
        private final Map<String, Object> filters;
        private final boolean includeHistory;
        private final int historySize;
        
        public NotificationSubscription(String subscriptionId, String sessionId,
                List<NotificationType> types, List<String> categories, List<String> sources,
                PriorityLevel minPriority, Map<String, Object> filters,
                boolean includeHistory, int historySize) {
            this.subscriptionId = subscriptionId;
            this.sessionId = sessionId;
            this.types = types != null ? types : new ArrayList<>();
            this.categories = categories != null ? categories : new ArrayList<>();
            this.sources = sources != null ? sources : new ArrayList<>();
            this.minPriority = minPriority;
            this.filters = filters != null ? filters : new HashMap<>();
            this.includeHistory = includeHistory;
            this.historySize = historySize > 0 ? historySize : DEFAULT_HISTORY_SIZE;
        }
        
        public String getSubscriptionId() {
            return subscriptionId;
        }
        
        public String getSessionId() {
            return sessionId;
        }
        
        public List<NotificationType> getTypes() {
            return types;
        }
        
        public List<String> getCategories() {
            return categories;
        }
        
        public List<String> getSources() {
            return sources;
        }
        
        public PriorityLevel getMinPriority() {
            return minPriority;
        }
        
        public Map<String, Object> getFilters() {
            return filters;
        }
        
        public boolean isIncludeHistory() {
            return includeHistory;
        }
        
        public int getHistorySize() {
            return historySize;
        }
        
        public boolean matches(NotificationEvent event) {
            // Check priority
            if (event.getPriority().getValue() < minPriority.getValue()) {
                return false;
            }
            
            // Check types
            if (!types.isEmpty() && !types.contains(event.getType())) {
                return false;
            }
            
            // Check categories
            if (!categories.isEmpty() && !categories.contains(event.getCategory())) {
                return false;
            }
            
            // Check sources
            if (!sources.isEmpty() && !sources.contains(event.getSource())) {
                return false;
            }
            
            // Check target sessions
            if (!event.getTargetSessions().isEmpty() && !event.getTargetSessions().contains(sessionId)) {
                return false;
            }
            
            // Advanced filters (simple implementation)
            for (Map.Entry<String, Object> filter : filters.entrySet()) {
                Object value = event.getData().get(filter.getKey());
                if (value == null || !value.equals(filter.getValue())) {
                    return false;
                }
            }
            
            return true;
        }
    }
    
    /**
     * Initialize the notification service.
     */
    @PostConstruct
    public void init() {
        isRunning.set(true);
        
        // Start notification processor
        notificationProcessor.submit(this::processNotifications);
        
        // Start scheduled notification processor
        scheduledProcessor.submit(this::processScheduledNotifications);
        
        LOGGER.info("NotificationService initialized");
    }
    
    /**
     * Clean up resources when the service is being destroyed.
     */
    @PreDestroy
    public void shutdown() {
        isRunning.set(false);
        
        // Shutdown processors
        notificationProcessor.shutdownNow();
        scheduledProcessor.shutdownNow();
        
        try {
            if (!notificationProcessor.awaitTermination(5, TimeUnit.SECONDS)) {
                LOGGER.warn("Notification processor did not terminate in time");
            }
            
            if (!scheduledProcessor.awaitTermination(5, TimeUnit.SECONDS)) {
                LOGGER.warn("Scheduled processor did not terminate in time");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            LOGGER.error("Service shutdown interrupted", e);
        }
        
        LOGGER.info("NotificationService shutdown complete");
    }
    
    /**
     * Send a notification immediately.
     * 
     * @param notification The notification to send
     * @return The notification ID
     */
    public String sendNotification(NotificationEvent notification) {
        if (!isRunning.get()) {
            throw new IllegalStateException("NotificationService is not running");
        }
        
        // Add to queue for processing
        notificationQueue.add(notification);
        
        // If persistent, add to history
        if (notification.isPersistent()) {
            addToHistory(notification);
        }
        
        return notification.getId();
    }
    
    /**
     * Schedule a notification to be sent after a delay.
     * 
     * @param notification The notification to send
     * @param delayMillis The delay in milliseconds
     * @return The notification ID
     */
    public String scheduleNotification(NotificationEvent notification, long delayMillis) {
        if (!isRunning.get()) {
            throw new IllegalStateException("NotificationService is not running");
        }
        
        if (delayMillis <= 0) {
            return sendNotification(notification);
        }
        
        ScheduledNotification scheduledNotification = new ScheduledNotification(notification, delayMillis);
        scheduledNotifications.add(scheduledNotification);
        
        return notification.getId();
    }
    
    /**
     * Create a notification builder.
     * 
     * @return A new notification builder instance
     */
    public NotificationEvent.Builder createNotification() {
        return new NotificationEvent.Builder();
    }
    
    /**
     * Create a simple notification with default values.
     * 
     * @param title The notification title
     * @param message The notification message
     * @param type The notification type
     * @return The notification instance
     */
    public NotificationEvent createSimpleNotification(String title, String message, NotificationType type) {
        return new NotificationEvent.Builder()
                .title(title)
                .message(message)
                .type(type)
                .build();
    }
    
    /**
     * Subscribe to notifications.
     * 
     * @param sessionId The WebSocket session ID
     * @param types List of notification types to subscribe to (empty for all)
     * @param categories List of categories to subscribe to (empty for all)
     * @param sources List of sources to subscribe to (empty for all)
     * @param minPriority Minimum priority level
     * @param filters Additional filters as key-value pairs
     * @param includeHistory Whether to include notification history
     * @param historySize Max number of history items to include
     * @return The subscription ID
     */
    public String subscribe(String sessionId, List<NotificationType> types, 
            List<String> categories, List<String> sources, PriorityLevel minPriority,
            Map<String, Object> filters, boolean includeHistory, int historySize) {
        
        if (!isRunning.get()) {
            throw new IllegalStateException("NotificationService is not running");
        }
        
        String subscriptionId = UUID.randomUUID().toString();
        
        NotificationSubscription subscription = new NotificationSubscription(
                subscriptionId, sessionId, types, categories, sources, 
                minPriority, filters, includeHistory, historySize);
        
        // Add to subscriptions
        subscriptions.computeIfAbsent(sessionId, k -> new ArrayList<>()).add(subscription);
        
        // Send history if requested
        if (includeHistory) {
            sendNotificationHistory(subscription);
        }
        
        LOGGER.info("Session " + sessionId + " subscribed to notifications with ID: " + subscriptionId);
        return subscriptionId;
    }
    
    /**
     * Unsubscribe from notifications.
     * 
     * @param sessionId The WebSocket session ID
     * @param subscriptionId The subscription ID (null to unsubscribe from all)
     * @return true if successfully unsubscribed, false otherwise
     */
    public boolean unsubscribe(String sessionId, String subscriptionId) {
        if (!isRunning.get()) {
            return false;
        }
        
        List<NotificationSubscription> sessionSubscriptions = subscriptions.get(sessionId);
        if (sessionSubscriptions == null || sessionSubscriptions.isEmpty()) {
            return false;
        }
        
        if (subscriptionId == null) {
            // Unsubscribe from all
            subscriptions.remove(sessionId);
            LOGGER.info("Session " + sessionId + " unsubscribed from all notifications");
            return true;
        } else {
            // Unsubscribe from specific subscription
            boolean removed = sessionSubscriptions.removeIf(sub -> sub.getSubscriptionId().equals(subscriptionId));
            
            if (removed) {
                // Remove the session if no more subscriptions
                if (sessionSubscriptions.isEmpty()) {
                    subscriptions.remove(sessionId);
                }
                
                LOGGER.info("Session " + sessionId + " unsubscribed from notifications with ID: " + subscriptionId);
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Get notification history.
     * 
     * @param sessionId The WebSocket session ID
     * @param types List of notification types to filter by (empty for all)
     * @param categories List of categories to filter by (empty for all)
     * @param sources List of sources to filter by (empty for all)
     * @param minPriority Minimum priority level
     * @param limit Maximum number of notifications to return
     * @return List of notification events matching the criteria
     */
    public List<NotificationEvent> getNotificationHistory(String sessionId, 
            List<NotificationType> types, List<String> categories, List<String> sources, 
            PriorityLevel minPriority, int limit) {
        
        if (!isRunning.get()) {
            return new ArrayList<>();
        }
        
        List<NotificationEvent> result = new ArrayList<>();
        
        // Define filters
        Predicate<NotificationEvent> typesFilter = types.isEmpty() ? 
                e -> true : e -> types.contains(e.getType());
                
        Predicate<NotificationEvent> categoriesFilter = categories.isEmpty() ? 
                e -> true : e -> categories.contains(e.getCategory());
                
        Predicate<NotificationEvent> sourcesFilter = sources.isEmpty() ? 
                e -> true : e -> sources.contains(e.getSource());
                
        Predicate<NotificationEvent> priorityFilter = e -> 
                e.getPriority().getValue() >= minPriority.getValue();
                
        Predicate<NotificationEvent> sessionFilter = e -> 
                e.getTargetSessions().isEmpty() || e.getTargetSessions().contains(sessionId);
        
        // Apply filters
        historyLock.readLock().lock();
        try {
            // Collect all notifications from global and session-specific history
            List<NotificationEvent> allNotifications = new ArrayList<>();
            
            // Add global notifications
            List<NotificationEvent> globalHistory = notificationHistory.get(CSConstants.GLOBAL_HISTORY_KEY);
            if (globalHistory != null) {
                allNotifications.addAll(globalHistory);
            }
            
            // Add session-specific notifications
            List<NotificationEvent> sessionHistory = notificationHistory.get(sessionId);
            if (sessionHistory != null) {
                allNotifications.addAll(sessionHistory);
            }
            
            // Filter and limit
            result = allNotifications.stream()
                    .filter(typesFilter)
                    .filter(categoriesFilter)
                    .filter(sourcesFilter)
                    .filter(priorityFilter)
                    .filter(sessionFilter)
                    .sorted((a, b) -> Long.compare(b.getTimestamp(), a.getTimestamp())) // Newest first
                    .limit(limit > 0 ? limit : DEFAULT_HISTORY_SIZE)
                    .collect(Collectors.toList());
        } finally {
            historyLock.readLock().unlock();
        }
        
        return result;
    }
    
    /**
     * Mark a notification as read.
     * 
     * @param notificationId The notification ID
     * @param sessionId The session ID
     * @return true if successfully marked as read, false otherwise
     */
    public boolean markAsRead(String notificationId, String sessionId) {
        if (!isRunning.get()) {
            return false;
        }
        
        boolean found = false;
        
        historyLock.writeLock().lock();
        try {
            // Check global history
            found = updateNotificationStatus(notificationId, CSConstants.GLOBAL_HISTORY_KEY, true, false, null, sessionId);
            
            // Check session-specific history if not found
            if (!found) {
                found = updateNotificationStatus(notificationId, sessionId, true, false, null, sessionId);
            }
        } finally {
            historyLock.writeLock().unlock();
        }
        
        return found;
    }
    
    /**
     * Mark a notification as acknowledged.
     * 
     * @param notificationId The notification ID
     * @param sessionId The session ID
     * @param acknowledgedBy The user who acknowledged the notification
     * @return true if successfully acknowledged, false otherwise
     */
    public boolean acknowledgeNotification(String notificationId, String sessionId, String acknowledgedBy) {
        if (!isRunning.get()) {
            return false;
        }
        
        boolean found = false;
        
        historyLock.writeLock().lock();
        try {
            // Check global history
            found = updateNotificationStatus(notificationId, CSConstants.GLOBAL_HISTORY_KEY, true, true, acknowledgedBy, sessionId);
            
            // Check session-specific history if not found
            if (!found) {
                found = updateNotificationStatus(notificationId, sessionId, true, true, acknowledgedBy, sessionId);
            }
        } finally {
            historyLock.writeLock().unlock();
        }
        
        return found;
    }
    
    /**
     * Delete a notification from history.
     * 
     * @param notificationId The notification ID
     * @param sessionId The session ID
     * @return true if successfully deleted, false otherwise
     */
    public boolean deleteNotification(String notificationId, String sessionId) {
        if (!isRunning.get()) {
            return false;
        }
        
        boolean found = false;
        
        historyLock.writeLock().lock();
        try {
            // Check global history
            List<NotificationEvent> globalHistory = notificationHistory.get(CSConstants.GLOBAL_HISTORY_KEY);
            if (globalHistory != null) {
                found = globalHistory.removeIf(n -> n.getId().equals(notificationId));
            }
            
            // Check session-specific history if not found
            if (!found) {
                List<NotificationEvent> sessionHistory = notificationHistory.get(sessionId);
                if (sessionHistory != null) {
                    found = sessionHistory.removeIf(n -> n.getId().equals(notificationId));
                }
            }
        } finally {
            historyLock.writeLock().unlock();
        }
        
        return found;
    }
    
    /**
     * Clear all notifications for a session.
     * 
     * @param sessionId The session ID
     * @return The number of notifications cleared
     */
    public int clearNotifications(String sessionId) {
        if (!isRunning.get()) {
            return 0;
        }
        
        int count = 0;
        
        historyLock.writeLock().lock();
        try {
            List<NotificationEvent> sessionHistory = notificationHistory.get(sessionId);
            if (sessionHistory != null) {
                count = sessionHistory.size();
                sessionHistory.clear();
            }
        } finally {
            historyLock.writeLock().unlock();
        }
        
        return count;
    }
    
    /**
     * Send a test notification to a session.
     * 
     * @param sessionId The session ID
     * @return The notification ID
     */
    public String sendTestNotification(String sessionId) {
        NotificationEvent notification = new NotificationEvent.Builder()
                .title("Test Notification")
                .message("This is a test notification from the NotificationService.")
                .type(NotificationType.SYSTEM)
                .priority(PriorityLevel.LOW)
                .targetSession(sessionId)
                .timestamp(Instant.now().toEpochMilli())
                .build();
        
        return sendNotification(notification);
    }
    
    /**
     * Process notifications from the queue.
     */
    private void processNotifications() {
        LOGGER.info("Starting notification processor");
        
        while (isRunning.get()) {
            try {
                List<NotificationEvent> batch = new ArrayList<>(MAX_BATCH_SIZE);
                
                // Get the next notification (blocking)
                NotificationEvent notification = notificationQueue.take();
                batch.add(notification);
                
                // Drain more notifications if available (non-blocking)
                notificationQueue.drainTo(batch, MAX_BATCH_SIZE - 1);
                
                // Process the batch
                for (NotificationEvent event : batch) {
                    // Global notification (no specific targets)
                    if (event.getTargetSessions().isEmpty() && event.getTargetGroups().isEmpty()) {
                        broadcastNotification(event);
                    } else {
                        // Targeted notification
                        sendTargetedNotification(event);
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                LOGGER.debug("Notification processor interrupted");
                break;
            } catch (Exception e) {
                LOGGER.error("Error processing notification", e);
            }
        }
        
        LOGGER.info("Notification processor stopped");
    }
    
    /**
     * Process scheduled notifications.
     */
    private void processScheduledNotifications() {
        LOGGER.info("Starting scheduled notification processor");
        
        while (isRunning.get()) {
            try {
                // Take the next scheduled notification that's ready (blocking)
                ScheduledNotification scheduledNotification = scheduledNotifications.take();
                
                // Add to the regular notification queue
                notificationQueue.add(scheduledNotification.getEvent());
                
                // Sleep a bit to avoid busy-waiting if there are many notifications
                if (scheduledNotifications.isEmpty()) {
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                LOGGER.debug("Scheduled notification processor interrupted");
                break;
            } catch (Exception e) {
                LOGGER.error("Error processing scheduled notification", e);
            }
        }
        
        LOGGER.info("Scheduled notification processor stopped");
    }
    
    /**
     * Broadcast a notification to all subscribed sessions.
     * 
     * @param notification The notification to broadcast
     */
    private void broadcastNotification(NotificationEvent notification) {
        // For each session with subscriptions
        for (Map.Entry<String, List<NotificationSubscription>> entry : subscriptions.entrySet()) {
            String sessionId = entry.getKey();
            List<NotificationSubscription> sessionSubscriptions = entry.getValue();
            
            // Check if any subscription matches
            boolean matched = false;
            for (NotificationSubscription subscription : sessionSubscriptions) {
                if (subscription.matches(notification)) {
                    matched = true;
                    break;
                }
            }
            
            // Send if matched
            if (matched) {
                sendNotificationToSession(notification, sessionId);
            }
        }
    }
    
    /**
     * Send a targeted notification to specific sessions or groups.
     * 
     * @param notification The notification to send
     */
    private void sendTargetedNotification(NotificationEvent notification) {
        // Target specific sessions
        for (String sessionId : notification.getTargetSessions()) {
            sendNotificationToSession(notification, sessionId);
        }
    }
    
    /**
     * Send a notification to a specific session.
     * 
     * @param notification The notification to send
     * @param sessionId The session ID to send to
     */
    private void sendNotificationToSession(NotificationEvent notification, String sessionId) {
        try {
            // Create WebSocket message
            NotificationMessage message = new NotificationMessage();
            message.setNotification(notification.toMap());
            message.setTimestamp(Instant.now().toEpochMilli());
            
            WebSocketMessage wsMessage = new WebSocketMessage();
            wsMessage.setType(MessageType.NOTIFICATION);
            wsMessage.setData(message);
            
            // Send message
            messagePublisher.sendMessageToSession(sessionId, wsMessage);
        } catch (Exception e) {
            LOGGER.error("Error sending notification to session: " + sessionId, e);
        }
    }
    
    /**
     * Add a notification to history.
     * 
     * @param notification The notification to add
     */
    private void addToHistory(NotificationEvent notification) {
        historyLock.writeLock().lock();
        try {
            // For global history
            if (notification.getTargetSessions().isEmpty()) {
                notificationHistory.computeIfAbsent(CSConstants.GLOBAL_HISTORY_KEY, k -> new LinkedList<>())
                    .add(0, notification); // Add to the beginning (newest first)
                
                // Trim if necessary
                trimHistory(CSConstants.GLOBAL_HISTORY_KEY);
            }
            
            // For each target session
            for (String sessionId : notification.getTargetSessions()) {
                notificationHistory.computeIfAbsent(sessionId, k -> new LinkedList<>())
                    .add(0, notification); // Add to the beginning (newest first)
                
                // Trim if necessary
                trimHistory(sessionId);
            }
        } finally {
            historyLock.writeLock().unlock();
        }
    }
    
    /**
     * Trim history to limit its size.
     * 
     * @param historyKey The history key to trim
     */
    private void trimHistory(String historyKey) {
        List<NotificationEvent> history = notificationHistory.get(historyKey);
        if (history != null && history.size() > DEFAULT_HISTORY_SIZE) {
            while (history.size() > DEFAULT_HISTORY_SIZE) {
                history.remove(history.size() - 1); // Remove the oldest
            }
        }
    }
    
    /**
     * Update notification status (read/acknowledged).
     * 
     * @param notificationId The notification ID
     * @param historyKey The history key
     * @param markRead Whether to mark as read
     * @param markAcknowledged Whether to mark as acknowledged
     * @param acknowledgedBy Who acknowledged the notification
     * @param sessionId The session ID
     * @return true if the notification was found and updated, false otherwise
     */
    private boolean updateNotificationStatus(String notificationId, String historyKey, 
            boolean markRead, boolean markAcknowledged, String acknowledgedBy, String sessionId) {
        
        List<NotificationEvent> history = notificationHistory.get(historyKey);
        if (history == null) {
            return false;
        }
        
        for (NotificationEvent notification : history) {
            if (notification.getId().equals(notificationId)) {
                if (markRead) {
                    notification.setRead(true);
                }
                
                if (markAcknowledged) {
                    notification.setAcknowledged(true);
                    notification.setAcknowledgedTimestamp(Instant.now().toEpochMilli());
                    notification.setAcknowledgedBy(acknowledgedBy);
                    
                    // Create an acknowledgement notification for audit purposes
                    NotificationEvent ackNotification = new NotificationEvent.Builder()
                            .title("Notification Acknowledged")
                            .message("Notification \"" + notification.getTitle() + "\" was acknowledged by " + acknowledgedBy)
                            .type(NotificationType.SYSTEM)
                            .priority(PriorityLevel.LOW)
                            .targetSession(sessionId)
                            .addData("originalNotificationId", notificationId)
                            .addData("acknowledgedBy", acknowledgedBy)
                            .build();
                    
                    sendNotification(ackNotification);
                }
                
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Send notification history to a subscription.
     * 
     * @param subscription The subscription to send history to
     */
    private void sendNotificationHistory(NotificationSubscription subscription) {
        List<NotificationEvent> history = getNotificationHistory(
                subscription.getSessionId(),
                subscription.getTypes(),
                subscription.getCategories(),
                subscription.getSources(),
                subscription.getMinPriority(),
                subscription.getHistorySize());
        
        // Send each historical notification
        for (NotificationEvent notification : history) {
            sendNotificationToSession(notification, subscription.getSessionId());
        }
    }
    
    /**
     * Register a session disconnection to clean up resources.
     * 
     * @param sessionId The session ID that disconnected
     */
    public void handleSessionDisconnect(String sessionId) {
        // Unsubscribe from all notifications
        unsubscribe(sessionId, null);
        
        // Clean up session-specific history
        historyLock.writeLock().lock();
        try {
            notificationHistory.remove(sessionId);
        } finally {
            historyLock.writeLock().unlock();
        }
        
        LOGGER.info("Cleaned up resources for disconnected session: " + sessionId);
    }
}


ExecutionUpdateMessage.java
---------------------------------

Predicate<NotificationEvent> sourcesFilter = sources.isEmpty() ? 
                e -> true : e -> sources.contains(e.getSource());
                
        Predicate<NotificationEvent> priorityFilter = e -> 
                e.getPriority().getValue() >= minPriority.getValue();
                
        Predicate<NotificationEvent> sessionFilter = e -> 
                e.getTargetSessions().isEmpty() || e.getTargetSessions().contains(sessionId);
        
        // Apply filters
        historyLock.readLock().lock();
        try {
            // Collect all notifications from global and session-specific history
            List<NotificationEvent> allNotifications = new ArrayList<>();
            
            // Add global notifications
            List<NotificationEvent> globalHistory = notificationHistory.get(CSConstants.GLOBAL_HISTORY_KEY);
            if (globalHistory != null) {
                allNotifications.addAll(globalHistory);
            }
            
            // Add session-specific notifications
            List<NotificationEvent> sessionHistory = notificationHistory.get(sessionId);
            if (sessionHistory != null) {
                allNotifications.addAll(sessionHistory);
            }
            
            // Filter and limit
            result = allNotifications.stream()
                    .filter(typesFilter)
                    .filter(categoriesFilter)
                    .filter(sourcesFilter)
                    .filter(priorityFilter)
                    .filter(sessionFilter)
                    .sorted((a, b) -> Long.compare(b.getTimestamp(), a.getTimestamp())) // Newest first
                    .limit(limit > 0 ? limit : DEFAULT_HISTORY_SIZE)
                    .collect(Collectors.toList());
        } finally {
            historyLock.readLock().unlock();
        }
        
        return result;
    }
    
    /**
     * Mark a notification as read.
     * 
     * @param notificationId The notification ID
     * @param sessionId The session ID
     * @return true if successfully marked as read, false otherwise
     */
    public boolean markAsRead(String notificationId, String sessionId) {
        if (!isRunning.get()) {
            return false;
        }
        
        boolean found = false;
        
        historyLock.writeLock().lock();
        try {
            // Check global history
            found = updateNotificationStatus(notificationId, CSConstants.GLOBAL_HISTORY_KEY, true, false, null, sessionId);
            
            // Check session-specific history if not found
            if (!found) {
                found = updateNotificationStatus(notificationId, sessionId, true, false, null, sessionId);
            }
        } finally {
            historyLock.writeLock().unlock();
        }
        
        return found;
    }
    
    /**
     * Mark a notification as acknowledged.
     * 
     * @param notificationId The notification ID
     * @param sessionId The session ID
     * @param acknowledgedBy The user who acknowledged the notification
     * @return true if successfully acknowledged, false otherwise
     */
    public boolean acknowledgeNotification(String notificationId, String sessionId, String acknowledgedBy) {
        if (!isRunning.get()) {
            return false;
        }
        
        boolean found = false;
        
        historyLock.writeLock().lock();
        try {
            // Check global history
            found = updateNotificationStatus(notificationId, CSConstants.GLOBAL_HISTORY_KEY, true, true, acknowledgedBy, sessionId);
            
            // Check session-specific history if not found
            if (!found) {
                found = updateNotificationStatus(notificationId, sessionId, true, true, acknowledgedBy, sessionId);
            }
        } finally {
            historyLock.writeLock().unlock();
        }
        
        return found;
    }
    
    /**
     * Delete a notification from history.
     * 
     * @param notificationId The notification ID
     * @param sessionId The session ID
     * @return true if successfully deleted, false otherwise
     */
    public boolean deleteNotification(String notificationId, String sessionId) {
        if (!isRunning.get()) {
            return false;
        }
        
        boolean found = false;
        
        historyLock.writeLock().lock();
        try {
            // Check global history
            List<NotificationEvent> globalHistory = notificationHistory.get(CSConstants.GLOBAL_HISTORY_KEY);
            if (globalHistory != null) {
                found = globalHistory.removeIf(n -> n.getId().equals(notificationId));
            }
            
            // Check session-specific history if not found
            if (!found) {
                List<NotificationEvent> sessionHistory = notificationHistory.get(sessionId);
                if (sessionHistory != null) {
                    found = sessionHistory.removeIf(n -> n.getId().equals(notificationId));
                }
            }
        } finally {
            historyLock.writeLock().unlock();
        }
        
        return found;
    }
    
    /**
     * Clear all notifications for a session.
     * 
     * @param sessionId The session ID
     * @return The number of notifications cleared
     */
    public int clearNotifications(String sessionId) {
        if (!isRunning.get()) {
            return 0;
        }
        
        int count = 0;
        
        historyLock.writeLock().lock();
        try {
            List<NotificationEvent> sessionHistory = notificationHistory.get(sessionId);
            if (sessionHistory != null) {
                count = sessionHistory.size();
                sessionHistory.clear();
            }
        } finally {
            historyLock.writeLock().unlock();
        }
        
        return count;
    }
    
    /**
     * Send a test notification to a session.
     * 
     * @param sessionId The session ID
     * @return The notification ID
     */
    public String sendTestNotification(String sessionId) {
        NotificationEvent notification = new NotificationEvent.Builder()
                .title("Test Notification")
                .message("This is a test notification from the NotificationService.")
                .type(NotificationType.SYSTEM)
                .priority(PriorityLevel.LOW)
                .targetSession(sessionId)
                .timestamp(Instant.now().toEpochMilli())
                .build();
        
        return sendNotification(notification);
    }
    
    /**
     * Process notifications from the queue.
     */
    private void processNotifications() {
        LOGGER.info("Starting notification processor");
        
        while (isRunning.get()) {
            try {
                List<NotificationEvent> batch = new ArrayList<>(MAX_BATCH_SIZE);
                
                // Get the next notification (blocking)
                NotificationEvent notification = notificationQueue.take();
                batch.add(notification);
                
                // Drain more notifications if available (non-blocking)
                notificationQueue.drainTo(batch, MAX_BATCH_SIZE - 1);
                
                // Process the batch
                for (NotificationEvent event : batch) {
                    // Global notification (no specific targets)
                    if (event.getTargetSessions().isEmpty() && event.getTargetGroups().isEmpty()) {
                        broadcastNotification(event);
                    } else {
                        // Targeted notification
                        sendTargetedNotification(event);
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                LOGGER.debug("Notification processor interrupted");
                break;
            } catch (Exception e) {
                LOGGER.error("Error processing notification", e);
            }
        }
        
        LOGGER.info("Notification processor stopped");
    }
    
    /**
     * Process scheduled notifications.
     */
    private void processScheduledNotifications() {
        LOGGER.info("Starting scheduled notification processor");
        
        while (isRunning.get()) {
            try {
                // Take the next scheduled notification that's ready (blocking)
                ScheduledNotification scheduledNotification = scheduledNotifications.take();
                
                // Add to the regular notification queue
                notificationQueue.add(scheduledNotification.getEvent());
                
                // Sleep a bit to avoid busy-waiting if there are many notifications
                if (scheduledNotifications.isEmpty()) {
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                LOGGER.debug("Scheduled notification processor interrupted");
                break;
            } catch (Exception e) {
                LOGGER.error("Error processing scheduled notification", e);
            }
        }
        
        LOGGER.info("Scheduled notification processor stopped");
    }
    
    /**
     * Broadcast a notification to all subscribed sessions.
     * 
     * @param notification The notification to broadcast
     */
    private void broadcastNotification(NotificationEvent notification) {
        // For each session with subscriptions
        for (Map.Entry<String, List<NotificationSubscription>> entry : subscriptions.entrySet()) {
            String sessionId = entry.getKey();
            List<NotificationSubscription> sessionSubscriptions = entry.getValue();
            
            // Check if any subscription matches
            boolean matched = false;
            for (NotificationSubscription subscription : sessionSubscriptions) {
                if (subscription.matches(notification)) {
                    matched = true;
                    break;
                }
            }
            
            // Send if matched
            if (matched) {
                sendNotificationToSession(notification, sessionId);
            }
        }
    }
    
    /**
     * Send a targeted notification to specific sessions or groups.
     * 
     * @param notification The notification to send
     */
    private void sendTargetedNotification(NotificationEvent notification) {
        // Target specific sessions
        for (String sessionId : notification.getTargetSessions()) {
            sendNotificationToSession(notification, sessionId);
        }
    }
    
    /**
     * Send a notification to a specific session.
     * 
     * @param notification The notification to send
     * @param sessionId The session ID to send to
     */
    private void sendNotificationToSession(NotificationEvent notification, String sessionId) {
        try {
            // Create WebSocket message
            NotificationMessage message = new NotificationMessage();
            message.setNotification(notification.toMap());
            message.setTimestamp(Instant.now().toEpochMilli());
            
            WebSocketMessage wsMessage = new WebSocketMessage();
            wsMessage.setType(MessageType.NOTIFICATION);
            wsMessage.setData(message);
            
            // Send message
            messagePublisher.sendMessageToSession(sessionId, wsMessage);
        } catch (Exception e) {
            LOGGER.error("Error sending notification to session: " + sessionId, e);
        }
    }
    
    /**
     * Add a notification to history.
     * 
     * @param notification The notification to add
     */
    private void addToHistory(NotificationEvent notification) {
        historyLock.writeLock().lock();
        try {
            // For global history
            if (notification.getTargetSessions().isEmpty()) {
                notificationHistory.computeIfAbsent(CSConstants.GLOBAL_HISTORY_KEY, k -> new LinkedList<>())
                    .add(0, notification); // Add to the beginning (newest first)
                
                // Trim if necessary
                trimHistory(CSConstants.GLOBAL_HISTORY_KEY);
            }
            
            // For each target session
            for (String sessionId : notification.getTargetSessions()) {
                notificationHistory.computeIfAbsent(sessionId, k -> new LinkedList<>())
                    .add(0, notification); // Add to the beginning (newest first)
                
                // Trim if necessary
                trimHistory(sessionId);
            }
        } finally {
            historyLock.writeLock().unlock();
        }
    }
    
    /**
     * Trim history to limit its size.
     * 
     * @param historyKey The history key to trim
     */
    private void trimHistory(String historyKey) {
        List<NotificationEvent> history = notificationHistory.get(historyKey);
        if (history != null && history.size() > DEFAULT_HISTORY_SIZE) {
            while (history.size() > DEFAULT_HISTORY_SIZE) {
                history.remove(history.size() - 1); // Remove the oldest
            }
        }
    }
    
    /**
     * Update notification status (read/acknowledged).
     * 
     * @param notificationId The notification ID
     * @param historyKey The history key
     * @param markRead Whether to mark as read
     * @param markAcknowledged Whether to mark as acknowledged
     * @param acknowledgedBy Who acknowledged the notification
     * @param sessionId The session ID
     * @return true if the notification was found and updated, false otherwise
     */
    private boolean updateNotificationStatus(String notificationId, String historyKey, 
            boolean markRead, boolean markAcknowledged, String acknowledgedBy, String sessionId) {
        
        List<NotificationEvent> history = notificationHistory.get(historyKey);
        if (history == null) {
            return false;
        }
        
        for (NotificationEvent notification : history) {
            if (notification.getId().equals(notificationId)) {
                if (markRead) {
                    notification.setRead(true);
                }
                
                if (markAcknowledged) {
                    notification.setAcknowledged(true);
                    notification.setAcknowledgedTimestamp(Instant.now().toEpochMilli());
                    notification.setAcknowledgedBy(acknowledgedBy);
                    
                    // Create an acknowledgement notification for audit purposes
                    NotificationEvent ackNotification = new NotificationEvent.Builder()
                            .title("Notification Acknowledged")
                            .message("Notification \"" + notification.getTitle() + "\" was acknowledged by " + acknowledgedBy)
                            .type(NotificationType.SYSTEM)
                            .priority(PriorityLevel.LOW)
                            .targetSession(sessionId)
                            .addData("originalNotificationId", notificationId)
                            .addData("acknowledgedBy", acknowledgedBy)
                            .build();
                    
                    sendNotification(ackNotification);
                }
                
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Send notification history to a subscription.
     * 
     * @param subscription The subscription to send history to
     */
    private void sendNotificationHistory(NotificationSubscription subscription) {
        List<NotificationEvent> history = getNotificationHistory(
                subscription.getSessionId(),
                subscription.getTypes(),
                subscription.getCategories(),
                subscription.getSources(),
                subscription.getMinPriority(),
                subscription.getHistorySize());
        
        // Send each historical notification
        for (NotificationEvent notification : history) {
            sendNotificationToSession(notification, subscription.getSessionId());
        }
    }
    
    /**
     * Register a session disconnection to clean up resources.
     * 
     * @param sessionId The session ID that disconnected
     */
    public void handleSessionDisconnect(String sessionId) {
        // Unsubscribe from all notifications
        unsubscribe(sessionId, null);
        
        // Clean up session-specific history
        historyLock.writeLock().lock();
        try {
            notificationHistory.remove(sessionId);
        } finally {
            historyLock.writeLock().unlock();
        }
        
        LOGGER.info("Cleaned up resources for disconnected session: " + sessionId);
    }
}

LogMessage.java
------------------------------

package com.cstestforge.model.websocket;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Message class for real-time log streaming.
 * Contains log entries and related metadata for transmission via WebSocket.
 */
public class LogMessage {

    private String streamId;
    private long timestamp;
    private List<Map<String, Object>> entries;
    private boolean hasMore;
    private Map<String, Object> metadata;
    
    /**
     * Default constructor.
     */
    public LogMessage() {
        this.entries = new ArrayList<>();
        this.hasMore = false;
    }
    
    /**
     * Constructor with streamId and timestamp.
     * 
     * @param streamId The log stream ID
     * @param timestamp The message timestamp
     */
    public LogMessage(String streamId, long timestamp) {
        this.streamId = streamId;
        this.timestamp = timestamp;
        this.entries = new ArrayList<>();
        this.hasMore = false;
    }
    
    /**
     * Constructor with all fields.
     * 
     * @param streamId The log stream ID
     * @param timestamp The message timestamp
     * @param entries The log entries
     * @param hasMore Whether there are more entries available
     * @param metadata Additional metadata
     */
    public LogMessage(String streamId, long timestamp, List<Map<String, Object>> entries, 
            boolean hasMore, Map<String, Object> metadata) {
        this.streamId = streamId;
        this.timestamp = timestamp;
        this.entries = entries;
        this.hasMore = hasMore;
        this.metadata = metadata;
    }
    
    /**
     * Get the stream ID.
     * 
     * @return The stream ID
     */
    public String getStreamId() {
        return streamId;
    }
    
    /**
     * Set the stream ID.
     * 
     * @param streamId The stream ID
     */
    public void setStreamId(String streamId) {
        this.streamId = streamId;
    }
    
    /**
     * Get the timestamp.
     * 
     * @return The timestamp
     */
    public long getTimestamp() {
        return timestamp;
    }
    
    /**
     * Set the timestamp.
     * 
     * @param timestamp The timestamp
     */
    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }
    
    /**
     * Get the log entries.
     * 
     * @return The log entries
     */
    public List<Map<String, Object>> getEntries() {
        return entries;
    }
    
    /**
     * Set the log entries.
     * 
     * @param entries The log entries
     */
    public void setEntries(List<Map<String, Object>> entries) {
        this.entries = entries;
    }
    
    /**
     * Add a log entry.
     * 
     * @param entry The log entry to add
     */
    public void addEntry(Map<String, Object> entry) {
        if (this.entries == null) {
            this.entries = new ArrayList<>();
        }
        this.entries.add(entry);
    }
    
    /**
     * Get whether there are more entries available.
     * 
     * @return true if there are more entries, false otherwise
     */
    public boolean isHasMore() {
        return hasMore;
    }
    
    /**
     * Set whether there are more entries available.
     * 
     * @param hasMore Whether there are more entries
     */
    public void setHasMore(boolean hasMore) {
        this.hasMore = hasMore;
    }
    
    /**
     * Get the metadata.
     * 
     * @return The metadata
     */
    public Map<String, Object> getMetadata() {
        return metadata;
    }
    
    /**
     * Set the metadata.
     * 
     * @param metadata The metadata
     */
    public void setMetadata(Map<String, Object> metadata) {
        this.metadata = metadata;
    }
    
    /**
     * Get the number of entries.
     * 
     * @return The number of entries
     */
    public int getEntryCount() {
        return entries != null ? entries.size() : 0;
    }
    
    /**
     * Check if the message is empty (no entries).
     * 
     * @return true if the message is empty, false otherwise
     */
    public boolean isEmpty() {
        return entries == null || entries.isEmpty();
    }
    
    @Override
    public String toString() {
        return "LogMessage{" +
                "streamId='" + streamId + '\'' +
                ", timestamp=" + timestamp +
                ", entries=" + (entries != null ? entries.size() : 0) +
                ", hasMore=" + hasMore +
                '}';
    }
}

ResourceMetricsMessage.java
--------------------------------------------------

package com.cstestforge.model.websocket;

import java.util.HashMap;
import java.util.Map;

/**
 * Message class for system resource metrics.
 * Contains CPU, memory, disk I/O, and other system resource metrics.
 */
public class ResourceMetricsMessage {

    private String monitoringId;
    private long timestamp;
    private Map<String, Double> metrics;
    private Map<String, Object> metadata;
    private String hostname;
    private String environment;
    private boolean aggregated;
    
    /**
     * Default constructor.
     */
    public ResourceMetricsMessage() {
        this.metrics = new HashMap<>();
        this.metadata = new HashMap<>();
        this.aggregated = false;
    }
    
    /**
     * Constructor with monitoringId and timestamp.
     * 
     * @param monitoringId The resource monitoring ID
     * @param timestamp The message timestamp
     */
    public ResourceMetricsMessage(String monitoringId, long timestamp) {
        this.monitoringId = monitoringId;
        this.timestamp = timestamp;
        this.metrics = new HashMap<>();
        this.metadata = new HashMap<>();
        this.aggregated = false;
    }
    
    /**
     * Constructor with all fields.
     * 
     * @param monitoringId The resource monitoring ID
     * @param timestamp The message timestamp
     * @param metrics The resource metrics
     * @param metadata Additional metadata
     * @param hostname The hostname
     * @param environment The environment
     * @param aggregated Whether the metrics are aggregated
     */
    public ResourceMetricsMessage(String monitoringId, long timestamp, Map<String, Double> metrics,
            Map<String, Object> metadata, String hostname, String environment, boolean aggregated) {
        this.monitoringId = monitoringId;
        this.timestamp = timestamp;
        this.metrics = metrics;
        this.metadata = metadata;
        this.hostname = hostname;
        this.environment = environment;
        this.aggregated = aggregated;
    }
    
    /**
     * Get the monitoring ID.
     * 
     * @return The monitoring ID
     */
    public String getMonitoringId() {
        return monitoringId;
    }
    
    /**
     * Set the monitoring ID.
     * 
     * @param monitoringId The monitoring ID
     */
    public void setMonitoringId(String monitoringId) {
        this.monitoringId = monitoringId;
    }
    
    /**
     * Get the timestamp.
     * 
     * @return The timestamp
     */
    public long getTimestamp() {
        return timestamp;
    }
    
    /**
     * Set the timestamp.
     * 
     * @param timestamp The timestamp
     */
    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }
    
    /**
     * Get the metrics.
     * 
     * @return The metrics
     */
    public Map<String, Double> getMetrics() {
        return metrics;
    }
    
    /**
     * Set the metrics.
     * 
     * @param metrics The metrics
     */
    public void setMetrics(Map<String, Double> metrics) {
        this.metrics = metrics;
    }
    
    /**
     * Add a metric.
     * 
     * @param key The metric name
     * @param value The metric value
     */
    public void addMetric(String key, Double value) {
        if (this.metrics == null) {
            this.metrics = new HashMap<>();
        }
        this.metrics.put(key, value);
    }
    
    /**
     * Get a specific metric.
     * 
     * @param key The metric name
     * @return The metric value, or null if not found
     */
    public Double getMetric(String key) {
        return metrics != null ? metrics.get(key) : null;
    }
    
    /**
     * Get the metadata.
     * 
     * @return The metadata
     */
    public Map<String, Object> getMetadata() {
        return metadata;
    }
    
    /**
     * Set the metadata.
     * 
     * @param metadata The metadata
     */
    public void setMetadata(Map<String, Object> metadata) {
        this.metadata = metadata;
    }
    
    /**
     * Add metadata.
     * 
     * @param key The metadata key
     * @param value The metadata value
     */
    public void addMetadata(String key, Object value) {
        if (this.metadata == null) {
            this.metadata = new HashMap<>();
        }
        this.metadata.put(key, value);
    }
    
    /**
     * Get the hostname.
     * 
     * @return The hostname
     */
    public String getHostname() {
        return hostname;
    }
    
    /**
     * Set the hostname.
     * 
     * @param hostname The hostname
     */
    public void setHostname(String hostname) {
        this.hostname = hostname;
    }
    
    /**
     * Get the environment.
     * 
     * @return The environment
     */
    public String getEnvironment() {
        return environment;
    }
    
    /**
     * Set the environment.
     * 
     * @param environment The environment
     */
    public void setEnvironment(String environment) {
        this.environment = environment;
    }
    
    /**
     * Check if the metrics are aggregated.
     * 
     * @return true if the metrics are aggregated, false otherwise
     */
    public boolean isAggregated() {
        return aggregated;
    }
    
    /**
     * Set whether the metrics are aggregated.
     * 
     * @param aggregated Whether the metrics are aggregated
     */
    public void setAggregated(boolean aggregated) {
        this.aggregated = aggregated;
    }
    
    /**
     * Get CPU usage metric.
     * 
     * @return The CPU usage as a percentage (0-100)
     */
    public Double getCpuUsage() {
        return getMetric("cpuUsage");
    }
    
    /**
     * Get memory usage metric.
     * 
     * @return The memory usage as a percentage (0-100)
     */
    public Double getMemoryUsage() {
        return getMetric("memoryUsage");
    }
    
    /**
     * Get disk read I/O metric.
     * 
     * @return The disk read I/O in MB
     */
    public Double getDiskIoRead() {
        return getMetric("diskIoRead");
    }
    
    /**
     * Get disk write I/O metric.
     * 
     * @return The disk write I/O in MB
     */
    public Double getDiskIoWrite() {
        return getMetric("diskIoWrite");
    }
    
    /**
     * Get network received metric.
     * 
     * @return The network received in MB
     */
    public Double getNetworkReceived() {
        return getMetric("networkReceived");
    }
    
    /**
     * Get network sent metric.
     * 
     * @return The network sent in MB
     */
    public Double getNetworkSent() {
        return getMetric("networkSent");
    }
    
    /**
     * Get thread count metric.
     * 
     * @return The thread count
     */
    public Double getThreadCount() {
        return getMetric("threadCount");
    }
    
    /**
     * Get heap usage metric.
     * 
     * @return The heap usage as a percentage (0-100)
     */
    public Double getHeapUsage() {
        return getMetric("heapUsage");
    }
    
    /**
     * Get non-heap usage metric.
     * 
     * @return The non-heap usage as a percentage (0-100)
     */
    public Double getNonHeapUsage() {
        return getMetric("nonHeapUsage");
    }
    
    /**
     * Get system load metric.
     * 
     * @return The system load
     */
    public Double getSystemLoad() {
        return getMetric("systemLoad");
    }
    
    /**
     * Create a composite metric representing overall system health (0-100).
     * 
     * @return The system health score
     */
    public Double calculateSystemHealthScore() {
        if (metrics == null || metrics.isEmpty()) {
            return 0.0;
        }
        
        // Get key metrics with fallbacks to 0 if not present
        double cpuUsage = metrics.getOrDefault("cpuUsage", 0.0);
        double memoryUsage = metrics.getOrDefault("memoryUsage", 0.0);
        double heapUsage = metrics.getOrDefault("heapUsage", 0.0);
        double systemLoad = metrics.getOrDefault("systemLoad", 0.0) * 25; // Scale to 0-100
        
        // Calculate weights based on available metrics
        int metricCount = 0;
        double weightedSum = 0.0;
        
        if (metrics.containsKey("cpuUsage")) {
            weightedSum += (100 - cpuUsage) * 0.4; // Invert: lower CPU usage is better
            metricCount++;
        }
        
        if (metrics.containsKey("memoryUsage")) {
            weightedSum += (100 - memoryUsage) * 0.3; // Invert: lower memory usage is better
            metricCount++;
        }
        
        if (metrics.containsKey("heapUsage")) {
            weightedSum += (100 - heapUsage) * 0.2; // Invert: lower heap usage is better
            metricCount++;
        }
        
        if (metrics.containsKey("systemLoad")) {
            weightedSum += (100 - systemLoad) * 0.1; // Invert: lower system load is better
            metricCount++;
        }
        
        // Calculate the average
        return metricCount > 0 ? weightedSum / metricCount : 0.0;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("ResourceMetricsMessage{")
          .append("monitoringId='").append(monitoringId).append('\'')
          .append(", timestamp=").append(timestamp);
        
        if (metrics != null) {
            sb.append(", metrics={");
            for (Map.Entry<String, Double> entry : metrics.entrySet()) {
                sb.append(entry.getKey()).append('=').append(entry.getValue()).append(", ");
            }
            if (!metrics.isEmpty()) {
                sb.delete(sb.length() - 2, sb.length());
            }
            sb.append('}');
        }
        
        sb.append(", aggregated=").append(aggregated)
          .append('}');
          
        return sb.toString();
    }
}


NotificationMessage.java
--------------------------------------

package com.cstestforge.model.websocket;

import java.util.HashMap;
import java.util.Map;

/**
 * Message class for real-time notifications.
 * Contains notification content and metadata for WebSocket transmission.
 */
public class NotificationMessage {

    private Map<String, Object> notification;
    private long timestamp;
    private String subscriptionId;
    private boolean batched;
    private int batchCount;
    private Map<String, Object> metadata;
    
    /**
     * Default constructor.
     */
    public NotificationMessage() {
        this.notification = new HashMap<>();
        this.timestamp = System.currentTimeMillis();
        this.batched = false;
        this.batchCount = 1;
        this.metadata = new HashMap<>();
    }
    
    /**
     * Constructor with notification content.
     * 
     * @param notification The notification content
     */
    public NotificationMessage(Map<String, Object> notification) {
        this.notification = notification;
        this.timestamp = System.currentTimeMillis();
        this.batched = false;
        this.batchCount = 1;
        this.metadata = new HashMap<>();
    }
    
    /**
     * Constructor with notification content and timestamp.
     * 
     * @param notification The notification content
     * @param timestamp The message timestamp
     */
    public NotificationMessage(Map<String, Object> notification, long timestamp) {
        this.notification = notification;
        this.timestamp = timestamp;
        this.batched = false;
        this.batchCount = 1;
        this.metadata = new HashMap<>();
    }
    
    /**
     * Constructor with all fields.
     * 
     * @param notification The notification content
     * @param timestamp The message timestamp
     * @param subscriptionId The subscription ID
     * @param batched Whether the message contains batched notifications
     * @param batchCount The number of notifications in the batch
     * @param metadata Additional metadata
     */
    public NotificationMessage(Map<String, Object> notification, long timestamp, String subscriptionId,
            boolean batched, int batchCount, Map<String, Object> metadata) {
        this.notification = notification;
        this.timestamp = timestamp;
        this.subscriptionId = subscriptionId;
        this.batched = batched;
        this.batchCount = batchCount;
        this.metadata = metadata;
    }
    
    /**
     * Get the notification content.
     * 
     * @return The notification content
     */
    public Map<String, Object> getNotification() {
        return notification;
    }
    
    /**
     * Set the notification content.
     * 
     * @param notification The notification content
     */
    public void setNotification(Map<String, Object> notification) {
        this.notification = notification;
    }
    
    /**
     * Get the timestamp.
     * 
     * @return The timestamp
     */
    public long getTimestamp() {
        return timestamp;
    }
    
    /**
     * Set the timestamp.
     * 
     * @param timestamp The timestamp
     */
    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }
    
    /**
     * Get the subscription ID.
     * 
     * @return The subscription ID
     */
    public String getSubscriptionId() {
        return subscriptionId;
    }
    
    /**
     * Set the subscription ID.
     * 
     * @param subscriptionId The subscription ID
     */
    public void setSubscriptionId(String subscriptionId) {
        this.subscriptionId = subscriptionId;
    }
    
    /**
     * Check if the message contains batched notifications.
     * 
     * @return true if the message contains batched notifications, false otherwise
     */
    public boolean isBatched() {
        return batched;
    }
    
    /**
     * Set whether the message contains batched notifications.
     * 
     * @param batched Whether the message contains batched notifications
     */
    public void setBatched(boolean batched) {
        this.batched = batched;
    }
    
    /**
     * Get the number of notifications in the batch.
     * 
     * @return The number of notifications in the batch
     */
    public int getBatchCount() {
        return batchCount;
    }
    
    /**
     * Set the number of notifications in the batch.
     * 
     * @param batchCount The number of notifications in the batch
     */
    public void setBatchCount(int batchCount) {
        this.batchCount = batchCount;
    }
    
    /**
     * Get the metadata.
     * 
     * @return The metadata
     */
    public Map<String, Object> getMetadata() {
        return metadata;
    }
    
    /**
     * Set the metadata.
     * 
     * @param metadata The metadata
     */
    public void setMetadata(Map<String, Object> metadata) {
        this.metadata = metadata;
    }
    
    /**
     * Add metadata.
     * 
     * @param key The metadata key
     * @param value The metadata value
     */
    public void addMetadata(String key, Object value) {
        if (this.metadata == null) {
            this.metadata = new HashMap<>();
        }
        this.metadata.put(key, value);
    }
    
    /**
     * Get the notification ID.
     * 
     * @return The notification ID, or null if not found
     */
    public String getNotificationId() {
        return notification != null ? (String) notification.get("id") : null;
    }
    
    /**
     * Get the notification title.
     * 
     * @return The notification title, or null if not found
     */
    public String getNotificationTitle() {
        return notification != null ? (String) notification.get("title") : null;
    }
    
    /**
     * Get the notification message.
     * 
     * @return The notification message, or null if not found
     */
    public String getNotificationMessage() {
        return notification != null ? (String) notification.get("message") : null;
    }
    
    /**
     * Get the notification type.
     * 
     * @return The notification type, or null if not found
     */
    public String getNotificationType() {
        return notification != null ? (String) notification.get("type") : null;
    }
    
    /**
     * Get the notification priority.
     * 
     * @return The notification priority, or null if not found
     */
    public String getNotificationPriority() {
        return notification != null ? (String) notification.get("priority") : null;
    }
    
    /**
     * Get the notification timestamp.
     * 
     * @return The notification timestamp, or 0 if not found
     */
    public long getNotificationTimestamp() {
        if (notification != null && notification.get("timestamp") instanceof Number) {
            return ((Number) notification.get("timestamp")).longValue();
        }
        return 0;
    }
    
    /**
     * Check if the notification is persistent.
     * 
     * @return true if the notification is persistent, false otherwise
     */
    public boolean isNotificationPersistent() {
        if (notification != null && notification.get("persistent") instanceof Boolean) {
            return (Boolean) notification.get("persistent");
        }
        return false;
    }
    
    /**
     * Check if the notification has been read.
     * 
     * @return true if the notification has been read, false otherwise
     */
    public boolean isNotificationRead() {
        if (notification != null && notification.get("read") instanceof Boolean) {
            return (Boolean) notification.get("read");
        }
        return false;
    }
    
    /**
     * Check if the notification has been acknowledged.
     * 
     * @return true if the notification has been acknowledged, false otherwise
     */
    public boolean isNotificationAcknowledged() {
        if (notification != null && notification.get("acknowledged") instanceof Boolean) {
            return (Boolean) notification.get("acknowledged");
        }
        return false;
    }
    
    /**
     * Get the notification data.
     * 
     * @return The notification data, or null if not found
     */
    @SuppressWarnings("unchecked")
    public Map<String, Object> getNotificationData() {
        if (notification != null && notification.get("data") instanceof Map) {
            return (Map<String, Object>) notification.get("data");
        }
        return null;
    }
    
    /**
     * Create a copy of this notification message.
     * 
     * @return A new NotificationMessage instance with the same values
     */
    public NotificationMessage copy() {
        Map<String, Object> notificationCopy = notification != null ? new HashMap<>(notification) : null;
        Map<String, Object> metadataCopy = metadata != null ? new HashMap<>(metadata) : null;
        
        return new NotificationMessage(
                notificationCopy,
                timestamp,
                subscriptionId,
                batched,
                batchCount,
                metadataCopy
        );
    }
    
    @Override
    public String toString() {
        return "NotificationMessage{" +
                "notification_id='" + getNotificationId() + '\'' +
                ", title='" + getNotificationTitle() + '\'' +
                ", type='" + getNotificationType() + '\'' +
                ", timestamp=" + timestamp +
                ", subscriptionId='" + subscriptionId + '\'' +
                ", batched=" + batched +
                ", batchCount=" + batchCount +
                '}';
    }
}

FileSystemStorageService.java
---------------------------------------

package com.cstestforge.service.storage;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.CRC32;

/**
 * Core service for file-system based storage operations.
 * Provides thread-safe access to files with locking mechanisms,
 * automatic backups, versioning, and efficient data serialization.
 */
@Service
public class FileSystemStorageService {

    private static final CSLogger LOGGER = new CSLogger(FileSystemStorageService.class);
    private static final int MAX_RETRIES = 5;
    private static final long RETRY_DELAY_MS = 100;
    private static final int BUFFER_SIZE = 8192;
    private static final int DEFAULT_BACKUPS = 5;
    private static final long DEFAULT_BACKUP_INTERVAL_MINUTES = 30;
    
    private final Map<String, FileLockWrapper> activeLocks = new ConcurrentHashMap<>();
    private final Map<String, Long> lastModifiedTimes = new ConcurrentHashMap<>();
    private final AtomicBoolean shutdownFlag = new AtomicBoolean(false);
    
    private final ScheduledExecutorService backupScheduler = Executors.newScheduledThreadPool(1);
    private final ExecutorService ioExecutor = Executors.newFixedThreadPool(4);
    
    private String baseStoragePath;
    private String projectsPath;
    private String resultsPath;
    private String configPath;
    private String tempPath;
    private String backupPath;
    
    @Autowired
    private DataSerializer dataSerializer;
    
    @Autowired
    private StoragePathResolver pathResolver;
    
    @Autowired
    private BackupService backupService;
    
    @Autowired
    private DataVersioningService versioningService;
    
    @Autowired
    private DataCompressionService compressionService;
    
    /**
     * Wrapper class for file channel and lock objects.
     */
    private static class FileLockWrapper {
        private final FileChannel channel;
        private final FileLock lock;
        private final long lockTime;
        private String owner;
        
        public FileLockWrapper(FileChannel channel, FileLock lock, String owner) {
            this.channel = channel;
            this.lock = lock;
            this.lockTime = System.currentTimeMillis();
            this.owner = owner;
        }
        
        public FileChannel getChannel() {
            return channel;
        }
        
        public FileLock getLock() {
            return lock;
        }
        
        public long getLockTime() {
            return lockTime;
        }
        
        public String getOwner() {
            return owner;
        }
        
        public void setOwner(String owner) {
            this.owner = owner;
        }
        
        public void release() {
            try {
                if (lock != null && lock.isValid()) {
                    lock.release();
                }
                if (channel != null && channel.isOpen()) {
                    channel.close();
                }
            } catch (IOException e) {
                LOGGER.error("Error releasing file lock", e);
            }
        }
    }
    
    /**
     * Initialize the storage service.
     */
    @PostConstruct
    public void init() {
        // Set default storage paths
        baseStoragePath = System.getProperty("cstestforge.storage.path", "cstestforge-data");
        projectsPath = Paths.get(baseStoragePath, "projects").toString();
        resultsPath = Paths.get(baseStoragePath, "results").toString();
        configPath = Paths.get(baseStoragePath, "config").toString();
        tempPath = Paths.get(baseStoragePath, "temp").toString();
        backupPath = Paths.get(baseStoragePath, "backups").toString();
        
        // Create directory structure
        createDirectories();
        
        // Schedule periodic backup
        backupScheduler.scheduleAtFixedRate(
                this::performPeriodicBackup,
                DEFAULT_BACKUP_INTERVAL_MINUTES, 
                DEFAULT_BACKUP_INTERVAL_MINUTES, 
                TimeUnit.MINUTES);
        
        LOGGER.info("FileSystemStorageService initialized with base path: " + baseStoragePath);
    }
    
    /**
     * Clean up resources when the service is being destroyed.
     */
    @PreDestroy
    public void shutdown() {
        shutdownFlag.set(true);
        
        // Release all locks
        for (FileLockWrapper lockWrapper : activeLocks.values()) {
            lockWrapper.release();
        }
        activeLocks.clear();
        
        // Shutdown executors
        backupScheduler.shutdownNow();
        ioExecutor.shutdownNow();
        
        try {
            if (!backupScheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                LOGGER.warn("Backup scheduler did not terminate in time");
            }
            
            if (!ioExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                LOGGER.warn("IO executor did not terminate in time");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            LOGGER.error("Service shutdown interrupted", e);
        }
        
        LOGGER.info("FileSystemStorageService shutdown complete");
    }
    
    /**
     * Create the necessary directory structure.
     */
    private void createDirectories() {
        try {
            Files.createDirectories(Paths.get(baseStoragePath));
            Files.createDirectories(Paths.get(projectsPath));
            Files.createDirectories(Paths.get(resultsPath));
            Files.createDirectories(Paths.get(configPath));
            Files.createDirectories(Paths.get(tempPath));
            Files.createDirectories(Paths.get(backupPath));
        } catch (IOException e) {
            LOGGER.error("Failed to create storage directories", e);
            throw new StorageException("Failed to create storage directories", e);
        }
    }
    
    /**
     * Store an object as JSON.
     * 
     * @param object The object to store
     * @param path The path relative to the base storage path
     * @param <T> The type of the object
     * @return true if successful, false otherwise
     */
    public <T> boolean storeObject(T object, String path) {
        return storeObject(object, path, null);
    }
    
    /**
     * Store an object as JSON with an owner identifier.
     * 
     * @param object The object to store
     * @param path The path relative to the base storage path
     * @param owner The owner identifier for locking
     * @param <T> The type of the object
     * @return true if successful, false otherwise
     */
    public <T> boolean storeObject(T object, String path, String owner) {
        if (object == null || path == null || path.isEmpty()) {
            return false;
        }
        
        String fullPath = Paths.get(baseStoragePath, path).toString();
        String json = dataSerializer.serializeToJson(object);
        
        return writeTextToFile(json, fullPath, owner);
    }
    
    /**
     * Load an object from JSON.
     * 
     * @param path The path relative to the base storage path
     * @param classType The class of the object
     * @param <T> The type of the object
     * @return The loaded object, or null if not found
     */
    public <T> T loadObject(String path, Class<T> classType) {
        return loadObject(path, classType, null);
    }
    
    /**
     * Load an object from JSON with an owner identifier.
     * 
     * @param path The path relative to the base storage path
     * @param classType The class of the object
     * @param owner The owner identifier for locking
     * @param <T> The type of the object
     * @return The loaded object, or null if not found
     */
    public <T> T loadObject(String path, Class<T> classType, String owner) {
        if (path == null || path.isEmpty() || classType == null) {
            return null;
        }
        
        String fullPath = Paths.get(baseStoragePath, path).toString();
        String json = readTextFromFile(fullPath, owner);
        
        if (json == null || json.isEmpty()) {
            return null;
        }
        
        return dataSerializer.deserializeFromJson(json, classType);
    }
    
    /**
     * Store binary data.
     * 
     * @param data The binary data to store
     * @param path The path relative to the base storage path
     * @return true if successful, false otherwise
     */
    public boolean storeBinaryData(byte[] data, String path) {
        return storeBinaryData(data, path, null);
    }
    
    /**
     * Store binary data with an owner identifier.
     * 
     * @param data The binary data to store
     * @param path The path relative to the base storage path
     * @param owner The owner identifier for locking
     * @return true if successful, false otherwise
     */
    public boolean storeBinaryData(byte[] data, String path, String owner) {
        if (data == null || path == null || path.isEmpty()) {
            return false;
        }
        
        String fullPath = Paths.get(baseStoragePath, path).toString();
        
        return writeBinaryToFile(data, fullPath, owner);
    }
    
    /**
     * Load binary data.
     * 
     * @param path The path relative to the base storage path
     * @return The loaded binary data, or null if not found
     */
    public byte[] loadBinaryData(String path) {
        return loadBinaryData(path, null);
    }
    
    /**
     * Load binary data with an owner identifier.
     * 
     * @param path The path relative to the base storage path
     * @param owner The owner identifier for locking
     * @return The loaded binary data, or null if not found
     */
    public byte[] loadBinaryData(String path, String owner) {
        if (path == null || path.isEmpty()) {
            return null;
        }
        
        String fullPath = Paths.get(baseStoragePath, path).toString();
        
        return readBinaryFromFile(fullPath, owner);
    }
    
    /**
     * Delete a file or directory.
     * 
     * @param path The path relative to the base storage path
     * @return true if successful, false otherwise
     */
    public boolean delete(String path) {
        return delete(path, null);
    }
    
    /**
     * Delete a file or directory with an owner identifier.
     * 
     * @param path The path relative to the base storage path
     * @param owner The owner identifier for locking
     * @return true if successful, false otherwise
     */
    public boolean delete(String path, String owner) {
        if (path == null || path.isEmpty()) {
            return false;
        }
        
        Path fullPath = Paths.get(baseStoragePath, path);
        
        try {
            // For directories, get exclusive lock on the directory marker file
            if (Files.isDirectory(fullPath)) {
                File lockFile = new File(fullPath.toString(), ".lock");
                lockFile.createNewFile(); // Create if not exists
                
                FileLockWrapper lock = acquireLock(lockFile.getPath(), owner);
                if (lock == null) {
                    return false;
                }
                
                try {
                    boolean deleted;
                    try (Stream<Path> pathStream = Files.walk(fullPath)) {
                        pathStream.sorted(Comparator.reverseOrder())
                                .forEach(p -> {
                                    try {
                                        Files.deleteIfExists(p);
                                    } catch (IOException e) {
                                        LOGGER.warn("Failed to delete path: " + p, e);
                                    }
                                });
                        deleted = true;
                    } catch (IOException e) {
                        LOGGER.error("Error deleting directory: " + fullPath, e);
                        deleted = false;
                    }
                    
                    return deleted;
                } finally {
                    releaseLock(lockFile.getPath());
                }
            } else {
                // For files, acquire lock before deleting
                FileLockWrapper lock = acquireLock(fullPath.toString(), owner);
                if (lock == null) {
                    return false;
                }
                
                try {
                    return Files.deleteIfExists(fullPath);
                } catch (IOException e) {
                    LOGGER.error("Error deleting file: " + fullPath, e);
                    return false;
                } finally {
                    releaseLock(fullPath.toString());
                }
            }
        } catch (IOException e) {
            LOGGER.error("Error deleting path: " + fullPath, e);
            return false;
        }
    }
    
    /**
     * Copy a file or directory.
     * 
     * @param sourcePath The source path relative to the base storage path
     * @param targetPath The target path relative to the base storage path
     * @return true if successful, false otherwise
     */
    public boolean copy(String sourcePath, String targetPath) {
        return copy(sourcePath, targetPath, null);
    }
    
    /**
     * Copy a file or directory with an owner identifier.
     * 
     * @param sourcePath The source path relative to the base storage path
     * @param targetPath The target path relative to the base storage path
     * @param owner The owner identifier for locking
     * @return true if successful, false otherwise
     */
    public boolean copy(String sourcePath, String targetPath, String owner) {
        if (sourcePath == null || sourcePath.isEmpty() || targetPath == null || targetPath.isEmpty()) {
            return false;
        }
        
        Path fullSourcePath = Paths.get(baseStoragePath, sourcePath);
        Path fullTargetPath = Paths.get(baseStoragePath, targetPath);
        
        try {
            // For directories, copy recursively
            if (Files.isDirectory(fullSourcePath)) {
                // Create target directory if not exists
                Files.createDirectories(fullTargetPath);
                
                try (Stream<Path> pathStream = Files.walk(fullSourcePath)) {
                    pathStream.filter(path -> !path.equals(fullSourcePath))
                            .forEach(path -> {
                                Path relativePath = fullSourcePath.relativize(path);
                                Path targetFile = fullTargetPath.resolve(relativePath);
                                
                                try {
                                    if (Files.isDirectory(path)) {
                                        Files.createDirectories(targetFile);
                                    } else {
                                        // Copy file with lock
                                        FileLockWrapper sourceLock = acquireLock(path.toString(), owner);
                                        if (sourceLock != null) {
                                            try {
                                                Files.createDirectories(targetFile.getParent());
                                                Files.copy(path, targetFile, StandardCopyOption.REPLACE_EXISTING);
                                            } finally {
                                                releaseLock(path.toString());
                                            }
                                        }
                                    }
                                } catch (IOException e) {
                                    LOGGER.warn("Failed to copy path: " + path, e);
                                }
                            });
                }
                
                return true;
            } else {
                // For files, acquire locks before copying
                FileLockWrapper sourceLock = acquireLock(fullSourcePath.toString(), owner);
                if (sourceLock == null) {
                    return false;
                }
                
                try {
                    // Create parent directories if not exist
                    Files.createDirectories(fullTargetPath.getParent());
                    
                    Files.copy(fullSourcePath, fullTargetPath, StandardCopyOption.REPLACE_EXISTING);
                    return true;
                } catch (IOException e) {
                    LOGGER.error("Error copying file: " + fullSourcePath + " to " + fullTargetPath, e);
                    return false;
                } finally {
                    releaseLock(fullSourcePath.toString());
                }
            }
        } catch (IOException e) {
            LOGGER.error("Error copying path: " + fullSourcePath + " to " + fullTargetPath, e);
            return false;
        }
    }
    
    /**
     * Move a file or directory.
     * 
     * @param sourcePath The source path relative to the base storage path
     * @param targetPath The target path relative to the base storage path
     * @return true if successful, false otherwise
     */
    public boolean move(String sourcePath, String targetPath) {
        return move(sourcePath, targetPath, null);
    }
    
    /**
     * Move a file or directory with an owner identifier.
     * 
     * @param sourcePath The source path relative to the base storage path
     * @param targetPath The target path relative to the base storage path
     * @param owner The owner identifier for locking
     * @return true if successful, false otherwise
     */
    public boolean move(String sourcePath, String targetPath, String owner) {
        if (sourcePath == null || sourcePath.isEmpty() || targetPath == null || targetPath.isEmpty()) {
            return false;
        }
        
        // First copy, then delete source if successful
        boolean copied = copy(sourcePath, targetPath, owner);
        if (copied) {
            return delete(sourcePath, owner);
        }
        
        return false;
    }
    
    /**
     * List files in a directory.
     * 
     * @param directoryPath The directory path relative to the base storage path
     * @return List of file names, or empty list if not found
     */
    public List<String> listFiles(String directoryPath) {
        if (directoryPath == null || directoryPath.isEmpty()) {
            return Collections.emptyList();
        }
        
        Path fullPath = Paths.get(baseStoragePath, directoryPath);
        
        try {
            if (!Files.isDirectory(fullPath)) {
                return Collections.emptyList();
            }
            
            try (Stream<Path> pathStream = Files.list(fullPath)) {
                return pathStream
                        .filter(Files::isRegularFile)
                        .filter(p -> !p.getFileName().toString().startsWith(".")) // Skip hidden files
                        .map(p -> p.getFileName().toString())
                        .collect(Collectors.toList());
            }
        } catch (IOException e) {
            LOGGER.error("Error listing files in directory: " + fullPath, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * List directories in a directory.
     * 
     * @param directoryPath The directory path relative to the base storage path
     * @return List of directory names, or empty list if not found
     */
    public List<String> listDirectories(String directoryPath) {
        if (directoryPath == null || directoryPath.isEmpty()) {
            return Collections.emptyList();
        }
        
        Path fullPath = Paths.get(baseStoragePath, directoryPath);
        
        try {
            if (!Files.isDirectory(fullPath)) {
                return Collections.emptyList();
            }
            
            try (Stream<Path> pathStream = Files.list(fullPath)) {
                return pathStream
                        .filter(Files::isDirectory)
                        .filter(p -> !p.getFileName().toString().startsWith(".")) // Skip hidden directories
                        .map(p -> p.getFileName().toString())
                        .collect(Collectors.toList());
            }
        } catch (IOException e) {
            LOGGER.error("Error listing directories in directory: " + fullPath, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Check if a file or directory exists.
     * 
     * @param path The path relative to the base storage path
     * @return true if exists, false otherwise
     */
    public boolean exists(String path) {
        if (path == null || path.isEmpty()) {
            return false;
        }
        
        Path fullPath = Paths.get(baseStoragePath, path);
        
        return Files.exists(fullPath);
    }
    
    /**
     * Create a directory.
     * 
     * @param directoryPath The directory path relative to the base storage path
     * @return true if successful, false otherwise
     */
    public boolean createDirectory(String directoryPath) {
        if (directoryPath == null || directoryPath.isEmpty()) {
            return false;
        }
        
        Path fullPath = Paths.get(baseStoragePath, directoryPath);
        
        try {
            Files.createDirectories(fullPath);
            return true;
        } catch (IOException e) {
            LOGGER.error("Error creating directory: " + fullPath, e);
            return false;
        }
    }
    
    /**
     * Get file metadata.
     * 
     * @param path The path relative to the base storage path
     * @return Map of metadata, or empty map if not found
     */
    public Map<String, Object> getFileMetadata(String path) {
        if (path == null || path.isEmpty()) {
            return Collections.emptyMap();
        }
        
        Path fullPath = Paths.get(baseStoragePath, path);
        
        try {
            if (!Files.exists(fullPath)) {
                return Collections.emptyMap();
            }
            
            Map<String, Object> metadata = new HashMap<>();
            metadata.put("name", fullPath.getFileName().toString());
            metadata.put("path", path);
            metadata.put("fullPath", fullPath.toString());
            metadata.put("size", Files.size(fullPath));
            metadata.put("lastModified", Files.getLastModifiedTime(fullPath).toMillis());
            metadata.put("isDirectory", Files.isDirectory(fullPath));
            metadata.put("isRegularFile", Files.isRegularFile(fullPath));
            metadata.put("isSymbolicLink", Files.isSymbolicLink(fullPath));
            metadata.put("isHidden", Files.isHidden(fullPath));
            
            if (Files.isRegularFile(fullPath)) {
                String contentType = Files.probeContentType(fullPath);
                metadata.put("contentType", contentType != null ? contentType : "application/octet-stream");
                
                // Calculate checksum
                byte[] data = Files.readAllBytes(fullPath);
                CRC32 crc32 = new CRC32();
                crc32.update(data);
                metadata.put("checksum", crc32.getValue());
            }
            
            return metadata;
        } catch (IOException e) {
            LOGGER.error("Error getting file metadata: " + fullPath, e);
            return Collections.emptyMap();
        }
    }
    
    /**
     * Get file size.
     * 
     * @param path The path relative to the base storage path
     * @return File size in bytes, or -1 if not found
     */
    public long getFileSize(String path) {
        if (path == null || path.isEmpty()) {
            return -1;
        }
        
        Path fullPath = Paths.get(baseStoragePath, path);
        
        try {
            if (!Files.exists(fullPath) || !Files.isRegularFile(fullPath)) {
                return -1;
            }
            
            return Files.size(fullPath);
        } catch (IOException e) {
            LOGGER.error("Error getting file size: " + fullPath, e);
            return -1;
        }
    }
    
    /**
     * Get last modified time.
     * 
     * @param path The path relative to the base storage path
     * @return Last modified time in milliseconds, or -1 if not found
     */
    public long getLastModifiedTime(String path) {
        if (path == null || path.isEmpty()) {
            return -1;
        }
        
        Path fullPath = Paths.get(baseStoragePath, path);
        
        try {
            if (!Files.exists(fullPath)) {
                return -1;
            }
            
            return Files.getLastModifiedTime(fullPath).toMillis();
        } catch (IOException e) {
            LOGGER.error("Error getting last modified time: " + fullPath, e);
            return -1;
        }
    }
    
    /**
     * Set last modified time.
     * 
     * @param path The path relative to the base storage path
     * @param lastModifiedTime The last modified time in milliseconds
     * @return true if successful, false otherwise
     */
    public boolean setLastModifiedTime(String path, long lastModifiedTime) {
        if (path == null || path.isEmpty() || lastModifiedTime <= 0) {
            return false;
        }
        
        Path fullPath = Paths.get(baseStoragePath, path);
        
        try {
            if (!Files.exists(fullPath)) {
                return false;
            }
            
            FileLockWrapper lock = acquireLock(fullPath.toString(), null);
            if (lock == null) {
                return false;
            }
            
            try {
                Files.setLastModifiedTime(fullPath, java.nio.file.attribute.FileTime.fromMillis(lastModifiedTime));
                lastModifiedTimes.put(fullPath.toString(), lastModifiedTime);
                return true;
            } finally {
                releaseLock(fullPath.toString());
            }
        } catch (IOException e) {
            LOGGER.error("Error setting last modified time: " + fullPath, e);
            return false;
        }
    }
    
    /**
     * Create a backup of a file or directory.
     * 
     * @param path The path relative to the base storage path
     * @return Backup ID, or null if failed
     */
    public String createBackup(String path) {
        return createBackup(path, null);
    }
    
    /**
     * Create a backup of a file or directory with an owner identifier.
     * 
     * @param path The path relative to the base storage path
     * @param owner The owner identifier for locking
     * @return Backup ID, or null if failed
     */
    public String createBackup(String path, String owner) {
        return backupService.createBackup(path, owner);
    }
    
    /**
     * Restore a backup.
     * 
     * @param backupId The backup ID
     * @return true if successful, false otherwise
     */
    public boolean restoreBackup(String backupId) {
        return backupService.restoreBackup(backupId, null);
    }
    
    /**
     * Restore a backup with an owner identifier.
     * 
     * @param backupId The backup ID
     * @param owner The owner identifier for locking
     * @return true if successful, false otherwise
     */
    public boolean restoreBackup(String backupId, String owner) {
        return backupService.restoreBackup(backupId, owner);
    }
    
    /**
     * List backups for a path.
     * 
     * @param path The path relative to the base storage path
     * @return List of backup metadata, or empty list if not found
     */
    public List<Map<String, Object>> listBackups(String path) {
        return backupService.listBackups(path);
    }
    
    /**
     * Delete a backup.
     * 
     * @param backupId The backup ID
     * @return true if successful, false otherwise
     */
    public boolean deleteBackup(String backupId) {
        return backupService.deleteBackup(backupId);
    }
    
    /**
     * Create a version of a file or directory.
     * 
     * @param path The path relative to the base storage path
     * @param versionLabel The version label
     * @return Version ID, or null if failed
     */
    public String createVersion(String path, String versionLabel) {
        return versioningService.createVersion(path, versionLabel, null);
    }
    
    /**
     * Create a version of a file or directory with an owner identifier.
     * 
     * @param path The path relative to the base storage path
     * @param versionLabel The version label
     * @param owner The owner identifier for locking
     * @return Version ID, or null if failed
     */
    public String createVersion(String path, String versionLabel, String owner) {
        return versioningService.createVersion(path, versionLabel, owner);
    }
    
    /**
     * Restore a version.
     * 
     * @param versionId The version ID
     * @return true if successful, false otherwise
     */
    public boolean restoreVersion(String versionId) {
        return versioningService.restoreVersion(versionId, null);
    }
    
    /**
     * Restore a version with an owner identifier.
     * 
     * @param versionId The version ID
     * @param owner The owner identifier for locking
     * @return true if successful, false otherwise
     */
    public boolean restoreVersion(String versionId, String owner) {
        return versioningService.restoreVersion(versionId, owner);
    }
    
    /**
     * List versions for a path.
     * 
     * @param path The path relative to the base storage path
     * @return List of version metadata, or empty list if not found
     */
    public List<Map<String, Object>> listVersions(String path) {
        return versioningService.listVersions(path);
    }
    
    /**
     * Delete a version.
     * 
     * @param versionId The version ID
     * @return true if successful, false otherwise
     */
    public boolean deleteVersion(String versionId) {
        return versioningService.deleteVersion(versionId);
    }
    
    /**
     * Compress a file or directory.
     * 
     * @param path The path relative to the base storage path
     * @param targetPath The target path relative to the base storage path
     * @return true if successful, false otherwise
     */
    public boolean compress(String path, String targetPath) {
        return compressionService.compress(path, targetPath, null);
    }
    
    /**
     * Compress a file or directory with an owner identifier.
     * 
     * @param path The path relative to the base storage path
     * @param targetPath The target path relative to the base storage path
     * @param owner The owner identifier for locking
     * @return true if successful, false otherwise
     */
    public boolean compress(String path, String targetPath, String owner) {
        return compressionService.compress(path, targetPath, owner);
    }
    
    /**
     * Decompress a file.
     * 
     * @param path The path relative to the base storage path
     * @param targetPath The target path relative to the base storage path
     * @return true if successful, false otherwise
     */
    public boolean decompress(String path, String targetPath) {
        return compressionService.decompress(path, targetPath, null);
    }
    
    /**
     * Decompress a file with an owner identifier.
     * 
     * @param path The path relative to the base storage path
     * @param targetPath The target path relative to the base storage path
     * @param owner The owner identifier for locking
     * @return true if successful, false otherwise
     */
    public boolean decompress(String path, String targetPath, String owner) {
        return compressionService.decompress(path, targetPath, owner);
    }
    
    /**
     * Write text to a file.
     * 
     * @param text The text to write
     * @param fullPath The full path of the file
     * @param owner The owner identifier for locking
     * @return true if successful, false otherwise
     */
    private boolean writeTextToFile(String text, String fullPath, String owner) {
        if (text == null || fullPath == null || fullPath.isEmpty()) {
            return false;
        }
        
        Path path = Paths.get(fullPath);
        
        try {
            // Create parent directories if not exist
            Files.createDirectories(path.getParent());
            
            // Create a temporary file
            Path tempFile = Files.createTempFile(path.getParent(), "tmp_", ".tmp");
            
            // Write to the temporary file
            Files.write(tempFile, text.getBytes(StandardCharsets.UTF_8));
            
            // Acquire lock on the target file
            FileLockWrapper lock = acquireLock(fullPath, owner);
            if (lock == null) {
                // Clean up temporary file
                Files.deleteIfExists(tempFile);
                return false;
            }
            
            try {
                // Atomically replace the target file with the temporary file
                Files.move(tempFile, path, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
                
                // Update last modified time
                long lastModified = Files.getLastModifiedTime(path).toMillis();
                lastModifiedTimes.put(fullPath, lastModified);
                
                // Create a backup if it's not a temporary file
                if (!fullPath.contains("/temp/") && !fullPath.contains("\\temp\\")) {
                    ioExecutor.submit(() -> backupService.createBackup(CSPathUtils.relativizeToBasePath(fullPath, baseStoragePath), owner));
                }
                
                return true;
            } finally {
                releaseLock(fullPath);
                
                // Clean up temporary file if it still exists
                Files.deleteIfExists(tempFile);
            }
        } catch (IOException e) {
            LOGGER.error("Error writing text to file: " + fullPath, e);
            return false;
        }
    }
    
    /**
     * Read text from a file.
     * 
     * @param fullPath The full path of the file
     * @param owner The owner identifier for locking
     * @return The read text, or null if failed
     */
    private String readTextFromFile(String fullPath, String owner) {
        if (fullPath == null || fullPath.isEmpty()) {
            return null;
        }
        
        Path path = Paths.get(fullPath);
        
        if (!Files.exists(path)) {
            return null;
        }
        
        FileLockWrapper lock = acquireLock(fullPath, owner);
        if (lock == null) {
            return null;
        }
        
        try {
            return new String(Files.readAllBytes(path), StandardCharsets.UTF_8);
        } catch (IOException e) {
            LOGGER.error("Error reading text from file: " + fullPath, e);
            return null;
        } finally {
            releaseLock(fullPath);
        }
    }
    
    /**
     * Write binary data to a file.
     * 
     * @param data The binary data to write
     * @param fullPath The full path of the file
     * @param owner The owner identifier for locking
     * @return true if successful, false otherwise
     */
    private boolean writeBinaryToFile(byte[] data, String fullPath, String owner) {
        if (data == null || fullPath == null || fullPath.isEmpty()) {
            return false;
        }
        
        Path path = Paths.get(fullPath);
        
        try {
            // Create parent directories if not exist
            Files.createDirectories(path.getParent());
            
            // Create a temporary file
            Path tempFile = Files.createTempFile(path.getParent(), "tmp_", ".tmp");
            
            // Write to the temporary file
            Files.write(tempFile, data);
            
            // Acquire lock on the target file
            FileLockWrapper lock = acquireLock(fullPath, owner);
            if (lock == null) {
                // Clean up temporary file
                Files.deleteIfExists(tempFile);
                return false;
            }
            
            try {
                // Atomically replace the target file with the temporary file
                Files.move(tempFile, path, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
                
                // Update last modified time
                long lastModified = Files.getLastModifiedTime(path).toMillis();
                lastModifiedTimes.put(fullPath, lastModified);
                
                // Create a backup if it's not a temporary file
                if (!fullPath.contains("/temp/") && !fullPath.contains("\\temp\\")) {
                    ioExecutor.submit(() -> backupService.createBackup(CSPathUtils.relativizeToBasePath(fullPath, baseStoragePath), owner));
                }
                
                return true;
            } finally {
                releaseLock(fullPath);
                
                // Clean up temporary file if it still exists
                Files.deleteIfExists(tempFile);
            }
        } catch (IOException e) {
            LOGGER.error("Error writing binary to file: " + fullPath, e);
            return false;
        }
    }
    
    /**
     * Read binary data from a file.
     * 
     * @param fullPath The full path of the file
     * @param owner The owner identifier for locking
     * @return The read binary data, or null if failed
     */
    private byte[] readBinaryFromFile(String fullPath, String owner) {
        if (fullPath == null || fullPath.isEmpty()) {
            return null;
        }
        
        Path path = Paths.get(fullPath);
        
        if (!Files.exists(path)) {
            return null;
        }
        
        FileLockWrapper lock = acquireLock(fullPath, owner);
        if (lock == null) {
            return null;
        }
        
        try {
            return Files.readAllBytes(path);
        } catch (IOException e) {
            LOGGER.error("Error reading binary from file: " + fullPath, e);
            return null;
        } finally {
            releaseLock(fullPath);
        }
    }
    
    /**
     * Acquire a file lock.
     * 
     * @param filePath The file path
     * @param owner The owner identifier
     * @return The file lock wrapper, or null if failed
     */
    private FileLockWrapper acquireLock(String filePath, String owner) {
        if (shutdownFlag.get()) {
            return null;
        }
        
        if (filePath == null || filePath.isEmpty()) {
            return null;
        }
        
        // Check if the lock is already held by the owner
        FileLockWrapper existingLock = activeLocks.get(filePath);
        if (existingLock != null && existingLock.getOwner() != null && existingLock.getOwner().equals(owner)) {
            return existingLock;
        }
        
        // Create parent directories if not exist
        try {
            File file = new File(filePath);
            File parentDir = file.getParentFile();
            if (parentDir != null && !parentDir.exists()) {
                parentDir.mkdirs();
            }
        } catch (Exception e) {
            LOGGER.error("Error creating parent directories for file: " + filePath, e);
            return null;
        }
        
        // Try to acquire the lock with retries
        for (int retry = 0; retry < MAX_RETRIES; retry++) {
            try {
                // Create the file if it doesn't exist
                Path path = Paths.get(filePath);
                if (!Files.exists(path)) {
                    Files.createFile(path);
                }
                
                FileChannel channel = FileChannel.open(path, StandardOpenOption.READ, StandardOpenOption.WRITE);
                
                // Try to acquire the lock (non-blocking)
                FileLock lock = channel.tryLock();
                if (lock != null) {
                    FileLockWrapper lockWrapper = new FileLockWrapper(channel, lock, owner);
                    activeLocks.put(filePath, lockWrapper);
                    return lockWrapper;
                }
                
                // Lock not acquired, close channel and retry
                channel.close();
                
                // Wait before retrying
                Thread.sleep(RETRY_DELAY_MS);
            } catch (IOException | InterruptedException e) {
                if (e instanceof InterruptedException) {
                    Thread.currentThread().interrupt();
                    return null;
                }
                
                LOGGER.warn("Failed to acquire lock for file: " + filePath + ", retry: " + retry, e);
                
                // Wait before retrying
                try {
                    Thread.sleep(RETRY_DELAY_MS);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    return null;
                }
            }
        }
        
        LOGGER.error("Failed to acquire lock for file after " + MAX_RETRIES + " retries: " + filePath);
        return null;
    }
    
    /**
     * Release a file lock.
     * 
     * @param filePath The file path
     * @return true if successful, false otherwise
     */
    private boolean releaseLock(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return false;
        }
        
        FileLockWrapper lockWrapper = activeLocks.remove(filePath);
        if (lockWrapper != null) {
            lockWrapper.release();
            return true;
        }
        
        return false;
    }
    
    /**
     * Perform periodic backup of all files.
     */
    private void performPeriodicBackup() {
        if (shutdownFlag.get()) {
            return;
        }
        
        try {
            LOGGER.info("Starting periodic backup");
            
            // Get list of project files
            List<String> projectFiles = listFilesRecursively(projectsPath);
            
            // Get list of configuration files
            List<String> configFiles = listFilesRecursively(configPath);
            
            // Combine all files
            List<String> allFiles = new ArrayList<>();
            allFiles.addAll(projectFiles);
            allFiles.addAll(configFiles);
            
            // Skip result files (can be regenerated)
            // allFiles.addAll(listFilesRecursively(resultsPath));
            
            // Create backups for each file
            for (String file : allFiles) {
                try {
                    // Skip temporary files
                    if (file.contains("/temp/") || file.contains("\\temp\\") || file.contains("/.") || file.contains("\\.")) {
                        continue;
                    }
                    
                    // Relativize path to base storage path
                    String relativePath = CSPathUtils.relativizeToBasePath(file, baseStoragePath);
                    
                    // Create backup
                    backupService.createBackup(relativePath, "system");
                } catch (Exception e) {
                    LOGGER.error("Error creating backup for file: " + file, e);
                }
            }
            
            LOGGER.info("Periodic backup completed");
        } catch (Exception e) {
            LOGGER.error("Error performing periodic backup", e);
        }
    }
    
    /**
     * List files recursively in a directory.
     * 
     * @param directoryPath The directory path
     * @return List of file paths
     */
    private List<String> listFilesRecursively(String directoryPath) {
        if (directoryPath == null || directoryPath.isEmpty()) {
            return Collections.emptyList();
        }
        
        Path path = Paths.get(directoryPath);
        
        try {
            if (!Files.isDirectory(path)) {
                return Collections.emptyList();
            }
            
            try (Stream<Path> pathStream = Files.walk(path)) {
                return pathStream
                        .filter(Files::isRegularFile)
                        .filter(p -> !p.getFileName().toString().startsWith(".")) // Skip hidden files
                        .map(Path::toString)
                        .collect(Collectors.toList());
            }
        } catch (IOException e) {
            LOGGER.error("Error listing files recursively in directory: " + directoryPath, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Get base storage path.
     * 
     * @return The base storage path
     */
    public String getBaseStoragePath() {
        return baseStoragePath;
    }
    
    /**
     * Get projects path.
     * 
     * @return The projects path
     */
    public String getProjectsPath() {
        return projectsPath;
    }
    
    /**
     * Get results path.
     * 
     * @return The results path
     */
    public String getResultsPath() {
        return resultsPath;
    }
    
    /**
     * Get config path.
     * 
     * @return The config path
     */
    public String getConfigPath() {
        return configPath;
    }
    
    /**
     * Get temp path.
     * 
     * @return The temp path
     */
    public String getTempPath() {
        return tempPath;
    }
    
    /**
     * Get backup path.
     * 
     * @return The backup path
     */
    public String getBackupPath() {
        return backupPath;
    }
    
    /**
     * Set base storage path.
     * 
     * @param baseStoragePath The base storage path
     */
    public void setBaseStoragePath(String baseStoragePath) {
        this.baseStoragePath = baseStoragePath;
        this.projectsPath = Paths.get(baseStoragePath, "projects").toString();
        this.resultsPath = Paths.get(baseStoragePath, "results").toString();
        this.configPath = Paths.get(baseStoragePath, "config").toString();
        this.tempPath = Paths.get(baseStoragePath, "temp").toString();
        this.backupPath = Paths.get(baseStoragePath, "backups").toString();
        
        // Create directory structure
        createDirectories();
    }
    
    /**
     * Exception class for storage operations.
     */
    public static class StorageException extends RuntimeException {
        
        private static final long serialVersionUID = 1L;
        
        /**
         * Constructor with message.
         * 
         * @param message The error message
         */
        public StorageException(String message) {
            super(message);
        }
        
        /**
         * Constructor with message and cause.
         * 
         * @param message The error message
         * @param cause The cause
         */
        public StorageException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}


DataSerializer.java
---------------------------------

package com.cstestforge.service.storage;

import com.cstestforge.framework.core.utils.CSLogger;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.IOException;
import java.lang.reflect.Type;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Service for serializing and deserializing data to and from various formats.
 * Provides methods for JSON, XML, and binary serialization with robust error handling.
 */
@Service
public class DataSerializer {

    private static final CSLogger LOGGER = new CSLogger(DataSerializer.class);
    private static final String CHARSET = "UTF-8";
    
    private ObjectMapper jsonMapper;
    private XmlMapper xmlMapper;
    
    /**
     * Initialize the serializer.
     */
    @PostConstruct
    public void init() {
        // Configure JSON mapper
        jsonMapper = new ObjectMapper();
        configureMappers(jsonMapper);
        
        // Configure XML mapper
        xmlMapper = new XmlMapper();
        configureMappers(xmlMapper);
        
        LOGGER.info("DataSerializer initialized");
    }
    
    /**
     * Configure a mapper with common settings.
     * 
     * @param mapper The mapper to configure
     */
    private void configureMappers(ObjectMapper mapper) {
        // Configure serialization features
        mapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);
        
        // Configure deserialization features
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        mapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);
        mapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);
        
        // Configure other features
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        
        // Register JavaTimeModule for handling Java 8 date/time types
        mapper.registerModule(new JavaTimeModule());
        
        // Register custom module for additional serializers/deserializers
        SimpleModule module = new SimpleModule();
        
        // Register custom date serializers/deserializers
        module.addSerializer(LocalDate.class, new LocalDateSerializer());
        module.addDeserializer(LocalDate.class, new LocalDateDeserializer());
        module.addSerializer(LocalDateTime.class, new LocalDateTimeSerializer());
        module.addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer());
        module.addSerializer(ZonedDateTime.class, new ZonedDateTimeSerializer());
        module.addDeserializer(ZonedDateTime.class, new ZonedDateTimeDeserializer());
        module.addSerializer(Instant.class, new InstantSerializer());
        module.addDeserializer(Instant.class, new InstantDeserializer());
        
        // Register custom byte array serializers/deserializers
        module.addSerializer(byte[].class, new ByteArraySerializer());
        module.addDeserializer(byte[].class, new ByteArrayDeserializer());
        
        mapper.registerModule(module);
    }
    
    /**
     * Serialize an object to JSON.
     * 
     * @param object The object to serialize
     * @return The JSON string, or null if serialization failed
     */
    public String serializeToJson(Object object) {
        if (object == null) {
            return null;
        }
        
        try {
            return jsonMapper.writeValueAsString(object);
        } catch (JsonProcessingException e) {
            LOGGER.error("Error serializing object to JSON", e);
            return null;
        }
    }
    
    /**
     * Deserialize from JSON to an object.
     * 
     * @param json The JSON string
     * @param classType The class of the object
     * @param <T> The type of the object
     * @return The deserialized object, or null if deserialization failed
     */
    public <T> T deserializeFromJson(String json, Class<T> classType) {
        if (json == null || json.isEmpty() || classType == null) {
            return null;
        }
        
        try {
            return jsonMapper.readValue(json, classType);
        } catch (IOException e) {
            LOGGER.error("Error deserializing JSON to object of type: " + classType.getName(), e);
            return null;
        }
    }
    
    /**
     * Deserialize from JSON to a parameterized type.
     * 
     * @param json The JSON string
     * @param type The type reference
     * @param <T> The type of the object
     * @return The deserialized object, or null if deserialization failed
     */
    public <T> T deserializeFromJson(String json, Type type) {
        if (json == null || json.isEmpty() || type == null) {
            return null;
        }
        
        try {
            JavaType javaType = jsonMapper.getTypeFactory().constructType(type);
            return jsonMapper.readValue(json, javaType);
        } catch (IOException e) {
            LOGGER.error("Error deserializing JSON to object of type: " + type.getTypeName(), e);
            return null;
        }
    }
    
    /**
     * Deserialize from JSON to a list of objects.
     * 
     * @param json The JSON string
     * @param elementType The class of the list elements
     * @param <T> The type of the list elements
     * @return The deserialized list, or empty list if deserialization failed
     */
    public <T> List<T> deserializeListFromJson(String json, Class<T> elementType) {
        if (json == null || json.isEmpty() || elementType == null) {
            return new ArrayList<>();
        }
        
        try {
            JavaType listType = jsonMapper.getTypeFactory().constructCollectionType(List.class, elementType);
            return jsonMapper.readValue(json, listType);
        } catch (IOException e) {
            LOGGER.error("Error deserializing JSON to list of type: " + elementType.getName(), e);
            return new ArrayList<>();
        }
    }
    
    /**
     * Deserialize from JSON to a map.
     * 
     * @param json The JSON string
     * @param keyType The class of the map keys
     * @param valueType The class of the map values
     * @param <K> The type of the map keys
     * @param <V> The type of the map values
     * @return The deserialized map, or empty map if deserialization failed
     */
    public <K, V> Map<K, V> deserializeMapFromJson(String json, Class<K> keyType, Class<V> valueType) {
        if (json == null || json.isEmpty() || keyType == null || valueType == null) {
            return new HashMap<>();
        }
        
        try {
            JavaType mapType = jsonMapper.getTypeFactory().constructMapType(Map.class, keyType, valueType);
            return jsonMapper.readValue(json, mapType);
        } catch (IOException e) {
            LOGGER.error("Error deserializing JSON to map with key type: " + keyType.getName() + 
                    " and value type: " + valueType.getName(), e);
            return new HashMap<>();
        }
    }
    
    /**
     * Serialize an object to XML.
     * 
     * @param object The object to serialize
     * @return The XML string, or null if serialization failed
     */
    public String serializeToXml(Object object) {
        if (object == null) {
            return null;
        }
        
        try {
            return xmlMapper.writeValueAsString(object);
        } catch (JsonProcessingException e) {
            LOGGER.error("Error serializing object to XML", e);
            return null;
        }
    }
    
    /**
     * Deserialize from XML to an object.
     * 
     * @param xml The XML string
     * @param classType The class of the object
     * @param <T> The type of the object
     * @return The deserialized object, or null if deserialization failed
     */
    public <T> T deserializeFromXml(String xml, Class<T> classType) {
        if (xml == null || xml.isEmpty() || classType == null) {
            return null;
        }
        
        try {
            return xmlMapper.readValue(xml, classType);
        } catch (IOException e) {
            LOGGER.error("Error deserializing XML to object of type: " + classType.getName(), e);
            return null;
        }
    }
    
    /**
     * Serialize an object to binary.
     * 
     * @param object The object to serialize
     * @return The binary data, or null if serialization failed
     */
    public byte[] serializeToBinary(Object object) {
        if (object == null) {
            return null;
        }
        
        try {
            return jsonMapper.writeValueAsBytes(object);
        } catch (JsonProcessingException e) {
            LOGGER.error("Error serializing object to binary", e);
            return null;
        }
    }
    
    /**
     * Deserialize from binary to an object.
     * 
     * @param data The binary data
     * @param classType The class of the object
     * @param <T> The type of the object
     * @return The deserialized object, or null if deserialization failed
     */
    public <T> T deserializeFromBinary(byte[] data, Class<T> classType) {
        if (data == null || data.length == 0 || classType == null) {
            return null;
        }
        
        try {
            return jsonMapper.readValue(data, classType);
        } catch (IOException e) {
            LOGGER.error("Error deserializing binary to object of type: " + classType.getName(), e);
            return null;
        }
    }
    
    /**
     * Convert an object to a map.
     * 
     * @param object The object to convert
     * @return The map representation of the object, or empty map if conversion failed
     */
    @SuppressWarnings("unchecked")
    public Map<String, Object> convertToMap(Object object) {
        if (object == null) {
            return new HashMap<>();
        }
        
        if (object instanceof Map) {
            return (Map<String, Object>) object;
        }
        
        try {
            return jsonMapper.convertValue(object, Map.class);
        } catch (Exception e) {
            LOGGER.error("Error converting object to map", e);
            return new HashMap<>();
        }
    }
    
    /**
     * Convert a map to an object.
     * 
     * @param map The map to convert
     * @param classType The class of the object
     * @param <T> The type of the object
     * @return The object, or null if conversion failed
     */
    public <T> T convertFromMap(Map<String, Object> map, Class<T> classType) {
        if (map == null || map.isEmpty() || classType == null) {
            return null;
        }
        
        try {
            return jsonMapper.convertValue(map, classType);
        } catch (Exception e) {
            LOGGER.error("Error converting map to object of type: " + classType.getName(), e);
            return null;
        }
    }
    
    /**
     * Merge two objects.
     * 
     * @param target The target object
     * @param source The source object
     * @param <T> The type of the objects
     * @return The merged object, or the target if merging failed
     */
    @SuppressWarnings("unchecked")
    public <T> T mergeObjects(T target, T source) {
        if (target == null || source == null) {
            return target;
        }
        
        try {
            Map<String, Object> targetMap = convertToMap(target);
            Map<String, Object> sourceMap = convertToMap(source);
            
            // Merge the maps
            mergeMaps(targetMap, sourceMap);
            
            // Convert back to object
            return convertFromMap(targetMap, (Class<T>) target.getClass());
        } catch (Exception e) {
            LOGGER.error("Error merging objects", e);
            return target;
        }
    }
    
    /**
     * Merge two maps.
     * 
     * @param target The target map
     * @param source The source map
     */
    @SuppressWarnings("unchecked")
    private void mergeMaps(Map<String, Object> target, Map<String, Object> source) {
        for (Map.Entry<String, Object> entry : source.entrySet()) {
            String key = entry.getKey();
            Object sourceValue = entry.getValue();
            
            if (sourceValue == null) {
                continue;
            }
            
            if (!target.containsKey(key)) {
                target.put(key, sourceValue);
                continue;
            }
            
            Object targetValue = target.get(key);
            
            if (targetValue == null) {
                target.put(key, sourceValue);
                continue;
            }
            
            // If both values are maps, merge them recursively
            if (targetValue instanceof Map && sourceValue instanceof Map) {
                mergeMaps((Map<String, Object>) targetValue, (Map<String, Object>) sourceValue);
                continue;
            }
            
            // If both values are lists, concat them
            if (targetValue instanceof List && sourceValue instanceof List) {
                ((List<Object>) targetValue).addAll((List<Object>) sourceValue);
                continue;
            }
            
            // Otherwise, overwrite the target value
            target.put(key, sourceValue);
        }
    }
    
    /**
     * Get the JSON mapper.
     * 
     * @return The JSON mapper
     */
    public ObjectMapper getJsonMapper() {
        return jsonMapper;
    }
    
    /**
     * Get the XML mapper.
     * 
     * @return The XML mapper
     */
    public XmlMapper getXmlMapper() {
        return xmlMapper;
    }
    
    /**
     * Serializer for LocalDate.
     */
    private static class LocalDateSerializer extends JsonSerializer<LocalDate> {
        
        private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE;
        
        @Override
        public void serialize(LocalDate value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
            gen.writeString(value.format(FORMATTER));
        }
    }
    
    /**
     * Deserializer for LocalDate.
     */
    private static class LocalDateDeserializer extends JsonDeserializer<LocalDate> {
        
        @Override
        public LocalDate deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
            String value = p.getValueAsString();
            if (value == null || value.isEmpty()) {
                return null;
            }
            return LocalDate.parse(value);
        }
    }
    
    /**
     * Serializer for LocalDateTime.
     */
    private static class LocalDateTimeSerializer extends JsonSerializer<LocalDateTime> {
        
        private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        
        @Override
        public void serialize(LocalDateTime value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
            gen.writeString(value.format(FORMATTER));
        }
    }
    
    /**
     * Deserializer for LocalDateTime.
     */
    private static class LocalDateTimeDeserializer extends JsonDeserializer<LocalDateTime> {
        
        @Override
        public LocalDateTime deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
            String value = p.getValueAsString();
            if (value == null || value.isEmpty()) {
                return null;
            }
            
            try {
                return LocalDateTime.parse(value);
            } catch (Exception e) {
                // Try parsing as long (timestamp)
                try {
                    long timestamp = Long.parseLong(value);
                    return LocalDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault());
                } catch (Exception ex) {
                    throw new IOException("Error parsing LocalDateTime: " + value, ex);
                }
            }
        }
    }
    
    /**
     * Serializer for ZonedDateTime.
     */
    private static class ZonedDateTimeSerializer extends JsonSerializer<ZonedDateTime> {
        
        private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_ZONED_DATE_TIME;
        
        @Override
        public void serialize(ZonedDateTime value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
            gen.writeString(value.format(FORMATTER));
        }
    }
    
    /**
     * Deserializer for ZonedDateTime.
     */
    private static class ZonedDateTimeDeserializer extends JsonDeserializer<ZonedDateTime> {
        
        @Override
        public ZonedDateTime deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
            String value = p.getValueAsString();
            if (value == null || value.isEmpty()) {
                return null;
            }
            
            try {
                return ZonedDateTime.parse(value);
            } catch (Exception e) {
                // Try parsing as long (timestamp)
                try {
                    long timestamp = Long.parseLong(value);
                    return ZonedDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault());
                } catch (Exception ex) {
                    throw new IOException("Error parsing ZonedDateTime: " + value, ex);
                }
            }
        }
    }
    
    /**
     * Serializer for Instant.
     */
    private static class InstantSerializer extends JsonSerializer<Instant> {
        
        @Override
        public void serialize(Instant value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
            gen.writeString(value.toString());
        }
    }
    
    /**
     * Deserializer for Instant.
     */
    private static class InstantDeserializer extends JsonDeserializer<Instant> {
        
        @Override
        public Instant deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
            String value = p.getValueAsString();
            if (value == null || value.isEmpty()) {
                return null;
            }
            
            try {
                return Instant.parse(value);
            } catch (Exception e) {
                // Try parsing as long (timestamp)
                try {
                    long timestamp = Long.parseLong(value);
                    return Instant.ofEpochMilli(timestamp);
                } catch (Exception ex) {
                    throw new IOException("Error parsing Instant: " + value, ex);
                }
            }
        }
    }
    
    /**
     * Serializer for byte array.
     */
    private static class ByteArraySerializer extends JsonSerializer<byte[]> {
        
        @Override
        public void serialize(byte[] value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
            gen.writeString(Base64.getEncoder().encodeToString(value));
        }
    }
    
    /**
     * Deserializer for byte array.
     */
    private static class ByteArrayDeserializer extends JsonDeserializer<byte[]> {
        
        @Override
        public byte[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
            String value = p.getValueAsString();
            if (value == null || value.isEmpty()) {
                return new byte[0];
            }
            
            try {
                return Base64.getDecoder().decode(value);
            } catch (Exception e) {
                throw new IOException("Error decoding Base64: " + value, e);
            }
        }
    }
}


StoragePathResolver.java
-----------------------------------------------

package com.cstestforge.service.storage;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Service for resolving storage paths for different data types.
 * Provides standardized path generation for projects, test results, configurations, and other data.
 */
@Service
public class StoragePathResolver {

    private static final CSLogger LOGGER = new CSLogger(StoragePathResolver.class);
    private static final Pattern INVALID_CHARS_PATTERN = Pattern.compile("[\\\\/:*?\"<>|]");
    private static final Pattern PATH_TRAVERSAL_PATTERN = Pattern.compile("\\.\\.");
    
    @Autowired
    private FileSystemStorageService storageService;
    
    private String baseStoragePath;
    private String projectsPath;
    private String resultsPath;
    private String configPath;
    private String tempPath;
    private String backupPath;
    
    private final Map<String, String> pathCache = new HashMap<>();
    
    /**
     * Initialize the path resolver.
     */
    @PostConstruct
    public void init() {
        // Wait for storageService to be initialized
        baseStoragePath = storageService.getBaseStoragePath();
        projectsPath = storageService.getProjectsPath();
        resultsPath = storageService.getResultsPath();
        configPath = storageService.getConfigPath();
        tempPath = storageService.getTempPath();
        backupPath = storageService.getBackupPath();
        
        LOGGER.info("StoragePathResolver initialized");
    }
    
    /**
     * Resolve a project path.
     * 
     * @param projectId The project ID
     * @return The resolved path relative to the base storage path
     */
    public String resolveProjectPath(String projectId) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        String sanitizedId = sanitizePathComponent(projectId);
        String cacheKey = "project_" + sanitizedId;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(projectsPath, sanitizedId).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a project file path.
     * 
     * @param projectId The project ID
     * @param filePath The file path relative to the project
     * @return The resolved path relative to the base storage path
     */
    public String resolveProjectFilePath(String projectId, String filePath) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        if (filePath == null || filePath.isEmpty()) {
            return resolveProjectPath(projectId);
        }
        
        String sanitizedId = sanitizePathComponent(projectId);
        String sanitizedPath = sanitizePath(filePath);
        String cacheKey = "project_file_" + sanitizedId + "_" + sanitizedPath;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(projectsPath, sanitizedId, sanitizedPath).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a test result path.
     * 
     * @param projectId The project ID
     * @param testRunId The test run ID
     * @return The resolved path relative to the base storage path
     */
    public String resolveTestResultPath(String projectId, String testRunId) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        if (testRunId == null || testRunId.isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        String sanitizedProjectId = sanitizePathComponent(projectId);
        String sanitizedTestRunId = sanitizePathComponent(testRunId);
        String cacheKey = "result_" + sanitizedProjectId + "_" + sanitizedTestRunId;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(resultsPath, sanitizedProjectId, sanitizedTestRunId).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a test result file path.
     * 
     * @param projectId The project ID
     * @param testRunId The test run ID
     * @param filePath The file path relative to the test result
     * @return The resolved path relative to the base storage path
     */
    public String resolveTestResultFilePath(String projectId, String testRunId, String filePath) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        if (testRunId == null || testRunId.isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        if (filePath == null || filePath.isEmpty()) {
            return resolveTestResultPath(projectId, testRunId);
        }
        
        String sanitizedProjectId = sanitizePathComponent(projectId);
        String sanitizedTestRunId = sanitizePathComponent(testRunId);
        String sanitizedPath = sanitizePath(filePath);
        String cacheKey = "result_file_" + sanitizedProjectId + "_" + sanitizedTestRunId + "_" + sanitizedPath;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(resultsPath, sanitizedProjectId, sanitizedTestRunId, sanitizedPath).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a config path.
     * 
     * @param configType The config type
     * @param configId The config ID
     * @return The resolved path relative to the base storage path
     */
    public String resolveConfigPath(String configType, String configId) {
        if (configType == null || configType.isEmpty()) {
            throw new IllegalArgumentException("Config type cannot be null or empty");
        }
        
        if (configId == null || configId.isEmpty()) {
            throw new IllegalArgumentException("Config ID cannot be null or empty");
        }
        
        String sanitizedType = sanitizePathComponent(configType);
        String sanitizedId = sanitizePathComponent(configId);
        String cacheKey = "config_" + sanitizedType + "_" + sanitizedId;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(configPath, sanitizedType, sanitizedId + ".json").toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a backup path.
     * 
     * @param originalPath The original path relative to the base storage path
     * @param backupId The backup ID
     * @return The resolved path relative to the base storage path
     */
    public String resolveBackupPath(String originalPath, String backupId) {
        if (originalPath == null || originalPath.isEmpty()) {
            throw new IllegalArgumentException("Original path cannot be null or empty");
        }
        
        if (backupId == null || backupId.isEmpty()) {
            backupId = UUID.randomUUID().toString();
        }
        
        String sanitizedPath = sanitizePath(originalPath);
        String sanitizedId = sanitizePathComponent(backupId);
        String cacheKey = "backup_" + sanitizedPath + "_" + sanitizedId;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(backupPath, sanitizedId, sanitizedPath).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a temp path.
     * 
     * @param tempId The temp ID
     * @return The resolved path relative to the base storage path
     */
    public String resolveTempPath(String tempId) {
        if (tempId == null || tempId.isEmpty()) {
            tempId = UUID.randomUUID().toString();
        }
        
        String sanitizedId = sanitizePathComponent(tempId);
        String cacheKey = "temp_" + sanitizedId;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(tempPath, sanitizedId).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a temp file path.
     * 
     * @param tempId The temp ID
     * @param filePath The file path relative to the temp directory
     * @return The resolved path relative to the base storage path
     */
    public String resolveTempFilePath(String tempId, String filePath) {
        if (tempId == null || tempId.isEmpty()) {
            tempId = UUID.randomUUID().toString();
        }
        
        if (filePath == null || filePath.isEmpty()) {
            return resolveTempPath(tempId);
        }
        
        String sanitizedId = sanitizePathComponent(tempId);
        String sanitizedPath = sanitizePath(filePath);
        String cacheKey = "temp_file_" + sanitizedId + "_" + sanitizedPath;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(tempPath, sanitizedId, sanitizedPath).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a screenshot path.
     * 
     * @param projectId The project ID
     * @param testRunId The test run ID
     * @param screenshotId The screenshot ID
     * @return The resolved path relative to the base storage path
     */
    public String resolveScreenshotPath(String projectId, String testRunId, String screenshotId) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        if (testRunId == null || testRunId.isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        if (screenshotId == null || screenshotId.isEmpty()) {
            screenshotId = UUID.randomUUID().toString();
        }
        
        String sanitizedProjectId = sanitizePathComponent(projectId);
        String sanitizedTestRunId = sanitizePathComponent(testRunId);
        String sanitizedScreenshotId = sanitizePathComponent(screenshotId);
        String cacheKey = "screenshot_" + sanitizedProjectId + "_" + sanitizedTestRunId + "_" + sanitizedScreenshotId;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(resultsPath, sanitizedProjectId, sanitizedTestRunId, "screenshots", sanitizedScreenshotId + ".png").toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a video path.
     * 
     * @param projectId The project ID
     * @param testRunId The test run ID
     * @param videoId The video ID
     * @return The resolved path relative to the base storage path
     */
    public String resolveVideoPath(String projectId, String testRunId, String videoId) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        if (testRunId == null || testRunId.isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        if (videoId == null || videoId.isEmpty()) {
            videoId = UUID.randomUUID().toString();
        }
        
        String sanitizedProjectId = sanitizePathComponent(projectId);
        String sanitizedTestRunId = sanitizePathComponent(testRunId);
        String sanitizedVideoId = sanitizePathComponent(videoId);
        String cacheKey = "video_" + sanitizedProjectId + "_" + sanitizedTestRunId + "_" + sanitizedVideoId;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(resultsPath, sanitizedProjectId, sanitizedTestRunId, "videos", sanitizedVideoId + ".mp4").toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a log path.
     * 
     * @param projectId The project ID
     * @param testRunId The test run ID
     * @param logName The log name
     * @return The resolved path relative to the base storage path
     */
    public String resolveLogPath(String projectId, String testRunId, String logName) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        if (testRunId == null || testRunId.isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        if (logName == null || logName.isEmpty()) {
            logName = "test.log";
        } else if (!logName.endsWith(".log")) {
            logName = logName + ".log";
        }
        
        String sanitizedProjectId = sanitizePathComponent(projectId);
        String sanitizedTestRunId = sanitizePathComponent(testRunId);
        String sanitizedLogName = sanitizePathComponent(logName);
        String cacheKey = "log_" + sanitizedProjectId + "_" + sanitizedTestRunId + "_" + sanitizedLogName;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(resultsPath, sanitizedProjectId, sanitizedTestRunId, "logs", sanitizedLogName).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a report path.
     * 
     * @param projectId The project ID
     * @param testRunId The test run ID
     * @param reportName The report name
     * @return The resolved path relative to the base storage path
     */
    public String resolveReportPath(String projectId, String testRunId, String reportName) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        if (testRunId == null || testRunId.isEmpty()) {
            throw new IllegalArgumentException("Test run ID cannot be null or empty");
        }
        
        if (reportName == null || reportName.isEmpty()) {
            reportName = "report.html";
        } else if (!reportName.endsWith(".html")) {
            reportName = reportName + ".html";
        }
        
        String sanitizedProjectId = sanitizePathComponent(projectId);
        String sanitizedTestRunId = sanitizePathComponent(testRunId);
        String sanitizedReportName = sanitizePathComponent(reportName);
        String cacheKey = "report_" + sanitizedProjectId + "_" + sanitizedTestRunId + "_" + sanitizedReportName;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(resultsPath, sanitizedProjectId, sanitizedTestRunId, "reports", sanitizedReportName).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a data file path.
     * 
     * @param projectId The project ID
     * @param dataFileName The data file name
     * @return The resolved path relative to the base storage path
     */
    public String resolveDataFilePath(String projectId, String dataFileName) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        if (dataFileName == null || dataFileName.isEmpty()) {
            throw new IllegalArgumentException("Data file name cannot be null or empty");
        }
        
        String sanitizedProjectId = sanitizePathComponent(projectId);
        String sanitizedDataFileName = sanitizePathComponent(dataFileName);
        String cacheKey = "data_file_" + sanitizedProjectId + "_" + sanitizedDataFileName;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(projectsPath, sanitizedProjectId, "data", sanitizedDataFileName).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a page object path.
     * 
     * @param projectId The project ID
     * @param pageObjectName The page object name
     * @return The resolved path relative to the base storage path
     */
    public String resolvePageObjectPath(String projectId, String pageObjectName) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        if (pageObjectName == null || pageObjectName.isEmpty()) {
            throw new IllegalArgumentException("Page object name cannot be null or empty");
        }
        
        String sanitizedProjectId = sanitizePathComponent(projectId);
        String sanitizedPageObjectName = sanitizePathComponent(pageObjectName);
        
        if (!sanitizedPageObjectName.endsWith(".json")) {
            sanitizedPageObjectName += ".json";
        }
        
        String cacheKey = "page_object_" + sanitizedProjectId + "_" + sanitizedPageObjectName;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(projectsPath, sanitizedProjectId, "pageobjects", sanitizedPageObjectName).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a test case path.
     * 
     * @param projectId The project ID
     * @param testCaseId The test case ID
     * @return The resolved path relative to the base storage path
     */
    public String resolveTestCasePath(String projectId, String testCaseId) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        if (testCaseId == null || testCaseId.isEmpty()) {
            throw new IllegalArgumentException("Test case ID cannot be null or empty");
        }
        
        String sanitizedProjectId = sanitizePathComponent(projectId);
        String sanitizedTestCaseId = sanitizePathComponent(testCaseId);
        
        if (!sanitizedTestCaseId.endsWith(".json")) {
            sanitizedTestCaseId += ".json";
        }
        
        String cacheKey = "test_case_" + sanitizedProjectId + "_" + sanitizedTestCaseId;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(projectsPath, sanitizedProjectId, "testcases", sanitizedTestCaseId).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a test suite path.
     * 
     * @param projectId The project ID
     * @param testSuiteId The test suite ID
     * @return The resolved path relative to the base storage path
     */
    public String resolveTestSuitePath(String projectId, String testSuiteId) {
        if (projectId == null || projectId.isEmpty()) {
            throw new IllegalArgumentException("Project ID cannot be null or empty");
        }
        
        if (testSuiteId == null || testSuiteId.isEmpty()) {
            throw new IllegalArgumentException("Test suite ID cannot be null or empty");
        }
        
        String sanitizedProjectId = sanitizePathComponent(projectId);
        String sanitizedTestSuiteId = sanitizePathComponent(testSuiteId);
        
        if (!sanitizedTestSuiteId.endsWith(".json")) {
            sanitizedTestSuiteId += ".json";
        }
        
        String cacheKey = "test_suite_" + sanitizedProjectId + "_" + sanitizedTestSuiteId;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(projectsPath, sanitizedProjectId, "testsuites", sanitizedTestSuiteId).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a framework config path.
     * 
     * @param frameworkType The framework type (selenium, playwright)
     * @param language The language (java, typescript)
     * @return The resolved path relative to the base storage path
     */
    public String resolveFrameworkConfigPath(String frameworkType, String language) {
        if (frameworkType == null || frameworkType.isEmpty()) {
            throw new IllegalArgumentException("Framework type cannot be null or empty");
        }
        
        if (language == null || language.isEmpty()) {
            throw new IllegalArgumentException("Language cannot be null or empty");
        }
        
        String sanitizedFrameworkType = sanitizePathComponent(frameworkType);
        String sanitizedLanguage = sanitizePathComponent(language);
        String cacheKey = "framework_config_" + sanitizedFrameworkType + "_" + sanitizedLanguage;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(configPath, "frameworks", sanitizedFrameworkType, sanitizedLanguage + ".json").toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a global config path.
     * 
     * @param configName The config name
     * @return The resolved path relative to the base storage path
     */
    public String resolveGlobalConfigPath(String configName) {
        if (configName == null || configName.isEmpty()) {
            throw new IllegalArgumentException("Config name cannot be null or empty");
        }
        
        String sanitizedConfigName = sanitizePathComponent(configName);
        
        if (!sanitizedConfigName.endsWith(".json")) {
            sanitizedConfigName += ".json";
        }
        
        String cacheKey = "global_config_" + sanitizedConfigName;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(configPath, "global", sanitizedConfigName).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a user config path.
     * 
     * @param userId The user ID
     * @param configName The config name
     * @return The resolved path relative to the base storage path
     */
    public String resolveUserConfigPath(String userId, String configName) {
        if (userId == null || userId.isEmpty()) {
            throw new IllegalArgumentException("User ID cannot be null or empty");
        }
        
        if (configName == null || configName.isEmpty()) {
            throw new IllegalArgumentException("Config name cannot be null or empty");
        }
        
        String sanitizedUserId = sanitizePathComponent(userId);
        String sanitizedConfigName = sanitizePathComponent(configName);
        
        if (!sanitizedConfigName.endsWith(".json")) {
            sanitizedConfigName += ".json";
        }
        
        String cacheKey = "user_config_" + sanitizedUserId + "_" + sanitizedConfigName;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(configPath, "users", sanitizedUserId, sanitizedConfigName).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Resolve a template path.
     * 
     * @param templateType The template type
     * @param templateName The template name
     * @return The resolved path relative to the base storage path
     */
    public String resolveTemplatePath(String templateType, String templateName) {
        if (templateType == null || templateType.isEmpty()) {
            throw new IllegalArgumentException("Template type cannot be null or empty");
        }
        
        if (templateName == null || templateName.isEmpty()) {
            throw new IllegalArgumentException("Template name cannot be null or empty");
        }
        
        String sanitizedTemplateType = sanitizePathComponent(templateType);
        String sanitizedTemplateName = sanitizePathComponent(templateName);
        String cacheKey = "template_" + sanitizedTemplateType + "_" + sanitizedTemplateName;
        
        if (pathCache.containsKey(cacheKey)) {
            return pathCache.get(cacheKey);
        }
        
        String relativePath = CSPathUtils.relativizeToBasePath(
                Paths.get(configPath, "templates", sanitizedTemplateType, sanitizedTemplateName).toString(), 
                baseStoragePath);
        
        pathCache.put(cacheKey, relativePath);
        return relativePath;
    }
    
    /**
     * Parse a path to extract components.
     * 
     * @param path The path to parse
     * @return Map of path components, or null if parsing failed
     */
    public Map<String, String> parsePath(String path) {
        if (path == null || path.isEmpty()) {
            return null;
        }
        
        try {
            Path fullPath = Paths.get(baseStoragePath, path);
            Path relativePath = Paths.get(baseStoragePath).relativize(fullPath);
            
            Map<String, String> components = new HashMap<>();
            components.put("fullPath", fullPath.toString());
            components.put("relativePath", relativePath.toString());
            
            // Extract project path
            if (relativePath.startsWith(Paths.get(projectsPath).getFileName())) {
                if (relativePath.getNameCount() > 1) {
                    components.put("projectId", relativePath.getName(1).toString());
                }
                
                if (relativePath.getNameCount() > 2) {
                    // Check for specific project component types
                    String component = relativePath.getName(2).toString();
                    components.put("componentType", component);
                    
                    if (relativePath.getNameCount() > 3) {
                        components.put("componentId", relativePath.getName(3).toString());
                    }
                }
            }
            // Extract result path
            else if (relativePath.startsWith(Paths.get(resultsPath).getFileName())) {
                if (relativePath.getNameCount() > 1) {
                    components.put("projectId", relativePath.getName(1).toString());
                }
                
                if (relativePath.getNameCount() > 2) {
                    components.put("testRunId", relativePath.getName(2).toString());
                }
                
                if (relativePath.getNameCount() > 3) {
                    // Check for specific result component types
                    String component = relativePath.getName(3).toString();
                    components.put("resultComponentType", component);
                    
                    if (relativePath.getNameCount() > 4) {
                        components.put("resultComponentId", relativePath.getName(4).toString());
                    }
                }
            }
            // Extract config path
            else if (relativePath.startsWith(Paths.get(configPath).getFileName())) {
                if (relativePath.getNameCount() > 1) {
                    components.put("configType", relativePath.getName(1).toString());
                }
                
                if (relativePath.getNameCount() > 2) {
                    components.put("configId", relativePath.getName(2).toString());
                }
            }
            // Extract backup path
            else if (relativePath.startsWith(Paths.get(backupPath).getFileName())) {
                if (relativePath.getNameCount() > 1) {
                    components.put("backupId", relativePath.getName(1).toString());
                }
            }
            // Extract temp path
            else if (relativePath.startsWith(Paths.get(tempPath).getFileName())) {
                if (relativePath.getNameCount() > 1) {
                    components.put("tempId", relativePath.getName(1).toString());
                }
            }
            
            return components;
        } catch (Exception e) {
            LOGGER.error("Error parsing path: " + path, e);
            return null;
        }
    }
    
    /**
     * Clear the path cache.
     */
    public void clearCache() {
        pathCache.clear();
    }
    
    /**
     * Sanitize a path component.
     * 
     * @param component The path component to sanitize
     * @return The sanitized path component
     */
    private String sanitizePathComponent(String component) {
        if (component == null || component.isEmpty()) {
            return "unknown";
        }
        
        // Replace invalid characters with underscores
        Matcher matcher = INVALID_CHARS_PATTERN.matcher(component);
        String sanitized = matcher.replaceAll("_");
        
        // Ensure no path traversal
        if (PATH_TRAVERSAL_PATTERN.matcher(sanitized).find()) {
            sanitized = sanitized.replace("..", "__");
        }
        
        return sanitized.trim();
    }
    
    /**
     * Sanitize a path.
     * 
     * @param path The path to sanitize
     * @return The sanitized path
     */
    private String sanitizePath(String path) {
        if (path == null || path.isEmpty()) {
            return "";
        }
        
        // Split path by separator and sanitize each component
        String[] components = path.split("[/\\\\]");
        StringBuilder sanitizedPath = new StringBuilder();
        
        for (String component : components) {
            if (!component.isEmpty()) {
                if (sanitizedPath.length() > 0) {
                    sanitizedPath.append("/");
                }
                sanitizedPath.append(sanitizePathComponent(component));
            }
        }
        
        return sanitizedPath.toString();
    }
}


FileLocManager.java
-------------------------------------

package com.cstestforge.service.storage;

import com.cstestforge.framework.core.utils.CSLogger;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.File;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Service for managing file locks to ensure thread-safe file operations.
 * Handles acquiring, releasing, and tracking of file locks with automatic
 * stale lock detection and cleanup.
 */
@Service
public class FileLockManager {

    private static final CSLogger LOGGER = new CSLogger(FileLockManager.class);
    private static final int MAX_RETRIES = 5;
    private static final long RETRY_DELAY_MS = 100;
    private static final long LOCK_TIMEOUT_MS = 60000; // 1 minute
    private static final long LOCK_CLEANUP_INTERVAL_MS = 30000; // 30 seconds
    
    private final Map<String, LockEntry> activeLocks = new ConcurrentHashMap<>();
    private final AtomicBoolean shutdownFlag = new AtomicBoolean(false);
    private final ScheduledExecutorService scheduler = new ScheduledThreadPoolExecutor(1);
    
    /**
     * Class representing a lock entry.
     */
    private static class LockEntry {
        private final FileChannel channel;
        private final FileLock lock;
        private final long acquiredTime;
        private final String owner;
        private final Thread ownerThread;
        
        public LockEntry(FileChannel channel, FileLock lock, String owner) {
            this.channel = channel;
            this.lock = lock;
            this.acquiredTime = System.currentTimeMillis();
            this.owner = owner;
            this.ownerThread = Thread.currentThread();
        }
        
        public FileChannel getChannel() {
            return channel;
        }
        
        public FileLock getLock() {
            return lock;
        }
        
        public long getAcquiredTime() {
            return acquiredTime;
        }
        
        public String getOwner() {
            return owner;
        }
        
        public Thread getOwnerThread() {
            return ownerThread;
        }
        
        public boolean isExpired() {
            return System.currentTimeMillis() - acquiredTime > LOCK_TIMEOUT_MS;
        }
        
        public boolean isOwnerThreadAlive() {
            return ownerThread.isAlive();
        }
        
        public void release() {
            try {
                if (lock != null && lock.isValid()) {
                    lock.release();
                }
                if (channel != null && channel.isOpen()) {
                    channel.close();
                }
            } catch (IOException e) {
                LOGGER.error("Error releasing file lock", e);
            }
        }
    }
    
    /**
     * Initialize the lock manager.
     */
    @PostConstruct
    public void init() {
        // Schedule periodic cleanup of stale locks
        scheduler.scheduleAtFixedRate(
                this::cleanupStaleLocks,
                LOCK_CLEANUP_INTERVAL_MS,
                LOCK_CLEANUP_INTERVAL_MS,
                TimeUnit.MILLISECONDS);
        
        LOGGER.info("FileLockManager initialized");
    }
    
    /**
     * Clean up resources when the service is being destroyed.
     */
    @PreDestroy
    public void shutdown() {
        shutdownFlag.set(true);
        
        // Release all locks
        for (LockEntry lockEntry : activeLocks.values()) {
            lockEntry.release();
        }
        activeLocks.clear();
        
        // Shutdown scheduler
        scheduler.shutdownNow();
        
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                LOGGER.warn("Scheduler did not terminate in time");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            LOGGER.error("Service shutdown interrupted", e);
        }
        
        LOGGER.info("FileLockManager shutdown complete");
    }
    
    /**
     * Acquire a lock on a file.
     * 
     * @param filePath The file path
     * @return true if the lock was acquired, false otherwise
     */
    public boolean acquireLock(String filePath) {
        return acquireLock(filePath, null);
    }
    
    /**
     * Acquire a lock on a file with an owner identifier.
     * 
     * @param filePath The file path
     * @param owner The owner identifier
     * @return true if the lock was acquired, false otherwise
     */
    public boolean acquireLock(String filePath, String owner) {
        if (shutdownFlag.get()) {
            return false;
        }
        
        if (filePath == null || filePath.isEmpty()) {
            return false;
        }
        
        // Check if the lock is already held by the owner
        LockEntry existingLock = activeLocks.get(filePath);
        if (existingLock != null) {
            if (existingLock.getOwnerThread().equals(Thread.currentThread())) {
                // Lock already acquired by this thread
                return true;
            }
            
            if (owner != null && owner.equals(existingLock.getOwner())) {
                // Lock already acquired by this owner
                return true;
            }
        }
        
        // Create parent directories if not exist
        try {
            File file = new File(filePath);
            File parentDir = file.getParentFile();
            if (parentDir != null && !parentDir.exists()) {
                parentDir.mkdirs();
            }
        } catch (Exception e) {
            LOGGER.error("Error creating parent directories for file: " + filePath, e);
            return false;
        }
        
        // Try to acquire the lock with retries
        for (int retry = 0; retry < MAX_RETRIES; retry++) {
            try {
                // Create the file if it doesn't exist
                Path path = Paths.get(filePath);
                if (!Files.exists(path)) {
                    Files.createFile(path);
                }
                
                FileChannel channel = FileChannel.open(path, StandardOpenOption.READ, StandardOpenOption.WRITE);
                
                // Try to acquire the lock (non-blocking)
                FileLock lock = channel.tryLock();
                if (lock != null) {
                    LockEntry lockEntry = new LockEntry(channel, lock, owner);
                    activeLocks.put(filePath, lockEntry);
                    return true;
                }
                
                // Lock not acquired, close channel and retry
                channel.close();
                
                // Wait before retrying
                Thread.sleep(RETRY_DELAY_MS);
            } catch (IOException | InterruptedException e) {
                if (e instanceof InterruptedException) {
                    Thread.currentThread().interrupt();
                    return false;
                }
                
                LOGGER.warn("Failed to acquire lock for file: " + filePath + ", retry: " + retry, e);
                
                // Wait before retrying
                try {
                    Thread.sleep(RETRY_DELAY_MS);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    return false;
                }
            }
        }
        
        LOGGER.error("Failed to acquire lock for file after " + MAX_RETRIES + " retries: " + filePath);
        return false;
    }
    
    /**
     * Release a lock on a file.
     * 
     * @param filePath The file path
     * @return true if the lock was released, false otherwise
     */
    public boolean releaseLock(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return false;
        }
        
        LockEntry lockEntry = activeLocks.remove(filePath);
        if (lockEntry != null) {
            lockEntry.release();
            return true;
        }
        
        return false;
    }
    
    /**
     * Check if a file is locked.
     * 
     * @param filePath The file path
     * @return true if the file is locked, false otherwise
     */
    public boolean isLocked(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return false;
        }
        
        return activeLocks.containsKey(filePath);
    }
    
    /**
     * Check if a file is locked by the current thread.
     * 
     * @param filePath The file path
     * @return true if the file is locked by the current thread, false otherwise
     */
    public boolean isLockedByCurrentThread(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return false;
        }
        
        LockEntry lockEntry = activeLocks.get(filePath);
        return lockEntry != null && lockEntry.getOwnerThread().equals(Thread.currentThread());
    }
    
    /**
     * Check if a file is locked by a specific owner.
     * 
     * @param filePath The file path
     * @param owner The owner identifier
     * @return true if the file is locked by the owner, false otherwise
     */
    public boolean isLockedBy(String filePath, String owner) {
        if (filePath == null || filePath.isEmpty() || owner == null || owner.isEmpty()) {
            return false;
        }
        
        LockEntry lockEntry = activeLocks.get(filePath);
        return lockEntry != null && owner.equals(lockEntry.getOwner());
    }
    
    /**
     * Get the lock owner for a file.
     * 
     * @param filePath The file path
     * @return The lock owner, or null if the file is not locked
     */
    public String getLockOwner(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return null;
        }
        
        LockEntry lockEntry = activeLocks.get(filePath);
        return lockEntry != null ? lockEntry.getOwner() : null;
    }
    
    /**
     * Get the lock acquisition time for a file.
     * 
     * @param filePath The file path
     * @return The lock acquisition time in milliseconds, or 0 if the file is not locked
     */
    public long getLockAcquisitionTime(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return 0;
        }
        
        LockEntry lockEntry = activeLocks.get(filePath);
        return lockEntry != null ? lockEntry.getAcquiredTime() : 0;
    }
    
    /**
     * Get the number of active locks.
     * 
     * @return The number of active locks
     */
    public int getActiveLockCount() {
        return activeLocks.size();
    }
    
    /**
     * Clean up stale locks.
     */
    private void cleanupStaleLocks() {
        if (shutdownFlag.get()) {
            return;
        }
        
        try {
            for (Map.Entry<String, LockEntry> entry : activeLocks.entrySet()) {
                String filePath = entry.getKey();
                LockEntry lockEntry = entry.getValue();
                
                // Check if lock is expired or owner thread is no longer alive
                if (lockEntry.isExpired() || !lockEntry.isOwnerThreadAlive()) {
                    // Release the lock
                    lockEntry.release();
                    
                    // Remove from active locks
                    activeLocks.remove(filePath);
                    
                    LOGGER.info("Cleaned up stale lock for file: " + filePath + 
                            ", expired: " + lockEntry.isExpired() + 
                            ", thread alive: " + lockEntry.isOwnerThreadAlive());
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error cleaning up stale locks", e);
        }
    }
}


BackupService.java
-------------------------------------------

package com.cstestforge.service.storage;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Service for managing backups of files and directories.
 * Provides methods for creating, restoring, and managing backups
 * with automatic cleanup of old backups.
 */
@Service
public class BackupService {

    private static final CSLogger LOGGER = new CSLogger(BackupService.class);
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss");
    private static final int DEFAULT_MAX_BACKUPS = 10;
    private static final long DEFAULT_BACKUP_RETENTION_DAYS = 30;
    private static final long CLEANUP_INTERVAL_HOURS = 24;
    
    @Value("${cstestforge.backup.max-backups:10}")
    private int maxBackups;
    
    @Value("${cstestforge.backup.retention-days:30}")
    private long retentionDays;
    
    @Autowired
    private FileSystemStorageService storageService;
    
    @Autowired
    private FileLockManager lockManager;
    
    @Autowired
    private DataCompressionService compressionService;
    
    private final Map<String, BackupMetadata> backupRegistry = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    private final AtomicBoolean shutdownFlag = new AtomicBoolean(false);
    
    private String backupPath;
    private String baseStoragePath;
    
    /**
     * Class representing backup metadata.
     */
    private static class BackupMetadata {
        private final String backupId;
        private final String originalPath;
        private final String backupPath;
        private final long timestamp;
        private final String label;
        private final String owner;
        private final boolean compressed;
        private final long size;
        private final Map<String, String> metadata;
        
        public BackupMetadata(String backupId, String originalPath, String backupPath, long timestamp, 
                              String label, String owner, boolean compressed, long size) {
            this.backupId = backupId;
            this.originalPath = originalPath;
            this.backupPath = backupPath;
            this.timestamp = timestamp;
            this.label = label;
            this.owner = owner;
            this.compressed = compressed;
            this.size = size;
            this.metadata = new HashMap<>();
        }
        
        public String getBackupId() {
            return backupId;
        }
        
        public String getOriginalPath() {
            return originalPath;
        }
        
        public String getBackupPath() {
            return backupPath;
        }
        
        public long getTimestamp() {
            return timestamp;
        }
        
        public String getLabel() {
            return label;
        }
        
        public String getOwner() {
            return owner;
        }
        
        public boolean isCompressed() {
            return compressed;
        }
        
        public long getSize() {
            return size;
        }
        
        public Map<String, String> getMetadata() {
            return metadata;
        }
        
        public void addMetadata(String key, String value) {
            metadata.put(key, value);
        }
        
        public Map<String, Object> toMap() {
            Map<String, Object> map = new HashMap<>();
            map.put("backupId", backupId);
            map.put("originalPath", originalPath);
            map.put("backupPath", backupPath);
            map.put("timestamp", timestamp);
            
            // Format timestamp for display
            LocalDateTime dateTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault());
            map.put("formattedTimestamp", dateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
            
            map.put("label", label);
            map.put("owner", owner);
            map.put("compressed", compressed);
            map.put("size", size);
            
            // Format size for display
            map.put("formattedSize", formatSize(size));
            
            map.put("metadata", metadata);
            return map;
        }
    }
    
    /**
     * Initialize the backup service.
     */
    @PostConstruct
    public void init() {
        baseStoragePath = storageService.getBaseStoragePath();
        backupPath = storageService.getBackupPath();
        
        // Set configuration values
        if (maxBackups <= 0) {
            maxBackups = DEFAULT_MAX_BACKUPS;
        }
        
        if (retentionDays <= 0) {
            retentionDays = DEFAULT_BACKUP_RETENTION_DAYS;
        }
        
        // Load existing backups from backup directory
        loadExistingBackups();
        
        // Schedule periodic cleanup of old backups
        scheduler.scheduleAtFixedRate(
                this::cleanupOldBackups,
                1,
                CLEANUP_INTERVAL_HOURS,
                TimeUnit.HOURS);
        
        LOGGER.info("BackupService initialized with maxBackups: " + maxBackups + 
                ", retentionDays: " + retentionDays);
    }
    
    /**
     * Clean up resources when the service is being destroyed.
     */
    @PreDestroy
    public void shutdown() {
        shutdownFlag.set(true);
        
        // Shutdown scheduler
        scheduler.shutdownNow();
        
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                LOGGER.warn("Scheduler did not terminate in time");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            LOGGER.error("Service shutdown interrupted", e);
        }
        
        LOGGER.info("BackupService shutdown complete");
    }
    
    /**
     * Create a backup of a file or directory.
     * 
     * @param path The path relative to the base storage path
     * @param owner The owner identifier for locking
     * @return The backup ID, or null if the backup failed
     */
    public String createBackup(String path, String owner) {
        return createBackup(path, null, owner, false);
    }
    
    /**
     * Create a backup of a file or directory with a label.
     * 
     * @param path The path relative to the base storage path
     * @param label The backup label
     * @param owner The owner identifier for locking
     * @param compress Whether to compress the backup
     * @return The backup ID, or null if the backup failed
     */
    public String createBackup(String path, String label, String owner, boolean compress) {
        if (shutdownFlag.get()) {
            return null;
        }
        
        if (path == null || path.isEmpty()) {
            return null;
        }
        
        try {
            // Generate backup ID based on timestamp
            String timestamp = DATE_FORMATTER.format(LocalDateTime.now());
            String backupId = timestamp + "_" + path.replace('/', '_').replace('\\', '_');
            
            // Create backup directory structure
            Path backupDirPath = Paths.get(backupPath, backupId);
            Files.createDirectories(backupDirPath);
            
            // Get actual source path
            Path sourcePath = Paths.get(baseStoragePath, path);
            
            // Skip if the source doesn't exist
            if (!Files.exists(sourcePath)) {
                LOGGER.warn("Source path does not exist for backup: " + path);
                return null;
            }
            
            // Create destination path (preserving directory structure)
            Path destPath = backupDirPath.resolve(Paths.get(path).getFileName());
            
            boolean success;
            long size = 0;
            
            // Skip backup if it's a directory with no content
            if (Files.isDirectory(sourcePath) && isDirEmpty(sourcePath)) {
                LOGGER.debug("Skipping backup of empty directory: " + path);
                return null;
            }
            
            // Lock source for consistent backup
            if (lockManager.acquireLock(sourcePath.toString(), owner)) {
                try {
                    if (Files.isDirectory(sourcePath)) {
                        // Copy directory structure
                        success = copyDirectory(sourcePath, destPath);
                        
                        // Calculate directory size
                        size = calculateDirectorySize(destPath);
                    } else {
                        // Copy file
                        Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);
                        success = true;
                        
                        // Get file size
                        size = Files.size(destPath);
                    }
                } finally {
                    lockManager.releaseLock(sourcePath.toString());
                }
                
                // Compress if requested
                if (compress && success) {
                    String backupPathStr = CSPathUtils.relativizeToBasePath(destPath.toString(), baseStoragePath);
                    String compressedPath = backupPathStr + ".zip";
                    
                    boolean compressed = compressionService.compress(backupPathStr, compressedPath, owner);
                    if (compressed) {
                        // Update destination path and set compressed flag
                        destPath = Paths.get(baseStoragePath, compressedPath);
                        
                        // Delete original uncompressed backup
                        deleteDirectory(Paths.get(baseStoragePath, backupPathStr));
                        
                        // Update size
                        size = Files.size(destPath);
                    }
                }
                
                if (success) {
                    // Add to registry
                    String relativeBackupPath = CSPathUtils.relativizeToBasePath(destPath.toString(), baseStoragePath);
                    BackupMetadata metadata = new BackupMetadata(
                            backupId,
                            path,
                            relativeBackupPath,
                            System.currentTimeMillis(),
                            label != null ? label : "",
                            owner,
                            compress,
                            size
                    );
                    
                    // Add additional metadata
                    metadata.addMetadata("originalFileName", Paths.get(path).getFileName().toString());
                    metadata.addMetadata("backupTime", LocalDateTime.now().toString());
                    
                    backupRegistry.put(backupId, metadata);
                    
                    // Save backup registry
                    saveBackupRegistry();
                    
                    // Enforce max backups limit
                    enforceBackupLimits(path);
                    
                    LOGGER.info("Created backup with ID: " + backupId + " for path: " + path);
                    return backupId;
                }
            } else {
                LOGGER.error("Failed to acquire lock for backup: " + path);
            }
            
            return null;
        } catch (IOException e) {
            LOGGER.error("Error creating backup for path: " + path, e);
            return null;
        }
    }
    
    /**
     * Restore a backup.
     * 
     * @param backupId The backup ID
     * @param owner The owner identifier for locking
     * @return true if the restore was successful, false otherwise
     */
    public boolean restoreBackup(String backupId, String owner) {
        if (shutdownFlag.get()) {
            return false;
        }
        
        if (backupId == null || backupId.isEmpty()) {
            return false;
        }
        
        BackupMetadata metadata = backupRegistry.get(backupId);
        if (metadata == null) {
            LOGGER.warn("Backup not found with ID: " + backupId);
            return false;
        }
        
        try {
            String originalPath = metadata.getOriginalPath();
            String backupPath = metadata.getBackupPath();
            
            // Get actual paths
            Path sourcePath = Paths.get(baseStoragePath, backupPath);
            Path destPath = Paths.get(baseStoragePath, originalPath);
            
            // Skip if the source doesn't exist
            if (!Files.exists(sourcePath)) {
                LOGGER.warn("Backup source path does not exist for ID: " + backupId);
                return false;
            }
            
            // Decompress if compressed
            if (metadata.isCompressed()) {
                // Create temporary extraction directory
                String tempPath = storageService.resolveTempPath("restore_" + backupId);
                Path tempDirPath = Paths.get(baseStoragePath, tempPath);
                Files.createDirectories(tempDirPath);
                
                // Decompress to temp directory
                boolean decompressed = compressionService.decompress(backupPath, tempPath, owner);
                if (decompressed) {
                    // Update source path to decompressed content
                    try (Stream<Path> paths = Files.list(tempDirPath)) {
                        Optional<Path> firstItem = paths.findFirst();
                        if (firstItem.isPresent()) {
                            sourcePath = firstItem.get();
                        }
                    }
                } else {
                    LOGGER.error("Failed to decompress backup: " + backupId);
                    return false;
                }
            }
            
            boolean success;
            
            // Create destination parent directory if it doesn't exist
            Files.createDirectories(destPath.getParent());
            
            // Lock destination for consistent restore
            if (lockManager.acquireLock(destPath.toString(), owner)) {
                try {
                    // Create a backup of the current state before restoring
                    String currentBackupId = createBackup(originalPath, "pre_restore_" + backupId, owner, false);
                    
                    // Copy from backup to original location
                    if (Files.isDirectory(sourcePath)) {
                        // Delete existing directory content first
                        if (Files.exists(destPath)) {
                            deleteDirectory(destPath);
                        }
                        
                        // Create the directory
                        Files.createDirectories(destPath);
                        
                        // Copy directory structure
                        success = copyDirectory(sourcePath, destPath);
                    } else {
                        // Copy file
                        Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);
                        success = true;
                    }
                    
                    LOGGER.info("Restored backup with ID: " + backupId + " to path: " + originalPath +
                            ", previous state backup ID: " + currentBackupId);
                } finally {
                    lockManager.releaseLock(destPath.toString());
                }
                
                return success;
            } else {
                LOGGER.error("Failed to acquire lock for restore: " + originalPath);
            }
            
            return false;
        } catch (IOException e) {
            LOGGER.error("Error restoring backup with ID: " + backupId, e);
            return false;
        }
    }
    
    /**
     * List backups for a path.
     * 
     * @param path The path relative to the base storage path
     * @return List of backup metadata, or empty list if none found
     */
    public List<Map<String, Object>> listBackups(String path) {
        if (path == null || path.isEmpty()) {
            return Collections.emptyList();
        }
        
        return backupRegistry.values().stream()
                .filter(metadata -> metadata.getOriginalPath().equals(path))
                .sorted(Comparator.comparingLong(BackupMetadata::getTimestamp).reversed())
                .map(BackupMetadata::toMap)
                .collect(Collectors.toList());
    }
    
    /**
     * List all backups.
     * 
     * @return List of all backup metadata, or empty list if none found
     */
    public List<Map<String, Object>> listAllBackups() {
        return backupRegistry.values().stream()
                .sorted(Comparator.comparingLong(BackupMetadata::getTimestamp).reversed())
                .map(BackupMetadata::toMap)
                .collect(Collectors.toList());
    }
    
    /**
     * Get backup metadata.
     * 
     * @param backupId The backup ID
     * @return The backup metadata, or null if not found
     */
    public Map<String, Object> getBackupMetadata(String backupId) {
        if (backupId == null || backupId.isEmpty()) {
            return null;
        }
        
        BackupMetadata metadata = backupRegistry.get(backupId);
        return metadata != null ? metadata.toMap() : null;
    }
    
    /**
     * Delete a backup.
     * 
     * @param backupId The backup ID
     * @return true if the delete was successful, false otherwise
     */
    public boolean deleteBackup(String backupId) {
        if (backupId == null || backupId.isEmpty()) {
            return false;
        }
        
        BackupMetadata metadata = backupRegistry.get(backupId);
        if (metadata == null) {
            LOGGER.warn("Backup not found with ID: " + backupId);
            return false;
        }
        
        try {
            String backupPath = metadata.getBackupPath();
            
            // Get actual path
            Path path = Paths.get(baseStoragePath, backupPath);
            
            boolean success;
            
            // Delete backup files
            if (Files.isDirectory(path)) {
                success = deleteDirectory(path);
            } else {
                Files.deleteIfExists(path);
                success = true;
            }
            
            if (success) {
                // Remove from registry
                backupRegistry.remove(backupId);
                
                // Save backup registry
                saveBackupRegistry();
                
                LOGGER.info("Deleted backup with ID: " + backupId);
                return true;
            }
            
            return false;
        } catch (IOException e) {
            LOGGER.error("Error deleting backup with ID: " + backupId, e);
            return false;
        }
    }
    
    /**
     * Clean up old backups based on retention policy.
     */
    public void cleanupOldBackups() {
        if (shutdownFlag.get()) {
            return;
        }
        
        try {
            LOGGER.info("Starting backup cleanup");
            
            // Get cutoff timestamp for retention period
            long cutoffTime = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(retentionDays);
            
            // Find old backups
            List<String> backupsToDelete = backupRegistry.values().stream()
                    .filter(metadata -> metadata.getTimestamp() < cutoffTime)
                    .map(BackupMetadata::getBackupId)
                    .collect(Collectors.toList());
            
            int deletedCount = 0;
            
            // Delete old backups
            for (String backupId : backupsToDelete) {
                if (deleteBackup(backupId)) {
                    deletedCount++;
                }
            }
            
            LOGGER.info("Backup cleanup completed, deleted " + deletedCount + " old backups");
        } catch (Exception e) {
            LOGGER.error("Error cleaning up old backups", e);
        }
    }
    
    /**
     * Load existing backups from the backup directory.
     */
    private void loadExistingBackups() {
        try {
            // Create backup registry file if it doesn't exist
            Path registryFile = Paths.get(backupPath, "backup-registry.json");
            if (!Files.exists(registryFile)) {
                Files.createDirectories(registryFile.getParent());
                saveBackupRegistry();
                return;
            }
            
            // Load backup registry from file
            String json = new String(Files.readAllBytes(registryFile));
            
            // Deserialize registry
            Map<String, Map<String, Object>> registryMap = 
                    storageService.loadObject("backups/backup-registry.json", Map.class);
            
            if (registryMap != null) {
                for (Map.Entry<String, Map<String, Object>> entry : registryMap.entrySet()) {
                    String backupId = entry.getKey();
                    Map<String, Object> data = entry.getValue();
                    
                    String originalPath = (String) data.get("originalPath");
                    String backupPath = (String) data.get("backupPath");
                    long timestamp = ((Number) data.getOrDefault("timestamp", 0)).longValue();
                    String label = (String) data.getOrDefault("label", "");
                    String owner = (String) data.getOrDefault("owner", "");
                    boolean compressed = (Boolean) data.getOrDefault("compressed", false);
                    long size = ((Number) data.getOrDefault("size", 0)).longValue();
                    
                    BackupMetadata metadata = new BackupMetadata(
                            backupId, originalPath, backupPath, timestamp, 
                            label, owner, compressed, size);
                    
                    // Add additional metadata
                    @SuppressWarnings("unchecked")
                    Map<String, String> metadataMap = (Map<String, String>) data.getOrDefault("metadata", 
                            Collections.emptyMap());
                    
                    for (Map.Entry<String, String> metaEntry : metadataMap.entrySet()) {
                        metadata.addMetadata(metaEntry.getKey(), metaEntry.getValue());
                    }
                    
                    // Verify backup exists
                    Path backupFilePath = Paths.get(baseStoragePath, backupPath);
                    if (Files.exists(backupFilePath)) {
                        backupRegistry.put(backupId, metadata);
                    }
                }
            }
            
            LOGGER.info("Loaded " + backupRegistry.size() + " existing backups");
        } catch (Exception e) {
            LOGGER.error("Error loading existing backups", e);
        }
    }
    
    /**
     * Save backup registry to file.
     */
    private void saveBackupRegistry() {
        try {
            // Convert registry to map
            Map<String, Map<String, Object>> registryMap = new HashMap<>();
            
            for (Map.Entry<String, BackupMetadata> entry : backupRegistry.entrySet()) {
                registryMap.put(entry.getKey(), entry.getValue().toMap());
            }
            
            // Save to file
            storageService.storeObject(registryMap, "backups/backup-registry.json");
        } catch (Exception e) {
            LOGGER.error("Error saving backup registry", e);
        }
    }
    
    /**
     * Enforce backup limits for a path.
     * 
     * @param path The path to enforce limits for
     */
    private void enforceBackupLimits(String path) {
        if (path == null || path.isEmpty()) {
            return;
        }
        
        try {
            // Get backups for this path
            List<BackupMetadata> pathBackups = backupRegistry.values().stream()
                    .filter(metadata -> metadata.getOriginalPath().equals(path))
                    .sorted(Comparator.comparingLong(BackupMetadata::getTimestamp))
                    .collect(Collectors.toList());
            
            // Remove oldest backups if exceeding limit
            if (pathBackups.size() > maxBackups) {
                int toRemove = pathBackups.size() - maxBackups;
                
                for (int i = 0; i < toRemove; i++) {
                    BackupMetadata oldestBackup = pathBackups.get(i);
                    deleteBackup(oldestBackup.getBackupId());
                }
                
                LOGGER.info("Enforced backup limit for path: " + path + ", removed " + toRemove + " old backups");
            }
        } catch (Exception e) {
            LOGGER.error("Error enforcing backup limits for path: " + path, e);
        }
    }
    
    /**
     * Copy a directory recursively.
     * 
     * @param source The source directory
     * @param destination The destination directory
     * @return true if the copy was successful, false otherwise
     */
    private boolean copyDirectory(Path source, Path destination) throws IOException {
        Files.createDirectories(destination);
        
        try (Stream<Path> stream = Files.walk(source)) {
            for (Path sourcePath : stream.collect(Collectors.toList())) {
                Path targetPath = destination.resolve(source.relativize(sourcePath));
                
                if (Files.isDirectory(sourcePath)) {
                    Files.createDirectories(targetPath);
                } else {
                    Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
                }
            }
        }
        
        return true;
    }
    
    /**
     * Delete a directory recursively.
     * 
     * @param directory The directory to delete
     * @return true if the delete was successful, false otherwise
     */
    private boolean deleteDirectory(Path directory) throws IOException {
        if (!Files.exists(directory)) {
            return true;
        }
        
        try (Stream<Path> paths = Files.walk(directory)) {
            paths.sorted(Comparator.reverseOrder())
                 .forEach(path -> {
                     try {
                         Files.delete(path);
                     } catch (IOException e) {
                         LOGGER.warn("Failed to delete path: " + path, e);
                     }
                 });
        }
        
        return !Files.exists(directory);
    }
    
    /**
     * Calculate the size of a directory recursively.
     * 
     * @param directory The directory to calculate size for
     * @return The directory size in bytes
     */
    private long calculateDirectorySize(Path directory) throws IOException {
        if (!Files.exists(directory) || !Files.isDirectory(directory)) {
            return 0;
        }
        
        try (Stream<Path> paths = Files.walk(directory)) {
            return paths.filter(Files::isRegularFile)
                      .mapToLong(p -> {
                          try {
                              return Files.size(p);
                          } catch (IOException e) {
                              return 0;
                          }
                      })
                      .sum();
        }
    }
    
    /**
     * Check if a directory is empty.
     * 
     * @param directory The directory to check
     * @return true if the directory is empty, false otherwise
     */
    private boolean isDirEmpty(Path directory) throws IOException {
        if (!Files.isDirectory(directory)) {
            return false;
        }
        
        try (Stream<Path> entries = Files.list(directory)) {
            return !entries.findFirst().isPresent();
        }
    }
    
    /**
     * Format a size in bytes to a human-readable string.
     * 
     * @param size The size in bytes
     * @return The formatted size string
     */
    private static String formatSize(long size) {
        if (size < 1024) {
            return size + " B";
        }
        
        int exp = (int) (Math.log(size) / Math.log(1024));
        String pre = "KMGTPE".charAt(exp - 1) + "";
        
        return String.format("%.2f %sB", size / Math.pow(1024, exp), pre);
    }
}

DataCompressionService.java
----------------------------------------------------

package com.cstestforge.service.storage;

import com.cstestforge.framework.core.utils.CSLogger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.zip.Deflater;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

/**
 * Service for compression and decompression of files and directories.
 * Supports ZIP and GZIP formats with configurable compression levels
 * and additional metadata.
 */
@Service
public class DataCompressionService {

    private static final CSLogger LOGGER = new CSLogger(DataCompressionService.class);
    private static final int BUFFER_SIZE = 8192;
    private static final int DEFAULT_COMPRESSION_LEVEL = Deflater.BEST_COMPRESSION;
    private static final String ZIP_EXTENSION = ".zip";
    private static final String GZIP_EXTENSION = ".gz";
    private static final String METADATA_FILE = "meta.json";
    
    @Autowired
    private FileSystemStorageService storageService;
    
    @Autowired
    private FileLockManager lockManager;
    
    @Autowired
    private DataSerializer dataSerializer;
    
    private final Map<String, CompressionJob> activeJobs = new ConcurrentHashMap<>();
    private String baseStoragePath;
    
    /**
     * Class representing a compression job.
     */
    private static class CompressionJob {
        private final String sourcePath;
        private final String targetPath;
        private final long startTime;
        private long processedBytes;
        private long totalBytes;
        private int progress;
        private boolean completed;
        private boolean success;
        private String error;
        
        public CompressionJob(String sourcePath, String targetPath) {
            this.sourcePath = sourcePath;
            this.targetPath = targetPath;
            this.startTime = System.currentTimeMillis();
            this.processedBytes = 0;
            this.totalBytes = 0;
            this.progress = 0;
            this.completed = false;
            this.success = false;
            this.error = null;
        }
        
        public String getSourcePath() {
            return sourcePath;
        }
        
        public String getTargetPath() {
            return targetPath;
        }
        
        public long getStartTime() {
            return startTime;
        }
        
        public long getProcessedBytes() {
            return processedBytes;
        }
        
        public void setProcessedBytes(long processedBytes) {
            this.processedBytes = processedBytes;
            
            // Update progress if total bytes is known
            if (totalBytes > 0) {
                this.progress = (int) ((processedBytes * 100) / totalBytes);
            }
        }
        
        public long getTotalBytes() {
            return totalBytes;
        }
        
        public void setTotalBytes(long totalBytes) {
            this.totalBytes = totalBytes;
        }
        
        public int getProgress() {
            return progress;
        }
        
        public void setProgress(int progress) {
            this.progress = progress;
        }
        
        public boolean isCompleted() {
            return completed;
        }
        
        public void setCompleted(boolean completed) {
            this.completed = completed;
        }
        
        public boolean isSuccess() {
            return success;
        }
        
        public void setSuccess(boolean success) {
            this.success = success;
        }
        
        public String getError() {
            return error;
        }
        
        public void setError(String error) {
            this.error = error;
        }
        
        public Map<String, Object> toMap() {
            Map<String, Object> map = new HashMap<>();
            map.put("sourcePath", sourcePath);
            map.put("targetPath", targetPath);
            map.put("startTime", startTime);
            map.put("processedBytes", processedBytes);
            map.put("totalBytes", totalBytes);
            map.put("progress", progress);
            map.put("completed", completed);
            map.put("success", success);
            map.put("error", error);
            
            // Calculate elapsed time
            long elapsedTime = System.currentTimeMillis() - startTime;
            map.put("elapsedTimeMs", elapsedTime);
            
            // Calculate remaining time based on progress
            long remainingTimeMs = 0;
            if (progress > 0 && progress < 100) {
                remainingTimeMs = (elapsedTime * (100 - progress)) / progress;
            }
            map.put("remainingTimeMs", remainingTimeMs);
            
            return map;
        }
    }
    
    /**
     * Initialize the compression service.
     */
    @PostConstruct
    public void init() {
        baseStoragePath = storageService.getBaseStoragePath();
        LOGGER.info("DataCompressionService initialized");
    }
    
    /**
     * Compress a file or directory.
     * 
     * @param sourcePath The source path relative to the base storage path
     * @param targetPath The target path relative to the base storage path
     * @param owner The owner identifier for locking
     * @return true if the compression was successful, false otherwise
     */
    public boolean compress(String sourcePath, String targetPath, String owner) {
        return compress(sourcePath, targetPath, owner, DEFAULT_COMPRESSION_LEVEL, null);
    }
    
    /**
     * Compress a file or directory with a specific compression level and metadata.
     * 
     * @param sourcePath The source path relative to the base storage path
     * @param targetPath The target path relative to the base storage path
     * @param owner The owner identifier for locking
     * @param compressionLevel The compression level (0-9)
     * @param metadata Additional metadata to include in the archive
     * @return true if the compression was successful, false otherwise
     */
    public boolean compress(String sourcePath, String targetPath, String owner, 
                            int compressionLevel, Map<String, String> metadata) {
        if (sourcePath == null || sourcePath.isEmpty() || targetPath == null || targetPath.isEmpty()) {
            return false;
        }
        
        // Use default compression level if invalid
        if (compressionLevel < 0 || compressionLevel > 9) {
            compressionLevel = DEFAULT_COMPRESSION_LEVEL;
        }
        
        // Create a job ID for tracking
        String jobId = sourcePath + "_to_" + targetPath;
        
        // Create a compression job
        CompressionJob job = new CompressionJob(sourcePath, targetPath);
        activeJobs.put(jobId, job);
        
        try {
            // Get actual paths
            Path source = Paths.get(baseStoragePath, sourcePath);
            Path target = Paths.get(baseStoragePath, targetPath);
            
            // Skip if the source doesn't exist
            if (!Files.exists(source)) {
                job.setCompleted(true);
                job.setError("Source path does not exist: " + sourcePath);
                LOGGER.warn("Source path does not exist for compression: " + sourcePath);
                return false;
            }
            
            // Create parent directories if not exist
            Files.createDirectories(target.getParent());
            
            // Determine compression type based on target extension
            boolean isZip = targetPath.toLowerCase().endsWith(ZIP_EXTENSION);
            boolean isGzip = targetPath.toLowerCase().endsWith(GZIP_EXTENSION);
            
            // Default to ZIP for directories
            if (!isZip && !isGzip) {
                if (Files.isDirectory(source)) {
                    isZip = true;
                    target = Paths.get(target.toString() + ZIP_EXTENSION);
                    targetPath = targetPath + ZIP_EXTENSION;
                } else {
                    isGzip = true;
                    target = Paths.get(target.toString() + GZIP_EXTENSION);
                    targetPath = targetPath + GZIP_EXTENSION;
                }
            }
            
            // Lock source for consistent compression
            if (lockManager.acquireLock(source.toString(), owner)) {
                try {
                    // Calculate total size for progress tracking
                    job.setTotalBytes(calculateTotalSize(source));
                    
                    if (Files.isDirectory(source) && isZip) {
                        // Compress directory to ZIP
                        compressDirectoryToZip(source, target, compressionLevel, metadata, job);
                    } else if (!Files.isDirectory(source) && isZip) {
                        // Compress file to ZIP
                        compressFileToZip(source, target, compressionLevel, metadata, job);
                    } else if (!Files.isDirectory(source) && isGzip) {
                        // Compress file to GZIP
                        compressFileToGzip(source, target, compressionLevel, job);
                    } else {
                        job.setCompleted(true);
                        job.setError("Incompatible source type and compression format");
                        LOGGER.error("Cannot compress a directory with GZIP");
                        return false;
                    }
                    
                    job.setCompleted(true);
                    job.setSuccess(true);
                    job.setProgress(100);
                    
                    LOGGER.info("Compression completed successfully: " + sourcePath + " to " + targetPath);
                    return true;
                } finally {
                    lockManager.releaseLock(source.toString());
                }
            } else {
                job.setCompleted(true);
                job.setError("Failed to acquire lock for compression");
                LOGGER.error("Failed to acquire lock for compression: " + sourcePath);
                return false;
            }
        } catch (IOException e) {
            job.setCompleted(true);
            job.setError("Error during compression: " + e.getMessage());
            LOGGER.error("Error compressing: " + sourcePath + " to " + targetPath, e);
            return false;
        } finally {
            // Keep the job in the active jobs map for status queries
            // It will be removed automatically after a certain time period
            // or when explicitly queried and found to be completed
        }
    }
    
    /**
     * Decompress a file.
     * 
     * @param sourcePath The source path relative to the base storage path
     * @param targetPath The target path relative to the base storage path
     * @param owner The owner identifier for locking
     * @return true if the decompression was successful, false otherwise
     */
    public boolean decompress(String sourcePath, String targetPath, String owner) {
        if (sourcePath == null || sourcePath.isEmpty() || targetPath == null || targetPath.isEmpty()) {
            return false;
        }
        
        // Create a job ID for tracking
        String jobId = sourcePath + "_to_" + targetPath;
        
        // Create a compression job
        CompressionJob job = new CompressionJob(sourcePath, targetPath);
        activeJobs.put(jobId, job);
        
        try {
            // Get actual paths
            Path source = Paths.get(baseStoragePath, sourcePath);
            Path target = Paths.get(baseStoragePath, targetPath);
            
            // Skip if the source doesn't exist
            if (!Files.exists(source)) {
                job.setCompleted(true);
                job.setError("Source path does not exist: " + sourcePath);
                LOGGER.warn("Source path does not exist for decompression: " + sourcePath);
                return false;
            }
            
            // Create parent directories if not exist
            Files.createDirectories(target);
            
            // Determine compression type based on source extension
            boolean isZip = sourcePath.toLowerCase().endsWith(ZIP_EXTENSION);
            boolean isGzip = sourcePath.toLowerCase().endsWith(GZIP_EXTENSION);
            
            if (!isZip && !isGzip) {
                job.setCompleted(true);
                job.setError("Unsupported compression format");
                LOGGER.error("Unsupported compression format for decompression: " + sourcePath);
                return false;
            }
            
            // Lock source for consistent decompression
            if (lockManager.acquireLock(source.toString(), owner)) {
                try {
                    // Set total size for progress tracking
                    job.setTotalBytes(Files.size(source));
                    
                    if (isZip) {
                        // Decompress ZIP
                        decompressZip(source, target, job);
                    } else {
                        // Decompress GZIP
                        decompressGzip(source, target, job);
                    }
                    
                    job.setCompleted(true);
                    job.setSuccess(true);
                    job.setProgress(100);
                    
                    LOGGER.info("Decompression completed successfully: " + sourcePath + " to " + targetPath);
                    return true;
                } finally {
                    lockManager.releaseLock(source.toString());
                }
            } else {
                job.setCompleted(true);
                job.setError("Failed to acquire lock for decompression");
                LOGGER.error("Failed to acquire lock for decompression: " + sourcePath);
                return false;
            }
        } catch (IOException e) {
            job.setCompleted(true);
            job.setError("Error during decompression: " + e.getMessage());
            LOGGER.error("Error decompressing: " + sourcePath + " to " + targetPath, e);
            return false;
        } finally {
            // Keep the job in the active jobs map for status queries
            // It will be removed automatically after a certain time period
            // or when explicitly queried and found to be completed
        }
    }
    
    /**
     * Get the status of a compression or decompression job.
     * 
     * @param sourcePath The source path
     * @param targetPath The target path
     * @return The job status, or null if not found
     */
    public Map<String, Object> getJobStatus(String sourcePath, String targetPath) {
        String jobId = sourcePath + "_to_" + targetPath;
        CompressionJob job = activeJobs.get(jobId);
        
        if (job != null) {
            Map<String, Object> status = job.toMap();
            
            // Remove completed jobs from the map to free memory
            if (job.isCompleted()) {
                activeJobs.remove(jobId);
            }
            
            return status;
        }
        
        return null;
    }
    
    /**
     * Compress a string.
     * 
     * @param data The string to compress
     * @return The compressed data as a byte array, or null if compression failed
     */
    public byte[] compressString(String data) {
        if (data == null || data.isEmpty()) {
            return new byte[0];
        }
        
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
             GZIPOutputStream gzos = new GZIPOutputStream(baos)) {
            
            gzos.write(data.getBytes(StandardCharsets.UTF_8));
            gzos.finish();
            
            return baos.toByteArray();
        } catch (IOException e) {
            LOGGER.error("Error compressing string", e);
            return null;
        }
    }
    
    /**
     * Decompress a string.
     * 
     * @param compressedData The compressed data
     * @return The decompressed string, or null if decompression failed
     */
    public String decompressString(byte[] compressedData) {
        if (compressedData == null || compressedData.length == 0) {
            return "";
        }
        
        try (ByteArrayInputStream bais = new ByteArrayInputStream(compressedData);
             GZIPInputStream gzis = new GZIPInputStream(bais);
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            
            byte[] buffer = new byte[BUFFER_SIZE];
            int bytesRead;
            
            while ((bytesRead = gzis.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesRead);
            }
            
            return baos.toString(StandardCharsets.UTF_8.name());
        } catch (IOException e) {
            LOGGER.error("Error decompressing string", e);
            return null;
        }
    }
    
    /**
     * Compress a directory to a ZIP file.
     * 
     * @param source The source directory
     * @param target The target ZIP file
     * @param compressionLevel The compression level
     * @param metadata Additional metadata
     * @param job The compression job for tracking progress
     * @throws IOException If an I/O error occurs
     */
    private void compressDirectoryToZip(Path source, Path target, int compressionLevel, 
                                       Map<String, String> metadata, CompressionJob job) throws IOException {
        // Collect all files to compress
        final List<Path> filesToCompress = new ArrayList<>();
        Files.walkFileTree(source, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                filesToCompress.add(file);
                return FileVisitResult.CONTINUE;
            }
        });
        
        try (FileOutputStream fos = new FileOutputStream(target.toFile());
             BufferedOutputStream bos = new BufferedOutputStream(fos);
             ZipOutputStream zos = new ZipOutputStream(bos)) {
            
            // Set compression level
            zos.setLevel(compressionLevel);
            
            // Add metadata if provided
            if (metadata != null && !metadata.isEmpty()) {
                String metadataJson = dataSerializer.serializeToJson(metadata);
                ZipEntry metadataEntry = new ZipEntry(METADATA_FILE);
                zos.putNextEntry(metadataEntry);
                zos.write(metadataJson.getBytes(StandardCharsets.UTF_8));
                zos.closeEntry();
            }
            
            // Process each file
            byte[] buffer = new byte[BUFFER_SIZE];
            long totalBytesProcessed = 0;
            
            for (Path file : filesToCompress) {
                // Skip if the file doesn't exist anymore
                if (!Files.exists(file)) {
                    continue;
                }
                
                // Create ZIP entry using relative path
                String entryName = source.relativize(file).toString().replace('\\', '/');
                ZipEntry entry = new ZipEntry(entryName);
                zos.putNextEntry(entry);
                
                // Copy file content to ZIP
                try (FileInputStream fis = new FileInputStream(file.toFile());
                     BufferedInputStream bis = new BufferedInputStream(fis)) {
                    
                    int bytesRead;
                    while ((bytesRead = bis.read(buffer)) != -1) {
                        zos.write(buffer, 0, bytesRead);
                        totalBytesProcessed += bytesRead;
                        job.setProcessedBytes(totalBytesProcessed);
                    }
                }
                
                zos.closeEntry();
            }
        }
    }
    
    /**
     * Compress a file to a ZIP file.
     * 
     * @param source The source file
     * @param target The target ZIP file
     * @param compressionLevel The compression level
     * @param metadata Additional metadata
     * @param job The compression job for tracking progress
     * @throws IOException If an I/O error occurs
     */
    private void compressFileToZip(Path source, Path target, int compressionLevel,
                                  Map<String, String> metadata, CompressionJob job) throws IOException {
        try (FileOutputStream fos = new FileOutputStream(target.toFile());
             BufferedOutputStream bos = new BufferedOutputStream(fos);
             ZipOutputStream zos = new ZipOutputStream(bos)) {
            
            // Set compression level
            zos.setLevel(compressionLevel);
            
            // Add metadata if provided
            if (metadata != null && !metadata.isEmpty()) {
                String metadataJson = dataSerializer.serializeToJson(metadata);
                ZipEntry metadataEntry = new ZipEntry(METADATA_FILE);
                zos.putNextEntry(metadataEntry);
                zos.write(metadataJson.getBytes(StandardCharsets.UTF_8));
                zos.closeEntry();
            }
            
            // Create ZIP entry using file name
            ZipEntry entry = new ZipEntry(source.getFileName().toString());
            zos.putNextEntry(entry);
            
            // Copy file content to ZIP
            byte[] buffer = new byte[BUFFER_SIZE];
            long totalBytesProcessed = 0;
            
            try (FileInputStream fis = new FileInputStream(source.toFile());
                 BufferedInputStream bis = new BufferedInputStream(fis)) {
                
                int bytesRead;
                while ((bytesRead = bis.read(buffer)) != -1) {
                    zos.write(buffer, 0, bytesRead);
                    totalBytesProcessed += bytesRead;
                    job.setProcessedBytes(totalBytesProcessed);
                }
            }
            
            zos.closeEntry();
        }
    }
    
    /**
     * Compress a file using GZIP.
     * 
     * @param source The source file
     * @param target The target GZIP file
     * @param compressionLevel The compression level
     * @param job The compression job for tracking progress
     * @throws IOException If an I/O error occurs
     */
    private void compressFileToGzip(Path source, Path target, int compressionLevel,
                                   CompressionJob job) throws IOException {
        try (FileInputStream fis = new FileInputStream(source.toFile());
             BufferedInputStream bis = new BufferedInputStream(fis);
             FileOutputStream fos = new FileOutputStream(target.toFile());
             BufferedOutputStream bos = new BufferedOutputStream(fos);
             GZIPOutputStream gzos = new GZIPOutputStream(bos) {
                 {
                     def.setLevel(compressionLevel);
                 }
             }) {
            
            byte[] buffer = new byte[BUFFER_SIZE];
            long totalBytesProcessed = 0;
            int bytesRead;
            
            while ((bytesRead = bis.read(buffer)) != -1) {
                gzos.write(buffer, 0, bytesRead);
                totalBytesProcessed += bytesRead;
                job.setProcessedBytes(totalBytesProcessed);
            }
            
            gzos.finish();
        }
    }
    
    /**
     * Decompress a ZIP file.
     * 
     * @param source The source ZIP file
     * @param target The target directory
     * @param job The compression job for tracking progress
     * @throws IOException If an I/O error occurs
     */
    private void decompressZip(Path source, Path target, CompressionJob job) throws IOException {
        try (FileInputStream fis = new FileInputStream(source.toFile());
             BufferedInputStream bis = new BufferedInputStream(fis);
             ZipInputStream zis = new ZipInputStream(bis)) {
            
            byte[] buffer = new byte[BUFFER_SIZE];
            ZipEntry entry;
            long totalBytesProcessed = 0;
            
            while ((entry = zis.getNextEntry()) != null) {
                // Skip metadata file
                if (entry.getName().equals(METADATA_FILE)) {
                    zis.closeEntry();
                    continue;
                }
                
                Path entryPath = target.resolve(entry.getName());
                
                // Create parent directories if not exist
                if (entry.isDirectory()) {
                    Files.createDirectories(entryPath);
                } else {
                    Files.createDirectories(entryPath.getParent());
                    
                    // Create the file
                    try (FileOutputStream fos = new FileOutputStream(entryPath.toFile());
                         BufferedOutputStream bos = new BufferedOutputStream(fos)) {
                        
                        int bytesRead;
                        while ((bytesRead = zis.read(buffer)) != -1) {
                            bos.write(buffer, 0, bytesRead);
                            totalBytesProcessed += bytesRead;
                            job.setProcessedBytes(totalBytesProcessed);
                        }
                    }
                }
                
                zis.closeEntry();
            }
        }
    }
    
    /**
     * Decompress a GZIP file.
     * 
     * @param source The source GZIP file
     * @param target The target file or directory
     * @param job The compression job for tracking progress
     * @throws IOException If an I/O error occurs
     */
    private void decompressGzip(Path source, Path target, CompressionJob job) throws IOException {
        // Determine target file name (remove .gz extension)
        Path targetFile;
        if (Files.isDirectory(target)) {
            String fileName = source.getFileName().toString();
            if (fileName.toLowerCase().endsWith(GZIP_EXTENSION)) {
                fileName = fileName.substring(0, fileName.length() - GZIP_EXTENSION.length());
            }
            targetFile = target.resolve(fileName);
        } else {
            targetFile = target;
        }
        
        try (FileInputStream fis = new FileInputStream(source.toFile());
             BufferedInputStream bis = new BufferedInputStream(fis);
             GZIPInputStream gzis = new GZIPInputStream(bis);
             FileOutputStream fos = new FileOutputStream(targetFile.toFile());
             BufferedOutputStream bos = new BufferedOutputStream(fos)) {
            
            byte[] buffer = new byte[BUFFER_SIZE];
            long totalBytesProcessed = 0;
            int bytesRead;
            
            while ((bytesRead = gzis.read(buffer)) != -1) {
                bos.write(buffer, 0, bytesRead);
                totalBytesProcessed += bytesRead;
                job.setProcessedBytes(totalBytesProcessed);
            }
        }
    }
    
    /**
     * Calculate the total size of a file or directory.
     * 
     * @param path The path to calculate size for
     * @return The total size in bytes
     * @throws IOException If an I/O error occurs
     */
    private long calculateTotalSize(Path path) throws IOException {
        if (Files.isDirectory(path)) {
            final long[] totalSize = {0};
            
            Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                    totalSize[0] += attrs.size();
                    return FileVisitResult.CONTINUE;
                }
            });
            
            return totalSize[0];
        } else {
            return Files.size(path);
        }
    }
    
    /**
     * Read metadata from a ZIP file.
     * 
     * @param zipFile The ZIP file
     * @return The metadata, or empty map if not found
     */
    @SuppressWarnings("unchecked")
    public Map<String, String> readMetadataFromZip(String zipFile) {
        Path zipPath = Paths.get(baseStoragePath, zipFile);
        
        if (!Files.exists(zipPath)) {
            return new HashMap<>();
        }
        
        try (FileInputStream fis = new FileInputStream(zipPath.toFile());
             BufferedInputStream bis = new BufferedInputStream(fis);
             ZipInputStream zis = new ZipInputStream(bis)) {
            
            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                if (entry.getName().equals(METADATA_FILE)) {
                    // Read metadata file content
                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
                    byte[] buffer = new byte[BUFFER_SIZE];
                    int bytesRead;
                    
                    while ((bytesRead = zis.read(buffer)) != -1) {
                        baos.write(buffer, 0, bytesRead);
                    }
                    
                    zis.closeEntry();
                    
                    // Parse metadata JSON
                    String metadataJson = baos.toString(StandardCharsets.UTF_8.name());
                    Map<String, String> metadata = dataSerializer.deserializeFromJson(metadataJson, Map.class);
                    return metadata != null ? metadata : new HashMap<>();
                }
                
                zis.closeEntry();
            }
        } catch (IOException e) {
            LOGGER.error("Error reading metadata from ZIP: " + zipFile, e);
        }
        
        return new HashMap<>();
    }
    
    /**
     * Check if a file is compressed.
     * 
     * @param filePath The file path relative to the base storage path
     * @return true if the file is compressed, false otherwise
     */
    public boolean isCompressed(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return false;
        }
        
        String lowerPath = filePath.toLowerCase();
        if (lowerPath.endsWith(ZIP_EXTENSION) || lowerPath.endsWith(GZIP_EXTENSION)) {
            return true;
        }
        
        // Additional check for ZIP files by reading the file signature
        Path path = Paths.get(baseStoragePath, filePath);
        if (Files.exists(path) && Files.isRegularFile(path)) {
            try (FileInputStream fis = new FileInputStream(path.toFile())) {
                byte[] signature = new byte[4];
                int bytesRead = fis.read(signature);
                
                if (bytesRead == 4) {
                    // ZIP signature: 50 4B 03 04
                    if (signature[0] == 0x50 && signature[1] == 0x4B && 
                        signature[2] == 0x03 && signature[3] == 0x04) {
                        return true;
                    }
                    
                    // GZIP signature: 1F 8B
                    if (signature[0] == 0x1F && signature[1] == (byte) 0x8B) {
                        return true;
                    }
                }
            } catch (IOException e) {
                LOGGER.error("Error checking if file is compressed: " + filePath, e);
            }
        }
        
        return false;
    }
    
    /**
     * Get compression statistics for a file.
     * 
     * @param filePath The file path relative to the base storage path
     * @return A map of compression statistics, or null if not a compressed file
     */
    public Map<String, Object> getCompressionStats(String filePath) {
        if (!isCompressed(filePath)) {
            return null;
        }
        
        Path path = Paths.get(baseStoragePath, filePath);
        if (!Files.exists(path) || !Files.isRegularFile(path)) {
            return null;
        }
        
        Map<String, Object> stats = new HashMap<>();
        stats.put("fileName", path.getFileName().toString());
        stats.put("compressedSize", 0L);
        stats.put("uncompressedSize", 0L);
        stats.put("compressionRatio", 0.0);
        stats.put("format", "unknown");
        
        try {
            long compressedSize = Files.size(path);
            stats.put("compressedSize", compressedSize);
            
            String lowerPath = filePath.toLowerCase();
            if (lowerPath.endsWith(ZIP_EXTENSION)) {
                stats.put("format", "ZIP");
                
                // Calculate uncompressed size by reading each entry
                long uncompressedSize = 0;
                int entryCount = 0;
                
                try (FileInputStream fis = new FileInputStream(path.toFile());
                     BufferedInputStream bis = new BufferedInputStream(fis);
                     ZipInputStream zis = new ZipInputStream(bis)) {
                    
                    ZipEntry entry;
                    while ((entry = zis.getNextEntry()) != null) {
                        uncompressedSize += entry.getSize();
                        entryCount++;
                        zis.closeEntry();
                    }
                }
                
                stats.put("uncompressedSize", uncompressedSize);
                stats.put("entryCount", entryCount);
            } else if (lowerPath.endsWith(GZIP_EXTENSION)) {
                stats.put("format", "GZIP");
                
                // Extract uncompressed size from GZIP header
                try (FileInputStream fis = new FileInputStream(path.toFile());
                     BufferedInputStream bis = new BufferedInputStream(fis)) {
                    
                    // Skip GZIP header (10 bytes)
                    bis.skip(4);
                    
                    // Check if there's an FEXTRA header
                    int flags = bis.read();
                    if ((flags & 4) != 0) {
                        // Skip MTIME (4 bytes), XFL (1 byte), and OS (1 byte)
                        bis.skip(6);
                        
                        // Read XLEN
                        int xlen = bis.read() | (bis.read() << 8);
                        
                        // Skip extra field
                        bis.skip(xlen);
                    } else {
                        // Skip MTIME (4 bytes), XFL (1 byte), and OS (1 byte)
                        bis.skip(6);
                    }
                    
                    // Skip to the end of the file
                    while (bis.read() != -1) {
                        // Do nothing
                    }
                    
                    // Read uncompressed size (ISIZE) from the last 4 bytes
                    long uncompressedSize = 0;
                    
                    // This is not accurate for all GZIP files as it depends on the implementation
                    // For accurate size, we need to decompress the file
                    stats.put("uncompressedSize", uncompressedSize);
                }
            }
            
            // Calculate compression ratio
            long uncompressedSize = (long) stats.get("uncompressedSize");
            if (uncompressedSize > 0) {
                double ratio = (double) compressedSize / uncompressedSize;
                stats.put("compressionRatio", ratio);
                stats.put("compressionPercentage", (1 - ratio) * 100);
            }
        } catch (IOException e) {
            LOGGER.error("Error getting compression stats: " + filePath, e);
        }
        
        return stats;
    }
    
    /**
     * Get the list of active compression jobs.
     * 
     * @return A list of job status maps
     */
    public List<Map<String, Object>> getActiveJobs() {
        List<Map<String, Object>> jobs = new ArrayList<>();
        
        for (CompressionJob job : activeJobs.values()) {
            jobs.add(job.toMap());
        }
        
        return jobs;
    }
    
    /**
     * Cancel a compression or decompression job.
     * 
     * @param sourcePath The source path
     * @param targetPath The target path
     * @return true if the job was cancelled, false otherwise
     */
    public boolean cancelJob(String sourcePath, String targetPath) {
        String jobId = sourcePath + "_to_" + targetPath;
        CompressionJob job = activeJobs.remove(jobId);
        
        if (job != null && !job.isCompleted()) {
            job.setCompleted(true);
            job.setError("Job cancelled by user");
            
            // Clean up partial files
            try {
                Path target = Paths.get(baseStoragePath, targetPath);
                Files.deleteIfExists(target);
            } catch (IOException e) {
                LOGGER.error("Error cleaning up after job cancellation", e);
            }
            
            return true;
        }
        
        return false;
    }
    
    /**
     * Compress a byte array.
     * 
     * @param data The data to compress
     * @param compressionLevel The compression level
     * @return The compressed data, or null if compression failed
     */
    public byte[] compressBytes(byte[] data, int compressionLevel) {
        if (data == null || data.length == 0) {
            return new byte[0];
        }
        
        // Use default compression level if invalid
        if (compressionLevel < 0 || compressionLevel > 9) {
            compressionLevel = DEFAULT_COMPRESSION_LEVEL;
        }
        
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
             GZIPOutputStream gzos = new GZIPOutputStream(baos) {
                 {
                     def.setLevel(compressionLevel);
                 }
             }) {
            
            gzos.write(data);
            gzos.finish();
            
            return baos.toByteArray();
        } catch (IOException e) {
            LOGGER.error("Error compressing byte array", e);
            return null;
        }
    }
    
    /**
     * Decompress a byte array.
     * 
     * @param compressedData The compressed data
     * @return The decompressed data, or null if decompression failed
     */
    public byte[] decompressBytes(byte[] compressedData) {
        if (compressedData == null || compressedData.length == 0) {
            return new byte[0];
        }
        
        try (ByteArrayInputStream bais = new ByteArrayInputStream(compressedData);
             GZIPInputStream gzis = new GZIPInputStream(bais);
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            
            byte[] buffer = new byte[BUFFER_SIZE];
            int bytesRead;
            
            while ((bytesRead = gzis.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesRead);
            }
            
            return baos.toByteArray();
        } catch (IOException e) {
            LOGGER.error("Error decompressing byte array", e);
            return null;
        }
    }
    
    /**
     * Copy input stream to output stream with buffer.
     * 
     * @param input The input stream
     * @param output The output stream
     * @param buffer The buffer
     * @param progressConsumer The progress consumer function
     * @return The number of bytes copied
     * @throws IOException If an I/O error occurs
     */
    private long copyStream(InputStream input, OutputStream output, byte[] buffer, 
                           ProgressConsumer progressConsumer) throws IOException {
        long totalBytes = 0;
        int bytesRead;
        
        while ((bytesRead = input.read(buffer)) != -1) {
            output.write(buffer, 0, bytesRead);
            totalBytes += bytesRead;
            
            if (progressConsumer != null) {
                progressConsumer.accept(totalBytes);
            }
        }
        
        return totalBytes;
    }
    
    /**
     * Calculate the optimal buffer size based on file size.
     * 
     * @param fileSize The file size
     * @return The optimal buffer size
     */
    private int calculateBufferSize(long fileSize) {
        if (fileSize < 1024 * 1024) { // Less than 1 MB
            return BUFFER_SIZE;
        } else if (fileSize < 10 * 1024 * 1024) { // 1-10 MB
            return BUFFER_SIZE * 2;
        } else if (fileSize < 100 * 1024 * 1024) { // 10-100 MB
            return BUFFER_SIZE * 4;
        } else if (fileSize < 1024 * 1024 * 1024) { // 100 MB - 1 GB
            return BUFFER_SIZE * 8;
        } else { // More than 1 GB
            return BUFFER_SIZE * 16;
        }
    }
    
    /**
     * Functional interface for progress reporting.
     */
    @FunctionalInterface
    private interface ProgressConsumer {
        void accept(long processedBytes);
    }
}


DataVersioningService.java
---------------------------------------------

package com.cstestforge.service.storage;

import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Service for managing file and directory versions with tracking and historical
 * versioning capabilities. Provides methods for creating, restoring, and comparing
 * versions with detailed metadata.
 */
@Service
public class DataVersioningService {

    private static final CSLogger LOGGER = new CSLogger(DataVersioningService.class);
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss");
    private static final int DEFAULT_MAX_VERSIONS = 20;
    
    @Value("${cstestforge.versioning.max-versions:20}")
    private int maxVersions;
    
    @Autowired
    private FileSystemStorageService storageService;
    
    @Autowired
    private FileLockManager lockManager;
    
    @Autowired
    private DataSerializer dataSerializer;
    
    @Autowired
    private BackupService backupService;
    
    @Autowired
    private DataCompressionService compressionService;
    
    private final Map<String, Map<String, VersionEntry>> versionRegistry = new ConcurrentHashMap<>();
    private String baseStoragePath;
    private String versionsPath;
    
    /**
     * Class representing a version entry.
     */
    private static class VersionEntry {
        private final String versionId;
        private final String originalPath;
        private final String versionPath;
        private final long timestamp;
        private final String label;
        private final String owner;
        private final long size;
        private final Map<String, String> metadata;
        
        public VersionEntry(String versionId, String originalPath, String versionPath, long timestamp, 
                         String label, String owner, long size) {
            this.versionId = versionId;
            this.originalPath = originalPath;
            this.versionPath = versionPath;
            this.timestamp = timestamp;
            this.label = label;
            this.owner = owner;
            this.size = size;
            this.metadata = new HashMap<>();
        }
        
        public String getVersionId() {
            return versionId;
        }
        
        public String getOriginalPath() {
            return originalPath;
        }
        
        public String getVersionPath() {
            return versionPath;
        }
        
        public long getTimestamp() {
            return timestamp;
        }
        
        public String getLabel() {
            return label;
        }
        
        public String getOwner() {
            return owner;
        }
        
        public long getSize() {
            return size;
        }
        
        public Map<String, String> getMetadata() {
            return metadata;
        }
        
        public void addMetadata(String key, String value) {
            metadata.put(key, value);
        }
        
        public Map<String, Object> toMap() {
            Map<String, Object> map = new HashMap<>();
            map.put("versionId", versionId);
            map.put("originalPath", originalPath);
            map.put("versionPath", versionPath);
            map.put("timestamp", timestamp);
            
            // Format timestamp for display
            LocalDateTime dateTime = LocalDateTime.ofInstant(
                    java.time.Instant.ofEpochMilli(timestamp), 
                    java.time.ZoneId.systemDefault());
            map.put("formattedTimestamp", dateTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
            
            map.put("label", label);
            map.put("owner", owner);
            map.put("size", size);
            
            // Format size for display
            map.put("formattedSize", formatSize(size));
            
            map.put("metadata", metadata);
            return map;
        }
    }
    
    /**
     * Initialize the versioning service.
     */
    @PostConstruct
    public void init() {
        baseStoragePath = storageService.getBaseStoragePath();
        versionsPath = Paths.get(baseStoragePath, "versions").toString();
        
        // Set configuration values
        if (maxVersions <= 0) {
            maxVersions = DEFAULT_MAX_VERSIONS;
        }
        
        // Create versions directory if not exists
        try {
            Files.createDirectories(Paths.get(versionsPath));
        } catch (IOException e) {
            LOGGER.error("Error creating versions directory", e);
        }
        
        // Load existing versions from versions directory
        loadExistingVersions();
        
        LOGGER.info("DataVersioningService initialized with maxVersions: " + maxVersions);
    }
    
    /**
     * Create a version of a file or directory.
     * 
     * @param path The path relative to the base storage path
     * @param label The version label
     * @param owner The owner identifier for locking
     * @return The version ID, or null if creation failed
     */
    public String createVersion(String path, String label, String owner) {
        if (path == null || path.isEmpty()) {
            return null;
        }
        
        try {
            // Generate version ID based on timestamp and UUID
            String timestamp = DATE_FORMATTER.format(LocalDateTime.now());
            String versionId = timestamp + "_" + UUID.randomUUID().toString().substring(0, 8);
            
            // Create version directory structure
            Path versionDirPath = Paths.get(versionsPath, path);
            Files.createDirectories(versionDirPath);
            
            // Get actual source path
            Path sourcePath = Paths.get(baseStoragePath, path);
            
            // Skip if the source doesn't exist
            if (!Files.exists(sourcePath)) {
                LOGGER.warn("Source path does not exist for version: " + path);
                return null;
            }
            
            // Create destination path (preserving directory structure)
            Path destPath = Paths.get(versionsPath, path, versionId);
            
            boolean success;
            long size = 0;
            
            // Lock source for consistent versioning
            if (lockManager.acquireLock(sourcePath.toString(), owner)) {
                try {
                    if (Files.isDirectory(sourcePath)) {
                        // Create destination directory
                        Files.createDirectories(destPath);
                        
                        // Copy directory structure
                        success = copyDirectory(sourcePath, destPath);
                        
                        // Calculate directory size
                        size = calculateDirectorySize(destPath);
                    } else {
                        // Create parent directory if not exists
                        Files.createDirectories(destPath.getParent());
                        
                        // Copy file
                        Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);
                        success = true;
                        
                        // Get file size
                        size = Files.size(destPath);
                    }
                } finally {
                    lockManager.releaseLock(sourcePath.toString());
                }
                
                if (success) {
                    // Create version entry
                    String relativeVersionPath = CSPathUtils.relativizeToBasePath(destPath.toString(), baseStoragePath);
                    VersionEntry versionEntry = new VersionEntry(
                            versionId,
                            path,
                            relativeVersionPath,
                            System.currentTimeMillis(),
                            label != null ? label : "",
                            owner,
                            size
                    );
                    
                    // Add additional metadata
                    versionEntry.addMetadata("originalFileName", Paths.get(path).getFileName().toString());
                    versionEntry.addMetadata("versionTime", LocalDateTime.now().toString());
                    
                    // Add to version registry
                    versionRegistry.computeIfAbsent(path, k -> new ConcurrentHashMap<>())
                                  .put(versionId, versionEntry);
                    
                    // Save version registry
                    saveVersionRegistry();
                    
                    // Enforce max versions limit
                    enforceVersionLimits(path);
                    
                    LOGGER.info("Created version with ID: " + versionId + " for path: " + path);
                    return versionId;
                }
            } else {
                LOGGER.error("Failed to acquire lock for version: " + path);
            }
            
            return null;
        } catch (IOException e) {
            LOGGER.error("Error creating version for path: " + path, e);
            return null;
        }
    }
    
    /**
     * Get the list of versions for a path.
     * 
     * @param path The path relative to the base storage path
     * @return List of version metadata, or empty list if none found
     */
    public List<Map<String, Object>> listVersions(String path) {
        if (path == null || path.isEmpty()) {
            return new ArrayList<>();
        }
        
        Map<String, VersionEntry> pathVersions = versionRegistry.get(path);
        if (pathVersions == null || pathVersions.isEmpty()) {
            return new ArrayList<>();
        }
        
        return pathVersions.values().stream()
                .sorted(Comparator.comparingLong(VersionEntry::getTimestamp).reversed())
                .map(VersionEntry::toMap)
                .collect(Collectors.toList());
    }
    
    /**
     * Get the metadata for a specific version.
     * 
     * @param versionId The version ID
     * @return The version metadata, or null if not found
     */
    public Map<String, Object> getVersionMetadata(String versionId) {
        if (versionId == null || versionId.isEmpty()) {
            return null;
        }
        
        // Find the version in the registry
        for (Map<String, VersionEntry> pathVersions : versionRegistry.values()) {
            VersionEntry versionEntry = pathVersions.get(versionId);
            if (versionEntry != null) {
                return versionEntry.toMap();
            }
        }
        
        return null;
    }
    
    /**
     * Restore a version.
     * 
     * @param versionId The version ID
     * @param owner The owner identifier for locking
     * @return true if the restore was successful, false otherwise
     */
    public boolean restoreVersion(String versionId, String owner) {
        if (versionId == null || versionId.isEmpty()) {
            return false;
        }
        
        // Find the version in the registry
        VersionEntry versionEntry = null;
        for (Map<String, VersionEntry> pathVersions : versionRegistry.values()) {
            if (pathVersions.containsKey(versionId)) {
                versionEntry = pathVersions.get(versionId);
                break;
            }
        }
        
        if (versionEntry == null) {
            LOGGER.warn("Version not found with ID: " + versionId);
            return false;
        }
        
        try {
            String originalPath = versionEntry.getOriginalPath();
            String versionPath = versionEntry.getVersionPath();
            
            // Get actual paths
            Path sourcePath = Paths.get(baseStoragePath, versionPath);
            Path destPath = Paths.get(baseStoragePath, originalPath);
            
            // Skip if the source doesn't exist
            if (!Files.exists(sourcePath)) {
                LOGGER.warn("Version source path does not exist for ID: " + versionId);
                return false;
            }
            
            boolean success;
            
            // Create destination parent directory if it doesn't exist
            Files.createDirectories(destPath.getParent());
            
            // Lock destination for consistent restore
            if (lockManager.acquireLock(destPath.toString(), owner)) {
                try {
                    // Create a backup of the current state before restoring
                    String backupId = backupService.createBackup(originalPath, "pre_restore_" + versionId, owner, false);
                    
                    // Copy from version to original location
                    if (Files.isDirectory(sourcePath)) {
                        // Delete existing directory content first
                        if (Files.exists(destPath)) {
                            deleteDirectory(destPath);
                        }
                        
                        // Create the directory
                        Files.createDirectories(destPath);
                        
                        // Copy directory structure
                        success = copyDirectory(sourcePath, destPath);
                    } else {
                        // Copy file
                        Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);
                        success = true;
                    }
                    
                    // Create a new version for the restored state
                    String newVersionId = createVersion(originalPath, "Restored from " + versionId, owner);
                    
                    LOGGER.info("Restored version with ID: " + versionId + " to path: " + originalPath +
                            ", previous state backup ID: " + backupId +
                            ", new version ID: " + newVersionId);
                } finally {
                    lockManager.releaseLock(destPath.toString());
                }
                
                return success;
            } else {
                LOGGER.error("Failed to acquire lock for restore: " + originalPath);
            }
            
            return false;
        } catch (IOException e) {
            LOGGER.error("Error restoring version with ID: " + versionId, e);
            return false;
        }
    }
    
    /**
     * Delete a version.
     * 
     * @param versionId The version ID
     * @return true if the delete was successful, false otherwise
     */
    public boolean deleteVersion(String versionId) {
        if (versionId == null || versionId.isEmpty()) {
            return false;
        }
        
        // Find the version in the registry
        String originalPath = null;
        VersionEntry versionEntry = null;
        
        for (Map.Entry<String, Map<String, VersionEntry>> entry : versionRegistry.entrySet()) {
            Map<String, VersionEntry> pathVersions = entry.getValue();
            if (pathVersions.containsKey(versionId)) {
                originalPath = entry.getKey();
                versionEntry = pathVersions.get(versionId);
                break;
            }
        }
        
        if (originalPath == null || versionEntry == null) {
            LOGGER.warn("Version not found with ID: " + versionId);
            return false;
        }
        
        try {
            String versionPath = versionEntry.getVersionPath();
            
            // Get actual path
            Path path = Paths.get(baseStoragePath, versionPath);
            
            boolean success;
            
            // Delete version files
            if (Files.isDirectory(path)) {
                success = deleteDirectory(path);
            } else {
                Files.deleteIfExists(path);
                success = true;
            }
            
            if (success) {
                // Remove from registry
                Map<String, VersionEntry> pathVersions = versionRegistry.get(originalPath);
                pathVersions.remove(versionId);
                
                // Remove empty maps
                if (pathVersions.isEmpty()) {
                    versionRegistry.remove(originalPath);
                }
                
                // Save version registry
                saveVersionRegistry();
                
                LOGGER.info("Deleted version with ID: " + versionId);
                return true;
            }
            
            return false;
        } catch (IOException e) {
            LOGGER.error("Error deleting version with ID: " + versionId, e);
            return false;
        }
    }
    
    /**
     * Compare two versions.
     * 
     * @param versionId1 The first version ID
     * @param versionId2 The second version ID
     * @return A map of comparison results, or null if comparison failed
     */
    public Map<String, Object> compareVersions(String versionId1, String versionId2) {
        if (versionId1 == null || versionId1.isEmpty() || versionId2 == null || versionId2.isEmpty()) {
            return null;
        }
        
        // Find the versions in the registry
        VersionEntry version1 = null;
        VersionEntry version2 = null;
        
        for (Map<String, VersionEntry> pathVersions : versionRegistry.values()) {
            if (version1 == null && pathVersions.containsKey(versionId1)) {
                version1 = pathVersions.get(versionId1);
            }
            
            if (version2 == null && pathVersions.containsKey(versionId2)) {
                version2 = pathVersions.get(versionId2);
            }
            
            if (version1 != null && version2 != null) {
                break;
            }
        }
        
        if (version1 == null || version2 == null) {
            LOGGER.warn("One or both versions not found for comparison");
            return null;
        }
        
        // Check if versions are for the same original path
        if (!version1.getOriginalPath().equals(version2.getOriginalPath())) {
            LOGGER.warn("Cannot compare versions for different paths");
            return null;
        }
        
        try {
            Map<String, Object> result = new HashMap<>();
            result.put("version1", version1.toMap());
            result.put("version2", version2.toMap());
            
            // Get actual paths
            Path path1 = Paths.get(baseStoragePath, version1.getVersionPath());
            Path path2 = Paths.get(baseStoragePath, version2.getVersionPath());
            
            // Skip if one of the paths doesn't exist
            if (!Files.exists(path1) || !Files.exists(path2)) {
                LOGGER.warn("One or both version paths do not exist for comparison");
                return null;
            }
            
            List<Map<String, Object>> differences = new ArrayList<>();
            
            // Compare files or directories
            if (Files.isDirectory(path1) && Files.isDirectory(path2)) {
                differences = compareDirectories(path1, path2);
            } else if (!Files.isDirectory(path1) && !Files.isDirectory(path2)) {
                Map<String, Object> fileDiff = compareFiles(path1, path2);
                if (fileDiff != null) {
                    differences.add(fileDiff);
                }
            } else {
                // One is a file and one is a directory, totally different
                Map<String, Object> diff = new HashMap<>();
                diff.put("path", version1.getOriginalPath());
                diff.put("type", "type_change");
                diff.put("version1", Files.isDirectory(path1) ? "directory" : "file");
                diff.put("version2", Files.isDirectory(path2) ? "directory" : "file");
                differences.add(diff);
            }
            
            result.put("differences", differences);
            result.put("differenceCount", differences.size());
            
            return result;
        } catch (IOException e) {
            LOGGER.error("Error comparing versions", e);
            return null;
        }
    }
    
    /**
     * Load existing versions from the versions directory.
     */
    private void loadExistingVersions() {
        try {
            Path versionRegistryPath = Paths.get(baseStoragePath, "versions", "version-registry.json");
            
            // Create version registry file if it doesn't exist
            if (!Files.exists(versionRegistryPath)) {
                Files.createDirectories(versionRegistryPath.getParent());
                saveVersionRegistry();
                return;
            }
            
            // Load version registry from file
            @SuppressWarnings("unchecked")
            Map<String, Map<String, Map<String, Object>>> registryMap = 
                    dataSerializer.deserializeFromJson(
                            new String(Files.readAllBytes(versionRegistryPath)), 
                            Map.class);
            
            if (registryMap != null) {
                for (Map.Entry<String, Map<String, Map<String, Object>>> pathEntry : registryMap.entrySet()) {
                    String originalPath = pathEntry.getKey();
                    Map<String, Map<String, Object>> versionsMap = pathEntry.getValue();
                    
                    for (Map.Entry<String, Map<String, Object>> versionEntry : versionsMap.entrySet()) {
                        String versionId = versionEntry.getKey();
                        Map<String, Object> data = versionEntry.getValue();
                        
                        String versionPath = (String) data.get("versionPath");
                        long timestamp = ((Number) data.getOrDefault("timestamp", 0)).longValue();
                        String label = (String) data.getOrDefault("label", "");
                        String owner = (String) data.getOrDefault("owner", "");
                        long size = ((Number) data.getOrDefault("size", 0)).longValue();
                        
                        VersionEntry entry = new VersionEntry(
                                versionId, originalPath, versionPath, timestamp, 
                                label, owner, size);
                        
                        // Add additional metadata
                        @SuppressWarnings("unchecked")
                        Map<String, String> metadataMap = (Map<String, String>) data.getOrDefault("metadata", 
                                new HashMap<>());
                        
                        for (Map.Entry<String, String> metaEntry : metadataMap.entrySet()) {
                            entry.addMetadata(metaEntry.getKey(), metaEntry.getValue());
                        }
                        
                        // Verify version exists
                        Path versionFilePath = Paths.get(baseStoragePath, versionPath);
                        if (Files.exists(versionFilePath)) {
                            versionRegistry.computeIfAbsent(originalPath, k -> new ConcurrentHashMap<>())
                                          .put(versionId, entry);
                        }
                    }
                }
            }
            
            int totalVersions = versionRegistry.values().stream()
                    .mapToInt(Map::size)
                    .sum();
            
            LOGGER.info("Loaded " + totalVersions + " existing versions for " + 
                    versionRegistry.size() + " paths");
        } catch (Exception e) {
            LOGGER.error("Error loading existing versions", e);
        }
    }
    
    /**
     * Save version registry to file.
     */
    private void saveVersionRegistry() {
        try {
            // Convert registry to map
            Map<String, Map<String, Map<String, Object>>> registryMap = new HashMap<>();
            
            for (Map.Entry<String, Map<String, VersionEntry>> pathEntry : versionRegistry.entrySet()) {
                String originalPath = pathEntry.getKey();
                Map<String, VersionEntry> versionsMap = pathEntry.getValue();
                
                Map<String, Map<String, Object>> pathVersionsMap = new HashMap<>();
                registryMap.put(originalPath, pathVersionsMap);
                
                for (Map.Entry<String, VersionEntry> versionEntry : versionsMap.entrySet()) {
                    String versionId = versionEntry.getKey();
                    VersionEntry version = versionEntry.getValue();
                    
                    pathVersionsMap.put(versionId, version.toMap());
                }
            }
            
            // Save to file
            String registryJson = dataSerializer.serializeToJson(registryMap);
            Files.write(Paths.get(baseStoragePath, "versions", "version-registry.json"), 
                    registryJson.getBytes());
        } catch (Exception e) {
            LOGGER.error("Error saving version registry", e);
        }
    }
    
    /**
     * Enforce version limits for a path.
     * 
     * @param path The path to enforce limits for
     */
    private void enforceVersionLimits(String path) {
        if (path == null || path.isEmpty()) {
            return;
        }
        
        try {
            Map<String, VersionEntry> pathVersions = versionRegistry.get(path);
            if (pathVersions == null || pathVersions.size() <= maxVersions) {
                return;
            }
            
            // Get versions sorted by timestamp (oldest first)
            List<VersionEntry> sortedVersions = pathVersions.values().stream()
                    .sorted(Comparator.comparingLong(VersionEntry::getTimestamp))
                    .collect(Collectors.toList());
            
            // Remove oldest versions exceeding the limit
            int toRemove = sortedVersions.size() - maxVersions;
            
            for (int i = 0; i < toRemove; i++) {
                VersionEntry oldestVersion = sortedVersions.get(i);
                deleteVersion(oldestVersion.getVersionId());
            }
            
            LOGGER.info("Enforced version limit for path: " + path + ", removed " + toRemove + " old versions");
        } catch (Exception e) {
            LOGGER.error("Error enforcing version limits for path: " + path, e);
        }
    }
    
    /**
     * Copy a directory recursively.
     * 
     * @param source The source directory
     * @param destination The destination directory
     * @return true if the copy was successful, false otherwise
     */
    private boolean copyDirectory(Path source, Path destination) throws IOException {
        Files.createDirectories(destination);
        
        Files.walk(source)
             .forEach(sourcePath -> {
                 try {
                     Path targetPath = destination.resolve(source.relativize(sourcePath));
                     
                     if (Files.isDirectory(sourcePath)) {
                         Files.createDirectories(targetPath);
                     } else {
                         Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
                     }
                 } catch (IOException e) {
                     throw new RuntimeException(e);
                 }
             });
        
        return true;
    }
    
    /**
     * Delete a directory recursively.
     * 
     * @param directory The directory to delete
     * @return true if the delete was successful, false otherwise
     */
    private boolean deleteDirectory(Path directory) throws IOException {
        if (!Files.exists(directory)) {
            return true;
        }
        
        Files.walk(directory)
             .sorted(Comparator.reverseOrder())
             .forEach(path -> {
                 try {
                     Files.delete(path);
                 } catch (IOException e) {
                     throw new RuntimeException(e);
                 }
             });
        
        return !Files.exists(directory);
    }
    
    /**
     * Calculate the size of a directory recursively.
     * 
     * @param directory The directory to calculate size for
     * @return The directory size in bytes
     */
    private long calculateDirectorySize(Path directory) throws IOException {
        if (!Files.exists(directory) || !Files.isDirectory(directory)) {
            return 0;
        }
        
        return Files.walk(directory)
                   .filter(Files::isRegularFile)
                   .mapToLong(path -> {
                       try {
                           return Files.size(path);
                       } catch (IOException e) {
                           return 0;
                       }
                   })
                   .sum();
    }
    
    /**
     * Compare two directories recursively.
     * 
     * @param dir1 The first directory
     * @param dir2 The second directory
     * @return List of differences
     */
    private List<Map<String, Object>> compareDirectories(Path dir1, Path dir2) throws IOException {
        List<Map<String, Object>> differences = new ArrayList<>();
        
        // Get all files in both directories
        Map<String, Path> files1 = new HashMap<>();
        Map<String, Path> files2 = new HashMap<>();
        
        Files.walk(dir1)
             .filter(path -> !Files.isDirectory(path))
             .forEach(path -> files1.put(dir1.relativize(path).toString(), path));
        
        Files.walk(dir2)
             .filter(path -> !Files.isDirectory(path))
             .forEach(path -> files2.put(dir2.relativize(path).toString(), path));
        
        // Find files only in dir1
        for (Map.Entry<String, Path> entry : files1.entrySet()) {
            String relativePath = entry.getKey();
            
            if (!files2.containsKey(relativePath)) {
                Map<String, Object> diff = new HashMap<>();
                diff.put("path", relativePath);
                diff.put("type", "deleted");
                diff.put("version1Size", Files.size(entry.getValue()));
                differences.add(diff);
            }
        }
        
        // Find files only in dir2
        for (Map.Entry<String, Path> entry : files2.entrySet()) {
            String relativePath = entry.getKey();
            
            if (!files1.containsKey(relativePath)) {
                Map<String, Object> diff = new HashMap<>();
                diff.put("path", relativePath);
                diff.put("type", "added");
                diff.put("version2Size", Files.size(entry.getValue()));
                differences.add(diff);
            }
        }
        
        // Compare common files
        for (Map.Entry<String, Path> entry : files1.entrySet()) {
            String relativePath = entry.getKey();
            Path path1 = entry.getValue();
            
            if (files2.containsKey(relativePath)) {
                Path path2 = files2.get(relativePath);
                
                Map<String, Object> fileDiff = compareFiles(path1, path2);
                if (fileDiff != null) {
                    fileDiff.put("path", relativePath);
                    differences.add(fileDiff);
                }
            }
        }
        
        return differences;
    }
    
    /**
     * Compare two files.
     * 
     * @param file1 The first file
     * @param file2 The second file
     * @return Map of differences, or null if files are identical
     */
    private Map<String, Object> compareFiles(Path file1, Path file2) throws IOException {
        // Compare file sizes
        long size1 = Files.size(file1);
        long size2 = Files.size(file2);
        
        if (size1 != size2) {
            Map<String, Object> diff = new HashMap<>();
            diff.put("type", "modified");
            diff.put("version1Size", size1);
            diff.put("version2Size", size2);
            diff.put("sizeDifference", size2 - size1);
            return diff;
        }
        
        // Compare file content
        byte[] content1 = Files.readAllBytes(file1);
        byte[] content2 = Files.readAllBytes(file2);
        
        if (!java.util.Arrays.equals(content1, content2)) {
            Map<String, Object> diff = new HashMap<>();
            diff.put("type", "modified");
            diff.put("version1Size", size1);
            diff.put("version2Size", size2);
            diff.put("contentDifferent", true);
            
            // Calculate number of differing bytes
            int diffCount = 0;
            for (int i = 0; i < content1.length; i++) {
                if (content1[i] != content2[i]) {
                    diffCount++;
                }
            }
            
            diff.put("differentBytes", diffCount);
            diff.put("differentPercentage", (double) diffCount / content1.length * 100);
            
            return diff;
        }
        
        // Files are identical
        return null;
    }
    
    /**
     * Format a size in bytes to a human-readable string.
     * 
     * @param size The size in bytes
     * @return The formatted size string
     */
    private static String formatSize(long size) {
        if (size < 1024) {
            return size + " B";
        }
        
        int unit = (int) (Math.log10(size) / Math.log10(1024));
        char prefix = "KMGTPE".charAt(unit - 1);
        return String.format("%.2f %sB", size / Math.pow(1024, unit), prefix);
    }
}


