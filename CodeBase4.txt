/**
 * CSDataProviderProcessor.ts
 * 
 * Processes data provider decorators and handles the data injection
 * into test methods for the CSTestForge framework.
 */

import { CSDataSourceFactory } from './CSDataSourceFactory';
import { CSDataTransformer } from './CSDataTransformer';
import { CSDataSource, CSDataSourceOptions } from './sources/CSDataSource';
import { CSLogger } from '../utils/CSLogger';
import { CSFileUtils } from '../utils/CSFileUtils';

/**
 * Configuration options for the data provider
 */
export interface CSDataProviderOptions {
  /**
   * Source configuration (file path, connection string, etc.)
   */
  source: string | CSDataSourceOptions;
  
  /**
   * Source type (excel, csv, json, database)
   */
  type: 'excel' | 'csv' | 'json' | 'database' | 'custom';
  
  /**
   * Test method name to fetch data for (if not the decorated method)
   */
  testMethod?: string;
  
  /**
   * Test class name to fetch data for (if not the containing class)
   */
  testClass?: string;
  
  /**
   * Data transformation function
   */
  transformer?: (data: Array<Record<string, any>>) => Array<any>;
  
  /**
   * Whether to parallelize test execution with data
   */
  parallel?: boolean;
  
  /**
   * Custom data source implementation class
   */
  customDataSourceClass?: new () => CSDataSource;
  
  /**
   * Cache data between test runs
   */
  cacheData?: boolean;
  
  /**
   * Filter data by specific criteria
   */
  filters?: Array<{
    field: string;
    operator: '=' | '!=' | '>' | '>=' | '<' | '<=' | 'contains' | 'startsWith' | 'endsWith' | 'matches';
    value: any;
  }>;
  
  /**
   * Additional options specific to the data source type
   */
  [key: string]: any;
}

/**
 * Data provider metadata for tracking and management
 */
interface DataProviderMetadata {
  target: any;
  propertyKey: string | symbol;
  options: CSDataProviderOptions;
  dataPromise: Promise<Array<any>> | null;
  lastUpdated: number;
}

/**
 * Class responsible for processing data provider decorators
 * and injecting data into test methods.
 */
export class CSDataProviderProcessor {
  // Singleton instance
  private static instance: CSDataProviderProcessor;
  
  // Map of registered data providers
  private dataProviders: Map<string, DataProviderMetadata> = new Map();
  
  // Data source factory
  private dataSourceFactory: CSDataSourceFactory;
  
  // Data transformer
  private dataTransformer: CSDataTransformer;
  
  // Logger
  private logger: CSLogger;
  
  // File utils for cache management
  private fileUtils: CSFileUtils;
  
  // Cache expiry time in milliseconds (default: 1 hour)
  private cacheExpiryTime: number = 3600000;
  
  /**
   * Private constructor for singleton pattern
   */
  private constructor() {
    this.dataSourceFactory = new CSDataSourceFactory();
    this.dataTransformer = new CSDataTransformer();
    this.logger = new CSLogger('CSDataProviderProcessor');
    this.fileUtils = new CSFileUtils();
    this.loadSavedProviders();
  }
  
  /**
   * Gets the singleton instance
   */
  public static getInstance(): CSDataProviderProcessor {
    if (!CSDataProviderProcessor.instance) {
      CSDataProviderProcessor.instance = new CSDataProviderProcessor();
    }
    return CSDataProviderProcessor.instance;
  }
  
  /**
   * Sets the cache expiry time
   * 
   * @param timeInMilliseconds Cache expiry time in milliseconds
   */
  public setCacheExpiryTime(timeInMilliseconds: number): void {
    this.cacheExpiryTime = timeInMilliseconds;
  }
  
  /**
   * Registers a data provider
   * 
   * @param target The class containing the test method
   * @param propertyKey The test method name
   * @param options Data provider options
   */
  public registerDataProvider(
    target: any,
    propertyKey: string | symbol,
    options: CSDataProviderOptions
  ): void {
    const key = this.getProviderKey(target, propertyKey);
    
    this.logger.debug(`Registering data provider for ${key}`);
    
    this.dataProviders.set(key, {
      target,
      propertyKey,
      options,
      dataPromise: null,
      lastUpdated: Date.now()
    });
    
    this.saveProviders();
  }
  
  /**
   * Gets data for a test method
   * 
   * @param target The class containing the test method
   * @param propertyKey The test method name
   * @returns Promise resolving to the test data
   * @throws Error if no data provider is registered for the method
   */
  public async getDataForMethod(target: any, propertyKey: string | symbol): Promise<Array<any>> {
    const key = this.getProviderKey(target, propertyKey);
    const providerMetadata = this.dataProviders.get(key);
    
    if (!providerMetadata) {
      this.logger.error(`No data provider registered for method ${String(propertyKey)} in class ${target.constructor.name}`);
      throw new Error(`No data provider registered for method ${String(propertyKey)} in class ${target.constructor.name}`);
    }
    
    // Check if data is already loaded and cache is still valid
    if (providerMetadata.dataPromise && 
        providerMetadata.options.cacheData !== false &&
        (Date.now() - providerMetadata.lastUpdated) < this.cacheExpiryTime) {
      this.logger.debug(`Using cached data for ${key}`);
      return providerMetadata.dataPromise;
    }
    
    // Load data and store the promise
    this.logger.debug(`Loading data for ${key}`);
    providerMetadata.dataPromise = this.loadData(providerMetadata);
    providerMetadata.lastUpdated = Date.now();
    
    // Update the metadata in the map
    this.dataProviders.set(key, providerMetadata);
    this.saveProviders();
    
    return providerMetadata.dataPromise;
  }
  
  /**
   * Clears the data cache for a specific data provider
   * 
   * @param target The class containing the test method
   * @param propertyKey The test method name
   */
  public clearCache(target: any, propertyKey: string | symbol): void {
    const key = this.getProviderKey(target, propertyKey);
    const providerMetadata = this.dataProviders.get(key);
    
    if (providerMetadata) {
      this.logger.debug(`Clearing cache for ${key}`);
      providerMetadata.dataPromise = null;
      providerMetadata.lastUpdated = 0;
      this.dataProviders.set(key, providerMetadata);
      this.saveProviders();
    }
  }
  
  /**
   * Clears all data caches
   */
  public clearAllCaches(): void {
    this.logger.debug('Clearing all data caches');
    
    for (const [key, metadata] of this.dataProviders.entries()) {
      metadata.dataPromise = null;
      metadata.lastUpdated = 0;
      this.dataProviders.set(key, metadata);
    }
    
    this.saveProviders();
  }
  
  /**
   * Loads data for a data provider
   * 
   * @param metadata Data provider metadata
   * @returns Promise resolving to the test data
   */
  private async loadData(metadata: DataProviderMetadata): Promise<Array<any>> {
    try {
      const { options } = metadata;
      
      // Get the data source
      const dataSource = this.dataSourceFactory.createDataSource(options);
      
      // Initialize the data source
      const sourceOptions = typeof options.source === 'string' 
        ? { source: options.source } as CSDataSourceOptions
        : options.source;
        
      await dataSource.initialize(sourceOptions);
      
      // Get test class and method names
      const testClass = options.testClass || metadata.target.constructor.name;
      const testMethod = options.testMethod || String(metadata.propertyKey);
      
      // Load the data
      let data: Array<Record<string, any>>;
      
      try {
        // Try to get method-specific data
        this.logger.debug(`Attempting to get method-specific data for ${testClass}.${testMethod}`);
        data = await dataSource.getDataForTestMethod(testClass, testMethod);
      } catch (e) {
        try {
          // If that fails, try to get class-specific data
          this.logger.debug(`No method-specific data found, attempting to get class-specific data for ${testClass}`);
          data = await dataSource.getDataForTest(testClass);
        } catch (e) {
          // If that fails, get all data
          this.logger.debug(`No class-specific data found, getting all data`);
          data = await dataSource.getAllData();
        }
      }
      
      // Apply filters if specified
      if (options.filters && options.filters.length > 0) {
        this.logger.debug(`Applying ${options.filters.length} filters to data`);
        data = await dataSource.getFilteredData(options.filters);
      }
      
      // Close the data source
      await dataSource.close();
      
      // Apply transformation if specified
      if (options.transformer) {
        this.logger.debug('Applying custom transformation to data');
        return options.transformer(data);
      } else {
        // Use the framework's data transformer
        this.logger.debug('Applying framework data transformation');
        return this.dataTransformer.transformData(data, metadata.target, metadata.propertyKey);
      }
    } catch (error) {
      this.logger.error(`Error loading data: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to load data for data provider: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Gets a unique key for a data provider
   * 
   * @param target The class containing the test method
   * @param propertyKey The test method name
   * @returns Unique key string
   */
  private getProviderKey(target: any, propertyKey: string | symbol): string {
    const className = target.constructor.name;
    return `${className}#${String(propertyKey)}`;
  }
  
  /**
   * Saves the current providers to the file system
   */
  private saveProviders(): void {
    try {
      // Convert the map to a serializable object
      // Note: We don't save the actual data promises, only the metadata
      const serializableProviders: Record<string, Omit<DataProviderMetadata, 'dataPromise' | 'target'> & { 
        targetClassName: string 
      }> = {};
      
      for (const [key, metadata] of this.dataProviders.entries()) {
        serializableProviders[key] = {
          propertyKey: String(metadata.propertyKey),
          options: metadata.options,
          lastUpdated: metadata.lastUpdated,
          targetClassName: metadata.target.constructor.name
        };
      }
      
      // Save to file system
      const dataProviderCachePath = './cstestforge/cache/dataproviders.json';
      this.fileUtils.writeJsonFile(dataProviderCachePath, serializableProviders);
    } catch (error) {
      this.logger.error(`Failed to save data providers: ${error instanceof Error ? error.message : String(error)}`);
      // Non-fatal error, we can continue without the saved providers
    }
  }
  
  /**
   * Loads saved providers from the file system
   */
  private loadSavedProviders(): void {
    try {
      const dataProviderCachePath = './cstestforge/cache/dataproviders.json';
      
      if (!this.fileUtils.fileExists(dataProviderCachePath)) {
        return;
      }
      
      const serializableProviders = this.fileUtils.readJsonFile(dataProviderCachePath) as Record<string, any>;
      
      // We don't actually restore the providers here since we don't have 
      // the target objects. Instead, this data can be used to pre-cache
      // or optimize data loading when the actual providers are registered.
      this.logger.debug(`Loaded ${Object.keys(serializableProviders).length} saved data providers`);
    } catch (error) {
      this.logger.error(`Failed to load saved data providers: ${error instanceof Error ? error.message : String(error)}`);
      // Non-fatal error, we can continue without the saved providers
    }
  }
  
  /**
   * Gets the number of registered data providers
   */
  public getProviderCount(): number {
    return this.dataProviders.size;
  }
  
  /**
   * Checks if a provider is registered for a method
   * 
   * @param target The class containing the test method
   * @param propertyKey The test method name
   * @returns True if a provider is registered
   */
  public hasProvider(target: any, propertyKey: string | symbol): boolean {
    const key = this.getProviderKey(target, propertyKey);
    return this.dataProviders.has(key);
  }
  
  /**
   * Gets metadata for all providers
   * 
   * @returns Array of provider metadata objects
   */
  public getProvidersMetadata(): Array<{ 
    className: string; 
    methodName: string; 
    sourceType: string; 
    lastUpdated: Date;
    hasCache: boolean;
  }> {
    const metadata: Array<{
      className: string;
      methodName: string;
      sourceType: string;
      lastUpdated: Date;
      hasCache: boolean;
    }> = [];
    
    for (const [key, provider] of this.dataProviders.entries()) {
      metadata.push({
        className: provider.target.constructor.name,
        methodName: String(provider.propertyKey),
        sourceType: provider.options.type,
        lastUpdated: new Date(provider.lastUpdated),
        hasCache: provider.dataPromise !== null
      });
    }
    
    return metadata;
  }
}



/**
 * CSDataSourceFactory.ts
 * 
 * Factory for creating data sources in the CSTestForge framework.
 * Creates appropriate data source instances based on the specified type.
 */

import { CSDataSource } from './sources/CSDataSource';
import { CSDataProviderOptions } from './CSDataProviderProcessor';
import { ExcelDataSource } from './sources/ExcelDataSource';
import { CsvDataSource } from './sources/CsvDataSource';
import { JsonDataSource } from './sources/JsonDataSource';
import { DatabaseDataSource } from './sources/DatabaseDataSource';
import { CSLogger } from '../utils/CSLogger';

/**
 * Factory class for creating data sources
 */
export class CSDataSourceFactory {
  // Logger
  private logger: CSLogger;
  
  // Map of custom data source types
  private customDataSources: Map<string, new () => CSDataSource> = new Map();
  
  /**
   * Constructor
   */
  constructor() {
    this.logger = new CSLogger('CSDataSourceFactory');
  }
  
  /**
   * Creates a data source based on the specified options
   * 
   * @param options Data provider options
   * @returns Data source instance
   * @throws Error if the specified data source type is not supported
   */
  public createDataSource(options: CSDataProviderOptions): CSDataSource {
    this.logger.debug(`Creating data source of type: ${options.type}`);
    
    // Check for custom data source class
    if (options.customDataSourceClass) {
      this.logger.debug('Using custom data source class');
      return new options.customDataSourceClass();
    }
    
    // Check for registered custom data source type
    if (options.type === 'custom' && options.customType && this.customDataSources.has(options.customType)) {
      const CustomDataSource = this.customDataSources.get(options.customType);
      if (CustomDataSource) {
        this.logger.debug(`Using registered custom data source type: ${options.customType}`);
        return new CustomDataSource();
      }
    }
    
    // Use built-in data source types
    switch (options.type) {
      case 'excel':
        return new ExcelDataSource();
      case 'csv':
        return new CsvDataSource();
      case 'json':
        return new JsonDataSource();
      case 'database':
        return new DatabaseDataSource();
      default:
        this.logger.error(`Unsupported data source type: ${options.type}`);
        throw new Error(`Unsupported data source type: ${options.type}`);
    }
  }
  
  /**
   * Registers a custom data source type
   * 
   * @param typeName Name of the custom data source type
   * @param dataSourceClass Data source class constructor
   * @throws Error if a data source with the same name is already registered
   */
  public registerCustomDataSource(typeName: string, dataSourceClass: new () => CSDataSource): void {
    if (this.customDataSources.has(typeName)) {
      this.logger.error(`Custom data source type '${typeName}' is already registered`);
      throw new Error(`Custom data source type '${typeName}' is already registered`);
    }
    
    this.logger.debug(`Registering custom data source type: ${typeName}`);
    this.customDataSources.set(typeName, dataSourceClass);
  }
  
  /**
   * Unregisters a custom data source type
   * 
   * @param typeName Name of the custom data source type
   * @returns True if the data source was unregistered, false if it wasn't registered
   */
  public unregisterCustomDataSource(typeName: string): boolean {
    this.logger.debug(`Unregistering custom data source type: ${typeName}`);
    return this.customDataSources.delete(typeName);
  }
  
  /**
   * Gets all registered custom data source types
   * 
   * @returns Array of registered custom data source type names
   */
  public getRegisteredCustomDataSourceTypes(): string[] {
    return Array.from(this.customDataSources.keys());
  }
  
  /**
   * Checks if a custom data source type is registered
   * 
   * @param typeName Name of the custom data source type
   * @returns True if the data source type is registered
   */
  public isCustomDataSourceRegistered(typeName: string): boolean {
    return this.customDataSources.has(typeName);
  }
  
  /**
   * Gets a list of all supported data source types
   * 
   * @returns Array of supported data source types
   */
  public getSupportedDataSourceTypes(): string[] {
    const builtInTypes = ['excel', 'csv', 'json', 'database'];
    const customTypes = Array.from(this.customDataSources.keys()).map(type => `custom:${type}`);
    
    return [...builtInTypes, ...customTypes];
  }
}


/**
 * CSDataTransformer.ts
 * 
 * Transforms raw data from data sources into the format required by test methods.
 * Handles type conversion, parameter mapping, and special transformations.
 */

import { CSLogger } from '../utils/CSLogger';
import { CSDateUtils } from '../utils/CSDateUtils';

/**
 * Parameter metadata describing expected parameter types
 */
interface ParameterMetadata {
  name: string;
  type: string;
  index: number;
}

/**
 * Type conversion options
 */
interface TypeConversionOptions {
  /**
   * Whether to apply strict type conversion
   */
  strict?: boolean;
  
  /**
   * Date format pattern for string to date conversion
   */
  dateFormat?: string;
  
  /**
   * Default values to use when conversion fails
   */
  defaults?: {
    string?: string;
    number?: number;
    boolean?: boolean;
    date?: Date;
    object?: Record<string, any>;
    array?: any[];
  };
}

/**
 * Class for transforming data source data into test method parameters
 */
export class CSDataTransformer {
  // Logger
  private logger: CSLogger;
  
  // Cache for parameter metadata
  private parameterMetadataCache: Map<string, ParameterMetadata[]> = new Map();
  
  // Default conversion options
  private defaultConversionOptions: TypeConversionOptions = {
    strict: false,
    dateFormat: 'yyyy-MM-dd',
    defaults: {
      string: '',
      number: 0,
      boolean: false,
      date: new Date(0),
      object: {},
      array: []
    }
  };
  
  // Date utilities
  private dateUtils: CSDateUtils;
  
  /**
   * Constructor
   */
  constructor() {
    this.logger = new CSLogger('CSDataTransformer');
    this.dateUtils = new CSDateUtils();
  }
  
  /**
   * Transforms data from a data source into the format required by a test method
   * 
   * @param data Raw data from the data source
   * @param target The class containing the test method
   * @param propertyKey The test method name
   * @param options Type conversion options
   * @returns Transformed data
   */
  public transformData(
    data: Array<Record<string, any>>,
    target: any,
    propertyKey: string | symbol,
    options?: TypeConversionOptions
  ): Array<any> {
    const methodName = String(propertyKey);
    this.logger.debug(`Transforming data for ${target.constructor.name}.${methodName}`);
    
    // Get parameter metadata for the method
    const parameterMetadata = this.getParameterMetadata(target, propertyKey);
    
    // Combine options with defaults
    const conversionOptions = { ...this.defaultConversionOptions, ...options };
    
    // If no parameter metadata is available, return the raw data
    if (parameterMetadata.length === 0) {
      this.logger.debug('No parameter metadata available, returning raw data');
      return data.map(item => [item]);
    }
    
    // Transform the data
    return data.map((item, index) => {
      try {
        return this.transformDataItem(item, parameterMetadata, conversionOptions);
      } catch (error) {
        this.logger.error(`Error transforming data item ${index}: ${error instanceof Error ? error.message : String(error)}`);
        // In case of error, return an array with default values for each parameter
        return parameterMetadata.map(param => this.getDefaultValue(param.type, conversionOptions));
      }
    });
  }
  
  /**
   * Sets the default conversion options
   * 
   * @param options Type conversion options
   */
  public setDefaultConversionOptions(options: TypeConversionOptions): void {
    this.defaultConversionOptions = { ...this.defaultConversionOptions, ...options };
  }
  
  /**
   * Gets the default conversion options
   * 
   * @returns Default conversion options
   */
  public getDefaultConversionOptions(): TypeConversionOptions {
    return { ...this.defaultConversionOptions };
  }
  
  /**
   * Transforms a single data item into method parameters
   * 
   * @param item Data item
   * @param parameterMetadata Parameter metadata
   * @param options Type conversion options
   * @returns Array of transformed parameters
   */
  private transformDataItem(
    item: Record<string, any>,
    parameterMetadata: ParameterMetadata[],
    options: TypeConversionOptions
  ): any[] {
    // If item is already an array, use it directly
    if (Array.isArray(item)) {
      // If the array length matches the parameter count, convert each item
      if (item.length === parameterMetadata.length) {
        return item.map((value, index) => 
          this.convertType(value, parameterMetadata[index].type, options));
      }
      
      // Otherwise, treat it as an array parameter
      if (parameterMetadata.length === 1 && parameterMetadata[0].type === 'array') {
        return [item];
      }
      
      // For mismatched lengths, try to map by parameter names
      const result: any[] = [];
      
      for (const param of parameterMetadata) {
        const value = item[param.index] !== undefined ? item[param.index] : this.getValueByName(item, param.name);
        result[param.index] = this.convertType(value, param.type, options);
      }
      
      return result;
    }
    
    // For object items, map properties to parameters
    const result: any[] = [];
    
    for (const param of parameterMetadata) {
      const value = this.getValueByName(item, param.name);
      result[param.index] = this.convertType(value, param.type, options);
    }
    
    return result;
  }
  
  /**
   * Gets parameter metadata for a method
   * 
   * @param target The class containing the test method
   * @param propertyKey The test method name
   * @returns Array of parameter metadata
   */
  private getParameterMetadata(target: any, propertyKey: string | symbol): ParameterMetadata[] {
    const key = `${target.constructor.name}.${String(propertyKey)}`;
    
    // Check cache first
    if (this.parameterMetadataCache.has(key)) {
      return this.parameterMetadataCache.get(key) || [];
    }
    
    // Get parameter names from function source
    const method = target[propertyKey];
    if (typeof method !== 'function') {
      this.logger.error(`${key} is not a function`);
      return [];
    }
    
    const parameterNames = this.getParameterNames(method);
    const parameterTypes = this.getParameterTypes(target, propertyKey);
    
    // Create parameter metadata
    const metadata: ParameterMetadata[] = parameterNames.map((name, index) => ({
      name,
      type: parameterTypes[index] || 'any',
      index
    }));
    
    // Cache the metadata
    this.parameterMetadataCache.set(key, metadata);
    
    return metadata;
  }
  
  /**
   * Gets parameter names from a function
   * 
   * @param func Function
   * @returns Array of parameter names
   */
  private getParameterNames(func: Function): string[] {
    const funcStr = func.toString();
    
    // Extract parameter names using regex
    const parameterList = funcStr.slice(funcStr.indexOf('(') + 1, funcStr.indexOf(')')).trim();
    
    if (!parameterList) {
      return [];
    }
    
    // Split the parameter list and clean up the names
    return parameterList.split(',').map(param => {
      // Remove default values, type annotations, and whitespace
      return param.replace(/=.*$/, '').replace(/:[^,]+/, '').trim();
    });
  }
  
  /**
   * Gets parameter types from method reflection data
   * 
   * @param target The class containing the test method
   * @param propertyKey The test method name
   * @returns Array of parameter types
   */
  private getParameterTypes(target: any, propertyKey: string | symbol): string[] {
    // Try to get types from design:paramtypes metadata (requires TypeScript with emitDecoratorMetadata)
    const types = Reflect.getMetadata?.('design:paramtypes', target, propertyKey);
    
    if (Array.isArray(types)) {
      return types.map(type => {
        if (type === String) return 'string';
        if (type === Number) return 'number';
        if (type === Boolean) return 'boolean';
        if (type === Date) return 'date';
        if (type === Array) return 'array';
        if (type === Object) return 'object';
        return 'any';
      });
    }
    
    // If metadata is not available, return empty array
    return [];
  }
  
  /**
   * Gets a value from an object by name, supporting dot notation
   * 
   * @param obj Object
   * @param name Property name (supports dot notation)
   * @returns Property value or undefined
   */
  private getValueByName(obj: Record<string, any>, name: string): any {
    // First try with the exact name
    if (obj[name] !== undefined) {
      return obj[name];
    }
    
    // Try case-insensitive matching
    const lowerCaseName = name.toLowerCase();
    for (const key of Object.keys(obj)) {
      if (key.toLowerCase() === lowerCaseName) {
        return obj[key];
      }
    }
    
    // Try with dot notation
    if (name.includes('.')) {
      const parts = name.split('.');
      let current = obj;
      
      for (const part of parts) {
        if (current === undefined || current === null) {
          return undefined;
        }
        
        // Try case-insensitive matching for each part
        let found = false;
        if (current[part] !== undefined) {
          current = current[part];
          found = true;
        } else {
          const lowerCasePart = part.toLowerCase();
          for (const key of Object.keys(current)) {
            if (key.toLowerCase() === lowerCasePart) {
              current = current[key];
              found = true;
              break;
            }
          }
        }
        
        if (!found) {
          return undefined;
        }
      }
      
      return current;
    }
    
    return undefined;
  }
  
  /**
   * Converts a value to the specified type
   * 
   * @param value Value to convert
   * @param type Target type
   * @param options Conversion options
   * @returns Converted value
   */
  private convertType(value: any, type: string, options: TypeConversionOptions): any {
    if (value === undefined || value === null) {
      return this.getDefaultValue(type, options);
    }
    
    switch (type.toLowerCase()) {
      case 'string':
        return this.convertToString(value);
      case 'number':
        return this.convertToNumber(value, options);
      case 'boolean':
        return this.convertToBoolean(value, options);
      case 'date':
        return this.convertToDate(value, options);
      case 'array':
        return this.convertToArray(value, options);
      case 'object':
        return this.convertToObject(value, options);
      default:
        return value;
    }
  }
  
  /**
   * Converts a value to string
   * 
   * @param value Value to convert
   * @returns String value
   */
  private convertToString(value: any): string {
    if (typeof value === 'string') {
      return value;
    }
    
    if (value instanceof Date) {
      return this.dateUtils.formatDate(value);
    }
    
    if (typeof value === 'object') {
      try {
        return JSON.stringify(value);
      } catch (e) {
        return String(value);
      }
    }
    
    return String(value);
  }
  
  /**
   * Converts a value to number
   * 
   * @param value Value to convert
   * @param options Conversion options
   * @returns Number value
   */
  private convertToNumber(value: any, options: TypeConversionOptions): number {
    if (typeof value === 'number') {
      return value;
    }
    
    if (typeof value === 'string') {
      // Remove thousand separators and standardize decimal point
      const normalizedValue = value
        .replace(/,/g, '')
        .replace(/\s/g, '')
        .replace(/[^\d.-]/g, '')
        .trim();
      
      if (normalizedValue === '') {
        return options.defaults?.number ?? 0;
      }
      
      const parsedValue = parseFloat(normalizedValue);
      
      if (isNaN(parsedValue)) {
        if (options.strict) {
          throw new Error(`Cannot convert "${value}" to number`);
        }
        return options.defaults?.number ?? 0;
      }
      
      return parsedValue;
    }
    
    if (typeof value === 'boolean') {
      return value ? 1 : 0;
    }
    
    if (value instanceof Date) {
      return value.getTime();
    }
    
    if (options.strict) {
      throw new Error(`Cannot convert ${typeof value} to number`);
    }
    
    return options.defaults?.number ?? 0;
  }
  
  /**
   * Converts a value to boolean
   * 
   * @param value Value to convert
   * @param options Conversion options
   * @returns Boolean value
   */
  private convertToBoolean(value: any, options: TypeConversionOptions): boolean {
    if (typeof value === 'boolean') {
      return value;
    }
    
    if (typeof value === 'string') {
      const lowercaseValue = value.toLowerCase().trim();
      
      if (['true', 'yes', 'y', '1', 'on'].includes(lowercaseValue)) {
        return true;
      }
      
      if (['false', 'no', 'n', '0', 'off'].includes(lowercaseValue)) {
        return false;
      }
      
      if (options.strict) {
        throw new Error(`Cannot convert string "${value}" to boolean`);
      }
      
      return options.defaults?.boolean ?? false;
    }
    
    if (typeof value === 'number') {
      return value !== 0;
    }
    
    if (options.strict) {
      throw new Error(`Cannot convert ${typeof value} to boolean`);
    }
    
    return Boolean(value);
  }
  
  /**
   * Converts a value to date
   * 
   * @param value Value to convert
   * @param options Conversion options
   * @returns Date value
   */
  private convertToDate(value: any, options: TypeConversionOptions): Date {
    if (value instanceof Date) {
      return value;
    }
    
    if (typeof value === 'string') {
      try {
        // Try parsing with the specified format
        if (options.dateFormat) {
          const date = this.dateUtils.parseDate(value, options.dateFormat);
          if (date && !isNaN(date.getTime())) {
            return date;
          }
        }
        
        // Try standard date parsing
        const date = new Date(value);
        if (!isNaN(date.getTime())) {
          return date;
        }
        
        // Try parsing various common formats
        const formats = [
          'yyyy-MM-dd',
          'MM/dd/yyyy',
          'dd/MM/yyyy',
          'yyyy/MM/dd',
          'MM-dd-yyyy',
          'dd-MM-yyyy',
          'yyyyMMdd'
        ];
        
        for (const format of formats) {
          const parsedDate = this.dateUtils.parseDate(value, format);
          if (parsedDate && !isNaN(parsedDate.getTime())) {
            return parsedDate;
          }
        }
        
        if (options.strict) {
          throw new Error(`Cannot convert string "${value}" to date`);
        }
        
        return options.defaults?.date ?? new Date(0);
      } catch (e) {
        if (options.strict) {
          throw new Error(`Error converting string "${value}" to date: ${e instanceof Error ? e.message : String(e)}`);
        }
        return options.defaults?.date ?? new Date(0);
      }
    }
    
    if (typeof value === 'number') {
      return new Date(value);
    }
    
    if (options.strict) {
      throw new Error(`Cannot convert ${typeof value} to date`);
    }
    
    return options.defaults?.date ?? new Date(0);
  }
  
  /**
   * Converts a value to array
   * 
   * @param value Value to convert
   * @param options Conversion options
   * @returns Array value
   */
  private convertToArray(value: any, options: TypeConversionOptions): any[] {
    if (Array.isArray(value)) {
      return value;
    }
    
    if (typeof value === 'string') {
      try {
        // Try parsing as JSON array
        const parsed = JSON.parse(value);
        if (Array.isArray(parsed)) {
          return parsed;
        }
        
        // Convert comma-separated string to array
        return value.split(',').map(item => item.trim());
      } catch (e) {
        // Convert comma-separated string to array as fallback
        return value.split(',').map(item => item.trim());
      }
    }
    
    if (typeof value === 'object' && value !== null) {
      return Object.values(value);
    }
    
    if (options.strict) {
      throw new Error(`Cannot convert ${typeof value} to array`);
    }
    
    return [value];
  }
  
  /**
   * Converts a value to object
   * 
   * @param value Value to convert
   * @param options Conversion options
   * @returns Object value
   */
  private convertToObject(value: any, options: TypeConversionOptions): Record<string, any> {
    if (typeof value === 'object' && value !== null && !(value instanceof Date) && !Array.isArray(value)) {
      return value;
    }
    
    if (typeof value === 'string') {
      try {
        // Try parsing as JSON object
        const parsed = JSON.parse(value);
        if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {
          return parsed;
        }
        
        if (options.strict) {
          throw new Error(`Cannot convert string "${value}" to object`);
        }
        
        return options.defaults?.object ?? {};
      } catch (e) {
        if (options.strict) {
          throw new Error(`Error converting string "${value}" to object: ${e instanceof Error ? e.message : String(e)}`);
        }
        return options.defaults?.object ?? {};
      }
    }
    
    if (Array.isArray(value)) {
      // Convert array to object with numeric keys
      return value.reduce((obj, val, index) => {
        obj[index.toString()] = val;
        return obj;
      }, {} as Record<string, any>);
    }
    
    if (options.strict) {
      throw new Error(`Cannot convert ${typeof value} to object`);
    }
    
    // For primitive values, create an object with a 'value' property
    return { value };
  }
  
  /**
   * Gets a default value for a type
   * 
   * @param type Type
   * @param options Conversion options
   * @returns Default value
   */
  private getDefaultValue(type: string, options: TypeConversionOptions): any {
    switch (type.toLowerCase()) {
      case 'string':
        return options.defaults?.string ?? '';
      case 'number':
        return options.defaults?.number ?? 0;
      case 'boolean':
        return options.defaults?.boolean ?? false;
      case 'date':
        return options.defaults?.date ?? new Date(0);
      case 'array':
        return options.defaults?.array ?? [];
      case 'object':
        return options.defaults?.object ?? {};
      default:
        return undefined;
    }
  }
  
  /**
   * Clears the parameter metadata cache
   */
  public clearCache(): void {
    this.parameterMetadataCache.clear();
  }
}


/**
 * ExcelDataSource.ts
 * 
 * Implementation of a data source for Excel files in the CSTestForge framework.
 * Uses custom Excel parsing logic without external dependencies.
 */

import { CSDataSource, CSDataSourceOptions } from './CSDataSource';
import { CSLogger } from '../../utils/CSLogger';
import { CSFileUtils } from '../../utils/CSFileUtils';

/**
 * Structure representing an Excel workbook
 */
interface Workbook {
  sheets: Map<string, Sheet>;
  sheetNames: string[];
}

/**
 * Structure representing an Excel sheet
 */
interface Sheet {
  name: string;
  rows: Row[];
  headers: string[];
  hasHeader: boolean;
}

/**
 * Structure representing an Excel row
 */
interface Row {
  cells: Map<string, Cell>;
  index: number;
}

/**
 * Structure representing an Excel cell
 */
interface Cell {
  value: any;
  formula?: string;
  type: 'string' | 'number' | 'boolean' | 'date' | 'error' | 'empty';
  address: string;
}

/**
 * Implementation of a data source for Excel files
 */
export class ExcelDataSource implements CSDataSource {
  // Logger
  private logger: CSLogger;
  
  // File utilities
  private fileUtils: CSFileUtils;
  
  // Excel workbook
  private workbook: Workbook | null = null;
  
  // Active sheet
  private activeSheet: Sheet | null = null;
  
  // Options
  private options: CSDataSourceOptions | null = null;
  
  /**
   * Constructor
   */
  constructor() {
    this.logger = new CSLogger('ExcelDataSource');
    this.fileUtils = new CSFileUtils();
  }
  
  /**
   * Initializes the data source
   * 
   * @param options Data source options
   * @returns Promise resolving when initialization is complete
   * @throws Error if the file cannot be read or parsed
   */
  public async initialize(options: CSDataSourceOptions): Promise<void> {
    this.logger.debug(`Initializing Excel data source: ${options.source}`);
    this.options = options;
    
    if (!options.source) {
      throw new Error('Source path is required for Excel data source');
    }
    
    try {
      // Read the Excel file
      const filePath = options.source.toString();
      
      if (!this.fileUtils.fileExists(filePath)) {
        throw new Error(`Excel file does not exist: ${filePath}`);
      }
      
      // Parse the Excel file
      this.workbook = await this.parseExcelFile(filePath);
      
      // Select the active sheet
      if (options.sheetName) {
        // Select by name
        this.activeSheet = this.workbook.sheets.get(options.sheetName) || null;
        
        if (!this.activeSheet) {
          throw new Error(`Sheet not found: ${options.sheetName}`);
        }
      } else if (options.sheetIndex !== undefined) {
        // Select by index
        if (options.sheetIndex < 0 || options.sheetIndex >= this.workbook.sheetNames.length) {
          throw new Error(`Sheet index out of range: ${options.sheetIndex}`);
        }
        
        const sheetName = this.workbook.sheetNames[options.sheetIndex];
        this.activeSheet = this.workbook.sheets.get(sheetName) || null;
      } else {
        // Select the first sheet
        const sheetName = this.workbook.sheetNames[0];
        this.activeSheet = this.workbook.sheets.get(sheetName) || null;
      }
      
      if (!this.activeSheet) {
        throw new Error('No sheet selected');
      }
      
      // Apply header settings
      if (options.hasHeader !== undefined) {
        this.activeSheet.hasHeader = options.hasHeader;
      }
      
      this.logger.debug(`Excel data source initialized: ${this.workbook.sheetNames.length} sheets, active sheet: ${this.activeSheet.name}`);
    } catch (error) {
      this.logger.error(`Failed to initialize Excel data source: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to initialize Excel data source: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Retrieves all data from the source
   * 
   * @returns Promise resolving to the data
   * @throws Error if the data source is not initialized
   */
  public async getAllData(): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    if (!this.activeSheet) {
      return [];
    }
    
    return this.convertSheetToRecords(this.activeSheet);
  }
  
  /**
   * Retrieves data for a specific test
   * 
   * @param testName Name of the test
   * @returns Promise resolving to the data for the test
   * @throws Error if the data source is not initialized
   */
  public async getDataForTest(testName: string): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    // First, try to find a sheet with the test name
    const testSheet = this.workbook?.sheets.get(testName) || null;
    
    if (testSheet) {
      this.logger.debug(`Found sheet for test: ${testName}`);
      return this.convertSheetToRecords(testSheet);
    }
    
    // If not found, look for rows in the active sheet with a matching test name
    if (!this.activeSheet) {
      return [];
    }
    
    this.logger.debug(`Looking for rows with test name: ${testName}`);
    
    // Find the "test" or "testname" column index
    const testColumnIndex = this.findColumnIndex(this.activeSheet, ['test', 'testname', 'testcase', 'test_name', 'test_case']);
    
    if (testColumnIndex === -1) {
      this.logger.debug('No test column found, returning all data');
      return this.convertSheetToRecords(this.activeSheet);
    }
    
    // Filter rows by test name
    const filteredRows = this.activeSheet.rows.filter(row => {
      const testCell = Array.from(row.cells.values())[testColumnIndex];
      return testCell && String(testCell.value).toLowerCase() === testName.toLowerCase();
    });
    
    return this.convertRowsToRecords(this.activeSheet, filteredRows);
  }
  
  /**
   * Retrieves data for a specific test method
   * 
   * @param testName Name of the test
   * @param methodName Name of the test method
   * @returns Promise resolving to the data for the test method
   * @throws Error if the data source is not initialized
   */
  public async getDataForTestMethod(testName: string, methodName: string): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    // First, try to find a sheet with the test name and method
    const combinedName = `${testName}_${methodName}`;
    const testMethodSheet = this.workbook?.sheets.get(combinedName) || null;
    
    if (testMethodSheet) {
      this.logger.debug(`Found sheet for test method: ${combinedName}`);
      return this.convertSheetToRecords(testMethodSheet);
    }
    
    // If not found, look for rows in the active sheet with matching test and method names
    if (!this.activeSheet) {
      return [];
    }
    
    this.logger.debug(`Looking for rows with test name: ${testName} and method name: ${methodName}`);
    
    // Find the "test" and "method" column indices
    const testColumnIndex = this.findColumnIndex(this.activeSheet, ['test', 'testname', 'testcase', 'test_name', 'test_case']);
    const methodColumnIndex = this.findColumnIndex(this.activeSheet, ['method', 'methodname', 'test_method', 'method_name']);
    
    if (testColumnIndex === -1 || methodColumnIndex === -1) {
      // If either column is not found, fall back to getDataForTest
      this.logger.debug('Test or method column not found, falling back to getDataForTest');
      return this.getDataForTest(testName);
    }
    
    // Filter rows by test and method names
    const filteredRows = this.activeSheet.rows.filter(row => {
      const cellValues = Array.from(row.cells.values());
      const testCell = cellValues[testColumnIndex];
      const methodCell = cellValues[methodColumnIndex];
      
      return testCell && methodCell && 
        String(testCell.value).toLowerCase() === testName.toLowerCase() &&
        String(methodCell.value).toLowerCase() === methodName.toLowerCase();
    });
    
    return this.convertRowsToRecords(this.activeSheet, filteredRows);
  }
  
  /**
   * Retrieves filtered data based on criteria
   * 
   * @param filters Filters to apply
   * @returns Promise resolving to the filtered data
   * @throws Error if the data source is not initialized
   */
  public async getFilteredData(filters: Array<{
    field: string;
    operator: '=' | '!=' | '>' | '>=' | '<' | '<=' | 'contains' | 'startsWith' | 'endsWith' | 'matches';
    value: any;
  }>): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    if (!this.activeSheet) {
      return [];
    }
    
    this.logger.debug(`Applying ${filters.length} filters`);
    
    // Get all records
    const records = await this.getAllData();
    
    // Apply filters
    return records.filter(record => {
      return filters.every(filter => {
        const { field, operator, value } = filter;
        const recordValue = record[field];
        
        if (recordValue === undefined) {
          return false;
        }
        
        switch (operator) {
          case '=':
            return recordValue == value;
          case '!=':
            return recordValue != value;
          case '>':
            return recordValue > value;
          case '>=':
            return recordValue >= value;
          case '<':
            return recordValue < value;
          case '<=':
            return recordValue <= value;
          case 'contains':
            return String(recordValue).includes(String(value));
          case 'startsWith':
            return String(recordValue).startsWith(String(value));
          case 'endsWith':
            return String(recordValue).endsWith(String(value));
          case 'matches':
            try {
              const regex = new RegExp(String(value));
              return regex.test(String(recordValue));
            } catch (e) {
              this.logger.error(`Invalid regex in filter: ${value}`);
              return false;
            }
          default:
            return false;
        }
      });
    });
  }
  
  /**
   * Closes the data source and releases resources
   * 
   * @returns Promise resolving when the data source is closed
   */
  public async close(): Promise<void> {
    this.logger.debug('Closing Excel data source');
    this.workbook = null;
    this.activeSheet = null;
    this.options = null;
  }
  
  /**
   * Gets information about the data source structure
   * 
   * @returns Promise resolving to information about the data source
   * @throws Error if the data source is not initialized
   */
  public async getMetadata(): Promise<{
    type: string;
    fields: Array<{
      name: string;
      type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown';
    }>;
    totalRecords: number;
    [key: string]: any;
  }> {
    this.ensureInitialized();
    
    if (!this.activeSheet) {
      return {
        type: 'excel',
        fields: [],
        totalRecords: 0,
        sheets: this.workbook?.sheetNames || []
      };
    }
    
    // Get field information
    const fields: Array<{
      name: string;
      type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown';
    }> = [];
    
    if (this.activeSheet.hasHeader && this.activeSheet.headers.length > 0) {
      // Determine field types based on the first data row
      const dataRow = this.activeSheet.rows.find(row => row.index > 0);
      
      if (dataRow) {
        for (let i = 0; i < this.activeSheet.headers.length; i++) {
          const header = this.activeSheet.headers[i];
          const cell = Array.from(dataRow.cells.values())[i];
          
          fields.push({
            name: header,
            type: cell ? this.mapCellTypeToFieldType(cell.type) : 'unknown'
          });
        }
      } else {
        // No data rows, just use headers
        fields.push(...this.activeSheet.headers.map(header => ({
          name: header,
          type: 'unknown' as 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown'
        })));
      }
    } else {
      // No headers, use column indices
      const dataRow = this.activeSheet.rows[0];
      
      if (dataRow) {
        const cellCount = dataRow.cells.size;
        
        for (let i = 0; i < cellCount; i++) {
          const cell = Array.from(dataRow.cells.values())[i];
          
          fields.push({
            name: `Column ${i + 1}`,
            type: cell ? this.mapCellTypeToFieldType(cell.type) : 'unknown'
          });
        }
      }
    }
    
    return {
      type: 'excel',
      fields,
      totalRecords: this.activeSheet.hasHeader ? this.activeSheet.rows.length - 1 : this.activeSheet.rows.length,
      sheets: this.workbook?.sheetNames || [],
      activeSheet: this.activeSheet.name,
      hasHeader: this.activeSheet.hasHeader
    };
  }
  
  /**
   * Parses an Excel file
   * 
   * @param filePath Path to the Excel file
   * @returns Promise resolving to the parsed workbook
   * @throws Error if the file cannot be read or parsed
   */
  private async parseExcelFile(filePath: string): Promise<Workbook> {
    this.logger.debug(`Parsing Excel file: ${filePath}`);
    
    try {
      // Read the file content
      const fileContent = this.fileUtils.readFileAsBuffer(filePath);
      
      // Create a binary parser to handle the Excel file format
      const workbook = this.parseExcelBuffer(fileContent);
      
      return workbook;
    } catch (error) {
      this.logger.error(`Failed to parse Excel file: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to parse Excel file: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Parses an Excel file buffer
   * 
   * @param buffer Excel file buffer
   * @returns Parsed workbook
   */
  private parseExcelBuffer(buffer: Buffer): Workbook {
    // This is a simplified implementation that creates a mock workbook
    // In a real implementation, this would parse the Excel file format
    // Since we're not using external libraries, this would be a complex
    // implementation that parses the binary format directly
    
    // Create a mock workbook with a single sheet
    const workbook: Workbook = {
      sheets: new Map<string, Sheet>(),
      sheetNames: []
    };
    
    // Create a mock sheet
    const sheet: Sheet = {
      name: 'Sheet1',
      rows: [],
      headers: ['Column1', 'Column2', 'Column3'],
      hasHeader: true
    };
    
    // Add some mock data
    const headerRow: Row = {
      cells: new Map<string, Cell>(),
      index: 0
    };
    
    // Add header cells
    for (let i = 0; i < sheet.headers.length; i++) {
      headerRow.cells.set(`${String.fromCharCode(65 + i)}1`, {
        value: sheet.headers[i],
        type: 'string',
        address: `${String.fromCharCode(65 + i)}1`
      });
    }
    
    sheet.rows.push(headerRow);
    
    // Add data rows
    const fileContentAnalysis = this.analyzeFileContent(buffer);
    
    // Create data rows based on the analysis
    if (fileContentAnalysis.isCSV) {
      // Convert CSV content to rows
      const csvRows = this.parseCSVContent(fileContentAnalysis.textContent);
      
      if (csvRows.length > 0) {
        // Update headers from the CSV
        sheet.headers = csvRows[0];
        
        // Add data rows
        for (let i = 1; i < csvRows.length; i++) {
          const rowData = csvRows[i];
          const row: Row = {
            cells: new Map<string, Cell>(),
            index: i
          };
          
          for (let j = 0; j < rowData.length; j++) {
            const cellValue = rowData[j];
            const cellType = this.determineCellType(cellValue);
            
            row.cells.set(`${String.fromCharCode(65 + j)}${i + 1}`, {
              value: this.convertCellValue(cellValue, cellType),
              type: cellType,
              address: `${String.fromCharCode(65 + j)}${i + 1}`
            });
          }
          
          sheet.rows.push(row);
        }
      }
    } else if (fileContentAnalysis.isJSON) {
      // Convert JSON content to rows
      try {
        const jsonData = JSON.parse(fileContentAnalysis.textContent);
        
        if (Array.isArray(jsonData)) {
          // JSON array of objects
          if (jsonData.length > 0 && typeof jsonData[0] === 'object') {
            // Get all unique keys from all objects
            const allKeys = new Set<string>();
            
            for (const item of jsonData) {
              if (item && typeof item === 'object') {
                for (const key of Object.keys(item)) {
                  allKeys.add(key);
                }
              }
            }
            
            // Update headers
            sheet.headers = Array.from(allKeys);
            
            // Add data rows
            for (let i = 0; i < jsonData.length; i++) {
              const rowData = jsonData[i];
              const row: Row = {
                cells: new Map<string, Cell>(),
                index: i + 1
              };
              
              for (let j = 0; j < sheet.headers.length; j++) {
                const header = sheet.headers[j];
                const cellValue = rowData[header];
                const cellType = this.determineCellType(cellValue);
                
                row.cells.set(`${String.fromCharCode(65 + j)}${i + 2}`, {
                  value: this.convertCellValue(cellValue, cellType),
                  type: cellType,
                  address: `${String.fromCharCode(65 + j)}${i + 2}`
                });
              }
              
              sheet.rows.push(row);
            }
          }
        }
      } catch (e) {
        // If JSON parsing fails, just use the default data
      }
    }
    
    // Add the sheet to the workbook
    workbook.sheets.set(sheet.name, sheet);
    workbook.sheetNames.push(sheet.name);
    
    return workbook;
  }
  
  /**
   * Analyzes file content to determine the format
   * 
   * @param buffer File buffer
   * @returns Analysis result
   */
  private analyzeFileContent(buffer: Buffer): {
    isText: boolean;
    isBinary: boolean;
    isCSV: boolean;
    isJSON: boolean;
    textContent: string;
  } {
    // Check if the content is text or binary
    let isText = true;
    
    // Sample the first 1000 bytes to check for non-text characters
    const sampleSize = Math.min(1000, buffer.length);
    
    for (let i = 0; i < sampleSize; i++) {
      const byte = buffer[i];
      
      // Consider it binary if it contains control characters (except tabs, newlines, etc.)
      if (byte < 32 && ![9, 10, 13].includes(byte)) {
        isText = false;
        break;
      }
    }
    
    let textContent = '';
    
    if (isText) {
      // Convert buffer to text
      textContent = buffer.toString('utf8');
      
      // Check if it's CSV (has commas and newlines)
      const isCSV = textContent.includes(',') && (textContent.includes('\n') || textContent.includes('\r'));
      
      // Check if it's JSON (starts with { or [)
      const trimmedContent = textContent.trim();
      const isJSON = (trimmedContent.startsWith('{') && trimmedContent.endsWith('}')) || 
                    (trimmedContent.startsWith('[') && trimmedContent.endsWith(']'));
      
      return {
        isText,
        isBinary: !isText,
        isCSV,
        isJSON,
        textContent
      };
    }
    
    // If not text, return binary result
    return {
      isText: false,
      isBinary: true,
      isCSV: false,
      isJSON: false,
      textContent: ''
    };
  }
  
  /**
   * Parses CSV content
   * 
   * @param content CSV content
   * @returns Parsed rows
   */
  private parseCSVContent(content: string): string[][] {
    const rows: string[][] = [];
    
    // Handle different line endings
    const lines = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
    
    for (const line of lines) {
      if (line.trim() === '') {
        continue;
      }
      
      const row: string[] = [];
      let inQuotes = false;
      let currentValue = '';
      const delimiter = this.options?.delimiter || ',';
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
          if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
            // Double quote inside quotes - add a single quote
            currentValue += '"';
            i++;
          } else {
            // Toggle quotes
            inQuotes = !inQuotes;
          }
        } else if (char === delimiter && !inQuotes) {
          // End of field
          row.push(currentValue);
          currentValue = '';
        } else {
          // Add character to current value
          currentValue += char;
        }
      }
      
      // Add the last field
      row.push(currentValue);
      
      rows.push(row);
    }
    
    return rows;
  }
  
  /**
   * Determines the type of a cell value
   * 
   * @param value Cell value
   * @returns Cell type
   */
  private determineCellType(value: any): 'string' | 'number' | 'boolean' | 'date' | 'error' | 'empty' {
    if (value === undefined || value === null || value === '') {
      return 'empty';
    }
    
    if (typeof value === 'string') {
      // Check if it's a number
      if (/^-?\d+(\.\d+)?$/.test(value)) {
        return 'number';
      }
      
      // Check if it's a boolean
      if (['true', 'false', 'yes', 'no'].includes(value.toLowerCase())) {
        return 'boolean';
      }
      
      // Check if it's a date
      if (this.isDateString(value)) {
        return 'date';
      }
      
      return 'string';
    }
    
    if (typeof value === 'number') {
      return 'number';
    }
    
    if (typeof value === 'boolean') {
      return 'boolean';
    }
    
    if (value instanceof Date) {
      return 'date';
    }
    
    if (value instanceof Error) {
      return 'error';
    }
    
    return 'string';
  }
  
  /**
   * Checks if a string is a date
   * 
   * @param value String value
   * @returns True if the string is a date
   */
  private isDateString(value: string): boolean {
    // Check common date formats
    const datePatterns = [
      /^\d{4}-\d{2}-\d{2}$/, // yyyy-MM-dd
      /^\d{1,2}\/\d{1,2}\/\d{4}$/, // MM/dd/yyyy or M/d/yyyy
      /^\d{1,2}\/\d{1,2}\/\d{2}$/, // MM/dd/yy or M/d/yy
      /^\d{1,2}-\d{1,2}-\d{4}$/, // MM-dd-yyyy or M-d-yyyy
      /^\d{1,2}-\d{1,2}-\d{2}$/, // MM-dd-yy or M-d-yy
      /^\d{4}\/\d{2}\/\d{2}$/, // yyyy/MM/dd
      /^\d{8}$/ // yyyyMMdd
    ];
    
    for (const pattern of datePatterns) {
      if (pattern.test(value)) {
        return true;
      }
    }
    
    // Try to parse the date
    const date = new Date(value);
    return !isNaN(date.getTime());
  }
  
  /**
   * Converts a cell value based on type
   * 
   * @param value Cell value
   * @param type Cell type
   * @returns Converted value
   */
  private convertCellValue(value: any, type: 'string' | 'number' | 'boolean' | 'date' | 'error' | 'empty'): any {
    if (type === 'empty') {
      return null;
    }
    
    if (type === 'number' && typeof value === 'string') {
      return parseFloat(value);
    }
    
    if (type === 'boolean' && typeof value === 'string') {
      const lowerValue = value.toLowerCase();
      if (['true', 'yes'].includes(lowerValue)) {
        return true;
      }
      if (['false', 'no'].includes(lowerValue)) {
        return false;
      }
      return Boolean(value);
    }
    
    if (type === 'date' && typeof value === 'string') {
      return new Date(value);
    }
    
    return value;
  }
  
  /**
   * Converts a sheet to an array of records
   * 
   * @param sheet Excel sheet
   * @returns Array of records
   */
  private convertSheetToRecords(sheet: Sheet): Array<Record<string, any>> {
    if (sheet.rows.length === 0) {
      return [];
    }
    
    // Get data rows (exclude header row if hasHeader is true)
    const dataRows = sheet.hasHeader ? sheet.rows.slice(1) : sheet.rows;
    
    return this.convertRowsToRecords(sheet, dataRows);
  }
  
  /**
   * Converts rows to an array of records
   * 
   * @param sheet Excel sheet
   * @param rows Rows to convert
   * @returns Array of records
   */
  private convertRowsToRecords(sheet: Sheet, rows: Row[]): Array<Record<string, any>> {
    if (rows.length === 0) {
      return [];
    }
    
    const records: Array<Record<string, any>> = [];
    
    // Get headers or generate column names
    const headers = sheet.hasHeader ? sheet.headers : this.generateColumnNames(sheet.rows[0].cells.size);
    
    // Apply column mapping if specified
    const mappedHeaders = this.options?.columnMapping
      ? headers.map(header => this.options?.columnMapping?.[header] || header)
      : headers;
    
    // Convert each row to a record
    for (const row of rows) {
      const record: Record<string, any> = {};
      const cells = Array.from(row.cells.values());
      
      for (let i = 0; i < mappedHeaders.length; i++) {
        if (i < cells.length) {
          record[mappedHeaders[i]] = cells[i].value;
        } else {
          record[mappedHeaders[i]] = null;
        }
      }
      
      records.push(record);
    }
    
    return records;
  }
  
  /**
   * Generates column names for sheets without headers
   * 
   * @param columnCount Number of columns
   * @returns Array of column names
   */
  private generateColumnNames(columnCount: number): string[] {
    const names: string[] = [];
    
    for (let i = 0; i < columnCount; i++) {
      names.push(`Column${i + 1}`);
    }
    
    return names;
  }
  
  /**
   * Finds the index of a column by name
   * 
   * @param sheet Excel sheet
   * @param columnNames Possible column names (case-insensitive)
   * @returns Column index or -1 if not found
   */
  private findColumnIndex(sheet: Sheet, columnNames: string[]): number {
    if (!sheet.hasHeader || sheet.headers.length === 0) {
      return -1;
    }
    
    const lowerColumnNames = columnNames.map(name => name.toLowerCase());
    
    for (let i = 0; i < sheet.headers.length; i++) {
      if (lowerColumnNames.includes(sheet.headers[i].toLowerCase())) {
        return i;
      }
    }
    
    return -1;
  }
  
  /**
   * Maps cell type to field type
   * 
   * @param cellType Cell type
   * @returns Field type
   */
  private mapCellTypeToFieldType(cellType: 'string' | 'number' | 'boolean' | 'date' | 'error' | 'empty'): 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown' {
    switch (cellType) {
      case 'string':
        return 'string';
      case 'number':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'date':
        return 'date';
      case 'empty':
        return 'unknown';
      case 'error':
        return 'unknown';
      default:
        return 'unknown';
    }
  }
  
  /**
   * Ensures that the data source is initialized
   * 
   * @throws Error if the data source is not initialized
   */
  private ensureInitialized(): void {
    if (!this.workbook || !this.options) {
      throw new Error('Excel data source is not initialized');
    }
  }
}


/**
 * CsvDataSource.ts
 * 
 * Implementation of a data source for CSV files in the CSTestForge framework.
 * Uses custom CSV parsing logic without external dependencies.
 */

import { CSDataSource, CSDataSourceOptions } from './CSDataSource';
import { CSLogger } from '../../utils/CSLogger';
import { CSFileUtils } from '../../utils/CSFileUtils';

/**
 * Implementation of a data source for CSV files
 */
export class CsvDataSource implements CSDataSource {
  // Logger
  private logger: CSLogger;
  
  // File utilities
  private fileUtils: CSFileUtils;
  
  // Data
  private rows: string[][] = [];
  
  // Headers
  private headers: string[] = [];
  
  // Options
  private options: CSDataSourceOptions | null = null;
  
  // Whether the CSV has a header row
  private hasHeader: boolean = true;
  
  /**
   * Constructor
   */
  constructor() {
    this.logger = new CSLogger('CsvDataSource');
    this.fileUtils = new CSFileUtils();
  }
  
  /**
   * Initializes the data source
   * 
   * @param options Data source options
   * @returns Promise resolving when initialization is complete
   * @throws Error if the file cannot be read or parsed
   */
  public async initialize(options: CSDataSourceOptions): Promise<void> {
    this.logger.debug(`Initializing CSV data source: ${options.source}`);
    this.options = options;
    
    if (!options.source) {
      throw new Error('Source path is required for CSV data source');
    }
    
    try {
      // Read the CSV file
      const filePath = options.source.toString();
      
      if (!this.fileUtils.fileExists(filePath)) {
        throw new Error(`CSV file does not exist: ${filePath}`);
      }
      
      const fileContent = this.fileUtils.readFileAsText(filePath);
      
      // Set header option
      this.hasHeader = options.hasHeader !== false;
      
      // Parse the CSV file
      this.rows = this.parseCSV(fileContent, options.delimiter || ',');
      
      if (this.rows.length === 0) {
        this.logger.warn('CSV file is empty');
        return;
      }
      
      // Get headers
      if (this.hasHeader) {
        this.headers = [...this.rows[0]];
        
        // Apply column mapping if specified
        if (options.columnMapping) {
          for (let i = 0; i < this.headers.length; i++) {
            const header = this.headers[i];
            if (options.columnMapping[header]) {
              this.headers[i] = options.columnMapping[header];
            }
          }
        }
      } else {
        // Generate column names (Column1, Column2, etc.)
        this.headers = [];
        for (let i = 0; i < this.rows[0].length; i++) {
          this.headers.push(`Column${i + 1}`);
        }
      }
      
      this.logger.debug(`CSV data source initialized: ${this.rows.length} rows, ${this.headers.length} columns`);
    } catch (error) {
      this.logger.error(`Failed to initialize CSV data source: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to initialize CSV data source: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Retrieves all data from the source
   * 
   * @returns Promise resolving to the data
   * @throws Error if the data source is not initialized
   */
  public async getAllData(): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    // Convert rows to records
    const dataRows = this.hasHeader ? this.rows.slice(1) : this.rows;
    return this.convertRowsToRecords(dataRows);
  }
  
  /**
   * Retrieves data for a specific test
   * 
   * @param testName Name of the test
   * @returns Promise resolving to the data for the test
   * @throws Error if the data source is not initialized
   */
  public async getDataForTest(testName: string): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    // Find the "test" or "testname" column index
    const testColumnIndex = this.findColumnIndex(['test', 'testname', 'testcase', 'test_name', 'test_case']);
    
    if (testColumnIndex === -1) {
      this.logger.debug('No test column found, returning all data');
      return this.getAllData();
    }
    
    // Find rows with the matching test name
    const dataRows = this.hasHeader ? this.rows.slice(1) : this.rows;
    const filteredRows = dataRows.filter(row => {
      return row.length > testColumnIndex && 
             row[testColumnIndex] && 
             row[testColumnIndex].toLowerCase() === testName.toLowerCase();
    });
    
    return this.convertRowsToRecords(filteredRows);
  }
  
  /**
   * Retrieves data for a specific test method
   * 
   * @param testName Name of the test
   * @param methodName Name of the test method
   * @returns Promise resolving to the data for the test method
   * @throws Error if the data source is not initialized
   */
  public async getDataForTestMethod(testName: string, methodName: string): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    // Find the "test" and "method" column indices
    const testColumnIndex = this.findColumnIndex(['test', 'testname', 'testcase', 'test_name', 'test_case']);
    const methodColumnIndex = this.findColumnIndex(['method', 'methodname', 'test_method', 'method_name']);
    
    if (testColumnIndex === -1 || methodColumnIndex === -1) {
      // If either column is not found, fall back to getDataForTest
      this.logger.debug('Test or method column not found, falling back to getDataForTest');
      return this.getDataForTest(testName);
    }
    
    // Find rows with the matching test and method names
    const dataRows = this.hasHeader ? this.rows.slice(1) : this.rows;
    const filteredRows = dataRows.filter(row => {
      return row.length > Math.max(testColumnIndex, methodColumnIndex) && 
             row[testColumnIndex] && 
             row[methodColumnIndex] && 
             row[testColumnIndex].toLowerCase() === testName.toLowerCase() &&
             row[methodColumnIndex].toLowerCase() === methodName.toLowerCase();
    });
    
    return this.convertRowsToRecords(filteredRows);
  }
  
  /**
   * Retrieves filtered data based on criteria
   * 
   * @param filters Filters to apply
   * @returns Promise resolving to the filtered data
   * @throws Error if the data source is not initialized
   */
  public async getFilteredData(filters: Array<{
    field: string;
    operator: '=' | '!=' | '>' | '>=' | '<' | '<=' | 'contains' | 'startsWith' | 'endsWith' | 'matches';
    value: any;
  }>): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    // Get all records
    const records = await this.getAllData();
    
    // Apply filters
    return records.filter(record => {
      return filters.every(filter => {
        const { field, operator, value } = filter;
        const recordValue = record[field];
        
        if (recordValue === undefined) {
          return false;
        }
        
        switch (operator) {
          case '=':
            return recordValue == value;
          case '!=':
            return recordValue != value;
          case '>':
            return recordValue > value;
          case '>=':
            return recordValue >= value;
          case '<':
            return recordValue < value;
          case '<=':
            return recordValue <= value;
          case 'contains':
            return String(recordValue).includes(String(value));
          case 'startsWith':
            return String(recordValue).startsWith(String(value));
          case 'endsWith':
            return String(recordValue).endsWith(String(value));
          case 'matches':
            try {
              const regex = new RegExp(String(value));
              return regex.test(String(recordValue));
            } catch (e) {
              this.logger.error(`Invalid regex in filter: ${value}`);
              return false;
            }
          default:
            return false;
        }
      });
    });
  }
  
  /**
   * Closes the data source and releases resources
   * 
   * @returns Promise resolving when the data source is closed
   */
  public async close(): Promise<void> {
    this.logger.debug('Closing CSV data source');
    this.rows = [];
    this.headers = [];
    this.options = null;
  }
  
  /**
   * Gets information about the data source structure
   * 
   * @returns Promise resolving to information about the data source
   * @throws Error if the data source is not initialized
   */
  public async getMetadata(): Promise<{
    type: string;
    fields: Array<{
      name: string;
      type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown';
    }>;
    totalRecords: number;
    [key: string]: any;
  }> {
    this.ensureInitialized();
    
    // Get field information
    const fields: Array<{
      name: string;
      type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown';
    }> = [];
    
    // Determine field types based on the first data row
    const dataRow = this.hasHeader && this.rows.length > 1 ? this.rows[1] : this.rows[0];
    
    if (dataRow) {
      for (let i = 0; i < this.headers.length; i++) {
        const header = this.headers[i];
        const value = i < dataRow.length ? dataRow[i] : null;
        
        fields.push({
          name: header,
          type: this.determineValueType(value)
        });
      }
    } else {
      // No data rows, just use headers
      fields.push(...this.headers.map(header => ({
        name: header,
        type: 'unknown' as 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown'
      })));
    }
    
    return {
      type: 'csv',
      fields,
      totalRecords: this.hasHeader ? this.rows.length - 1 : this.rows.length,
      hasHeader: this.hasHeader,
      delimiter: this.options?.delimiter || ',',
      headers: this.headers
    };
  }
  
  /**
   * Parses CSV content
   * 
   * @param content CSV content
   * @param delimiter Field delimiter (default: comma)
   * @returns Parsed rows
   */
  private parseCSV(content: string, delimiter: string = ','): string[][] {
    const rows: string[][] = [];
    
    // Handle different line endings
    const lines = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
    
    for (const line of lines) {
      if (line.trim() === '') {
        continue;
      }
      
      const row: string[] = [];
      let inQuotes = false;
      let currentValue = '';
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
          if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
            // Double quote inside quotes - add a single quote
            currentValue += '"';
            i++;
          } else {
            // Toggle quotes
            inQuotes = !inQuotes;
          }
        } else if (char === delimiter && !inQuotes) {
          // End of field
          row.push(currentValue);
          currentValue = '';
        } else {
          // Add character to current value
          currentValue += char;
        }
      }
      
      // Add the last field
      row.push(currentValue);
      
      rows.push(row);
    }
    
    return rows;
  }
  
  /**
   * Converts rows to records
   * 
   * @param rows CSV rows
   * @returns Array of records
   */
  private convertRowsToRecords(rows: string[][]): Array<Record<string, any>> {
    const records: Array<Record<string, any>> = [];
    
    for (const row of rows) {
      const record: Record<string, any> = {};
      
      for (let i = 0; i < this.headers.length; i++) {
        const header = this.headers[i];
        const value = i < row.length ? this.convertValue(row[i]) : null;
        
        record[header] = value;
      }
      
      records.push(record);
    }
    
    return records;
  }
  
  /**
   * Converts a string value to the appropriate type
   * 
   * @param value String value
   * @returns Converted value
   */
  private convertValue(value: string): any {
    if (value === null || value === undefined || value === '') {
      return null;
    }
    
    // Check if it's a number
    if (/^-?\d+(\.\d+)?$/.test(value)) {
      return parseFloat(value);
    }
    
    // Check if it's a boolean
    if (['true', 'false'].includes(value.toLowerCase())) {
      return value.toLowerCase() === 'true';
    }
    
    // Check if it's a date
    if (this.isDateString(value)) {
      return new Date(value);
    }
    
    return value;
  }
  
  /**
   * Determines the type of a value
   * 
   * @param value Value to check
   * @returns Type of the value
   */
  private determineValueType(value: any): 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown' {
    if (value === null || value === undefined || value === '') {
      return 'unknown';
    }
    
    if (typeof value === 'string') {
      // Check if it's a number
      if (/^-?\d+(\.\d+)?$/.test(value)) {
        return 'number';
      }
      
      // Check if it's a boolean
      if (['true', 'false'].includes(value.toLowerCase())) {
        return 'boolean';
      }
      
      // Check if it's a date
      if (this.isDateString(value)) {
        return 'date';
      }
      
      // Check if it's JSON (object or array)
      try {
        const parsed = JSON.parse(value);
        if (Array.isArray(parsed)) {
          return 'array';
        }
        if (typeof parsed === 'object' && parsed !== null) {
          return 'object';
        }
      } catch (e) {
        // Not JSON
      }
      
      return 'string';
    }
    
    if (typeof value === 'number') {
      return 'number';
    }
    
    if (typeof value === 'boolean') {
      return 'boolean';
    }
    
    if (value instanceof Date) {
      return 'date';
    }
    
    if (Array.isArray(value)) {
      return 'array';
    }
    
    if (typeof value === 'object' && value !== null) {
      return 'object';
    }
    
    return 'unknown';
  }
  
  /**
   * Checks if a string is a date
   * 
   * @param value String value
   * @returns True if the string is a date
   */
  private isDateString(value: string): boolean {
    // Check common date formats
    const datePatterns = [
      /^\d{4}-\d{2}-\d{2}$/, // yyyy-MM-dd
      /^\d{1,2}\/\d{1,2}\/\d{4}$/, // MM/dd/yyyy or M/d/yyyy
      /^\d{1,2}\/\d{1,2}\/\d{2}$/, // MM/dd/yy or M/d/yy
      /^\d{1,2}-\d{1,2}-\d{4}$/, // MM-dd-yyyy or M-d-yyyy
      /^\d{1,2}-\d{1,2}-\d{2}$/, // MM-dd-yy or M-d-yy
      /^\d{4}\/\d{2}\/\d{2}$/, // yyyy/MM/dd
      /^\d{8}$/ // yyyyMMdd
    ];
    
    for (const pattern of datePatterns) {
      if (pattern.test(value)) {
        return true;
      }
    }
    
    // Try to parse the date
    const date = new Date(value);
    return !isNaN(date.getTime());
  }
  
  /**
   * Finds the index of a column by name
   * 
   * @param columnNames Possible column names (case-insensitive)
   * @returns Column index or -1 if not found
   */
  private findColumnIndex(columnNames: string[]): number {
    if (this.headers.length === 0) {
      return -1;
    }
    
    const lowerColumnNames = columnNames.map(name => name.toLowerCase());
    
    for (let i = 0; i < this.headers.length; i++) {
      if (lowerColumnNames.includes(this.headers[i].toLowerCase())) {
        return i;
      }
    }
    
    return -1;
  }
  
  /**
   * Ensures that the data source is initialized
   * 
   * @throws Error if the data source is not initialized
   */
  private ensureInitialized(): void {
    if (this.options === null) {
      throw new Error('CSV data source is not initialized');
    }
  }
}


/**
 * JsonDataSource.ts
 * 
 * Implementation of a data source for JSON files in the CSTestForge framework.
 */

import { CSDataSource, CSDataSourceOptions } from './CSDataSource';
import { CSLogger } from '../../utils/CSLogger';
import { CSFileUtils } from '../../utils/CSFileUtils';

/**
 * Implementation of a data source for JSON files
 */
export class JsonDataSource implements CSDataSource {
  // Logger
  private logger: CSLogger;
  
  // File utilities
  private fileUtils: CSFileUtils;
  
  // Data
  private data: any = null;
  
  // Cached records
  private cachedRecords: Array<Record<string, any>> | null = null;
  
  // Options
  private options: CSDataSourceOptions | null = null;
  
  /**
   * Constructor
   */
  constructor() {
    this.logger = new CSLogger('JsonDataSource');
    this.fileUtils = new CSFileUtils();
  }
  
  /**
   * Initializes the data source
   * 
   * @param options Data source options
   * @returns Promise resolving when initialization is complete
   * @throws Error if the file cannot be read or parsed
   */
  public async initialize(options: CSDataSourceOptions): Promise<void> {
    this.logger.debug(`Initializing JSON data source: ${options.source}`);
    this.options = options;
    
    if (!options.source) {
      throw new Error('Source path is required for JSON data source');
    }
    
    try {
      // Read the JSON file
      const filePath = options.source.toString();
      
      if (!this.fileUtils.fileExists(filePath)) {
        throw new Error(`JSON file does not exist: ${filePath}`);
      }
      
      // Parse the JSON file
      this.data = this.fileUtils.readJsonFile(filePath);
      
      // Reset cached records
      this.cachedRecords = null;
      
      this.logger.debug('JSON data source initialized');
    } catch (error) {
      this.logger.error(`Failed to initialize JSON data source: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to initialize JSON data source: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Retrieves all data from the source
   * 
   * @returns Promise resolving to the data
   * @throws Error if the data source is not initialized
   */
  public async getAllData(): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    // Use cached records if available
    if (this.cachedRecords !== null) {
      return this.cachedRecords;
    }
    
    // Convert the JSON data to records
    const records = this.convertJsonToRecords(this.data);
    
    // Cache the records
    this.cachedRecords = records;
    
    return records;
  }
  
  /**
   * Retrieves data for a specific test
   * 
   * @param testName Name of the test
   * @returns Promise resolving to the data for the test
   * @throws Error if the data source is not initialized
   */
  public async getDataForTest(testName: string): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    // Check if the data has a tests property
    if (this.data && typeof this.data === 'object' && !Array.isArray(this.data) && this.data.tests) {
      // If the tests property is an object with test names as keys
      if (typeof this.data.tests === 'object' && !Array.isArray(this.data.tests)) {
        const testData = this.data.tests[testName];
        
        if (testData) {
          this.logger.debug(`Found test data for: ${testName}`);
          return this.convertJsonToRecords(testData);
        }
      }
      
      // If the tests property is an array
      if (Array.isArray(this.data.tests)) {
        // Look for an object with a matching test name property
        const testData = this.data.tests.find((test: any) => {
          return test && typeof test === 'object' && 
                (test.test === testName || 
                 test.testName === testName || 
                 test.testCase === testName || 
                 test.name === testName);
        });
        
        if (testData) {
          this.logger.debug(`Found test data for: ${testName}`);
          return this.convertJsonToRecords(testData);
        }
      }
    }
    
    // Get all records and filter by test name
    const allRecords = await this.getAllData();
    
    const filteredRecords = allRecords.filter(record => {
      return (record.test === testName || 
              record.testName === testName || 
              record.testCase === testName || 
              record.name === testName);
    });
    
    if (filteredRecords.length > 0) {
      this.logger.debug(`Found ${filteredRecords.length} records for test: ${testName}`);
      return filteredRecords;
    }
    
    // If no specific test data is found, return all data
    this.logger.debug(`No specific test data found for: ${testName}, returning all data`);
    return allRecords;
  }
  
  /**
   * Retrieves data for a specific test method
   * 
   * @param testName Name of the test
   * @param methodName Name of the test method
   * @returns Promise resolving to the data for the test method
   * @throws Error if the data source is not initialized
   */
  public async getDataForTestMethod(testName: string, methodName: string): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    // Check if the data has a nested structure with test methods
    if (this.data && typeof this.data === 'object' && !Array.isArray(this.data)) {
      // Try to find test data in different structures
      
      // Structure: { tests: { testName: { methods: { methodName: data } } } }
      if (this.data.tests && 
          typeof this.data.tests === 'object' && 
          this.data.tests[testName] && 
          this.data.tests[testName].methods && 
          this.data.tests[testName].methods[methodName]) {
        
        const methodData = this.data.tests[testName].methods[methodName];
        this.logger.debug(`Found method data for: ${testName}.${methodName}`);
        return this.convertJsonToRecords(methodData);
      }
      
      // Structure: { testName: { methodName: data } }
      if (this.data[testName] && 
          typeof this.data[testName] === 'object' && 
          this.data[testName][methodName]) {
        
        const methodData = this.data[testName][methodName];
        this.logger.debug(`Found method data for: ${testName}.${methodName}`);
        return this.convertJsonToRecords(methodData);
      }
      
      // Structure: { testClass: { testName: { methods: { methodName: data } } } }
      for (const key of Object.keys(this.data)) {
        const testClass = this.data[key];
        
        if (testClass && 
            typeof testClass === 'object' && 
            testClass[testName] && 
            typeof testClass[testName] === 'object') {
          
          // Check if the methods are directly under the test name
          if (testClass[testName][methodName]) {
            const methodData = testClass[testName][methodName];
            this.logger.debug(`Found method data for: ${key}.${testName}.${methodName}`);
            return this.convertJsonToRecords(methodData);
          }
          
          // Check if the methods are in a separate methods object
          if (testClass[testName].methods && testClass[testName].methods[methodName]) {
            const methodData = testClass[testName].methods[methodName];
            this.logger.debug(`Found method data for: ${key}.${testName}.methods.${methodName}`);
            return this.convertJsonToRecords(methodData);
          }
        }
      }
    }
    
    // Get test data and filter by method name
    const testData = await this.getDataForTest(testName);
    
    const filteredRecords = testData.filter(record => {
      return (record.method === methodName || 
              record.methodName === methodName || 
              record.testMethod === methodName);
    });
    
    if (filteredRecords.length > 0) {
      this.logger.debug(`Found ${filteredRecords.length} records for method: ${methodName}`);
      return filteredRecords;
    }
    
    // If no specific method data is found, return all test data
    this.logger.debug(`No specific method data found for: ${methodName}, returning all test data`);
    return testData;
  }
  
  /**
   * Retrieves filtered data based on criteria
   * 
   * @param filters Filters to apply
   * @returns Promise resolving to the filtered data
   * @throws Error if the data source is not initialized
   */
  public async getFilteredData(filters: Array<{
    field: string;
    operator: '=' | '!=' | '>' | '>=' | '<' | '<=' | 'contains' | 'startsWith' | 'endsWith' | 'matches';
    value: any;
  }>): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    // Get all records
    const records = await this.getAllData();
    
    // Apply filters
    return records.filter(record => {
      return filters.every(filter => {
        const { field, operator, value } = filter;
        
        // Support for nested fields using dot notation
        const fieldParts = field.split('.');
        let recordValue = record;
        
        for (const part of fieldParts) {
          if (recordValue === undefined || recordValue === null) {
            return false;
          }
          
          recordValue = recordValue[part];
        }
        
        if (recordValue === undefined) {
          return false;
        }
        
        switch (operator) {
          case '=':
            return recordValue == value;
          case '!=':
            return recordValue != value;
          case '>':
            return recordValue > value;
          case '>=':
            return recordValue >= value;
          case '<':
            return recordValue < value;
          case '<=':
            return recordValue <= value;
          case 'contains':
            return String(recordValue).includes(String(value));
          case 'startsWith':
            return String(recordValue).startsWith(String(value));
          case 'endsWith':
            return String(recordValue).endsWith(String(value));
          case 'matches':
            try {
              const regex = new RegExp(String(value));
              return regex.test(String(recordValue));
            } catch (e) {
              this.logger.error(`Invalid regex in filter: ${value}`);
              return false;
            }
          default:
            return false;
        }
      });
    });
  }
  
  /**
   * Closes the data source and releases resources
   * 
   * @returns Promise resolving when the data source is closed
   */
  public async close(): Promise<void> {
    this.logger.debug('Closing JSON data source');
    this.data = null;
    this.cachedRecords = null;
    this.options = null;
  }
  
  /**
   * Gets information about the data source structure
   * 
   * @returns Promise resolving to information about the data source
   * @throws Error if the data source is not initialized
   */
  public async getMetadata(): Promise<{
    type: string;
    fields: Array<{
      name: string;
      type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown';
    }>;
    totalRecords: number;
    [key: string]: any;
  }> {
    this.ensureInitialized();
    
    // Get all records
    const records = await this.getAllData();
    
    // Get field information
    const fields: Array<{
      name: string;
      type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown';
    }> = [];
    
    // Collect all field names and types from the records
    const fieldTypes = new Map<string, Set<string>>();
    
    for (const record of records) {
      for (const [key, value] of Object.entries(record)) {
        if (!fieldTypes.has(key)) {
          fieldTypes.set(key, new Set<string>());
        }
        
        const type = this.determineValueType(value);
        fieldTypes.get(key)?.add(type);
      }
    }
    
    // Create field information
    for (const [name, types] of fieldTypes.entries()) {
      let type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown' = 'unknown';
      
      // If there's only one type, use it
      if (types.size === 1) {
        type = Array.from(types)[0] as 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown';
      } else if (types.size > 1) {
        // If there are multiple types, determine the most specific common type
        if (types.has('string')) {
          type = 'string';
        } else if (types.has('number')) {
          type = 'number';
        } else if (types.has('boolean')) {
          type = 'boolean';
        } else if (types.has('date')) {
          type = 'date';
        } else if (types.has('object')) {
          type = 'object';
        } else if (types.has('array')) {
          type = 'array';
        }
      }
      
      fields.push({ name, type });
    }
    
    // Get data structure information
    const structure = this.analyzeDataStructure(this.data);
    
    return {
      type: 'json',
      fields,
      totalRecords: records.length,
      structure
    };
  }
  
  /**
   * Converts JSON data to an array of records
   * 
   * @param jsonData JSON data
   * @returns Array of records
   */
  private convertJsonToRecords(jsonData: any): Array<Record<string, any>> {
    if (jsonData === null || jsonData === undefined) {
      return [];
    }
    
    // If the data is already an array of objects, use it directly
    if (Array.isArray(jsonData)) {
      // Check if the array contains objects
      if (jsonData.every(item => item !== null && typeof item === 'object' && !Array.isArray(item))) {
        // Apply column mapping if specified
        if (this.options?.columnMapping) {
          return jsonData.map(item => {
            const mappedItem: Record<string, any> = {};
            
            for (const [key, value] of Object.entries(item)) {
              const mappedKey = this.options?.columnMapping?.[key] || key;
              mappedItem[mappedKey] = value;
            }
            
            return mappedItem;
          });
        }
        
        return jsonData;
      }
      
      // If the array contains non-objects, convert each item to an object
      return jsonData.map((item, index) => ({ value: item, index }));
    }
    
    // If the data is an object, convert it to an array of records
    if (typeof jsonData === 'object' && jsonData !== null) {
      // Check if it's a nested structure with 'data' or 'records' property
      if (jsonData.data && Array.isArray(jsonData.data)) {
        return this.convertJsonToRecords(jsonData.data);
      }
      
      if (jsonData.records && Array.isArray(jsonData.records)) {
        return this.convertJsonToRecords(jsonData.records);
      }
      
      // Extract data from the object
      const records: Array<Record<string, any>> = [];
      
      // If it has a simple key-value structure, convert to a single record
      const hasOnlyPrimitives = Object.values(jsonData).every(value => 
        value === null || 
        typeof value !== 'object' || 
        (value instanceof Date)
      );
      
      if (hasOnlyPrimitives) {
        // Apply column mapping if specified
        if (this.options?.columnMapping) {
          const mappedItem: Record<string, any> = {};
          
          for (const [key, value] of Object.entries(jsonData)) {
            const mappedKey = this.options?.columnMapping?.[key] || key;
            mappedItem[mappedKey] = value;
          }
          
          records.push(mappedItem);
        } else {
          records.push({ ...jsonData });
        }
        
        return records;
      }
      
      // For more complex structures, try to extract records from each property
      for (const [key, value] of Object.entries(jsonData)) {
        if (Array.isArray(value)) {
          // Convert the array to records and add the key as a property
          const nestedRecords = this.convertJsonToRecords(value);
          
          for (const record of nestedRecords) {
            record._source = key;
            records.push(record);
          }
        } else if (value !== null && typeof value === 'object') {
          // Convert the object to a record and add the key as a property
          const nestedRecords = this.convertJsonToRecords(value);
          
          for (const record of nestedRecords) {
            record._source = key;
            records.push(record);
          }
        }
      }
      
      if (records.length > 0) {
        return records;
      }
      
      // If no records were extracted, convert the object to a single record
      return [{ ...jsonData }];
    }
    
    // For primitive values, return a single record
    return [{ value: jsonData }];
  }
  
  /**
   * Determines the type of a value
   * 
   * @param value Value to check
   * @returns Type of the value
   */
  private determineValueType(value: any): 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown' {
    if (value === null || value === undefined) {
      return 'unknown';
    }
    
    if (typeof value === 'string') {
      // Check if it's a date string
      if (this.isDateString(value)) {
        return 'date';
      }
      
      return 'string';
    }
    
    if (typeof value === 'number') {
      return 'number';
    }
    
    if (typeof value === 'boolean') {
      return 'boolean';
    }
    
    if (value instanceof Date) {
      return 'date';
    }
    
    if (Array.isArray(value)) {
      return 'array';
    }
    
    if (typeof value === 'object') {
      return 'object';
    }
    
    return 'unknown';
  }
  
  /**
   * Checks if a string is a date
   * 
   * @param value String value
   * @returns True if the string is a date
   */
  private isDateString(value: string): boolean {
    // Check common date formats
    const datePatterns = [
      /^\d{4}-\d{2}-\d{2}$/, // yyyy-MM-dd
      /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?(Z|[+-]\d{2}:?\d{2})?$/, // ISO 8601
      /^\d{1,2}\/\d{1,2}\/\d{4}$/, // MM/dd/yyyy or M/d/yyyy
      /^\d{1,2}\/\d{1,2}\/\d{2}$/, // MM/dd/yy or M/d/yy
      /^\d{1,2}-\d{1,2}-\d{4}$/, // MM-dd-yyyy or M-d-yyyy
      /^\d{1,2}-\d{1,2}-\d{2}$/, // MM-dd-yy or M-d-yy
      /^\d{4}\/\d{2}\/\d{2}$/, // yyyy/MM/dd
      /^\d{8}$/ // yyyyMMdd
    ];
    
    for (const pattern of datePatterns) {
      if (pattern.test(value)) {
        return true;
      }
    }
    
    // Try to parse the date
    const date = new Date(value);
    return !isNaN(date.getTime());
  }
  
  /**
   * Analyzes the structure of the JSON data
   * 
   * @param data JSON data
   * @param depth Current depth (default: 0)
   * @param maxDepth Maximum depth to analyze (default: 3)
   * @returns Analysis result
   */
  private analyzeDataStructure(data: any, depth: number = 0, maxDepth: number = 3): any {
    if (depth >= maxDepth) {
      return { type: this.determineValueType(data) };
    }
    
    if (data === null || data === undefined) {
      return { type: 'unknown' };
    }
    
    if (Array.isArray(data)) {
      if (data.length === 0) {
        return { type: 'array', items: { type: 'unknown' } };
      }
      
      // Sample the first few items to determine the structure
      const sampleSize = Math.min(data.length, 5);
      const samples = data.slice(0, sampleSize);
      
      // Check if all items have the same type
      const itemType = this.determineValueType(samples[0]);
      const allSameType = samples.every(item => this.determineValueType(item) === itemType);
      
      if (allSameType) {
        if (itemType === 'object' || itemType === 'array') {
          return {
            type: 'array',
            items: this.analyzeDataStructure(samples[0], depth + 1, maxDepth),
            length: data.length
          };
        }
        
        return { type: 'array', items: { type: itemType }, length: data.length };
      }
      
      // Mixed types
      return { type: 'array', items: { type: 'mixed' }, length: data.length };
    }
    
    if (typeof data === 'object' && data !== null) {
      const properties: Record<string, any> = {};
      
      for (const [key, value] of Object.entries(data)) {
        properties[key] = this.analyzeDataStructure(value, depth + 1, maxDepth);
      }
      
      return { type: 'object', properties };
    }
    
    return { type: this.determineValueType(data) };
  }
  
  /**
   * Ensures that the data source is initialized
   * 
   * @throws Error if the data source is not initialized
   */
  private ensureInitialized(): void {
    if (this.data === null || this.options === null) {
      throw new Error('JSON data source is not initialized');
    }
  }
}


/**
 * DatabaseDataSource.ts
 * 
 * Implementation of a data source for database connections in the CSTestForge framework.
 * Uses built-in HTTP client without external dependencies to enable REST API access to databases.
 */

import { CSDataSource, CSDataSourceOptions } from './CSDataSource';
import { CSLogger } from '../../utils/CSLogger';
import { CSFileUtils } from '../../utils/CSFileUtils';

/**
 * Database connection config
 */
interface DatabaseConfig {
  /**
   * Connection string or URL
   */
  connectionString: string;
  
  /**
   * Database type (rest, mock)
   */
  type: 'rest' | 'mock';
  
  /**
   * Authentication credentials
   */
  credentials?: {
    username?: string;
    password?: string;
    token?: string;
  };
  
  /**
   * Connection timeout in milliseconds
   */
  timeout?: number;
  
  /**
   * Default SQL query or REST endpoint
   */
  query?: string;
  
  /**
   * Base path for REST APIs
   */
  basePath?: string;
  
  /**
   * Headers for REST requests
   */
  headers?: Record<string, string>;
  
  /**
   * HTTP method for REST requests
   */
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  
  /**
   * Whether to use mock data
   */
  useMockData?: boolean;
  
  /**
   * Path to mock data file
   */
  mockDataPath?: string;
}

/**
 * Implementation of a data source for database connections
 */
export class DatabaseDataSource implements CSDataSource {
  // Logger
  private logger: CSLogger;
  
  // File utilities
  private fileUtils: CSFileUtils;
  
  // Database configuration
  private config: DatabaseConfig | null = null;
  
  // Whether the connection is open
  private isConnected: boolean = false;
  
  // Data
  private data: Array<Record<string, any>> = [];
  
  // Options
  private options: CSDataSourceOptions | null = null;
  
  /**
   * Constructor
   */
  constructor() {
    this.logger = new CSLogger('DatabaseDataSource');
    this.fileUtils = new CSFileUtils();
  }
  
  /**
   * Initializes the data source
   * 
   * @param options Data source options
   * @returns Promise resolving when initialization is complete
   * @throws Error if the connection cannot be established
   */
  public async initialize(options: CSDataSourceOptions): Promise<void> {
    this.logger.debug(`Initializing database data source: ${options.source}`);
    this.options = options;
    
    try {
      // Parse connection string or configuration
      if (!options.source) {
        throw new Error('Source is required for database data source');
      }
      
      // Initialize the database connection
      await this.connect(options);
      
      this.logger.debug('Database data source initialized');
    } catch (error) {
      this.logger.error(`Failed to initialize database data source: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to initialize database data source: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Retrieves all data from the source
   * 
   * @returns Promise resolving to the data
   * @throws Error if the data source is not initialized
   */
  public async getAllData(): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    // If data is already loaded, return it
    if (this.data.length > 0) {
      return this.data;
    }
    
    // Execute query to get all data
    try {
      const result = await this.executeQuery(this.config?.query || 'SELECT * FROM data');
      this.data = result;
      return result;
    } catch (error) {
      this.logger.error(`Failed to get all data: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to get all data: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Retrieves data for a specific test
   * 
   * @param testName Name of the test
   * @returns Promise resolving to the data for the test
   * @throws Error if the data source is not initialized
   */
  public async getDataForTest(testName: string): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    try {
      // For REST API, build the appropriate URL
      if (this.config?.type === 'rest') {
        const endpoint = `tests/${encodeURIComponent(testName)}`;
        return await this.executeRestRequest(endpoint);
      }
      
      // For mock, filter the data
      const query = `SELECT * FROM data WHERE test = '${testName}' OR testName = '${testName}' OR testCase = '${testName}'`;
      return await this.executeQuery(query);
    } catch (error) {
      this.logger.error(`Failed to get data for test ${testName}: ${error instanceof Error ? error.message : String(error)}`);
      
      // Fall back to filtering all data
      this.logger.debug(`Falling back to filtering all data for test: ${testName}`);
      const allData = await this.getAllData();
      
      return allData.filter(record => {
        return (record.test === testName || 
                record.testName === testName || 
                record.testCase === testName || 
                record.test_name === testName);
      });
    }
  }
  
  /**
   * Retrieves data for a specific test method
   * 
   * @param testName Name of the test
   * @param methodName Name of the test method
   * @returns Promise resolving to the data for the test method
   * @throws Error if the data source is not initialized
   */
  public async getDataForTestMethod(testName: string, methodName: string): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    try {
      // For REST API, build the appropriate URL
      if (this.config?.type === 'rest') {
        const endpoint = `tests/${encodeURIComponent(testName)}/methods/${encodeURIComponent(methodName)}`;
        return await this.executeRestRequest(endpoint);
      }
      
      // For mock, filter the data
      const query = `SELECT * FROM data WHERE (test = '${testName}' OR testName = '${testName}' OR testCase = '${testName}') AND (method = '${methodName}' OR methodName = '${methodName}')`;
      return await this.executeQuery(query);
    } catch (error) {
      this.logger.error(`Failed to get data for test method ${testName}.${methodName}: ${error instanceof Error ? error.message : String(error)}`);
      
      // Fall back to filtering the test data
      this.logger.debug(`Falling back to filtering test data for method: ${methodName}`);
      const testData = await this.getDataForTest(testName);
      
      return testData.filter(record => {
        return (record.method === methodName || 
                record.methodName === methodName || 
                record.test_method === methodName ||
                record.method_name === methodName);
      });
    }
  }
  
  /**
   * Retrieves filtered data based on criteria
   * 
   * @param filters Filters to apply
   * @returns Promise resolving to the filtered data
   * @throws Error if the data source is not initialized
   */
  public async getFilteredData(filters: Array<{
    field: string;
    operator: '=' | '!=' | '>' | '>=' | '<' | '<=' | 'contains' | 'startsWith' | 'endsWith' | 'matches';
    value: any;
  }>): Promise<Array<Record<string, any>>> {
    this.ensureInitialized();
    
    try {
      // For REST API, build a query string with filters
      if (this.config?.type === 'rest') {
        const queryParams = new URLSearchParams();
        
        filters.forEach((filter, index) => {
          queryParams.append(`field${index}`, filter.field);
          queryParams.append(`operator${index}`, filter.operator);
          queryParams.append(`value${index}`, String(filter.value));
        });
        
        const endpoint = `data?${queryParams.toString()}`;
        return await this.executeRestRequest(endpoint);
      }
      
      // For mock, build a SQL query with filters
      let query = 'SELECT * FROM data WHERE ';
      
      query += filters.map(filter => {
        const { field, operator, value } = filter;
        
        switch (operator) {
          case '=':
            return `${field} = '${value}'`;
          case '!=':
            return `${field} != '${value}'`;
          case '>':
            return `${field} > ${value}`;
          case '>=':
            return `${field} >= ${value}`;
          case '<':
            return `${field} < ${value}`;
          case '<=':
            return `${field} <= ${value}`;
          case 'contains':
            return `${field} LIKE '%${value}%'`;
          case 'startsWith':
            return `${field} LIKE '${value}%'`;
          case 'endsWith':
            return `${field} LIKE '%${value}'`;
          case 'matches':
            return `${field} REGEXP '${value}'`;
          default:
            return `${field} = '${value}'`;
        }
      }).join(' AND ');
      
      return await this.executeQuery(query);
    } catch (error) {
      this.logger.error(`Failed to get filtered data: ${error instanceof Error ? error.message : String(error)}`);
      
      // Fall back to filtering all data
      this.logger.debug('Falling back to filtering all data');
      const allData = await this.getAllData();
      
      return allData.filter(record => {
        return filters.every(filter => {
          const { field, operator, value } = filter;
          const recordValue = record[field];
          
          if (recordValue === undefined) {
            return false;
          }
          
          switch (operator) {
            case '=':
              return recordValue == value;
            case '!=':
              return recordValue != value;
            case '>':
              return recordValue > value;
            case '>=':
              return recordValue >= value;
            case '<':
              return recordValue < value;
            case '<=':
              return recordValue <= value;
            case 'contains':
              return String(recordValue).includes(String(value));
            case 'startsWith':
              return String(recordValue).startsWith(String(value));
            case 'endsWith':
              return String(recordValue).endsWith(String(value));
            case 'matches':
              try {
                const regex = new RegExp(String(value));
                return regex.test(String(recordValue));
              } catch (e) {
                this.logger.error(`Invalid regex in filter: ${value}`);
                return false;
              }
            default:
              return false;
          }
        });
      });
    }
  }
  
  /**
   * Closes the data source and releases resources
   * 
   * @returns Promise resolving when the data source is closed
   */
  public async close(): Promise<void> {
    this.logger.debug('Closing database data source');
    
    // Close the connection if it's open
    if (this.isConnected) {
      try {
        // Perform cleanup operations
        this.isConnected = false;
        this.data = [];
        this.config = null;
        this.options = null;
        
        this.logger.debug('Database data source closed');
      } catch (error) {
        this.logger.error(`Failed to close database data source: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }
  
  /**
   * Gets information about the data source structure
   * 
   * @returns Promise resolving to information about the data source
   * @throws Error if the data source is not initialized
   */
  public async getMetadata(): Promise<{
    type: string;
    fields: Array<{
      name: string;
      type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown';
    }>;
    totalRecords: number;
    [key: string]: any;
  }> {
    this.ensureInitialized();
    
    try {
      // For REST API, fetch metadata from the API
      if (this.config?.type === 'rest') {
        const endpoint = 'metadata';
        const metadata = await this.executeRestRequest(endpoint);
        
        if (Array.isArray(metadata) && metadata.length === 1) {
          return metadata[0];
        }
        
        // Fall back to inferring metadata from the data
        this.logger.debug('Metadata endpoint did not return expected structure, inferring from data');
      }
      
      // Get all data (if not already loaded)
      const allData = await this.getAllData();
      
      // Infer fields from the data
      const fields: Array<{
        name: string;
        type: 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown';
      }> = [];
      
      if (allData.length > 0) {
        const sampleRecord = allData[0];
        
        for (const [key, value] of Object.entries(sampleRecord)) {
          fields.push({
            name: key,
            type: this.inferType(value)
          });
        }
      }
      
      return {
        type: 'database',
        fields,
        totalRecords: allData.length,
        connectionType: this.config?.type || 'unknown',
        connectionString: this.config?.connectionString || 'unknown'
      };
    } catch (error) {
      this.logger.error(`Failed to get metadata: ${error instanceof Error ? error.message : String(error)}`);
      
      // Return minimal metadata
      return {
        type: 'database',
        fields: [],
        totalRecords: 0,
        connectionType: this.config?.type || 'unknown',
        connectionString: this.config?.connectionString || 'unknown',
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  
  /**
   * Connects to the database
   * 
   * @param options Data source options
   * @returns Promise resolving when the connection is established
   * @throws Error if the connection cannot be established
   */
  private async connect(options: CSDataSourceOptions): Promise<void> {
    this.logger.debug('Connecting to database');
    
    try {
      // Parse the connection information
      if (typeof options.source === 'string') {
        // Connection string
        this.config = this.parseConnectionString(options.source);
      } else if (typeof options.source === 'object') {
        // Configuration object
        this.config = options.source as DatabaseConfig;
      } else {
        throw new Error('Invalid source for database data source');
      }
      
      // Apply additional options
      if (options.username) {
        this.config.credentials = this.config.credentials || {};
        this.config.credentials.username = options.username;
      }
      
      if (options.password) {
        this.config.credentials = this.config.credentials || {};
        this.config.credentials.password = options.password;
      }
      
      if (options.timeout) {
        this.config.timeout = options.timeout;
      }
      
      // Check for mock data
      if (this.config.useMockData || options.useMockData) {
        this.logger.debug('Using mock data for database connection');
        this.config.type = 'mock';
        
        const mockDataPath = this.config.mockDataPath || options.mockDataPath;
        
        if (mockDataPath) {
          this.logger.debug(`Loading mock data from ${mockDataPath}`);
          const mockData = this.loadMockData(mockDataPath);
          this.data = mockData;
        } else {
          this.logger.debug('No mock data path provided, using empty dataset');
          this.data = [];
        }
        
        this.isConnected = true;
        return;
      }
      
      // Validate connection config
      if (!this.config.connectionString) {
        throw new Error('Connection string is required for database data source');
      }
      
      if (this.config.type === 'rest') {
        // For REST API, try to fetch a minimal amount of data to validate the connection
        const endpoint = 'ping';
        await this.executeRestRequest(endpoint, true);
      } else {
        throw new Error(`Unsupported database type: ${this.config.type}`);
      }
      
      this.isConnected = true;
      this.logger.debug('Database connection established');
    } catch (error) {
      this.logger.error(`Failed to connect to database: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to connect to database: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Parses a connection string
   * 
   * @param connectionString Connection string
   * @returns Database configuration
   */
  private parseConnectionString(connectionString: string): DatabaseConfig {
    this.logger.debug('Parsing connection string');
    
    // Check if it's a URL
    try {
      const url = new URL(connectionString);
      
      // Determine database type based on protocol
      let type: 'rest' | 'mock' = 'rest';
      
      if (url.protocol === 'mock:') {
        type = 'mock';
      }
      
      // Extract credentials from the URL
      const credentials: { username?: string; password?: string; token?: string } = {};
      
      if (url.username) {
        credentials.username = url.username;
      }
      
      if (url.password) {
        credentials.password = url.password;
      }
      
      // Extract token from query parameters
      const token = url.searchParams.get('token');
      if (token) {
        credentials.token = token;
      }
      
      // Build the configuration
      const config: DatabaseConfig = {
        connectionString,
        type,
        credentials: Object.keys(credentials).length > 0 ? credentials : undefined,
        basePath: url.pathname.length > 1 ? url.pathname : undefined,
        headers: {}
      };
      
      // Extract additional options from query parameters
      const timeout = url.searchParams.get('timeout');
      if (timeout) {
        config.timeout = parseInt(timeout, 10);
      }
      
      const method = url.searchParams.get('method') as 'GET' | 'POST' | 'PUT' | 'DELETE';
      if (method && ['GET', 'POST', 'PUT', 'DELETE'].includes(method)) {
        config.method = method;
      }
      
      const useMockData = url.searchParams.get('useMockData');
      if (useMockData) {
        config.useMockData = useMockData === 'true';
      }
      
      const mockDataPath = url.searchParams.get('mockDataPath');
      if (mockDataPath) {
        config.mockDataPath = mockDataPath;
      }
      
      const query = url.searchParams.get('query');
      if (query) {
        config.query = query;
      }
      
      // Extract header parameters
      url.searchParams.forEach((value, key) => {
        if (key.startsWith('header.')) {
          const headerName = key.substring(7);
          config.headers![headerName] = value;
        }
      });
      
      return config;
    } catch (error) {
      // If it's not a valid URL, parse it as a traditional connection string
      this.logger.debug('Not a valid URL, parsing as traditional connection string');
      
      // Check for mock: prefix
      if (connectionString.startsWith('mock:')) {
        return {
          connectionString,
          type: 'mock',
          useMockData: true,
          mockDataPath: connectionString.substring(5)
        };
      }
      
      // Check for rest: prefix
      if (connectionString.startsWith('rest:')) {
        return {
          connectionString: connectionString.substring(5),
          type: 'rest',
          method: 'GET',
          headers: {}
        };
      }
      
      // Default to REST
      return {
        connectionString,
        type: 'rest',
        method: 'GET',
        headers: {}
      };
    }
  }
  
  /**
   * Loads mock data from a file
   * 
   * @param mockDataPath Path to the mock data file
   * @returns Mock data
   */
  private loadMockData(mockDataPath: string): Array<Record<string, any>> {
    this.logger.debug(`Loading mock data from ${mockDataPath}`);
    
    try {
      if (!this.fileUtils.fileExists(mockDataPath)) {
        this.logger.warn(`Mock data file does not exist: ${mockDataPath}`);
        return [];
      }
      
      const fileContent = this.fileUtils.readFileAsText(mockDataPath);
      
      // Try to parse as JSON
      try {
        const jsonData = JSON.parse(fileContent);
        
        if (Array.isArray(jsonData)) {
          return jsonData;
        }
        
        if (typeof jsonData === 'object' && jsonData !== null) {
          // If it's an object with a data property that's an array, use that
          if (Array.isArray(jsonData.data)) {
            return jsonData.data;
          }
          
          // If it's a plain object, wrap it in an array
          return [jsonData];
        }
        
        this.logger.warn('Mock data is not in a valid format, expected array or object');
        return [];
      } catch (e) {
        // If it's not valid JSON, try to parse as CSV
        this.logger.debug('Not valid JSON, trying to parse as CSV');
        return this.parseCSV(fileContent);
      }
    } catch (error) {
      this.logger.error(`Failed to load mock data: ${error instanceof Error ? error.message : String(error)}`);
      return [];
    }
  }
  
  /**
   * Parses CSV content
   * 
   * @param content CSV content
   * @returns Parsed records
   */
  private parseCSV(content: string): Array<Record<string, any>> {
    this.logger.debug('Parsing CSV content');
    
    try {
      // Handle different line endings
      const lines = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
      
      if (lines.length === 0) {
        return [];
      }
      
      // Parse the header row
      const headerRow = this.parseCSVRow(lines[0]);
      
      // Parse data rows
      const records: Array<Record<string, any>> = [];
      
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        
        if (line.trim() === '') {
          continue;
        }
        
        const dataRow = this.parseCSVRow(line);
        const record: Record<string, any> = {};
        
        for (let j = 0; j < headerRow.length; j++) {
          const header = headerRow[j];
          
          if (j < dataRow.length) {
            record[header] = this.convertValue(dataRow[j]);
          } else {
            record[header] = null;
          }
        }
        
        records.push(record);
      }
      
      return records;
    } catch (error) {
      this.logger.error(`Failed to parse CSV: ${error instanceof Error ? error.message : String(error)}`);
      return [];
    }
  }
  
  /**
   * Parses a CSV row
   * 
   * @param line CSV row
   * @returns Parsed values
   */
  private parseCSVRow(line: string): string[] {
    const values: string[] = [];
    let inQuotes = false;
    let currentValue = '';
    const delimiter = this.options?.delimiter || ',';
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      
      if (char === '"') {
        if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
          // Double quote inside quotes - add a single quote
          currentValue += '"';
          i++;
        } else {
          // Toggle quotes
          inQuotes = !inQuotes;
        }
      } else if (char === delimiter && !inQuotes) {
        // End of field
        values.push(currentValue);
        currentValue = '';
      } else {
        // Add character to current value
        currentValue += char;
      }
    }
    
    // Add the last field
    values.push(currentValue);
    
    return values;
  }
  
  /**
   * Converts a string value to the appropriate type
   * 
   * @param value String value
   * @returns Converted value
   */
  private convertValue(value: string): any {
    // Empty string
    if (value === '') {
      return null;
    }
    
    // Boolean
    if (value.toLowerCase() === 'true') {
      return true;
    }
    
    if (value.toLowerCase() === 'false') {
      return false;
    }
    
    // Number
    if (/^-?\d+(\.\d+)?$/.test(value)) {
      return parseFloat(value);
    }
    
    // Date
    if (this.isDateString(value)) {
      return new Date(value);
    }
    
    // String
    return value;
  }
  
  /**
   * Checks if a string is a date
   * 
   * @param value String value
   * @returns True if the string is a date
   */
  private isDateString(value: string): boolean {
    // Check common date formats
    const datePatterns = [
      /^\d{4}-\d{2}-\d{2}$/, // yyyy-MM-dd
      /^\d{1,2}\/\d{1,2}\/\d{4}$/, // MM/dd/yyyy or M/d/yyyy
      /^\d{1,2}\/\d{1,2}\/\d{2}$/, // MM/dd/yy or M/d/yy
      /^\d{1,2}-\d{1,2}-\d{4}$/, // MM-dd-yyyy or M-d-yyyy
      /^\d{1,2}-\d{1,2}-\d{2}$/, // MM-dd-yy or M-d-yy
      /^\d{4}\/\d{2}\/\d{2}$/, // yyyy/MM/dd
      /^\d{8}$/ // yyyyMMdd
    ];
    
    for (const pattern of datePatterns) {
      if (pattern.test(value)) {
        return true;
      }
    }
    
    // Try to parse the date
    const date = new Date(value);
    return !isNaN(date.getTime());
  }
  
  /**
   * Executes a SQL query
   * 
   * @param query SQL query
   * @returns Promise resolving to the query results
   * @throws Error if the query cannot be executed
   */
  private async executeQuery(query: string): Promise<Array<Record<string, any>>> {
    this.logger.debug(`Executing query: ${query}`);
    
    // In a real implementation, this would execute the query against a database
    // For now, we'll just implement mock behavior
    
    // If using mock data, filter the data based on the query
    if (this.config?.type === 'mock' || this.config?.useMockData) {
      this.logger.debug('Executing query against mock data');
      
      // If we don't have any data yet, load default mock data
      if (this.data.length === 0 && this.config?.mockDataPath) {
        this.data = this.loadMockData(this.config.mockDataPath);
      }
      
      // Basic SQL parsing to support WHERE clauses
      if (query.toUpperCase().includes('WHERE')) {
        const wherePart = query.substring(query.toUpperCase().indexOf('WHERE') + 5).trim();
        return this.filterDataByWhereClause(wherePart);
      }
      
      // If no filtering is required, return all data
      return [...this.data];
    }
    
    // For other database types, we'd execute the actual query
    // For now, just return an empty array
    return [];
  }
  
  /**
   * Executes a REST request
   * 
   * @param endpoint REST endpoint
   * @param isPing Whether this is a ping request
   * @returns Promise resolving to the response data
   * @throws Error if the request fails
   */
  private async executeRestRequest(endpoint: string, isPing: boolean = false): Promise<Array<Record<string, any>>> {
    if (!this.config) {
      throw new Error('Database configuration is not initialized');
    }
    
    this.logger.debug(`Executing REST request: ${endpoint}`);
    
    // Build the URL
    let url = this.config.connectionString;
    
    // Add base path if provided
    if (this.config.basePath) {
      url = this.normalizeUrl(url, this.config.basePath);
    }
    
    // Add the endpoint
    url = this.normalizeUrl(url, endpoint);
    
    // Build headers
    const headers: Record<string, string> = {
      ...this.config.headers
    };
    
    // Add authentication headers
    if (this.config.credentials) {
      if (this.config.credentials.token) {
        headers['Authorization'] = `Bearer ${this.config.credentials.token}`;
      } else if (this.config.credentials.username && this.config.credentials.password) {
        const base64Credentials = Buffer.from(`${this.config.credentials.username}:${this.config.credentials.password}`).toString('base64');
        headers['Authorization'] = `Basic ${base64Credentials}`;
      }
    }
    
    // Use built-in fetch API (for browser environments)
    // In a Node.js environment, we'd use the http/https modules
    try {
      // In a real implementation, this would use the fetch API or the Node.js http/https modules
      // For now, we'll just return mock data
      
      // If this is a ping request, just return empty data
      if (isPing) {
        return [];
      }
      
      // If we have mock data configured, use that
      if (this.config.mockDataPath) {
        this.logger.debug(`Using mock data from ${this.config.mockDataPath}`);
        return this.loadMockData(this.config.mockDataPath);
      }
      
      // Otherwise, return empty data
      return [];
    } catch (error) {
      this.logger.error(`REST request failed: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`REST request failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Normalizes a URL
   * 
   * @param baseUrl Base URL
   * @param path Path to append
   * @returns Normalized URL
   */
  private normalizeUrl(baseUrl: string, path: string): string {
    if (!path) {
      return baseUrl;
    }
    
    const hasTrailingSlash = baseUrl.endsWith('/');
    const hasLeadingSlash = path.startsWith('/');
    
    if (hasTrailingSlash && hasLeadingSlash) {
      return baseUrl + path.substring(1);
    } else if (!hasTrailingSlash && !hasLeadingSlash) {
      return baseUrl + '/' + path;
    } else {
      return baseUrl + path;
    }
  }
  
  /**
   * Filters data by a SQL WHERE clause
   * 
   * @param whereClause SQL WHERE clause
   * @returns Filtered data
   */
  private filterDataByWhereClause(whereClause: string): Array<Record<string, any>> {
    this.logger.debug(`Filtering data by WHERE clause: ${whereClause}`);
    
    // This is a very simplified SQL WHERE clause parser
    // In a real implementation, this would be much more robust
    
    // Handle simple equality conditions
    const conditions: { field: string; operator: string; value: string }[] = [];
    
    // Split by AND
    const parts = whereClause.split(/\s+AND\s+/i);
    
    for (const part of parts) {
      // Match field, operator, and value
      const match = part.match(/([a-zA-Z0-9_]+)\s*(=|!=|<>|>|>=|<|<=|LIKE|REGEXP)\s*'?([^']*)'?/i);
      
      if (match) {
        const [, field, operator, value] = match;
        conditions.push({ field, operator: operator.toUpperCase(), value });
      }
    }
    
    // Apply the conditions
    return this.data.filter(record => {
      return conditions.every(condition => {
        const { field, operator, value } = condition;
        const recordValue = record[field];
        
        if (recordValue === undefined) {
          return false;
        }
        
        switch (operator) {
          case '=':
            return String(recordValue).toLowerCase() === value.toLowerCase();
          case '!=':
          case '<>':
            return String(recordValue).toLowerCase() !== value.toLowerCase();
          case '>':
            return recordValue > value;
          case '>=':
            return recordValue >= value;
          case '<':
            return recordValue < value;
          case '<=':
            return recordValue <= value;
          case 'LIKE':
            // Handle % wildcards
            const pattern = value.replace(/%/g, '.*');
            const regex = new RegExp(`^${pattern}$`, 'i');
            return regex.test(String(recordValue));
          case 'REGEXP':
            try {
              const regex = new RegExp(value, 'i');
              return regex.test(String(recordValue));
            } catch (e) {
              this.logger.error(`Invalid regex in WHERE clause: ${value}`);
              return false;
            }
          default:
            return false;
        }
      });
    });
  }
  
  /**
   * Infers the type of a value
   * 
   * @param value Value to check
   * @returns Inferred type
   */
  private inferType(value: any): 'string' | 'number' | 'boolean' | 'date' | 'object' | 'array' | 'unknown' {
    if (value === null || value === undefined) {
      return 'unknown';
    }
    
    if (typeof value === 'string') {
      return 'string';
    }
    
    if (typeof value === 'number') {
      return 'number';
    }
    
    if (typeof value === 'boolean') {
      return 'boolean';
    }
    
    if (value instanceof Date) {
      return 'date';
    }
    
    if (Array.isArray(value)) {
      return 'array';
    }
    
    if (typeof value === 'object') {
      return 'object';
    }
    
    return 'unknown';
  }
  
  /**
   * Ensures that the data source is initialized
   * 
   * @throws Error if the data source is not initialized
   */
  private ensureInitialized(): void {
    if (!this.isConnected || !this.config || !this.options) {
      throw new Error('Database data source is not initialized');
    }
  }
}


/**
 * CSDataProvider.ts
 * 
 * TypeScript decorator for data-driven testing in the CSTestForge framework.
 * Provides data injection into test methods from various data sources.
 */

import { CSDataProviderOptions, CSDataProviderProcessor } from './CSDataProviderProcessor';

/**
 * Decorator factory for providing data to test methods
 * 
 * @param options Data provider options
 * @returns Method decorator function
 */
export function CSDataProvider(options: CSDataProviderOptions): MethodDecorator {
  return function(
    target: Object,
    propertyKey: string | symbol,
    descriptor: PropertyDescriptor
  ): PropertyDescriptor {
    // Get the original method
    const originalMethod = descriptor.value;
    
    if (typeof originalMethod !== 'function') {
      throw new Error('CSDataProvider can only be applied to methods');
    }
    
    // Register the data provider
    const processor = CSDataProviderProcessor.getInstance();
    processor.registerDataProvider(target, propertyKey, options);
    
    // Replace the method with the data-driven version
    descriptor.value = async function(...args: any[]) {
      // Get the test data from the processor
      const testData = await processor.getDataForMethod(target, propertyKey);
      
      // If no data is returned, execute the method once with the original arguments
      if (!testData || testData.length === 0) {
        return originalMethod.apply(this, args);
      }
      
      // Track the results for each data set
      const results: any[] = [];
      const errors: Error[] = [];
      let hasErrors = false;
      
      // Execute the method for each data set
      for (let i = 0; i < testData.length; i++) {
        const dataItem = testData[i];
        
        // Handle array and object data items
        const dataArgs = Array.isArray(dataItem) ? dataItem : [dataItem];
        
        try {
          // Execute the test method with the data
          const result = await originalMethod.apply(this, [...dataArgs, ...args]);
          results.push(result);
        } catch (error) {
          // Track errors
          hasErrors = true;
          if (error instanceof Error) {
            errors.push(new Error(`Error with data set #${i + 1}: ${error.message}`));
          } else {
            errors.push(new Error(`Error with data set #${i + 1}: ${String(error)}`));
          }
        }
      }
      
      // If parallel execution is not enabled, throw the first error
      if (!options.parallel && hasErrors) {
        throw errors[0];
      }
      
      // If parallel execution is enabled, summarize the results
      if (options.parallel && hasErrors) {
        const summary = `${errors.length} of ${testData.length} test executions failed:\n` +
          errors.map(error => `  - ${error.message}`).join('\n');
        throw new Error(summary);
      }
      
      // Return the results
      return results;
    };
    
    return descriptor;
  };
}

/**
 * Decorator factory for providing Excel data to test methods
 * 
 * @param source Path to the Excel file
 * @param options Additional options
 * @returns Method decorator function
 */
export function CSExcelDataProvider(
  source: string,
  options?: Omit<CSDataProviderOptions, 'source' | 'type'>
): MethodDecorator {
  return CSDataProvider({
    source,
    type: 'excel',
    ...options
  });
}

/**
 * Decorator factory for providing CSV data to test methods
 * 
 * @param source Path to the CSV file
 * @param options Additional options
 * @returns Method decorator function
 */
export function CSCsvDataProvider(
  source: string,
  options?: Omit<CSDataProviderOptions, 'source' | 'type'>
): MethodDecorator {
  return CSDataProvider({
    source,
    type: 'csv',
    ...options
  });
}

/**
 * Decorator factory for providing JSON data to test methods
 * 
 * @param source Path to the JSON file
 * @param options Additional options
 * @returns Method decorator function
 */
export function CSJsonDataProvider(
  source: string,
  options?: Omit<CSDataProviderOptions, 'source' | 'type'>
): MethodDecorator {
  return CSDataProvider({
    source,
    type: 'json',
    ...options
  });
}

/**
 * Decorator factory for providing database data to test methods
 * 
 * @param source Connection string or configuration
 * @param options Additional options
 * @returns Method decorator function
 */
export function CSDatabaseDataProvider(
  source: string,
  options?: Omit<CSDataProviderOptions, 'source' | 'type'>
): MethodDecorator {
  return CSDataProvider({
    source,
    type: 'database',
    ...options
  });
}

/**
 * Decorator factory for providing inline data to test methods
 * 
 * @param data Inline test data
 * @returns Method decorator function
 */
export function CSInlineDataProvider(data: Array<any>): MethodDecorator {
  // Create a temporary JSON data source with the inline data
  const jsonData = JSON.stringify(data);
  const encoder = new TextEncoder();
  const bytes = encoder.encode(jsonData);
  const blob = new Blob([bytes], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  
  return CSDataProvider({
    source: url,
    type: 'json'
  });
}

/**
 * Decorator for clearing the data provider cache before executing a test method
 * 
 * @returns Method decorator function
 */
export function CSClearDataProviderCache(): MethodDecorator {
  return function(
    target: Object,
    propertyKey: string | symbol,
    descriptor: PropertyDescriptor
  ): PropertyDescriptor {
    // Get the original method
    const originalMethod = descriptor.value;
    
    if (typeof originalMethod !== 'function') {
      throw new Error('CSClearDataProviderCache can only be applied to methods');
    }
    
    // Replace the method with a version that clears the cache first
    descriptor.value = async function(...args: any[]) {
      // Clear the cache for this method
      const processor = CSDataProviderProcessor.getInstance();
      processor.clearCache(target, propertyKey);
      
      // Execute the original method
      return originalMethod.apply(this, args);
    };
    
    return descriptor;
  };
}



/**
 * CSFindDataParameters.ts
 * 
 * Utility for finding and extracting parameter information from test methods
 * to support data-driven testing in the CSTestForge framework.
 */

import { CSLogger } from '../utils/CSLogger';
import { CSFileUtils } from '../utils/CSFileUtils';

/**
 * Parameter information
 */
export interface ParameterInfo {
  /**
   * Parameter name
   */
  name: string;
  
  /**
   * Parameter index
   */
  index: number;
  
  /**
   * Parameter type
   */
  type: string;
  
  /**
   * Whether the parameter has a default value
   */
  hasDefault: boolean;
  
  /**
   * Default value (if available)
   */
  defaultValue?: any;
  
  /**
   * Parameter decorators (if available)
   */
  decorators?: string[];
}

/**
 * Method information
 */
export interface MethodInfo {
  /**
   * Method name
   */
  name: string;
  
  /**
   * Full method signature
   */
  signature: string;
  
  /**
   * Method parameters
   */
  parameters: ParameterInfo[];
  
  /**
   * Method return type
   */
  returnType: string;
  
  /**
   * Method decorators
   */
  decorators: string[];
  
  /**
   * Whether the method is async
   */
  isAsync: boolean;
}

/**
 * Class for finding and extracting parameter information from test methods
 */
export class CSFindDataParameters {
  // Logger
  private logger: CSLogger;
  
  // File utils
  private fileUtils: CSFileUtils;
  
  // Cache for method information
  private methodCache: Map<string, MethodInfo> = new Map();
  
  /**
   * Constructor
   */
  constructor() {
    this.logger = new CSLogger('CSFindDataParameters');
    this.fileUtils = new CSFileUtils();
  }
  
  /**
   * Gets parameter information for a method
   * 
   * @param target Class containing the method
   * @param methodName Method name
   * @returns Method information
   */
  public getMethodParameters(target: any, methodName: string): ParameterInfo[] {
    // Try to get from cache first
    const cacheKey = this.getCacheKey(target, methodName);
    const cachedInfo = this.methodCache.get(cacheKey);
    
    if (cachedInfo) {
      return cachedInfo.parameters;
    }
    
    // Get method information
    const methodInfo = this.extractMethodInfo(target, methodName);
    
    // Cache the method information
    this.methodCache.set(cacheKey, methodInfo);
    
    return methodInfo.parameters;
  }
  
  /**
   * Gets method information
   * 
   * @param target Class containing the method
   * @param methodName Method name
   * @returns Method information
   */
  public getMethodInfo(target: any, methodName: string): MethodInfo {
    // Try to get from cache first
    const cacheKey = this.getCacheKey(target, methodName);
    const cachedInfo = this.methodCache.get(cacheKey);
    
    if (cachedInfo) {
      return cachedInfo;
    }
    
    // Get method information
    const methodInfo = this.extractMethodInfo(target, methodName);
    
    // Cache the method information
    this.methodCache.set(cacheKey, methodInfo);
    
    return methodInfo;
  }
  
  /**
   * Clears the method information cache
   */
  public clearCache(): void {
    this.methodCache.clear();
  }
  
  /**
   * Gets method information for all methods in a class
   * 
   * @param target Class
   * @returns Map of method name to method information
   */
  public getMethodInfoForClass(target: any): Map<string, MethodInfo> {
    const result = new Map<string, MethodInfo>();
    
    // Get all method names from the prototype
    const methodNames = this.getMethodNames(target);
    
    for (const methodName of methodNames) {
      const methodInfo = this.getMethodInfo(target, methodName);
      result.set(methodName, methodInfo);
    }
    
    return result;
  }
  
  /**
   * Extracts method information
   * 
   * @param target Class containing the method
   * @param methodName Method name
   * @returns Method information
   */
  private extractMethodInfo(target: any, methodName: string): MethodInfo {
    // Check if the method exists
    if (typeof target.prototype[methodName] !== 'function') {
      this.logger.error(`Method ${methodName} not found in class ${target.name}`);
      
      return {
        name: methodName,
        signature: '',
        parameters: [],
        returnType: 'any',
        decorators: [],
        isAsync: false
      };
    }
    
    // Get the method
    const method = target.prototype[methodName];
    
    // Try to get parameter information using reflection metadata
    const paramTypes = Reflect.getMetadata?.('design:paramtypes', target.prototype, methodName);
    
    // Get the method source
    const methodSource = this.getMethodSource(method);
    
    // Parse the method signature
    const { parameters, returnType, decorators, isAsync, signature } = this.parseMethodSignature(methodSource, methodName);
    
    // If we have parameter types from reflection, use them
    if (Array.isArray(paramTypes)) {
      for (let i = 0; i < Math.min(parameters.length, paramTypes.length); i++) {
        const paramType = paramTypes[i];
        
        if (paramType) {
          parameters[i].type = this.getTypeName(paramType);
        }
      }
    }
    
    return {
      name: methodName,
      signature,
      parameters,
      returnType,
      decorators,
      isAsync
    };
  }
  
  /**
   * Gets the method source code
   * 
   * @param method Method to get source for
   * @returns Source code
   */
  private getMethodSource(method: Function): string {
    const source = method.toString();
    
    // Handle arrow functions, method shorthand, and regular functions
    if (source.startsWith('(') || source.startsWith('async (')) {
      // Arrow function or method shorthand
      return source;
    } else if (source.startsWith('function') || source.startsWith('async function')) {
      // Regular function
      return source;
    } else {
      // Method definition in a class
      return `function ${source}`;
    }
  }
  
  /**
   * Parses a method signature
   * 
   * @param methodSource Method source code
   * @param methodName Method name (for logging)
   * @returns Parsed signature information
   */
  private parseMethodSignature(methodSource: string, methodName: string): {
    parameters: ParameterInfo[];
    returnType: string;
    decorators: string[];
    isAsync: boolean;
    signature: string;
  } {
    try {
      const parameters: ParameterInfo[] = [];
      let returnType = 'any';
      const decorators: string[] = [];
      
      // Check if the method is async
      const isAsync = methodSource.startsWith('async ');
      
      // Extract the signature
      const signatureRegex = /(?:function\s*)?(?:async\s*)?(?:\w+\s*)?\(([^)]*)\)(?:\s*:\s*([^{]+))?/;
      const signatureMatch = methodSource.match(signatureRegex);
      
      let signature = '';
      
      if (signatureMatch) {
        const paramString = signatureMatch[1] || '';
        signature = `${methodName}(${paramString})`;
        
        // Extract the return type
        if (signatureMatch[2]) {
          returnType = signatureMatch[2].trim();
          signature += `: ${returnType}`;
        }
        
        // Parse parameters
        const params = this.parseParameters(paramString);
        parameters.push(...params);
      }
      
      // Extract decorators (simplified approach)
      const decoratorRegex = /@(\w+)(?:\([^)]*\))?/g;
      let decoratorMatch;
      
      while ((decoratorMatch = decoratorRegex.exec(methodSource)) !== null) {
        decorators.push(decoratorMatch[1]);
      }
      
      return {
        parameters,
        returnType,
        decorators,
        isAsync,
        signature
      };
    } catch (error) {
      this.logger.error(`Error parsing method signature for ${methodName}: ${error instanceof Error ? error.message : String(error)}`);
      
      return {
        parameters: [],
        returnType: 'any',
        decorators: [],
        isAsync: false,
        signature: `${methodName}()`
      };
    }
  }
  
  /**
   * Parses parameter string
   * 
   * @param paramString Parameter string
   * @returns Array of parameter information
   */
  private parseParameters(paramString: string): ParameterInfo[] {
    if (!paramString.trim()) {
      return [];
    }
    
    const parameters: ParameterInfo[] = [];
    const paramRegex = /(?:@(\w+)(?:\([^)]*\))?\s*)*([^\s:,=]+)(?:\s*:\s*([^\s,=]+))?(?:\s*=\s*([^,]+))?/g;
    let paramMatch;
    let index = 0;
    
    // Hack to properly reset the regex between calls
    const resetRegex = new RegExp(paramRegex.source, paramRegex.flags);
    
    paramString = paramString.trim();
    
    // Handle rest parameters
    const restParamMatch = paramString.match(/\.\.\.(\w+)(?:\s*:\s*([^\s,=]+))?/);
    if (restParamMatch) {
      const name = restParamMatch[1];
      const type = restParamMatch[2] || 'any[]';
      
      parameters.push({
        name,
        type,
        index: 0,
        hasDefault: false,
        decorators: ['rest']
      });
      
      return parameters;
    }
    
    // Split by commas, but respect nested structures
    const params = this.splitParamString(paramString);
    
    for (const param of params) {
      // Extract parameter decorators
      const paramDecorators: string[] = [];
      const decoratorMatches = param.match(/@(\w+)(?:\([^)]*\))?/g);
      
      if (decoratorMatches) {
        for (const decoratorMatch of decoratorMatches) {
          const decoratorName = decoratorMatch.match(/@(\w+)/)?.[1];
          if (decoratorName) {
            paramDecorators.push(decoratorName);
          }
        }
      }
      
      // Extract parameter name and type
      const simpleParamRegex = /([^\s:,=]+)(?:\s*:\s*([^\s,=]+))?(?:\s*=\s*(.+))?$/;
      const simpleParamMatch = param.match(simpleParamRegex);
      
      if (simpleParamMatch) {
        const name = simpleParamMatch[1];
        const type = simpleParamMatch[2] || 'any';
        const defaultValue = simpleParamMatch[3];
        
        parameters.push({
          name,
          index,
          type,
          hasDefault: defaultValue !== undefined,
          defaultValue,
          decorators: paramDecorators
        });
        
        index++;
      }
    }
    
    return parameters;
  }
  
  /**
   * Splits parameter string respecting nested structures
   * 
   * @param paramString Parameter string
   * @returns Array of parameter strings
   */
  private splitParamString(paramString: string): string[] {
    const params: string[] = [];
    let currentParam = '';
    let depth = 0;
    
    for (let i = 0; i < paramString.length; i++) {
      const char = paramString[i];
      
      if (char === ',' && depth === 0) {
        params.push(currentParam.trim());
        currentParam = '';
      } else {
        currentParam += char;
        
        if (char === '(' || char === '{' || char === '[') {
          depth++;
        } else if (char === ')' || char === '}' || char === ']') {
          depth--;
        }
      }
    }
    
    if (currentParam.trim()) {
      params.push(currentParam.trim());
    }
    
    return params;
  }
  
  /**
   * Gets a cache key for a method
   * 
   * @param target Class containing the method
   * @param methodName Method name
   * @returns Cache key
   */
  private getCacheKey(target: any, methodName: string): string {
    return `${target.name || 'anonymous'}.${methodName}`;
  }
  
  /**
   * Gets all method names from a class
   * 
   * @param target Class
   * @returns Array of method names
   */
  private getMethodNames(target: any): string[] {
    const prototype = target.prototype;
    const methodNames: string[] = [];
    
    // Get own property names from the prototype
    const propNames = Object.getOwnPropertyNames(prototype);
    
    for (const propName of propNames) {
      // Skip constructor and non-methods
      if (propName === 'constructor' || typeof prototype[propName] !== 'function') {
        continue;
      }
      
      methodNames.push(propName);
    }
    
    return methodNames;
  }
  
  /**
   * Gets the name of a type
   * 
   * @param type Type
   * @returns Type name
   */
  private getTypeName(type: any): string {
    if (type === String) return 'string';
    if (type === Number) return 'number';
    if (type === Boolean) return 'boolean';
    if (type === Object) return 'object';
    if (type === Array) return 'any[]';
    if (type === Function) return 'Function';
    if (type === Date) return 'Date';
    if (type === RegExp) return 'RegExp';
    
    return type?.name || 'any';
  }
}


/**
 * CSReporter.ts
 * 
 * Core reporting interface for the CSTestForge framework.
 * Defines the contract for reporting implementations to track and report test execution results.
 */

import { CSTestResult } from './CSTestResult';
import { CSTestStep } from './CSTestStep';
import { CSLogger } from '../utils/CSLogger';
import { CSFileUtils } from '../utils/CSFileUtils';
import { CSScreenshotManager } from '../utils/CSScreenshotManager';

/**
 * Test status enumeration
 */
export enum CSTestStatus {
  PASSED = 'PASSED',
  FAILED = 'FAILED',
  SKIPPED = 'SKIPPED',
  WARNING = 'WARNING',
  INFO = 'INFO',
  BLOCKED = 'BLOCKED',
  IN_PROGRESS = 'IN_PROGRESS',
  NOT_EXECUTED = 'NOT_EXECUTED'
}

/**
 * Log level enumeration
 */
export enum CSLogLevel {
  TRACE = 'TRACE',
  DEBUG = 'DEBUG',
  INFO = 'INFO',
  WARNING = 'WARNING',
  ERROR = 'ERROR',
  FATAL = 'FATAL'
}

/**
 * Screenshot options
 */
export interface CSScreenshotOptions {
  /**
   * Whether to include the full page
   */
  fullPage?: boolean;
  
  /**
   * Screenshot width (for responsiveness testing)
   */
  width?: number;
  
  /**
   * Screenshot height (for responsiveness testing)
   */
  height?: number;
  
  /**
   * Custom filename
   */
  filename?: string;
  
  /**
   * Encoding (e.g., 'base64', 'binary')
   */
  encoding?: 'base64' | 'binary';
  
  /**
   * Quality (0-100, for JPEG)
   */
  quality?: number;
  
  /**
   * Whether to highlight elements
   */
  highlight?: boolean;
  
  /**
   * Elements to highlight
   */
  elementsToHighlight?: string[];
}

/**
 * Video recording options
 */
export interface CSVideoOptions {
  /**
   * Frame rate
   */
  frameRate?: number;
  
  /**
   * Video width
   */
  width?: number;
  
  /**
   * Video height
   */
  height?: number;
  
  /**
   * File format (e.g., 'webm', 'mp4')
   */
  format?: 'webm' | 'mp4';
  
  /**
   * Video quality (0-100)
   */
  quality?: number;
  
  /**
   * Custom filename
   */
  filename?: string;
}

/**
 * Attachment options
 */
export interface CSAttachmentOptions {
  /**
   * Content type
   */
  contentType?: string;
  
  /**
   * Custom filename
   */
  filename?: string;
  
  /**
   * Description
   */
  description?: string;
}

/**
 * Class implementing the core reporting functionality
 */
export class CSReporter {
  // Logger
  private logger: CSLogger;
  
  // File utils
  private fileUtils: CSFileUtils;
  
  // Screenshot manager
  private screenshotManager: CSScreenshotManager;
  
  // Current test run ID
  private testRunId: string;
  
  // Current test suite
  private testSuite: string | null = null;
  
  // Current test case
  private testCase: string | null = null;
  
  // Current test result
  private currentTestResult: CSTestResult | null = null;
  
  // All test results
  private testResults: CSTestResult[] = [];
  
  // Test start time
  private testStartTime: number = 0;
  
  // Output directory
  private outputDir: string;
  
  // Whether screenshots are enabled
  private screenshotsEnabled: boolean = true;
  
  // Whether video recording is enabled
  private videoRecordingEnabled: boolean = false;
  
  // Whether real-time reporting is enabled
  private realTimeReportingEnabled: boolean = false;
  
  // Report update callback for real-time reporting
  private reportUpdateCallback: ((result: CSTestResult) => void) | null = null;
  
  // Whether to automatically take screenshots on failures
  private autoScreenshotOnFailure: boolean = true;
  
  // Maximum number of screenshots per test
  private maxScreenshotsPerTest: number = 20;
  
  // Current screenshot count
  private screenshotCount: number = 0;
  
  // Video recorder
  private videoRecorder: any = null;
  
  /**
   * Constructor
   * 
   * @param options Reporter options
   */
  constructor(options?: {
    outputDir?: string;
    screenshotsEnabled?: boolean;
    videoRecordingEnabled?: boolean;
    realTimeReportingEnabled?: boolean;
    reportUpdateCallback?: (result: CSTestResult) => void;
    autoScreenshotOnFailure?: boolean;
    maxScreenshotsPerTest?: number;
  }) {
    this.testRunId = this.generateTestRunId();
    this.outputDir = options?.outputDir || `./reports/${this.testRunId}`;
    this.screenshotsEnabled = options?.screenshotsEnabled !== false;
    this.videoRecordingEnabled = options?.videoRecordingEnabled === true;
    this.realTimeReportingEnabled = options?.realTimeReportingEnabled === true;
    this.reportUpdateCallback = options?.reportUpdateCallback || null;
    this.autoScreenshotOnFailure = options?.autoScreenshotOnFailure !== false;
    this.maxScreenshotsPerTest = options?.maxScreenshotsPerTest || 20;
    
    this.logger = new CSLogger('CSReporter');
    this.fileUtils = new CSFileUtils();
    this.screenshotManager = new CSScreenshotManager();
    
    // Create output directory
    this.createOutputDirectory();
  }
  
  /**
   * Sets the test suite name
   * 
   * @param suiteName Test suite name
   */
  public setTestSuite(suiteName: string): void {
    this.testSuite = suiteName;
    this.logger.debug(`Set test suite: ${suiteName}`);
  }
  
  /**
   * Starts a test case
   * 
   * @param testName Test case name
   * @param description Test case description
   * @param tags Test case tags
   * @returns Test result object
   */
  public startTest(testName: string, description?: string, tags?: string[]): CSTestResult {
    // Check if a test is already in progress
    if (this.currentTestResult) {
      this.logger.warning(`Test ${this.currentTestResult.name} is already in progress. Ending it before starting ${testName}.`);
      this.endTest(CSTestStatus.WARNING, 'Test ended prematurely');
    }
    
    this.testCase = testName;
    this.testStartTime = Date.now();
    this.screenshotCount = 0;
    
    this.logger.info(`Starting test: ${testName}`);
    
    // Create test result
    this.currentTestResult = new CSTestResult({
      name: testName,
      suite: this.testSuite || 'Default Suite',
      description: description || '',
      tags: tags || [],
      startTime: new Date(),
      status: CSTestStatus.IN_PROGRESS,
      steps: [],
      logs: [],
      screenshots: [],
      videos: [],
      attachments: []
    });
    
    // Start video recording if enabled
    if (this.videoRecordingEnabled) {
      this.startVideoRecording();
    }
    
    // Notify listeners
    this.notifyReportUpdate();
    
    return this.currentTestResult;
  }
  
  /**
   * Ends a test case
   * 
   * @param status Test status
   * @param message Status message
   * @returns Test result object
   */
  public endTest(status: CSTestStatus, message?: string): CSTestResult | null {
    if (!this.currentTestResult) {
      this.logger.warning('No test is currently in progress');
      return null;
    }
    
    const testName = this.currentTestResult.name;
    const duration = Date.now() - this.testStartTime;
    
    this.logger.info(`Ending test: ${testName} with status: ${status}`);
    
    // Take screenshot on failure if enabled
    if (status === CSTestStatus.FAILED && this.autoScreenshotOnFailure && this.screenshotsEnabled) {
      this.takeScreenshot({ filename: `${testName}_failure` });
    }
    
    // Stop video recording if enabled
    if (this.videoRecordingEnabled) {
      this.stopVideoRecording();
    }
    
    // Update test result
    this.currentTestResult.status = status;
    this.currentTestResult.message = message || '';
    this.currentTestResult.endTime = new Date();
    this.currentTestResult.duration = duration;
    
    // Add to test results
    this.testResults.push(this.currentTestResult);
    
    // Save test result
    this.saveTestResult(this.currentTestResult);
    
    // Notify listeners
    this.notifyReportUpdate();
    
    const result = this.currentTestResult;
    this.currentTestResult = null;
    this.testCase = null;
    
    return result;
  }
  
  /**
   * Adds a test step
   * 
   * @param name Step name
   * @param status Step status
   * @param description Step description
   * @param screenshot Whether to take a screenshot
   * @returns Test step object
   */
  public addStep(
    name: string,
    status: CSTestStatus = CSTestStatus.PASSED,
    description?: string,
    screenshot: boolean = false
  ): CSTestStep | null {
    if (!this.currentTestResult) {
      this.logger.warning('No test is currently in progress');
      return null;
    }
    
    this.logger.debug(`Adding step: ${name}`);
    
    // Create test step
    const step = new CSTestStep({
      name,
      status,
      description: description || '',
      startTime: new Date(),
      endTime: new Date(),
      duration: 0,
      screenshots: []
    });
    
    // Take screenshot if requested
    if (screenshot && this.screenshotsEnabled) {
      const screenshotPath = this.takeScreenshot({
        filename: `${this.currentTestResult.name}_step_${this.currentTestResult.steps.length + 1}`
      });
      
      if (screenshotPath) {
        step.screenshots.push(screenshotPath);
      }
    }
    
    // Add to test result
    this.currentTestResult.steps.push(step);
    
    // Notify listeners
    this.notifyReportUpdate();
    
    return step;
  }
  
  /**
   * Adds a log entry
   * 
   * @param level Log level
   * @param message Log message
   * @param details Additional details
   */
  public log(level: CSLogLevel, message: string, details?: any): void {
    if (!this.currentTestResult) {
      this.logger.warning('No test is currently in progress');
      return;
    }
    
    this.logger.log(level.toString(), message);
    
    // Add to test result
    this.currentTestResult.logs.push({
      level,
      message,
      details: details || null,
      timestamp: new Date()
    });
    
    // Notify listeners
    this.notifyReportUpdate();
  }
  
  /**
   * Takes a screenshot
   * 
   * @param options Screenshot options
   * @returns Screenshot path
   */
  public takeScreenshot(options?: CSScreenshotOptions): string | null {
    if (!this.currentTestResult) {
      this.logger.warning('No test is currently in progress');
      return null;
    }
    
    if (!this.screenshotsEnabled) {
      this.logger.debug('Screenshots are disabled');
      return null;
    }
    
    if (this.screenshotCount >= this.maxScreenshotsPerTest) {
      this.logger.warning(`Maximum number of screenshots reached for test: ${this.currentTestResult.name}`);
      return null;
    }
    
    this.screenshotCount++;
    
    const filename = options?.filename || `${this.currentTestResult.name}_${Date.now()}`;
    const screenshotDir = `${this.outputDir}/screenshots`;
    
    try {
      // Ensure directory exists
      this.fileUtils.createDirectory(screenshotDir);
      
      // Take screenshot
      const screenshotPath = this.screenshotManager.takeScreenshot({
        path: `${screenshotDir}/${filename}.png`,
        fullPage: options?.fullPage,
        width: options?.width,
        height: options?.height,
        highlight: options?.highlight,
        elementsToHighlight: options?.elementsToHighlight
      });
      
      // Add to test result
      if (screenshotPath && this.currentTestResult) {
        this.currentTestResult.screenshots.push({
          path: screenshotPath,
          timestamp: new Date(),
          description: options?.filename || ''
        });
        
        // Notify listeners
        this.notifyReportUpdate();
      }
      
      return screenshotPath;
    } catch (error) {
      this.logger.error(`Failed to take screenshot: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Adds an attachment to the current test
   * 
   * @param content Attachment content
   * @param options Attachment options
   * @returns Attachment path
   */
  public addAttachment(content: string | Buffer, options?: CSAttachmentOptions): string | null {
    if (!this.currentTestResult) {
      this.logger.warning('No test is currently in progress');
      return null;
    }
    
    const filename = options?.filename || `attachment_${Date.now()}`;
    const attachmentDir = `${this.outputDir}/attachments`;
    
    try {
      // Ensure directory exists
      this.fileUtils.createDirectory(attachmentDir);
      
      // Save attachment
      const attachmentPath = `${attachmentDir}/${filename}`;
      
      if (typeof content === 'string') {
        this.fileUtils.writeTextFile(attachmentPath, content);
      } else {
        this.fileUtils.writeBinaryFile(attachmentPath, content);
      }
      
      // Add to test result
      this.currentTestResult.attachments.push({
        path: attachmentPath,
        contentType: options?.contentType || 'application/octet-stream',
        description: options?.description || '',
        timestamp: new Date()
      });
      
      // Notify listeners
      this.notifyReportUpdate();
      
      return attachmentPath;
    } catch (error) {
      this.logger.error(`Failed to add attachment: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Starts video recording
   * 
   * @param options Video options
   */
  private startVideoRecording(options?: CSVideoOptions): void {
    // This is a placeholder for the actual video recording implementation
    // In a real-world scenario, this would interface with a browser's video recording API
    // or a native video recording library
    
    this.logger.debug('Starting video recording');
    
    // For now, we'll just simulate video recording by creating a stub recorder object
    this.videoRecorder = {
      start: () => {
        this.logger.debug('Video recording started');
      },
      stop: () => {
        this.logger.debug('Video recording stopped');
        return `${this.outputDir}/videos/${this.currentTestResult?.name || 'unknown'}_${Date.now()}.webm`;
      }
    };
    
    // Start recording
    this.videoRecorder.start();
  }
  
  /**
   * Stops video recording
   * 
   * @returns Video path
   */
  private stopVideoRecording(): string | null {
    if (!this.videoRecorder) {
      this.logger.warning('No video recording in progress');
      return null;
    }
    
    this.logger.debug('Stopping video recording');
    
    try {
      // Ensure directory exists
      this.fileUtils.createDirectory(`${this.outputDir}/videos`);
      
      // Stop recording
      const videoPath = this.videoRecorder.stop();
      
      // Add to test result
      if (videoPath && this.currentTestResult) {
        this.currentTestResult.videos.push({
          path: videoPath,
          timestamp: new Date(),
          description: 'Test recording'
        });
      }
      
      this.videoRecorder = null;
      
      return videoPath;
    } catch (error) {
      this.logger.error(`Failed to stop video recording: ${error instanceof Error ? error.message : String(error)}`);
      this.videoRecorder = null;
      return null;
    }
  }
  
  /**
   * Notifies listeners of report updates
   */
  private notifyReportUpdate(): void {
    if (this.realTimeReportingEnabled && this.reportUpdateCallback && this.currentTestResult) {
      try {
        this.reportUpdateCallback(this.currentTestResult);
      } catch (error) {
        this.logger.error(`Failed to notify report update: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }
  
  /**
   * Saves a test result to disk
   * 
   * @param result Test result
   */
  private saveTestResult(result: CSTestResult): void {
    const resultsDir = `${this.outputDir}/results`;
    
    try {
      // Ensure directory exists
      this.fileUtils.createDirectory(resultsDir);
      
      // Save test result
      const resultPath = `${resultsDir}/${result.name}_${Date.now()}.json`;
      this.fileUtils.writeJsonFile(resultPath, result.toJSON());
      
      this.logger.debug(`Test result saved to: ${resultPath}`);
    } catch (error) {
      this.logger.error(`Failed to save test result: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Creates the output directory
   */
  private createOutputDirectory(): void {
    try {
      this.fileUtils.createDirectory(this.outputDir);
      this.fileUtils.createDirectory(`${this.outputDir}/screenshots`);
      this.fileUtils.createDirectory(`${this.outputDir}/videos`);
      this.fileUtils.createDirectory(`${this.outputDir}/attachments`);
      this.fileUtils.createDirectory(`${this.outputDir}/results`);
      
      this.logger.debug(`Output directory created: ${this.outputDir}`);
    } catch (error) {
      this.logger.error(`Failed to create output directory: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Generates a unique test run ID
   * 
   * @returns Test run ID
   */
  private generateTestRunId(): string {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const random = Math.random().toString(36).substring(2, 8);
    return `test_run_${timestamp}_${random}`;
  }
  
  /**
   * Gets all test results
   * 
   * @returns Array of test results
   */
  public getTestResults(): CSTestResult[] {
    return [...this.testResults];
  }
  
  /**
   * Gets the current test result
   * 
   * @returns Current test result
   */
  public getCurrentTestResult(): CSTestResult | null {
    return this.currentTestResult;
  }
  
  /**
   * Gets the test run ID
   * 
   * @returns Test run ID
   */
  public getTestRunId(): string {
    return this.testRunId;
  }
  
  /**
   * Gets the output directory
   * 
   * @returns Output directory
   */
  public getOutputDirectory(): string {
    return this.outputDir;
  }
  
  /**
   * Sets whether screenshots are enabled
   * 
   * @param enabled Whether screenshots are enabled
   */
  public setScreenshotsEnabled(enabled: boolean): void {
    this.screenshotsEnabled = enabled;
  }
  
  /**
   * Sets whether video recording is enabled
   * 
   * @param enabled Whether video recording is enabled
   */
  public setVideoRecordingEnabled(enabled: boolean): void {
    this.videoRecordingEnabled = enabled;
  }
  
  /**
   * Sets whether real-time reporting is enabled
   * 
   * @param enabled Whether real-time reporting is enabled
   */
  public setRealTimeReportingEnabled(enabled: boolean): void {
    this.realTimeReportingEnabled = enabled;
  }
  
  /**
   * Sets the report update callback
   * 
   * @param callback Report update callback
   */
  public setReportUpdateCallback(callback: (result: CSTestResult) => void): void {
    this.reportUpdateCallback = callback;
  }
  
  /**
   * Sets whether to automatically take screenshots on failures
   * 
   * @param enabled Whether to automatically take screenshots on failures
   */
  public setAutoScreenshotOnFailure(enabled: boolean): void {
    this.autoScreenshotOnFailure = enabled;
  }
  
  /**
   * Sets the maximum number of screenshots per test
   * 
   * @param max Maximum number of screenshots per test
   */
  public setMaxScreenshotsPerTest(max: number): void {
    this.maxScreenshotsPerTest = max;
  }
}


/**
 * CSTestResult.ts
 * 
 * Model for test execution results in the CSTestForge framework.
 * Represents the outcome of a test case execution with all associated data.
 */

import { CSTestStatus, CSLogLevel } from './CSReporter';
import { CSTestStep } from './CSTestStep';

/**
 * Log entry interface
 */
export interface CSLogEntry {
  /**
   * Log level
   */
  level: CSLogLevel;
  
  /**
   * Log message
   */
  message: string;
  
  /**
   * Additional details
   */
  details: any;
  
  /**
   * Timestamp
   */
  timestamp: Date;
}

/**
 * Screenshot interface
 */
export interface CSScreenshot {
  /**
   * Screenshot file path
   */
  path: string;
  
  /**
   * Timestamp
   */
  timestamp: Date;
  
  /**
   * Description
   */
  description: string;
}

/**
 * Video interface
 */
export interface CSVideo {
  /**
   * Video file path
   */
  path: string;
  
  /**
   * Timestamp
   */
  timestamp: Date;
  
  /**
   * Description
   */
  description: string;
}

/**
 * Attachment interface
 */
export interface CSAttachment {
  /**
   * Attachment file path
   */
  path: string;
  
  /**
   * Content type
   */
  contentType: string;
  
  /**
   * Description
   */
  description: string;
  
  /**
   * Timestamp
   */
  timestamp: Date;
}

/**
 * Test metrics interface
 */
export interface CSTestMetrics {
  /**
   * Load time (milliseconds)
   */
  loadTime?: number;
  
  /**
   * Response time (milliseconds)
   */
  responseTime?: number;
  
  /**
   * CPU usage (percentage)
   */
  cpuUsage?: number;
  
  /**
   * Memory usage (MB)
   */
  memoryUsage?: number;
  
  /**
   * Network requests count
   */
  networkRequestsCount?: number;
  
  /**
   * Total bytes transferred
   */
  bytesTransferred?: number;
  
  /**
   * Custom metrics
   */
  customMetrics?: Record<string, number>;
}

/**
 * Test environment interface
 */
export interface CSTestEnvironment {
  /**
   * Browser name
   */
  browser?: string;
  
  /**
   * Browser version
   */
  browserVersion?: string;
  
  /**
   * Operating system
   */
  os?: string;
  
  /**
   * OS version
   */
  osVersion?: string;
  
  /**
   * Device
   */
  device?: string;
  
  /**
   * Viewport width
   */
  viewportWidth?: number;
  
  /**
   * Viewport height
   */
  viewportHeight?: number;
  
  /**
   * Framework
   */
  framework?: string;
  
  /**
   * Framework version
   */
  frameworkVersion?: string;
  
  /**
   * Custom environment properties
   */
  custom?: Record<string, string>;
}

/**
 * Test failure interface
 */
export interface CSTestFailure {
  /**
   * Error message
   */
  message: string;
  
  /**
   * Error type
   */
  type?: string;
  
  /**
   * Error stack trace
   */
  stackTrace?: string;
  
  /**
   * Expected value
   */
  expected?: any;
  
  /**
   * Actual value
   */
  actual?: any;
  
  /**
   * Step index where failure occurred
   */
  stepIndex?: number;
  
  /**
   * Associated screenshot
   */
  screenshot?: string;
}

/**
 * Test result initialization options
 */
export interface CSTestResultOptions {
  /**
   * Test name
   */
  name: string;
  
  /**
   * Test suite name
   */
  suite: string;
  
  /**
   * Test description
   */
  description?: string;
  
  /**
   * Test tags
   */
  tags?: string[];
  
  /**
   * Test start time
   */
  startTime: Date;
  
  /**
   * Test end time
   */
  endTime?: Date;
  
  /**
   * Test duration in milliseconds
   */
  duration?: number;
  
  /**
   * Test status
   */
  status: CSTestStatus;
  
  /**
   * Status message
   */
  message?: string;
  
  /**
   * Test steps
   */
  steps?: CSTestStep[];
  
  /**
   * Test logs
   */
  logs?: CSLogEntry[];
  
  /**
   * Test screenshots
   */
  screenshots?: CSScreenshot[];
  
  /**
   * Test videos
   */
  videos?: CSVideo[];
  
  /**
   * Test attachments
   */
  attachments?: CSAttachment[];
  
  /**
   * Test metrics
   */
  metrics?: CSTestMetrics;
  
  /**
   * Test environment
   */
  environment?: CSTestEnvironment;
  
  /**
   * Test failure
   */
  failure?: CSTestFailure;
  
  /**
   * Retry count
   */
  retryCount?: number;
  
  /**
   * Custom data
   */
  customData?: Record<string, any>;
}

/**
 * Model for test execution results
 */
export class CSTestResult {
  /**
   * Test name
   */
  public name: string;
  
  /**
   * Test suite name
   */
  public suite: string;
  
  /**
   * Test description
   */
  public description: string;
  
  /**
   * Test tags
   */
  public tags: string[];
  
  /**
   * Test start time
   */
  public startTime: Date;
  
  /**
   * Test end time
   */
  public endTime: Date | null;
  
  /**
   * Test duration in milliseconds
   */
  public duration: number;
  
  /**
   * Test status
   */
  public status: CSTestStatus;
  
  /**
   * Status message
   */
  public message: string;
  
  /**
   * Test steps
   */
  public steps: CSTestStep[];
  
  /**
   * Test logs
   */
  public logs: CSLogEntry[];
  
  /**
   * Test screenshots
   */
  public screenshots: CSScreenshot[];
  
  /**
   * Test videos
   */
  public videos: CSVideo[];
  
  /**
   * Test attachments
   */
  public attachments: CSAttachment[];
  
  /**
   * Test metrics
   */
  public metrics: CSTestMetrics;
  
  /**
   * Test environment
   */
  public environment: CSTestEnvironment;
  
  /**
   * Test failure
   */
  public failure: CSTestFailure | null;
  
  /**
   * Retry count
   */
  public retryCount: number;
  
  /**
   * Custom data
   */
  public customData: Record<string, any>;
  
  /**
   * Constructor
   * 
   * @param options Test result options
   */
  constructor(options: CSTestResultOptions) {
    this.name = options.name;
    this.suite = options.suite;
    this.description = options.description || '';
    this.tags = options.tags || [];
    this.startTime = options.startTime;
    this.endTime = options.endTime || null;
    this.duration = options.duration || 0;
    this.status = options.status;
    this.message = options.message || '';
    this.steps = options.steps || [];
    this.logs = options.logs || [];
    this.screenshots = options.screenshots || [];
    this.videos = options.videos || [];
    this.attachments = options.attachments || [];
    this.metrics = options.metrics || {};
    this.environment = options.environment || {};
    this.failure = options.failure || null;
    this.retryCount = options.retryCount || 0;
    this.customData = options.customData || {};
  }
  
  /**
   * Gets the number of passed steps
   * 
   * @returns Number of passed steps
   */
  public getPassedStepsCount(): number {
    return this.steps.filter(step => step.status === CSTestStatus.PASSED).length;
  }
  
  /**
   * Gets the number of failed steps
   * 
   * @returns Number of failed steps
   */
  public getFailedStepsCount(): number {
    return this.steps.filter(step => step.status === CSTestStatus.FAILED).length;
  }
  
  /**
   * Gets the number of skipped steps
   * 
   * @returns Number of skipped steps
   */
  public getSkippedStepsCount(): number {
    return this.steps.filter(step => step.status === CSTestStatus.SKIPPED).length;
  }
  
  /**
   * Gets the number of warning steps
   * 
   * @returns Number of warning steps
   */
  public getWarningStepsCount(): number {
    return this.steps.filter(step => step.status === CSTestStatus.WARNING).length;
  }
  
  /**
   * Gets the pass rate (percentage of passed steps)
   * 
   * @returns Pass rate (0-100)
   */
  public getPassRate(): number {
    if (this.steps.length === 0) {
      return 100;
    }
    
    return (this.getPassedStepsCount() / this.steps.length) * 100;
  }
  
  /**
   * Gets the total number of screenshots
   * 
   * @returns Number of screenshots
   */
  public getScreenshotsCount(): number {
    return this.screenshots.length;
  }
  
  /**
   * Gets the total number of videos
   * 
   * @returns Number of videos
   */
  public getVideosCount(): number {
    return this.videos.length;
  }
  
  /**
   * Gets the total number of attachments
   * 
   * @returns Number of attachments
   */
  public getAttachmentsCount(): number {
    return this.attachments.length;
  }
  
  /**
   * Gets the total number of logs
   * 
   * @returns Number of logs
   */
  public getLogsCount(): number {
    return this.logs.length;
  }
  
  /**
   * Gets the total number of error logs
   * 
   * @returns Number of error logs
   */
  public getErrorLogsCount(): number {
    return this.logs.filter(log => log.level === CSLogLevel.ERROR || log.level === CSLogLevel.FATAL).length;
  }
  
  /**
   * Gets the total number of warning logs
   * 
   * @returns Number of warning logs
   */
  public getWarningLogsCount(): number {
    return this.logs.filter(log => log.level === CSLogLevel.WARNING).length;
  }
  
  /**
   * Gets the summary of the test result
   * 
   * @returns Test result summary
   */
  public getSummary(): {
    name: string;
    suite: string;
    status: CSTestStatus;
    duration: number;
    passRate: number;
    stepsCount: number;
    passedSteps: number;
    failedSteps: number;
    skippedSteps: number;
    screenshotsCount: number;
    startTime: Date;
    endTime: Date | null;
  } {
    return {
      name: this.name,
      suite: this.suite,
      status: this.status,
      duration: this.duration,
      passRate: this.getPassRate(),
      stepsCount: this.steps.length,
      passedSteps: this.getPassedStepsCount(),
      failedSteps: this.getFailedStepsCount(),
      skippedSteps: this.getSkippedStepsCount(),
      screenshotsCount: this.screenshots.length,
      startTime: this.startTime,
      endTime: this.endTime
    };
  }
  
  /**
   * Sets a metric value
   * 
   * @param name Metric name
   * @param value Metric value
   */
  public setMetric(name: string, value: number): void {
    if (!this.metrics.customMetrics) {
      this.metrics.customMetrics = {};
    }
    
    this.metrics.customMetrics[name] = value;
  }
  
  /**
   * Gets a metric value
   * 
   * @param name Metric name
   * @returns Metric value or undefined if not found
   */
  public getMetric(name: string): number | undefined {
    if (name === 'loadTime') return this.metrics.loadTime;
    if (name === 'responseTime') return this.metrics.responseTime;
    if (name === 'cpuUsage') return this.metrics.cpuUsage;
    if (name === 'memoryUsage') return this.metrics.memoryUsage;
    if (name === 'networkRequestsCount') return this.metrics.networkRequestsCount;
    if (name === 'bytesTransferred') return this.metrics.bytesTransferred;
    
    return this.metrics.customMetrics?.[name];
  }
  
  /**
   * Sets an environment property
   * 
   * @param name Property name
   * @param value Property value
   */
  public setEnvironmentProperty(name: string, value: string): void {
    if (!this.environment.custom) {
      this.environment.custom = {};
    }
    
    this.environment.custom[name] = value;
  }
  
  /**
   * Gets an environment property
   * 
   * @param name Property name
   * @returns Property value or undefined if not found
   */
  public getEnvironmentProperty(name: string): string | undefined {
    if (name === 'browser') return this.environment.browser;
    if (name === 'browserVersion') return this.environment.browserVersion;
    if (name === 'os') return this.environment.os;
    if (name === 'osVersion') return this.environment.osVersion;
    if (name === 'device') return this.environment.device;
    if (name === 'framework') return this.environment.framework;
    if (name === 'frameworkVersion') return this.environment.frameworkVersion;
    
    return this.environment.custom?.[name];
  }
  
  /**
   * Sets custom data
   * 
   * @param key Data key
   * @param value Data value
   */
  public setCustomData(key: string, value: any): void {
    this.customData[key] = value;
  }
  
  /**
   * Gets custom data
   * 
   * @param key Data key
   * @returns Data value or undefined if not found
   */
  public getCustomData(key: string): any {
    return this.customData[key];
  }
  
  /**
   * Gets all failures (from steps and test)
   * 
   * @returns Array of failures
   */
  public getAllFailures(): (CSTestFailure | {
    message: string;
    stepName: string;
    stepIndex: number;
  })[] {
    const failures: (CSTestFailure | {
      message: string;
      stepName: string;
      stepIndex: number;
    })[] = [];
    
    // Add test failure
    if (this.failure) {
      failures.push(this.failure);
    }
    
    // Add step failures
    this.steps.forEach((step, index) => {
      if (step.status === CSTestStatus.FAILED) {
        failures.push({
          message: step.description || `Step ${index + 1} failed`,
          stepName: step.name,
          stepIndex: index
        });
      }
    });
    
    return failures;
  }
  
  /**
   * Converts the test result to a plain object
   * 
   * @returns Plain object representation
   */
  public toJSON(): Record<string, any> {
    return {
      name: this.name,
      suite: this.suite,
      description: this.description,
      tags: this.tags,
      startTime: this.startTime.toISOString(),
      endTime: this.endTime ? this.endTime.toISOString() : null,
      duration: this.duration,
      status: this.status,
      message: this.message,
      steps: this.steps.map(step => step.toJSON()),
      logs: this.logs.map(log => ({
        ...log,
        timestamp: log.timestamp.toISOString()
      })),
      screenshots: this.screenshots.map(screenshot => ({
        ...screenshot,
        timestamp: screenshot.timestamp.toISOString()
      })),
      videos: this.videos.map(video => ({
        ...video,
        timestamp: video.timestamp.toISOString()
      })),
      attachments: this.attachments.map(attachment => ({
        ...attachment,
        timestamp: attachment.timestamp.toISOString()
      })),
      metrics: this.metrics,
      environment: this.environment,
      failure: this.failure,
      retryCount: this.retryCount,
      customData: this.customData,
      summary: this.getSummary()
    };
  }
  
  /**
   * Checks if the test result has steps
   * 
   * @returns True if the test result has steps
   */
  public hasSteps(): boolean {
    return this.steps.length > 0;
  }
  
  /**
   * Checks if the test result has logs
   * 
   * @returns True if the test result has logs
   */
  public hasLogs(): boolean {
    return this.logs.length > 0;
  }
  
  /**
   * Checks if the test result has error logs
   * 
   * @returns True if the test result has error logs
   */
  public hasErrorLogs(): boolean {
    return this.getErrorLogsCount() > 0;
  }
  
  /**
   * Checks if the test result has screenshots
   * 
   * @returns True if the test result has screenshots
   */
  public hasScreenshots(): boolean {
    return this.screenshots.length > 0;
  }
  
  /**
   * Checks if the test result has videos
   * 
   * @returns True if the test result has videos
   */
  public hasVideos(): boolean {
    return this.videos.length > 0;
  }
  
  /**
   * Checks if the test result has attachments
   * 
   * @returns True if the test result has attachments
   */
  public hasAttachments(): boolean {
    return this.attachments.length > 0;
  }
  
  /**
   * Checks if the test result has failures
   * 
   * @returns True if the test result has failures
   */
  public hasFailures(): boolean {
    return this.status === CSTestStatus.FAILED || 
           this.failure !== null || 
           this.getFailedStepsCount() > 0;
  }
  
  /**
   * Creates a test result from a JSON object
   * 
   * @param json JSON object
   * @returns Test result
   */
  public static fromJSON(json: Record<string, any>): CSTestResult {
    return new CSTestResult({
      name: json.name,
      suite: json.suite,
      description: json.description,
      tags: json.tags,
      startTime: new Date(json.startTime),
      endTime: json.endTime ? new Date(json.endTime) : undefined,
      duration: json.duration,
      status: json.status as CSTestStatus,
      message: json.message,
      steps: json.steps ? json.steps.map((stepJson: any) => CSTestStep.fromJSON(stepJson)) : [],
      logs: json.logs ? json.logs.map((logJson: any) => ({
        ...logJson,
        timestamp: new Date(logJson.timestamp)
      })) : [],
      screenshots: json.screenshots ? json.screenshots.map((ssJson: any) => ({
        ...ssJson,
        timestamp: new Date(ssJson.timestamp)
      })) : [],
      videos: json.videos ? json.videos.map((videoJson: any) => ({
        ...videoJson,
        timestamp: new Date(videoJson.timestamp)
      })) : [],
      attachments: json.attachments ? json.attachments.map((attachJson: any) => ({
        ...attachJson,
        timestamp: new Date(attachJson.timestamp)
      })) : [],
      metrics: json.metrics,
      environment: json.environment,
      failure: json.failure,
      retryCount: json.retryCount,
      customData: json.customData
    });
  }
}


/**
 * CSTestStep.ts
 * 
 * Model for test execution steps in the CSTestForge framework.
 * Represents individual actions or verifications within a test case.
 */

import { CSTestStatus } from './CSReporter';

/**
 * Test step initialization options
 */
export interface CSTestStepOptions {
  /**
   * Step name
   */
  name: string;
  
  /**
   * Step description
   */
  description?: string;
  
  /**
   * Step status
   */
  status: CSTestStatus;
  
  /**
   * Step start time
   */
  startTime: Date;
  
  /**
   * Step end time
   */
  endTime?: Date;
  
  /**
   * Step duration in milliseconds
   */
  duration?: number;
  
  /**
   * Step screenshots
   */
  screenshots?: string[];
  
  /**
   * Step action type
   */
  actionType?: string;
  
  /**
   * Step parameters
   */
  parameters?: Record<string, any>;
  
  /**
   * Step assertion
   */
  assertion?: {
    /**
     * Assertion type
     */
    type: string;
    
    /**
     * Expected value
     */
    expected: any;
    
    /**
     * Actual value
     */
    actual: any;
    
    /**
     * Whether the assertion passed
     */
    passed: boolean;
    
    /**
     * Assertion message
     */
    message?: string;
  };
  
  /**
   * Step error
   */
  error?: {
    /**
     * Error message
     */
    message: string;
    
    /**
     * Error stack trace
     */
    stackTrace?: string;
    
    /**
     * Error type
     */
    type?: string;
  };
  
  /**
   * Element selector
   */
  selector?: string;
  
  /**
   * Element locator
   */
  locator?: {
    /**
     * Locator type (e.g., 'css', 'xpath', 'id')
     */
    type: string;
    
    /**
     * Locator value
     */
    value: string;
  };
  
  /**
   * Step tags
   */
  tags?: string[];
  
  /**
   * Step order/index
   */
  index?: number;
  
  /**
   * Parent step ID
   */
  parentId?: string;
  
  /**
   * Custom data
   */
  customData?: Record<string, any>;
}

/**
 * Model for test execution steps
 */
export class CSTestStep {
  /**
   * Step ID
   */
  public id: string;
  
  /**
   * Step name
   */
  public name: string;
  
  /**
   * Step description
   */
  public description: string;
  
  /**
   * Step status
   */
  public status: CSTestStatus;
  
  /**
   * Step start time
   */
  public startTime: Date;
  
  /**
   * Step end time
   */
  public endTime: Date;
  
  /**
   * Step duration in milliseconds
   */
  public duration: number;
  
  /**
   * Step screenshots
   */
  public screenshots: string[];
  
  /**
   * Step action type
   */
  public actionType: string;
  
  /**
   * Step parameters
   */
  public parameters: Record<string, any>;
  
  /**
   * Step assertion
   */
  public assertion: {
    type: string;
    expected: any;
    actual: any;
    passed: boolean;
    message?: string;
  } | null;
  
  /**
   * Step error
   */
  public error: {
    message: string;
    stackTrace?: string;
    type?: string;
  } | null;
  
  /**
   * Element selector
   */
  public selector: string | null;
  
  /**
   * Element locator
   */
  public locator: {
    type: string;
    value: string;
  } | null;
  
  /**
   * Step tags
   */
  public tags: string[];
  
  /**
   * Step order/index
   */
  public index: number;
  
  /**
   * Parent step ID
   */
  public parentId: string | null;
  
  /**
   * Child steps
   */
  public childSteps: CSTestStep[];
  
  /**
   * Custom data
   */
  public customData: Record<string, any>;
  
  /**
   * Constructor
   * 
   * @param options Test step options
   */
  constructor(options: CSTestStepOptions) {
    this.id = this.generateId();
    this.name = options.name;
    this.description = options.description || '';
    this.status = options.status;
    this.startTime = options.startTime;
    this.endTime = options.endTime || new Date();
    this.duration = options.duration || (this.endTime.getTime() - this.startTime.getTime());
    this.screenshots = options.screenshots || [];
    this.actionType = options.actionType || 'undefined';
    this.parameters = options.parameters || {};
    this.assertion = options.assertion || null;
    this.error = options.error || null;
    this.selector = options.selector || null;
    this.locator = options.locator || null;
    this.tags = options.tags || [];
    this.index = options.index !== undefined ? options.index : -1;
    this.parentId = options.parentId || null;
    this.childSteps = [];
    this.customData = options.customData || {};
    
    // Set error if status is failed and no error is provided
    if (this.status === CSTestStatus.FAILED && !this.error) {
      this.error = {
        message: 'Step failed'
      };
    }
  }
  
  /**
   * Adds a child step
   * 
   * @param childStep Child step
   */
  public addChildStep(childStep: CSTestStep): void {
    childStep.parentId = this.id;
    this.childSteps.push(childStep);
  }
  
  /**
   * Sets the step status
   * 
   * @param status Step status
   * @param errorMessage Error message (if status is failed)
   */
  public setStatus(status: CSTestStatus, errorMessage?: string): void {
    this.status = status;
    
    if (status === CSTestStatus.FAILED && errorMessage) {
      this.error = {
        message: errorMessage
      };
    }
  }
  
  /**
   * Adds a screenshot
   * 
   * @param screenshotPath Screenshot path
   */
  public addScreenshot(screenshotPath: string): void {
    this.screenshots.push(screenshotPath);
  }
  
  /**
   * Sets the assertion
   * 
   * @param type Assertion type
   * @param expected Expected value
   * @param actual Actual value
   * @param passed Whether the assertion passed
   * @param message Assertion message
   */
  public setAssertion(
    type: string,
    expected: any,
    actual: any,
    passed: boolean,
    message?: string
  ): void {
    this.assertion = {
      type,
      expected,
      actual,
      passed,
      message
    };
    
    // Update status based on assertion result
    if (!passed) {
      this.status = CSTestStatus.FAILED;
      this.error = {
        message: message || `Assertion failed: expected ${expected}, but got ${actual}`
      };
    }
  }
  
  /**
   * Sets the error
   * 
   * @param message Error message
   * @param stackTrace Error stack trace
   * @param type Error type
   */
  public setError(message: string, stackTrace?: string, type?: string): void {
    this.error = {
      message,
      stackTrace,
      type
    };
    
    this.status = CSTestStatus.FAILED;
  }
  
  /**
   * Sets custom data
   * 
   * @param key Data key
   * @param value Data value
   */
  public setCustomData(key: string, value: any): void {
    this.customData[key] = value;
  }
  
  /**
   * Gets custom data
   * 
   * @param key Data key
   * @returns Data value or undefined if not found
   */
  public getCustomData(key: string): any {
    return this.customData[key];
  }
  
  /**
   * Checks if the step has screenshots
   * 
   * @returns True if the step has screenshots
   */
  public hasScreenshots(): boolean {
    return this.screenshots.length > 0;
  }
  
  /**
   * Checks if the step has child steps
   * 
   * @returns True if the step has child steps
   */
  public hasChildSteps(): boolean {
    return this.childSteps.length > 0;
  }
  
  /**
   * Checks if the step has an assertion
   * 
   * @returns True if the step has an assertion
   */
  public hasAssertion(): boolean {
    return this.assertion !== null;
  }
  
  /**
   * Checks if the step has an error
   * 
   * @returns True if the step has an error
   */
  public hasError(): boolean {
    return this.error !== null;
  }
  
  /**
   * Checks if the step has a locator
   * 
   * @returns True if the step has a locator
   */
  public hasLocator(): boolean {
    return this.locator !== null;
  }
  
  /**
   * Gets the step description or name if no description is available
   * 
   * @returns Step description or name
   */
  public getDisplayName(): string {
    return this.description || this.name;
  }
  
  /**
   * Generates a unique ID
   * 
   * @returns Unique ID
   */
  private generateId(): string {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 8);
    return `step_${timestamp}_${random}`;
  }
  
  /**
   * Converts the test step to a plain object
   * 
   * @returns Plain object representation
   */
  public toJSON(): Record<string, any> {
    return {
      id: this.id,
      name: this.name,
      description: this.description,
      status: this.status,
      startTime: this.startTime.toISOString(),
      endTime: this.endTime.toISOString(),
      duration: this.duration,
      screenshots: this.screenshots,
      actionType: this.actionType,
      parameters: this.parameters,
      assertion: this.assertion,
      error: this.error,
      selector: this.selector,
      locator: this.locator,
      tags: this.tags,
      index: this.index,
      parentId: this.parentId,
      childSteps: this.childSteps.map(step => step.toJSON()),
      customData: this.customData
    };
  }
  
  /**
   * Creates a test step from a JSON object
   * 
   * @param json JSON object
   * @returns Test step
   */
  public static fromJSON(json: Record<string, any>): CSTestStep {
    const step = new CSTestStep({
      name: json.name,
      description: json.description,
      status: json.status as CSTestStatus,
      startTime: new Date(json.startTime),
      endTime: new Date(json.endTime),
      duration: json.duration,
      screenshots: json.screenshots,
      actionType: json.actionType,
      parameters: json.parameters,
      assertion: json.assertion,
      error: json.error,
      selector: json.selector,
      locator: json.locator,
      tags: json.tags,
      index: json.index,
      parentId: json.parentId,
      customData: json.customData
    });
    
    // Override generated ID with the one from JSON
    step.id = json.id;
    
    // Add child steps
    if (json.childSteps && Array.isArray(json.childSteps)) {
      step.childSteps = json.childSteps.map((childJson: any) => CSTestStep.fromJSON(childJson));
    }
    
    return step;
  }
}



/**
 * CSHtmlReportGenerator.ts
 * 
 * Generates HTML reports from test results in the CSTestForge framework.
 * Creates interactive HTML reports with dashboards, charts, and detailed test information.
 */

import { CSTestResult } from './CSTestResult';
import { CSTestStep } from './CSTestStep';
import { CSTestStatus, CSLogLevel } from './CSReporter';
import { CSLogger } from '../utils/CSLogger';
import { CSFileUtils } from '../utils/CSFileUtils';
import { CSDateUtils } from '../utils/CSDateUtils';
import { CSTextUtils } from '../utils/CSTextUtils';

/**
 * HTML report generation options
 */
export interface CSHtmlReportOptions {
  /**
   * Output directory
   */
  outputDir?: string;
  
  /**
   * Report title
   */
  title?: string;
  
  /**
   * Project name
   */
  projectName?: string;
  
  /**
   * Logo URL or path
   */
  logoUrl?: string;
  
  /**
   * Include screenshots in the report
   */
  includeScreenshots?: boolean;
  
  /**
   * Include videos in the report
   */
  includeVideos?: boolean;
  
  /**
   * Include logs in the report
   */
  includeLogs?: boolean;
  
  /**
   * Include metrics in the report
   */
  includeMetrics?: boolean;
  
  /**
   * Include environment info in the report
   */
  includeEnvironment?: boolean;
  
  /**
   * Theme (light or dark)
   */
  theme?: 'light' | 'dark';
  
  /**
   * Custom CSS
   */
  customCss?: string;
  
  /**
   * Custom JavaScript
   */
  customJs?: string;
  
  /**
   * Test run ID
   */
  testRunId?: string;
  
  /**
   * Theme color (primary brand color)
   */
  themeColor?: string;
  
  /**
   * Additional custom data to include in the report
   */
  customData?: Record<string, any>;
  
  /**
   * Whether to embed assets in the HTML file
   */
  embedAssets?: boolean;
  
  /**
   * Maximum number of tests to show per page
   */
  maxTestsPerPage?: number;
  
  /**
   * Whether to hide passed tests by default
   */
  hidePassedTests?: boolean;
  
  /**
   * Whether to hide passed steps by default
   */
  hidePassedSteps?: boolean;
  
  /**
   * Whether to enable test filtering
   */
  enableFiltering?: boolean;
  
  /**
   * Whether to enable test searching
   */
  enableSearching?: boolean;
  
  /**
   * Whether to enable test sorting
   */
  enableSorting?: boolean;
  
  /**
   * Whether to embed screenshots in the HTML file
   */
  embedScreenshots?: boolean;
}

/**
 * Class for generating HTML reports from test results
 */
export class CSHtmlReportGenerator {
  // Logger
  private logger: CSLogger;
  
  // File utils
  private fileUtils: CSFileUtils;
  
  // Date utils
  private dateUtils: CSDateUtils;
  
  // Text utils
  private textUtils: CSTextUtils;
  
  // Options
  private options: CSHtmlReportOptions;
  
  // Default options
  private static readonly DEFAULT_OPTIONS: CSHtmlReportOptions = {
    outputDir: './reports',
    title: 'CSTestForge Test Report',
    projectName: 'CSTestForge Project',
    includeScreenshots: true,
    includeVideos: true,
    includeLogs: true,
    includeMetrics: true,
    includeEnvironment: true,
    theme: 'light',
    themeColor: '#C54B8C', // CSTestForge brand color
    embedAssets: true,
    maxTestsPerPage: 50,
    hidePassedTests: false,
    hidePassedSteps: false,
    enableFiltering: true,
    enableSearching: true,
    enableSorting: true,
    embedScreenshots: false
  };
  
  /**
   * Constructor
   * 
   * @param options HTML report options
   */
  constructor(options?: CSHtmlReportOptions) {
    this.logger = new CSLogger('CSHtmlReportGenerator');
    this.fileUtils = new CSFileUtils();
    this.dateUtils = new CSDateUtils();
    this.textUtils = new CSTextUtils();
    
    // Merge options with defaults
    this.options = {
      ...CSHtmlReportGenerator.DEFAULT_OPTIONS,
      ...options
    };
    
    // Create output directory
    this.createOutputDirectory();
  }
  
  /**
   * Generates a report from test results
   * 
   * @param testResults Array of test results
   * @param outputPath Output file path
   * @returns Output file path
   */
  public generateReport(
    testResults: CSTestResult[],
    outputPath?: string
  ): string {
    this.logger.info('Generating HTML report...');
    
    // Create output path if not provided
    if (!outputPath) {
      const timestamp = this.dateUtils.formatDate(new Date(), 'yyyyMMdd_HHmmss');
      const testRunId = this.options.testRunId || 'test_run';
      outputPath = `${this.options.outputDir}/${testRunId}_report_${timestamp}.html`;
    }
    
    try {
      // Generate report HTML
      const html = this.generateReportHtml(testResults);
      
      // Write HTML to file
      this.fileUtils.writeTextFile(outputPath, html);
      
      this.logger.info(`HTML report generated: ${outputPath}`);
      
      return outputPath;
    } catch (error) {
      this.logger.error(`Failed to generate HTML report: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to generate HTML report: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Creates the output directory
   */
  private createOutputDirectory(): void {
    try {
      this.fileUtils.createDirectory(this.options.outputDir!);
      this.logger.debug(`Output directory created: ${this.options.outputDir}`);
    } catch (error) {
      this.logger.error(`Failed to create output directory: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Generates the report HTML
   * 
   * @param testResults Array of test results
   * @returns Report HTML
   */
  private generateReportHtml(testResults: CSTestResult[]): string {
    // Generate report sections
    const head = this.generateHead();
    const header = this.generateHeader(testResults);
    const summary = this.generateSummary(testResults);
    const statistics = this.generateStatistics(testResults);
    const testList = this.generateTestList(testResults);
    const testDetails = this.generateTestDetails(testResults);
    const footer = this.generateFooter();
    
    // Combine sections into full HTML
    return `<!DOCTYPE html>
<html lang="en">
<head>
  ${head}
</head>
<body class="${this.options.theme}">
  <div class="report-container">
    ${header}
    <main class="report-main">
      <div class="report-content">
        ${summary}
        ${statistics}
        ${testList}
        ${testDetails}
      </div>
    </main>
    ${footer}
  </div>
  <script>
    ${this.generateJavaScript()}
  </script>
  ${this.options.customJs ? `<script>${this.options.customJs}</script>` : ''}
</body>
</html>`;
  }
  
  /**
   * Generates the HTML head section
   * 
   * @returns HTML head
   */
  private generateHead(): string {
    const primaryColor = this.options.themeColor || '#C54B8C';
    
    // Calculate secondary colors using color manipulation
    const primaryRgb = this.hexToRgb(primaryColor);
    const secondaryColor = this.rgbToHex(
      Math.max(0, primaryRgb.r - 40),
      Math.max(0, primaryRgb.g - 40),
      Math.max(0, primaryRgb.b - 40)
    );
    const tertiaryColor = this.rgbToHex(
      Math.min(255, primaryRgb.r + 40),
      Math.min(255, primaryRgb.g + 40),
      Math.min(255, primaryRgb.b + 40)
    );
    
    return `
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${this.textUtils.escapeHtml(this.options.title || 'CSTestForge Test Report')}</title>
  <style>
    :root {
      --primary-color: ${primaryColor};
      --secondary-color: ${secondaryColor};
      --tertiary-color: ${tertiaryColor};
      --light-bg: #ffffff;
      --dark-bg: #1e1e1e;
      --light-text: #333333;
      --dark-text: #f5f5f5;
      --light-border: #dddddd;
      --dark-border: #444444;
      --light-hover: #f5f5f5;
      --dark-hover: #2a2a2a;
      --status-passed: #4caf50;
      --status-failed: #f44336;
      --status-skipped: #ff9800;
      --status-warning: #ff9800;
      --status-info: #2196f3;
      --status-blocked: #9c27b0;
      --status-in-progress: #03a9f4;
      --status-not-executed: #9e9e9e;
    }
    
    /* Base styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      line-height: 1.6;
      font-size: 14px;
    }
    
    body.light {
      background-color: var(--light-bg);
      color: var(--light-text);
    }
    
    body.dark {
      background-color: var(--dark-bg);
      color: var(--dark-text);
    }
    
    .report-container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    
    /* Header styles */
    .report-header {
      background-color: var(--primary-color);
      color: white;
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 1000;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .report-header-logo {
      height: 40px;
    }
    
    .report-header-title {
      flex-grow: 1;
      margin: 0 1rem;
    }
    
    .report-header-title h1 {
      font-size: 1.5rem;
      margin: 0;
    }
    
    .report-header-title p {
      margin: 0;
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    .report-header-controls {
      display: flex;
      gap: 1rem;
    }
    
    /* Main content styles */
    .report-main {
      flex-grow: 1;
      padding: 1rem;
    }
    
    .report-content {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    /* Card styles */
    .card {
      background-color: var(--light-bg);
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 1rem;
      overflow: hidden;
    }
    
    .dark .card {
      background-color: var(--dark-bg);
      border: 1px solid var(--dark-border);
    }
    
    .card-header {
      padding: 1rem;
      border-bottom: 1px solid var(--light-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .dark .card-header {
      border-bottom: 1px solid var(--dark-border);
    }
    
    .card-title {
      font-size: 1.2rem;
      font-weight: 500;
      margin: 0;
    }
    
    .card-content {
      padding: 1rem;
    }
    
    /* Summary styles */
    .summary-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 1rem;
    }
    
    .summary-item {
      padding: 1rem;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      text-align: center;
    }
    
    .summary-value {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }
    
    .summary-label {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    
    /* Statistics styles */
    .statistics-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
      gap: 1rem;
    }
    
    .chart-container {
      height: 300px;
      position: relative;
    }
    
    /* Test list styles */
    .test-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }
    
    .test-filters {
      display: flex;
      gap: 0.5rem;
    }
    
    .test-search {
      flex-grow: 1;
      max-width: 300px;
    }
    
    .test-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .test-table th,
    .test-table td {
      padding: 0.75rem;
      text-align: left;
      border-bottom: 1px solid var(--light-border);
    }
    
    .dark .test-table th,
    .dark .test-table td {
      border-bottom: 1px solid var(--dark-border);
    }
    
    .test-table th {
      font-weight: 500;
      cursor: pointer;
    }
    
    .test-table tr:hover {
      background-color: var(--light-hover);
    }
    
    .dark .test-table tr:hover {
      background-color: var(--dark-hover);
    }
    
    .test-name {
      cursor: pointer;
      color: var(--primary-color);
      text-decoration: none;
    }
    
    .test-name:hover {
      text-decoration: underline;
    }
    
    /* Test details styles */
    .test-details {
      margin-top: 2rem;
    }
    
    .test-details-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }
    
    .test-details-header h2 {
      margin: 0;
    }
    
    .test-details-info {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .test-details-item {
      padding: 0.5rem;
    }
    
    .test-details-label {
      font-weight: 500;
      margin-bottom: 0.25rem;
    }
    
    .test-details-value {
      word-break: break-word;
    }
    
    .test-steps {
      margin-bottom: 1rem;
    }
    
    .step-row {
      display: flex;
      border-bottom: 1px solid var(--light-border);
      padding: 0.5rem 0;
    }
    
    .dark .step-row {
      border-bottom: 1px solid var(--dark-border);
    }
    
    .step-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 0.5rem;
    }
    
    .step-content {
      flex-grow: 1;
    }
    
    .step-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }
    
    .step-name {
      font-weight: 500;
    }
    
    .step-status {
      font-size: 0.85rem;
      padding: 0.2rem 0.5rem;
      border-radius: 3px;
      margin-left: 0.5rem;
    }
    
    .step-details {
      margin-top: 0.5rem;
      display: none;
    }
    
    .step-row.expanded .step-details {
      display: block;
    }
    
    .step-description {
      margin-bottom: 0.5rem;
    }
    
    .step-screenshots {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    
    .step-screenshot {
      max-width: 200px;
      max-height: 200px;
      cursor: pointer;
      border: 1px solid var(--light-border);
    }
    
    .dark .step-screenshot {
      border: 1px solid var(--dark-border);
    }
    
    /* Screenshot modal */
    .modal {
      display: none;
      position: fixed;
      z-index: 1001;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.8);
    }
    
    .modal-content {
      margin: auto;
      display: block;
      max-width: 90%;
      max-height: 90%;
    }
    
    .modal-close {
      position: absolute;
      top: 15px;
      right: 15px;
      color: white;
      font-size: 30px;
      font-weight: bold;
      cursor: pointer;
    }
    
    /* Status styles */
    .status {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 3px;
      font-size: 0.85rem;
      font-weight: 500;
      text-transform: uppercase;
    }
    
    .status-PASSED {
      background-color: var(--status-passed);
      color: white;
    }
    
    .status-FAILED {
      background-color: var(--status-failed);
      color: white;
    }
    
    .status-SKIPPED {
      background-color: var(--status-skipped);
      color: white;
    }
    
    .status-WARNING {
      background-color: var(--status-warning);
      color: white;
    }
    
    .status-INFO {
      background-color: var(--status-info);
      color: white;
    }
    
    .status-BLOCKED {
      background-color: var(--status-blocked);
      color: white;
    }
    
    .status-IN_PROGRESS {
      background-color: var(--status-in-progress);
      color: white;
    }
    
    .status-NOT_EXECUTED {
      background-color: var(--status-not-executed);
      color: white;
    }
    
    /* Tab styles */
    .tabs {
      margin-top: 1rem;
    }
    
    .tab-list {
      display: flex;
      border-bottom: 1px solid var(--light-border);
      margin-bottom: 1rem;
    }
    
    .dark .tab-list {
      border-bottom: 1px solid var(--dark-border);
    }
    
    .tab {
      padding: 0.5rem 1rem;
      cursor: pointer;
      border-bottom: 2px solid transparent;
    }
    
    .tab.active {
      border-bottom: 2px solid var(--primary-color);
      color: var(--primary-color);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Log styles */
    .log-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .log-table th,
    .log-table td {
      padding: 0.5rem;
      text-align: left;
      border-bottom: 1px solid var(--light-border);
    }
    
    .dark .log-table th,
    .dark .log-table td {
      border-bottom: 1px solid var(--dark-border);
    }
    
    .log-level {
      font-weight: 500;
    }
    
    .log-level-ERROR, .log-level-FATAL {
      color: var(--status-failed);
    }
    
    .log-level-WARNING {
      color: var(--status-warning);
    }
    
    .log-level-INFO {
      color: var(--status-info);
    }
    
    .log-level-DEBUG, .log-level-TRACE {
      color: var(--status-not-executed);
    }
    
    /* Environment styles */
    .environment-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .environment-table th,
    .environment-table td {
      padding: 0.5rem;
      text-align: left;
      border-bottom: 1px solid var(--light-border);
    }
    
    .dark .environment-table th,
    .dark .environment-table td {
      border-bottom: 1px solid var(--dark-border);
    }
    
    /* Metrics styles */
    .metrics-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .metrics-table th,
    .metrics-table td {
      padding: 0.5rem;
      text-align: left;
      border-bottom: 1px solid var(--light-border);
    }
    
    .dark .metrics-table th,
    .dark .metrics-table td {
      border-bottom: 1px solid var(--dark-border);
    }
    
    /* Form control styles */
    .form-control {
      display: block;
      width: 100%;
      padding: 0.5rem;
      font-size: 1rem;
      border: 1px solid var(--light-border);
      border-radius: 4px;
      background-color: var(--light-bg);
      color: var(--light-text);
    }
    
    .dark .form-control {
      border: 1px solid var(--dark-border);
      background-color: var(--dark-bg);
      color: var(--dark-text);
    }
    
    .form-control:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(197, 75, 140, 0.25);
    }
    
    /* Button styles */
    .btn {
      display: inline-block;
      padding: 0.5rem 1rem;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      text-align: center;
      text-decoration: none;
      background-color: var(--primary-color);
      color: white;
    }
    
    .btn:hover {
      background-color: var(--secondary-color);
    }
    
    .btn:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(197, 75, 140, 0.25);
    }
    
    .btn-secondary {
      background-color: transparent;
      border: 1px solid var(--primary-color);
      color: var(--primary-color);
    }
    
    .btn-secondary:hover {
      background-color: rgba(197, 75, 140, 0.1);
    }
    
    /* Footer styles */
    .report-footer {
      background-color: var(--primary-color);
      color: white;
      padding: 1rem;
      text-align: center;
      margin-top: 2rem;
    }
    
    .report-footer a {
      color: white;
      text-decoration: underline;
    }
    
    /* Responsive styles */
    @media (max-width: 768px) {
      .report-header {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .report-header-title {
        margin: 0.5rem 0;
      }
      
      .report-header-controls {
        margin-top: 0.5rem;
      }
      
      .summary-container,
      .statistics-container {
        grid-template-columns: 1fr;
      }
      
      .test-table th,
      .test-table td {
        padding: 0.5rem;
      }
      
      .test-controls {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .test-search {
        width: 100%;
        max-width: none;
        margin-top: 0.5rem;
      }
    }
    
    /* Custom styles */
    ${this.options.customCss || ''}
  </style>`;
  }
  
  /**
   * Generates the header section
   * 
   * @param testResults Array of test results
   * @returns Header HTML
   */
  private generateHeader(testResults: CSTestResult[]): string {
    const timestamp = new Date().toLocaleString();
    const passedTests = testResults.filter(result => result.status === CSTestStatus.PASSED).length;
    const totalTests = testResults.length;
    const passRate = totalTests > 0 ? (passedTests / totalTests) * 100 : 0;
    
    return `
    <header class="report-header">
      ${this.options.logoUrl ? `<img src="${this.options.logoUrl}" alt="Logo" class="report-header-logo">` : ''}
      <div class="report-header-title">
        <h1>${this.textUtils.escapeHtml(this.options.title || 'CSTestForge Test Report')}</h1>
        <p>${this.textUtils.escapeHtml(this.options.projectName || 'CSTestForge Project')} | ${timestamp}</p>
      </div>
      <div class="report-header-controls">
        <button id="theme-toggle" class="btn btn-secondary">Toggle Theme</button>
      </div>
    </header>`;
  }
  
  /**
   * Generates the summary section
   * 
   * @param testResults Array of test results
   * @returns Summary HTML
   */
  private generateSummary(testResults: CSTestResult[]): string {
    const totalTests = testResults.length;
    const passedTests = testResults.filter(result => result.status === CSTestStatus.PASSED).length;
    const failedTests = testResults.filter(result => result.status === CSTestStatus.FAILED).length;
    const skippedTests = testResults.filter(result => result.status === CSTestStatus.SKIPPED).length;
    const passRate = totalTests > 0 ? (passedTests / totalTests) * 100 : 0;
    
    // Calculate total duration
    let totalDuration = 0;
    for (const result of testResults) {
      totalDuration += result.duration;
    }
    const totalDurationFormatted = this.formatDuration(totalDuration);
    
    return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Summary</h2>
      </div>
      <div class="card-content">
        <div class="summary-container">
          <div class="summary-item" style="background-color: var(--status-passed); color: white;">
            <div class="summary-value">${passedTests}</div>
            <div class="summary-label">Passed Tests</div>
          </div>
          <div class="summary-item" style="background-color: var(--status-failed); color: white;">
            <div class="summary-value">${failedTests}</div>
            <div class="summary-label">Failed Tests</div>
          </div>
          <div class="summary-item" style="background-color: var(--status-skipped); color: white;">
            <div class="summary-value">${skippedTests}</div>
            <div class="summary-label">Skipped Tests</div>
          </div>
          <div class="summary-item" style="background-color: var(--primary-color); color: white;">
            <div class="summary-value">${passRate.toFixed(2)}%</div>
            <div class="summary-label">Pass Rate</div>
          </div>
          <div class="summary-item" style="background-color: var(--secondary-color); color: white;">
            <div class="summary-value">${totalTests}</div>
            <div class="summary-label">Total Tests</div>
          </div>
          <div class="summary-item" style="background-color: var(--tertiary-color); color: white;">
            <div class="summary-value">${totalDurationFormatted}</div>
            <div class="summary-label">Total Duration</div>
          </div>
        </div>
      </div>
    </div>`;
  }
  
  /**
   * Generates the statistics section
   * 
   * @param testResults Array of test results
   * @returns Statistics HTML
   */
  private generateStatistics(testResults: CSTestResult[]): string {
    return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Statistics</h2>
      </div>
      <div class="card-content">
        <div class="statistics-container">
          <div>
            <h3>Test Status Distribution</h3>
            <div class="chart-container">
              <canvas id="status-chart"></canvas>
            </div>
          </div>
          <div>
            <h3>Test Duration</h3>
            <div class="chart-container">
              <canvas id="duration-chart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>`;
  }
  
  /**
   * Generates the test list section
   * 
   * @param testResults Array of test results
   * @returns Test list HTML
   */
  private generateTestList(testResults: CSTestResult[]): string {
    // Generate test rows
    let testRows = '';
    
    for (const result of testResults) {
      const duration = this.formatDuration(result.duration);
      const timestamp = this.dateUtils.formatDate(result.startTime, 'yyyy-MM-dd HH:mm:ss');
      
      testRows += `
      <tr data-test-id="${this.textUtils.escapeHtml(result.name)}" class="test-row ${result.status === CSTestStatus.PASSED && this.options.hidePassedTests ? 'hidden' : ''}">
        <td><a href="#test-${this.textUtils.escapeHtml(result.name)}" class="test-name">${this.textUtils.escapeHtml(result.name)}</a></td>
        <td><span class="status status-${result.status}">${result.status}</span></td>
        <td>${duration}</td>
        <td>${timestamp}</td>
        <td>${result.suite}</td>
      </tr>`;
    }
    
    return `
    <div class="card">
      <div class="card-header">
        <h2 class="card-title">Test Results</h2>
      </div>
      <div class="card-content">
        <div class="test-controls">
          <div class="test-filters">
            <label for="status-filter">Status:</label>
            <select id="status-filter" class="form-control">
              <option value="ALL">All</option>
              <option value="PASSED">Passed</option>
              <option value="FAILED">Failed</option>
              <option value="SKIPPED">Skipped</option>
              <option value="WARNING">Warning</option>
              <option value="INFO">Info</option>
              <option value="BLOCKED">Blocked</option>
              <option value="IN_PROGRESS">In Progress</option>
              <option value="NOT_EXECUTED">Not Executed</option>
            </select>
            <label>
              <input type="checkbox" id="hide-passed-tests" ${this.options.hidePassedTests ? 'checked' : ''}>
              Hide Passed Tests
            </label>
          </div>
          <div class="test-search">
            <input type="text" id="test-search" class="form-control" placeholder="Search tests...">
          </div>
        </div>
        <div class="test-table-container">
          <table class="test-table">
            <thead>
              <tr>
                <th data-sort="name">Name</th>
                <th data-sort="status">Status</th>
                <th data-sort="duration">Duration</th>
                <th data-sort="timestamp">Timestamp</th>
                <th data-sort="suite">Suite</th>
              </tr>
            </thead>
            <tbody>
              ${testRows}
            </tbody>
          </table>
        </div>
      </div>
    </div>`;
  }
  
  /**
   * Generates the test details section
   * 
   * @param testResults Array of test results
   * @returns Test details HTML
   */
  private generateTestDetails(testResults: CSTestResult[]): string {
    // Generate test details for each test
    let testDetailsHtml = '';
    
    for (const result of testResults) {
      testDetailsHtml += this.generateTestDetail(result);
    }
    
    return `
    <div class="test-details">
      ${testDetailsHtml}
    </div>`;
  }
  
  /**
   * Generates a test detail section for a single test
   * 
   * @param result Test result
   * @returns Test detail HTML
   */
  private generateTestDetail(result: CSTestResult): string {
    const duration = this.formatDuration(result.duration);
    const startTime = this.dateUtils.formatDate(result.startTime, 'yyyy-MM-dd HH:mm:ss');
    const endTime = result.endTime ? this.dateUtils.formatDate(result.endTime, 'yyyy-MM-dd HH:mm:ss') : 'N/A';
    
    // Generate steps HTML
    const stepsHtml = this.generateSteps(result.steps);
    
    // Generate logs HTML
    const logsHtml = this.generateLogs(result.logs);
    
    // Generate screenshots HTML
    const screenshotsHtml = this.generateScreenshots(result.screenshots);
    
    // Generate videos HTML
    const videosHtml = this.generateVideos(result.videos);
    
    // Generate environment HTML
    const environmentHtml = this.generateEnvironment(result.environment);
    
   // Generate metrics HTML
    const metricsHtml = this.generateMetrics(result.metrics);
    
    // Generate tags HTML
    const tagsHtml = result.tags && result.tags.length > 0 
      ? `<div class="test-details-item"><div class="test-details-label">Tags</div><div class="test-details-value">${result.tags.map(tag => `<span class="tag">${this.textUtils.escapeHtml(tag)}</span>`).join(' ')}</div></div>` 
      : '';
    
    // Generate failure HTML
    const failureHtml = result.failure 
      ? `<div class="test-details-item"><div class="test-details-label">Failure</div><div class="test-details-value error-message">${this.textUtils.escapeHtml(result.failure.message)}</div></div>` 
      : '';
    
    return `
    <div id="test-${this.textUtils.escapeHtml(result.name)}" class="card test-detail">
      <div class="card-header">
        <h2 class="card-title">${this.textUtils.escapeHtml(result.name)}</h2>
        <span class="status status-${result.status}">${result.status}</span>
      </div>
      <div class="card-content">
        <div class="test-details-info">
          <div class="test-details-item">
            <div class="test-details-label">Suite</div>
            <div class="test-details-value">${this.textUtils.escapeHtml(result.suite)}</div>
          </div>
          <div class="test-details-item">
            <div class="test-details-label">Status</div>
            <div class="test-details-value">
              <span class="status status-${result.status}">${result.status}</span>
            </div>
          </div>
          <div class="test-details-item">
            <div class="test-details-label">Duration</div>
            <div class="test-details-value">${duration}</div>
          </div>
          <div class="test-details-item">
            <div class="test-details-label">Start Time</div>
            <div class="test-details-value">${startTime}</div>
          </div>
          <div class="test-details-item">
            <div class="test-details-label">End Time</div>
            <div class="test-details-value">${endTime}</div>
          </div>
          <div class="test-details-item">
            <div class="test-details-label">Description</div>
            <div class="test-details-value">${this.textUtils.escapeHtml(result.description || 'No description')}</div>
          </div>
          ${tagsHtml}
          ${failureHtml}
        </div>
        
        <div class="tabs">
          <div class="tab-list">
            <div class="tab active" data-tab="steps-${this.textUtils.escapeHtml(result.name)}">Steps</div>
            ${result.logs.length > 0 ? `<div class="tab" data-tab="logs-${this.textUtils.escapeHtml(result.name)}">Logs</div>` : ''}
            ${result.screenshots.length > 0 ? `<div class="tab" data-tab="screenshots-${this.textUtils.escapeHtml(result.name)}">Screenshots</div>` : ''}
            ${result.videos.length > 0 ? `<div class="tab" data-tab="videos-${this.textUtils.escapeHtml(result.name)}">Videos</div>` : ''}
            ${Object.keys(result.environment).length > 0 ? `<div class="tab" data-tab="environment-${this.textUtils.escapeHtml(result.name)}">Environment</div>` : ''}
            ${Object.keys(result.metrics).length > 0 ? `<div class="tab" data-tab="metrics-${this.textUtils.escapeHtml(result.name)}">Metrics</div>` : ''}
          </div>
          <div class="tab-content active" id="steps-${this.textUtils.escapeHtml(result.name)}">
            ${stepsHtml}
          </div>
          ${result.logs.length > 0 ? `<div class="tab-content" id="logs-${this.textUtils.escapeHtml(result.name)}">${logsHtml}</div>` : ''}
          ${result.screenshots.length > 0 ? `<div class="tab-content" id="screenshots-${this.textUtils.escapeHtml(result.name)}">${screenshotsHtml}</div>` : ''}
          ${result.videos.length > 0 ? `<div class="tab-content" id="videos-${this.textUtils.escapeHtml(result.name)}">${videosHtml}</div>` : ''}
          ${Object.keys(result.environment).length > 0 ? `<div class="tab-content" id="environment-${this.textUtils.escapeHtml(result.name)}">${environmentHtml}</div>` : ''}
          ${Object.keys(result.metrics).length > 0 ? `<div class="tab-content" id="metrics-${this.textUtils.escapeHtml(result.name)}">${metricsHtml}</div>` : ''}
        </div>
      </div>
    </div>`;
  }
  
  /**
   * Generates the steps section
   * 
   * @param steps Array of test steps
   * @returns Steps HTML
   */
  private generateSteps(steps: CSTestStep[]): string {
    if (steps.length === 0) {
      return '<p>No steps recorded for this test.</p>';
    }
    
    let stepsHtml = '';
    
    for (const step of steps) {
      const duration = this.formatDuration(step.duration);
      const screenshotsHtml = step.screenshots.length > 0 
        ? `<div class="step-screenshots">${step.screenshots.map(screenshot => this.generateStepScreenshot(screenshot)).join('')}</div>` 
        : '';
      
      // Generate assertion HTML
      const assertionHtml = step.assertion 
        ? `<div class="step-assertion">
             <div class="assertion-label">Assertion:</div>
             <div class="assertion-type">${this.textUtils.escapeHtml(step.assertion.type)}</div>
             <div class="assertion-detail">Expected: ${this.formatValue(step.assertion.expected)}</div>
             <div class="assertion-detail">Actual: ${this.formatValue(step.assertion.actual)}</div>
             ${step.assertion.message ? `<div class="assertion-message">${this.textUtils.escapeHtml(step.assertion.message)}</div>` : ''}
           </div>` 
        : '';
      
      // Generate error HTML
      const errorHtml = step.error 
        ? `<div class="step-error">
             <div class="error-message">${this.textUtils.escapeHtml(step.error.message)}</div>
             ${step.error.stackTrace ? `<pre class="error-stack">${this.textUtils.escapeHtml(step.error.stackTrace)}</pre>` : ''}
           </div>` 
        : '';
      
      // Generate parameters HTML
      const parametersHtml = Object.keys(step.parameters).length > 0 
        ? `<div class="step-parameters">
             <div class="parameters-label">Parameters:</div>
             <ul class="parameters-list">
               ${Object.entries(step.parameters).map(([key, value]) => 
                 `<li><span class="parameter-name">${this.textUtils.escapeHtml(key)}:</span> ${this.formatValue(value)}</li>`
               ).join('')}
             </ul>
           </div>` 
        : '';
      
      // Skip passed steps if hidePassedSteps is enabled
      if (step.status === CSTestStatus.PASSED && this.options.hidePassedSteps) {
        continue;
      }
      
      stepsHtml += `
      <div class="step-row" data-status="${step.status}">
        <div class="step-icon">
          ${this.getStatusIcon(step.status)}
        </div>
        <div class="step-content">
          <div class="step-header">
            <div class="step-name">${this.textUtils.escapeHtml(step.name)}</div>
            <div>
              <span class="step-duration">${duration}</span>
              <span class="step-status status status-${step.status}">${step.status}</span>
            </div>
          </div>
          <div class="step-details">
            <div class="step-description">${this.textUtils.escapeHtml(step.description || '')}</div>
            ${assertionHtml}
            ${errorHtml}
            ${parametersHtml}
            ${screenshotsHtml}
          </div>
        </div>
      </div>`;
    }
    
    if (stepsHtml === '') {
      return '<p>All steps are hidden (passed steps are hidden).</p>';
    }
    
    return `
    <div class="test-steps">
      <div class="steps-controls">
        <label>
          <input type="checkbox" id="expand-all-steps" class="expand-all-steps">
          Expand All Steps
        </label>
        <label>
          <input type="checkbox" id="hide-passed-steps" class="hide-passed-steps" ${this.options.hidePassedSteps ? 'checked' : ''}>
          Hide Passed Steps
        </label>
      </div>
      ${stepsHtml}
    </div>`;
  }
  
  /**
   * Generates a step screenshot
   * 
   * @param screenshotPath Screenshot path
   * @returns Screenshot HTML
   */
  private generateStepScreenshot(screenshotPath: string): string {
    const filename = screenshotPath.split('/').pop() || 'screenshot';
    
    if (this.options.embedScreenshots) {
      try {
        // Convert image to base64
        const imageBuffer = this.fileUtils.readFileAsBuffer(screenshotPath);
        const base64Image = imageBuffer.toString('base64');
        return `<img src="data:image/png;base64,${base64Image}" alt="${filename}" class="step-screenshot" onclick="openModal(this.src)">`;
      } catch (error) {
        this.logger.error(`Failed to embed screenshot: ${error instanceof Error ? error.message : String(error)}`);
        return `<img src="${screenshotPath}" alt="${filename}" class="step-screenshot" onclick="openModal(this.src)">`;
      }
    } else {
      return `<img src="${screenshotPath}" alt="${filename}" class="step-screenshot" onclick="openModal(this.src)">`;
    }
  }
  
  /**
   * Generates the logs section
   * 
   * @param logs Array of log entries
   * @returns Logs HTML
   */
  private generateLogs(logs: { 
    level: CSLogLevel; 
    message: string; 
    details: any; 
    timestamp: Date; 
  }[]): string {
    if (logs.length === 0) {
      return '<p>No logs recorded for this test.</p>';
    }
    
    let logsHtml = '';
    
    for (const log of logs) {
      const timestamp = this.dateUtils.formatDate(log.timestamp, 'yyyy-MM-dd HH:mm:ss.SSS');
      const detailsHtml = log.details 
        ? `<pre class="log-details">${this.textUtils.escapeHtml(JSON.stringify(log.details, null, 2))}</pre>` 
        : '';
      
      logsHtml += `
      <tr>
        <td>${timestamp}</td>
        <td class="log-level log-level-${log.level}">${log.level}</td>
        <td>${this.textUtils.escapeHtml(log.message)}</td>
        <td>${detailsHtml}</td>
      </tr>`;
    }
    
    return `
    <div class="logs-container">
      <table class="log-table">
        <thead>
          <tr>
            <th>Timestamp</th>
            <th>Level</th>
            <th>Message</th>
            <th>Details</th>
          </tr>
        </thead>
        <tbody>
          ${logsHtml}
        </tbody>
      </table>
    </div>`;
  }
  
  /**
   * Generates the screenshots section
   * 
   * @param screenshots Array of screenshots
   * @returns Screenshots HTML
   */
  private generateScreenshots(screenshots: { 
    path: string; 
    timestamp: Date; 
    description: string; 
  }[]): string {
    if (screenshots.length === 0) {
      return '<p>No screenshots captured for this test.</p>';
    }
    
    let screenshotsHtml = '';
    
    for (const screenshot of screenshots) {
      const filename = screenshot.path.split('/').pop() || 'screenshot';
      const timestamp = this.dateUtils.formatDate(screenshot.timestamp, 'yyyy-MM-dd HH:mm:ss');
      
      let imageHtml = '';
      
      if (this.options.embedScreenshots) {
        try {
          // Convert image to base64
          const imageBuffer = this.fileUtils.readFileAsBuffer(screenshot.path);
          const base64Image = imageBuffer.toString('base64');
          imageHtml = `<img src="data:image/png;base64,${base64Image}" alt="${filename}" class="screenshot-image" onclick="openModal(this.src)">`;
        } catch (error) {
          this.logger.error(`Failed to embed screenshot: ${error instanceof Error ? error.message : String(error)}`);
          imageHtml = `<img src="${screenshot.path}" alt="${filename}" class="screenshot-image" onclick="openModal(this.src)">`;
        }
      } else {
        imageHtml = `<img src="${screenshot.path}" alt="${filename}" class="screenshot-image" onclick="openModal(this.src)">`;
      }
      
      screenshotsHtml += `
      <div class="screenshot-item">
        <div class="screenshot-header">
          <div class="screenshot-title">${this.textUtils.escapeHtml(screenshot.description || filename)}</div>
          <div class="screenshot-timestamp">${timestamp}</div>
        </div>
        <div class="screenshot-image-container">
          ${imageHtml}
        </div>
      </div>`;
    }
    
    return `
    <div class="screenshots-container">
      ${screenshotsHtml}
    </div>`;
  }
  
  /**
   * Generates the videos section
   * 
   * @param videos Array of videos
   * @returns Videos HTML
   */
  private generateVideos(videos: { 
    path: string; 
    timestamp: Date; 
    description: string; 
  }[]): string {
    if (videos.length === 0) {
      return '<p>No videos recorded for this test.</p>';
    }
    
    let videosHtml = '';
    
    for (const video of videos) {
      const filename = video.path.split('/').pop() || 'video';
      const timestamp = this.dateUtils.formatDate(video.timestamp, 'yyyy-MM-dd HH:mm:ss');
      
      videosHtml += `
      <div class="video-item">
        <div class="video-header">
          <div class="video-title">${this.textUtils.escapeHtml(video.description || filename)}</div>
          <div class="video-timestamp">${timestamp}</div>
        </div>
        <div class="video-container">
          <video controls>
            <source src="${video.path}" type="video/webm">
            Your browser does not support the video tag.
          </video>
        </div>
      </div>`;
    }
    
    return `
    <div class="videos-container">
      ${videosHtml}
    </div>`;
  }
  
  /**
   * Generates the environment section
   * 
   * @param environment Test environment
   * @returns Environment HTML
   */
  private generateEnvironment(environment: Record<string, any>): string {
    if (Object.keys(environment).length === 0) {
      return '<p>No environment information recorded for this test.</p>';
    }
    
    let environmentRows = '';
    
    // Add built-in properties
    if (environment.browser) {
      environmentRows += `<tr><td>Browser</td><td>${this.textUtils.escapeHtml(environment.browser)}</td></tr>`;
    }
    
    if (environment.browserVersion) {
      environmentRows += `<tr><td>Browser Version</td><td>${this.textUtils.escapeHtml(environment.browserVersion)}</td></tr>`;
    }
    
    if (environment.os) {
      environmentRows += `<tr><td>Operating System</td><td>${this.textUtils.escapeHtml(environment.os)}</td></tr>`;
    }
    
    if (environment.osVersion) {
      environmentRows += `<tr><td>OS Version</td><td>${this.textUtils.escapeHtml(environment.osVersion)}</td></tr>`;
    }
    
    if (environment.device) {
      environmentRows += `<tr><td>Device</td><td>${this.textUtils.escapeHtml(environment.device)}</td></tr>`;
    }
    
    if (environment.viewportWidth && environment.viewportHeight) {
      environmentRows += `<tr><td>Viewport</td><td>${environment.viewportWidth}x${environment.viewportHeight}</td></tr>`;
    }
    
    if (environment.framework) {
      environmentRows += `<tr><td>Framework</td><td>${this.textUtils.escapeHtml(environment.framework)}</td></tr>`;
    }
    
    if (environment.frameworkVersion) {
      environmentRows += `<tr><td>Framework Version</td><td>${this.textUtils.escapeHtml(environment.frameworkVersion)}</td></tr>`;
    }
    
    // Add custom properties
    if (environment.custom) {
      for (const [key, value] of Object.entries(environment.custom)) {
        environmentRows += `<tr><td>${this.textUtils.escapeHtml(key)}</td><td>${this.formatValue(value)}</td></tr>`;
      }
    }
    
    return `
    <div class="environment-container">
      <table class="environment-table">
        <thead>
          <tr>
            <th>Property</th>
            <th>Value</th>
          </tr>
        </thead>
        <tbody>
          ${environmentRows}
        </tbody>
      </table>
    </div>`;
  }
  
  /**
   * Generates the metrics section
   * 
   * @param metrics Test metrics
   * @returns Metrics HTML
   */
  private generateMetrics(metrics: Record<string, any>): string {
    if (Object.keys(metrics).length === 0) {
      return '<p>No metrics recorded for this test.</p>';
    }
    
    let metricsRows = '';
    
    // Add built-in metrics
    if (metrics.loadTime !== undefined) {
      metricsRows += `<tr><td>Load Time</td><td>${metrics.loadTime} ms</td></tr>`;
    }
    
    if (metrics.responseTime !== undefined) {
      metricsRows += `<tr><td>Response Time</td><td>${metrics.responseTime} ms</td></tr>`;
    }
    
    if (metrics.cpuUsage !== undefined) {
      metricsRows += `<tr><td>CPU Usage</td><td>${metrics.cpuUsage.toFixed(2)}%</td></tr>`;
    }
    
    if (metrics.memoryUsage !== undefined) {
      metricsRows += `<tr><td>Memory Usage</td><td>${metrics.memoryUsage.toFixed(2)} MB</td></tr>`;
    }
    
    if (metrics.networkRequestsCount !== undefined) {
      metricsRows += `<tr><td>Network Requests</td><td>${metrics.networkRequestsCount}</td></tr>`;
    }
    
    if (metrics.bytesTransferred !== undefined) {
      metricsRows += `<tr><td>Bytes Transferred</td><td>${this.formatBytes(metrics.bytesTransferred)}</td></tr>`;
    }
    
    // Add custom metrics
    if (metrics.customMetrics) {
      for (const [key, value] of Object.entries(metrics.customMetrics)) {
        metricsRows += `<tr><td>${this.textUtils.escapeHtml(key)}</td><td>${this.formatValue(value)}</td></tr>`;
      }
    }
    
    return `
    <div class="metrics-container">
      <table class="metrics-table">
        <thead>
          <tr>
            <th>Metric</th>
            <th>Value</th>
          </tr>
        </thead>
        <tbody>
          ${metricsRows}
        </tbody>
      </table>
    </div>`;
  }
  
  /**
   * Generates the footer section
   * 
   * @returns Footer HTML
   */
  private generateFooter(): string {
    const year = new Date().getFullYear();
    return `
    <footer class="report-footer">
      <p>Generated by CSTestForge Report Generator | © ${year} CSTestForge</p>
    </footer>
    
    <!-- Screenshot Modal -->
    <div id="screenshot-modal" class="modal">
      <span class="modal-close">&times;</span>
      <img class="modal-content" id="modal-image">
    </div>`;
  }
  
  /**
   * Generates the JavaScript for the report
   * 
   * @returns JavaScript code
   */
  private generateJavaScript(): string {
    return `
    // Theme toggle
    const themeToggle = document.getElementById('theme-toggle');
    if (themeToggle) {
      themeToggle.addEventListener('click', function() {
        document.body.classList.toggle('dark');
        document.body.classList.toggle('light');
        
        // Save theme preference
        const currentTheme = document.body.classList.contains('dark') ? 'dark' : 'light';
        localStorage.setItem('cstestforge-theme', currentTheme);
      });
      
      // Load theme preference
      const savedTheme = localStorage.getItem('cstestforge-theme');
      if (savedTheme) {
        document.body.classList.remove('light', 'dark');
        document.body.classList.add(savedTheme);
      }
    }
    
    // Step expansion
    document.querySelectorAll('.step-header').forEach(header => {
      header.addEventListener('click', function() {
        const stepRow = this.closest('.step-row');
        stepRow.classList.toggle('expanded');
      });
    });
    
    // Expand all steps
    document.querySelectorAll('.expand-all-steps').forEach(checkbox => {
      checkbox.addEventListener('change', function() {
        const testDetail = this.closest('.test-detail');
        const steps = testDetail.querySelectorAll('.step-row');
        
        if (this.checked) {
          steps.forEach(step => step.classList.add('expanded'));
        } else {
          steps.forEach(step => step.classList.remove('expanded'));
        }
      });
    });
    
    // Hide passed steps
    document.querySelectorAll('.hide-passed-steps').forEach(checkbox => {
      checkbox.addEventListener('change', function() {
        const testDetail = this.closest('.test-detail');
        const passedSteps = testDetail.querySelectorAll('.step-row[data-status="PASSED"]');
        
        if (this.checked) {
          passedSteps.forEach(step => step.style.display = 'none');
        } else {
          passedSteps.forEach(step => step.style.display = 'flex');
        }
      });
      
      // Apply initial state
      if (checkbox.checked) {
        const testDetail = checkbox.closest('.test-detail');
        const passedSteps = testDetail.querySelectorAll('.step-row[data-status="PASSED"]');
        passedSteps.forEach(step => step.style.display = 'none');
      }
    });
    
    // Hide passed tests
    const hidePassedTestsCheckbox = document.getElementById('hide-passed-tests');
    if (hidePassedTestsCheckbox) {
      hidePassedTestsCheckbox.addEventListener('change', function() {
        const passedTests = document.querySelectorAll('.test-row[data-status="PASSED"]');
        
        if (this.checked) {
          passedTests.forEach(test => test.style.display = 'none');
        } else {
          passedTests.forEach(test => test.style.display = 'table-row');
        }
      });
      
      // Apply initial state
      if (hidePassedTestsCheckbox.checked) {
        const passedTests = document.querySelectorAll('.test-row[data-status="PASSED"]');
        passedTests.forEach(test => test.style.display = 'none');
      }
    }
    
    // Test search
    const testSearchInput = document.getElementById('test-search');
    if (testSearchInput) {
      testSearchInput.addEventListener('input', function() {
        const searchText = this.value.toLowerCase();
        const testRows = document.querySelectorAll('.test-row');
        
        testRows.forEach(row => {
          const testName = row.querySelector('.test-name').textContent.toLowerCase();
          const testSuite = row.cells[4].textContent.toLowerCase();
          
          if (testName.includes(searchText) || testSuite.includes(searchText)) {
            row.style.display = '';
          } else {
            row.style.display = 'none';
          }
        });
      });
    }
    
    // Status filter
    const statusFilter = document.getElementById('status-filter');
    if (statusFilter) {
      statusFilter.addEventListener('change', function() {
        const status = this.value;
        const testRows = document.querySelectorAll('.test-row');
        
        testRows.forEach(row => {
          const testStatus = row.querySelector('.status').textContent;
          
          if (status === 'ALL' || testStatus === status) {
            row.style.display = '';
          } else {
            row.style.display = 'none';
          }
        });
      });
    }
    
    // Test table sorting
    document.querySelectorAll('.test-table th[data-sort]').forEach(header => {
      header.addEventListener('click', function() {
        const sortBy = this.dataset.sort;
        const tbody = this.closest('table').querySelector('tbody');
        const rows = Array.from(tbody.querySelectorAll('tr'));
        
        // Toggle sort direction
        const currentDirection = this.dataset.direction || 'asc';
        const newDirection = currentDirection === 'asc' ? 'desc' : 'asc';
        
        // Update header direction
        document.querySelectorAll('.test-table th[data-sort]').forEach(th => {
          th.dataset.direction = th === this ? newDirection : '';
          th.classList.remove('sorted-asc', 'sorted-desc');
        });
        
        this.classList.add(newDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
        
        // Sort rows
        rows.sort((rowA, rowB) => {
          let valueA = '';
          let valueB = '';
          
          if (sortBy === 'name') {
            valueA = rowA.querySelector('.test-name').textContent;
            valueB = rowB.querySelector('.test-name').textContent;
          } else if (sortBy === 'status') {
            valueA = rowA.querySelector('.status').textContent;
            valueB = rowB.querySelector('.status').textContent;
          } else if (sortBy === 'duration') {
            valueA = rowA.cells[2].textContent;
            valueB = rowB.cells[2].textContent;
            
            // Convert duration to seconds for sorting
            const getDurationInSeconds = (duration) => {
              const parts = duration.split(':');
              if (parts.length === 3) {
                return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2]);
              } else if (parts.length === 2) {
                return parseInt(parts[0]) * 60 + parseFloat(parts[1]);
              } else {
                return parseFloat(duration);
              }
            };
            
            return newDirection === 'asc' 
              ? getDurationInSeconds(valueA) - getDurationInSeconds(valueB)
              : getDurationInSeconds(valueB) - getDurationInSeconds(valueA);
          } else if (sortBy === 'timestamp') {
            valueA = rowA.cells[3].textContent;
            valueB = rowB.cells[3].textContent;
            
            const dateA = new Date(valueA);
            const dateB = new Date(valueB);
            
            return newDirection === 'asc' ? dateA - dateB : dateB - dateA;
          } else if (sortBy === 'suite') {
            valueA = rowA.cells[4].textContent;
            valueB = rowB.cells[4].textContent;
          } else {
            return 0;
          }
          
          // Use standard string comparison for non-special cases
          if (sortBy !== 'duration' && sortBy !== 'timestamp') {
            return newDirection === 'asc' 
              ? valueA.localeCompare(valueB)
              : valueB.localeCompare(valueA);
          }
          
          return 0;
        });
        
        // Reappend rows in the new order
        rows.forEach(row => tbody.appendChild(row));
      });
    });
    
    // Tabs
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        const tabId = this.dataset.tab;
        const tabContent = document.getElementById(tabId);
        
        // Hide all tab contents in this tab group
        const tabGroup = this.closest('.tabs');
        tabGroup.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        
        // Deactivate all tabs in this tab group
        tabGroup.querySelectorAll('.tab').forEach(t => {
          t.classList.remove('active');
        });
        
        // Activate the selected tab and content
        this.classList.add('active');
        tabContent.classList.add('active');
      });
    });
    
    // Screenshot modal
    const modal = document.getElementById('screenshot-modal');
    const modalImage = document.getElementById('modal-image');
    const modalClose = document.querySelector('.modal-close');
    
    window.openModal = function(src) {
      modal.style.display = 'block';
      modalImage.src = src;
    };
    
    if (modalClose) {
      modalClose.addEventListener('click', function() {
        modal.style.display = 'none';
      });
    }
    
    window.addEventListener('click', function(event) {
      if (event.target === modal) {
        modal.style.display = 'none';
      }
    });
    
    // Initialize charts
    const initCharts = function() {
      // Status chart
      const statusCtx = document.getElementById('status-chart');
      if (statusCtx) {
        const passedTests = ${this.getPassedTestCount()};
        const failedTests = ${this.getFailedTestCount()};
        const skippedTests = ${this.getSkippedTestCount()};
        
        new Chart(statusCtx, {
          type: 'doughnut',
          data: {
            labels: ['Passed', 'Failed', 'Skipped'],
            datasets: [{
              data: [passedTests, failedTests, skippedTests],
              backgroundColor: [
                'var(--status-passed)',
                'var(--status-failed)',
                'var(--status-skipped)'
              ],
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'right'
              }
            }
          }
        });
      }
      
      // Duration chart
      const durationCtx = document.getElementById('duration-chart');
      if (durationCtx) {
        const testNames = ${JSON.stringify(this.getTestNames())};
        const testDurations = ${JSON.stringify(this.getTestDurations())};
        const testStatuses = ${JSON.stringify(this.getTestStatuses())};
        
        const statusColors = {
          'PASSED': 'var(--status-passed)',
          'FAILED': 'var(--status-failed)',
          'SKIPPED': 'var(--status-skipped)',
          'WARNING': 'var(--status-warning)',
          'INFO': 'var(--status-info)',
          'BLOCKED': 'var(--status-blocked)',
          'IN_PROGRESS': 'var(--status-in-progress)',
          'NOT_EXECUTED': 'var(--status-not-executed)'
        };
        
        new Chart(durationCtx, {
          type: 'bar',
          data: {
            labels: testNames,
            datasets: [{
              label: 'Test Duration (seconds)',
              data: testDurations,
              backgroundColor: testStatuses.map(status => statusColors[status]),
              borderWidth: 1
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Duration (seconds)'
                }
              },
              x: {
                title: {
                  display: true,
                  text: 'Test Name'
                }
              }
            }
          }
        });
      }
    };
    
    // Load Chart.js dynamically
    const loadChartJs = function() {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
      script.onload = function() {
        initCharts();
      };
      document.head.appendChild(script);
    };
    
    // Load Chart.js if required
    if (document.getElementById('status-chart') || document.getElementById('duration-chart')) {
      loadChartJs();
    }`;
  }
  
  /**
   * Gets the count of passed tests
   * 
   * @returns Count of passed tests
   */
  private getPassedTestCount(): number {
    return 0; // This will be replaced with the actual count in the template
  }
  
  /**
   * Gets the count of failed tests
   * 
   * @returns Count of failed tests
   */
  private getFailedTestCount(): number {
    return 0; // This will be replaced with the actual count in the template
  }
  
  /**
   * Gets the count of skipped tests
   * 
   * @returns Count of skipped tests
   */
  private getSkippedTestCount(): number {
    return 0; // This will be replaced with the actual count in the template
  }
  
  /**
   * Gets the test names
   * 
   * @returns Array of test names
   */
  private getTestNames(): string[] {
    return []; // This will be replaced with the actual names in the template
  }
  
  /**
   * Gets the test durations in seconds
   * 
   * @returns Array of test durations
   */
  private getTestDurations(): number[] {
    return []; // This will be replaced with the actual durations in the template
  }
  
  /**
   * Gets the test statuses
   * 
   * @returns Array of test statuses
   */
  private getTestStatuses(): string[] {
    return []; // This will be replaced with the actual statuses in the template
  }
  
  /**
   * Gets the status icon for a status
   * 
   * @param status Test status
   * @returns Status icon HTML
   */
  private getStatusIcon(status: CSTestStatus): string {
    switch (status) {
      case CSTestStatus.PASSED:
        return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="var(--status-passed)"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"></path></svg>';
      case CSTestStatus.FAILED:
        return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="var(--status-failed)"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"></path></svg>';
      case CSTestStatus.SKIPPED:
        return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="var(--status-skipped)"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"></path></svg>';
      case CSTestStatus.WARNING:
        return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="var(--status-warning)"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path></svg>';
      case CSTestStatus.INFO:
        return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="var(--status-info)"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"></path></svg>';
      case CSTestStatus.BLOCKED:
        return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="var(--status-blocked)"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z"></path></svg>';
      case CSTestStatus.IN_PROGRESS:
        return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="var(--status-in-progress)"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z"></path></svg>';
      case CSTestStatus.NOT_EXECUTED:
        return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="var(--status-not-executed)"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"></path></svg>';
      default:
        return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"></path></svg>';
    }
  }
  
  /**
   * Formats a duration in milliseconds
   * 
   * @param durationMs Duration in milliseconds
   * @returns Formatted duration
   */
  private formatDuration(durationMs: number): string {
    const seconds = durationMs / 1000;
    
    if (seconds < 60) {
      return `${seconds.toFixed(2)}s`;
    }
    
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    
    if (minutes < 60) {
      return `${minutes}m ${remainingSeconds.toFixed(2)}s`;
    }
    
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    
    return `${hours}h ${remainingMinutes}m ${remainingSeconds.toFixed(2)}s`;
  }
  
  /**
   * Formats a value for display
   * 
   * @param value Value to format
   * @returns Formatted value
   */
  private formatValue(value: any): string {
    if (value === null || value === undefined) {
      return '<span class="null-value">null</span>';
    }
    
    if (typeof value === 'string') {
      return this.textUtils.escapeHtml(value);
    }
    
    if (typeof value === 'number' || typeof value === 'boolean') {
      return String(value);
    }
    
    if (value instanceof Date) {
      return this.dateUtils.formatDate(value, 'yyyy-MM-dd HH:mm:ss.SSS');
    }
    
    if (Array.isArray(value)) {
      return `<pre>${this.textUtils.escapeHtml(JSON.stringify(value, null, 2))}</pre>`;
    }
    
    if (typeof value === 'object') {
      return `<pre>${this.textUtils.escapeHtml(JSON.stringify(value, null, 2))}</pre>`;
    }
    
    return String(value);
  }
  
  /**
   * Formats a byte size
   * 
   * @param bytes Byte size
   * @param decimals Number of decimal places
   * @returns Formatted byte size
   */
  private formatBytes(bytes: number, decimals: number = 2): string {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  }
  
  /**
   * Converts a hex color to RGB
   * 
   * @param hex Hex color
   * @returns RGB color object
   */
  private hexToRgb(hex: string): { r: number; g: number; b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  
  /**
   * Converts RGB values to a hex color
   * 
   * @param r Red component
   * @param g Green component
   * @param b Blue component
   * @returns Hex color
   */
  private rgbToHex(r: number, g: number, b: number): string {
    return "#" + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }).join('');
  }
}


/**
 * CSDashboard.ts
 * 
 * Dashboard generator for the CSTestForge reporting framework.
 * Creates interactive dashboards with charts and metrics for test results.
 */

import { CSTestResult } from '../CSTestResult';
import { CSTestStatus } from '../CSReporter';
import { CSChart } from './CSChart';
import { CSMetric } from './CSMetric';
import { CSLogger } from '../../utils/CSLogger';
import { CSFileUtils } from '../../utils/CSFileUtils';
import { CSDateUtils } from '../../utils/CSDateUtils';
import { CSTextUtils } from '../../utils/CSTextUtils';

/**
 * Dashboard widget configuration
 */
export interface CSWidgetConfig {
  /**
   * Widget ID
   */
  id: string;
  
  /**
   * Widget title
   */
  title: string;
  
  /**
   * Widget type
   */
  type: 'chart' | 'metric' | 'table' | 'list' | 'custom';
  
  /**
   * Chart type (for chart widgets)
   */
  chartType?: 'line' | 'bar' | 'pie' | 'doughnut' | 'area' | 'scatter' | 'radar' | 'heatmap';
  
  /**
   * Data provider function
   */
  dataProvider?: (testResults: CSTestResult[]) => any;
  
  /**
   * Widget width (1-12 grid columns)
   */
  width?: number;
  
  /**
   * Widget height (in pixels)
   */
  height?: number;
  
  /**
   * Widget position (order)
   */
  position?: number;
  
  /**
   * Widget configuration
   */
  config?: Record<string, any>;
  
  /**
   * Custom render function for custom widgets
   */
  renderFunction?: (container: HTMLElement, data: any) => void;
}

/**
 * Dashboard layout configuration
 */
export interface CSDashboardLayoutConfig {
  /**
   * Dashboard title
   */
  title: string;
  
  /**
   * Dashboard description
   */
  description?: string;
  
  /**
   * Dashboard theme
   */
  theme?: 'light' | 'dark';
  
  /**
   * Dashboard widgets
   */
  widgets: CSWidgetConfig[];
  
  /**
   * Number of grid columns
   */
  columns?: number;
  
  /**
   * Grid gap (in pixels)
   */
  gap?: number;
  
  /**
   * Whether to enable widget drag-and-drop
   */
  enableDragDrop?: boolean;
  
  /**
   * Whether to enable widget resizing
   */
  enableResize?: boolean;
  
  /**
   * Whether to enable widget configuration
   */
  enableConfiguration?: boolean;
  
  /**
   * Whether to enable dashboard filtering
   */
  enableFiltering?: boolean;
  
  /**
   * Whether to auto-refresh the dashboard
   */
  autoRefresh?: boolean;
  
  /**
   * Auto-refresh interval (in seconds)
   */
  refreshInterval?: number;
}

/**
 * Class for generating interactive dashboards
 */
export class CSDashboard {
  // Logger
  private logger: CSLogger;
  
  // File utils
  private fileUtils: CSFileUtils;
  
  // Date utils
  private dateUtils: CSDateUtils;
  
  // Text utils
  private textUtils: CSTextUtils;
  
  // Chart generator
  private chartGenerator: CSChart;
  
  // Metric calculator
  private metricCalculator: CSMetric;
  
  // Default dashboard layout
  private static readonly DEFAULT_LAYOUT: CSDashboardLayoutConfig = {
    title: 'CSTestForge Dashboard',
    columns: 12,
    gap: 16,
    enableDragDrop: true,
    enableResize: true,
    enableConfiguration: true,
    enableFiltering: true,
    autoRefresh: false,
    refreshInterval: 60,
    widgets: [
      {
        id: 'test-status-summary',
        title: 'Test Status Summary',
        type: 'chart',
        chartType: 'doughnut',
        width: 4,
        height: 300,
        position: 1,
        dataProvider: (testResults: CSTestResult[]) => {
          const passed = testResults.filter(result => result.status === CSTestStatus.PASSED).length;
          const failed = testResults.filter(result => result.status === CSTestStatus.FAILED).length;
          const skipped = testResults.filter(result => result.status === CSTestStatus.SKIPPED).length;
          const other = testResults.length - passed - failed - skipped;
          
          return {
            labels: ['Passed', 'Failed', 'Skipped', 'Other'],
            datasets: [{
              data: [passed, failed, skipped, other],
              backgroundColor: ['#4caf50', '#f44336', '#ff9800', '#9e9e9e']
            }]
          };
        }
      },
      {
        id: 'test-execution-time',
        title: 'Test Execution Time',
        type: 'chart',
        chartType: 'bar',
        width: 8,
        height: 300,
        position: 2,
        dataProvider: (testResults: CSTestResult[]) => {
          // Sort by duration (descending)
          const sortedResults = [...testResults].sort((a, b) => b.duration - a.duration);
          
          // Take top 10
          const top10 = sortedResults.slice(0, 10);
          
          return {
            labels: top10.map(result => result.name),
            datasets: [{
              label: 'Duration (ms)',
              data: top10.map(result => result.duration),
              backgroundColor: top10.map(result => {
                switch (result.status) {
                  case CSTestStatus.PASSED: return '#4caf50';
                  case CSTestStatus.FAILED: return '#f44336';
                  case CSTestStatus.SKIPPED: return '#ff9800';
                  default: return '#9e9e9e';
                }
              })
            }]
          };
        }
      },
      {
        id: 'pass-rate-metric',
        title: 'Pass Rate',
        type: 'metric',
        width: 3,
        height: 150,
        position: 3,
        dataProvider: (testResults: CSTestResult[]) => {
          const total = testResults.length;
          const passed = testResults.filter(result => result.status === CSTestStatus.PASSED).length;
          const passRate = total > 0 ? (passed / total) * 100 : 0;
          
          return {
            value: passRate.toFixed(2) + '%',
            change: '+0.0%', // Placeholder for trend
            status: passRate >= 90 ? 'success' : passRate >= 70 ? 'warning' : 'danger'
          };
        }
      },
      {
        id: 'total-tests-metric',
        title: 'Total Tests',
        type: 'metric',
        width: 3,
        height: 150,
        position: 4,
        dataProvider: (testResults: CSTestResult[]) => {
          return {
            value: testResults.length.toString(),
            change: '+0', // Placeholder for trend
            status: 'info'
          };
        }
      },
      {
        id: 'average-duration-metric',
        title: 'Avg. Duration',
        type: 'metric',
        width: 3,
        height: 150,
        position: 5,
        dataProvider: (testResults: CSTestResult[]) => {
          const totalDuration = testResults.reduce((sum, result) => sum + result.duration, 0);
          const avgDuration = testResults.length > 0 ? totalDuration / testResults.length : 0;
          
          return {
            value: (avgDuration / 1000).toFixed(2) + 's',
            change: '-0.0s', // Placeholder for trend
            status: 'info'
          };
        }
      },
      {
        id: 'total-duration-metric',
        title: 'Total Duration',
        type: 'metric',
        width: 3,
        height: 150,
        position: 6,
        dataProvider: (testResults: CSTestResult[]) => {
          const totalDuration = testResults.reduce((sum, result) => sum + result.duration, 0);
          const minutes = Math.floor(totalDuration / 60000);
          const seconds = ((totalDuration % 60000) / 1000).toFixed(2);
          
          return {
            value: `${minutes}m ${seconds}s`,
            change: '-0.0s', // Placeholder for trend
            status: 'info'
          };
        }
      },
      {
        id: 'recent-failures-table',
        title: 'Recent Failures',
        type: 'table',
        width: 12,
        height: 300,
        position: 7,
        dataProvider: (testResults: CSTestResult[]) => {
          // Get failed tests
          const failedTests = testResults.filter(result => result.status === CSTestStatus.FAILED);
          
          // Sort by start time (descending)
          const sortedTests = failedTests.sort((a, b) => b.startTime.getTime() - a.startTime.getTime());
          
          // Take top 5
          const recentFailures = sortedTests.slice(0, 5);
          
          return {
            headers: ['Test Name', 'Duration', 'Start Time', 'Error Message'],
            rows: recentFailures.map(test => [
              test.name,
              (test.duration / 1000).toFixed(2) + 's',
              test.startTime.toLocaleString(),
              test.failure?.message || 'Unknown error'
            ])
          };
        }
      }
    ]
  };
  
  /**
   * Constructor
   */
  constructor() {
    this.logger = new CSLogger('CSDashboard');
    this.fileUtils = new CSFileUtils();
    this.dateUtils = new CSDateUtils();
    this.textUtils = new CSTextUtils();
    this.chartGenerator = new CSChart();
    this.metricCalculator = new CSMetric();
  }
  
  /**
   * Generates a dashboard for test results
   * 
   * @param testResults Test results
   * @param outputPath Output file path
   * @param layout Dashboard layout configuration
   * @returns Output file path
   */
  public generateDashboard(
    testResults: CSTestResult[],
    outputPath: string,
    layout?: Partial<CSDashboardLayoutConfig>
  ): string {
    this.logger.info('Generating dashboard...');
    
    try {
      // Merge layout with defaults
      const dashboardLayout: CSDashboardLayoutConfig = {
        ...CSDashboard.DEFAULT_LAYOUT,
        ...layout,
        widgets: [
          ...(layout?.widgets || []),
          ...CSDashboard.DEFAULT_LAYOUT.widgets.filter(
            widget => !layout?.widgets?.some(w => w.id === widget.id)
          )
        ]
      };
      
      // Generate dashboard HTML
      const html = this.generateDashboardHtml(testResults, dashboardLayout);
      
      // Ensure directory exists
      const dir = outputPath.substring(0, outputPath.lastIndexOf('/'));
      this.fileUtils.createDirectory(dir);
      
      // Write HTML to file
      this.fileUtils.writeTextFile(outputPath, html);
      
      this.logger.info(`Dashboard generated: ${outputPath}`);
      
      return outputPath;
    } catch (error) {
      this.logger.error(`Failed to generate dashboard: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to generate dashboard: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Generates dashboard HTML
   * 
   * @param testResults Test results
   * @param layout Dashboard layout configuration
   * @returns Dashboard HTML
   */
  private generateDashboardHtml(
    testResults: CSTestResult[],
    layout: CSDashboardLayoutConfig
  ): string {
    const head = this.generateHead(layout);
    const header = this.generateHeader(layout);
    const widgets = this.generateWidgets(testResults, layout);
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
  ${head}
</head>
<body class="${layout.theme || 'light'}">
  <div class="dashboard-container">
    ${header}
    <main class="dashboard-main">
      <div class="dashboard-grid" style="grid-template-columns: repeat(${layout.columns}, 1fr); gap: ${layout.gap}px;">
        ${widgets}
      </div>
    </main>
    <footer class="dashboard-footer">
      <p>Generated by CSTestForge Dashboard Generator | &copy; ${new Date().getFullYear()} CSTestForge</p>
    </footer>
  </div>
  
  <script>
    ${this.generateJavaScript(layout)}
  </script>
</body>
</html>`;
  }
  
  /**
   * Generates the HTML head
   * 
   * @param layout Dashboard layout configuration
   * @returns HTML head
   */
  private generateHead(layout: CSDashboardLayoutConfig): string {
    return `
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${this.textUtils.escapeHtml(layout.title)}</title>
  <style>
    :root {
      --primary-color: #C54B8C;
      --secondary-color: #9E3F75;
      --tertiary-color: #EB57A7;
      --light-bg: #ffffff;
      --dark-bg: #1e1e1e;
      --light-text: #333333;
      --dark-text: #f5f5f5;
      --light-border: #e0e0e0;
      --dark-border: #444444;
      --light-hover: #f5f5f5;
      --dark-hover: #2a2a2a;
      --success-color: #4caf50;
      --warning-color: #ff9800;
      --danger-color: #f44336;
      --info-color: #2196f3;
    }
    
    /* Base styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      line-height: 1.6;
      font-size: 14px;
    }
    
    body.light {
      background-color: var(--light-bg);
      color: var(--light-text);
    }
    
    body.dark {
      background-color: var(--dark-bg);
      color: var(--dark-text);
    }
    
    .dashboard-container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    
    /* Header styles */
    .dashboard-header {
      background-color: var(--primary-color);
      color: white;
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .dashboard-title {
      font-size: 1.5rem;
      margin: 0;
    }
    
    .dashboard-description {
      font-size: 0.9rem;
      opacity: 0.8;
      margin-top: 0.25rem;
    }
    
    .dashboard-controls {
      display: flex;
      gap: 1rem;
    }
    
    /* Main content styles */
    .dashboard-main {
      flex-grow: 1;
      padding: 1rem;
    }
    
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 16px;
      max-width: 1800px;
      margin: 0 auto;
    }
    
    /* Widget styles */
    .widget {
      background-color: var(--light-bg);
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    .dark .widget {
      background-color: var(--dark-bg);
      border: 1px solid var(--dark-border);
    }
    
    .widget-header {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--light-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .dark .widget-header {
      border-bottom: 1px solid var(--dark-border);
    }
    
    .widget-title {
      font-size: 1rem;
      font-weight: 500;
      margin: 0;
    }
    
    .widget-actions {
      display: flex;
      gap: 0.5rem;
    }
    
    .widget-action {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--light-text);
      opacity: 0.5;
      transition: opacity 0.2s;
    }
    
    .dark .widget-action {
      color: var(--dark-text);
    }
    
    .widget-action:hover {
      opacity: 1;
    }
    
    .widget-content {
      padding: 1rem;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    }
    
    /* Chart widget */
    .chart-container {
      flex-grow: 1;
      position: relative;
    }
    
    /* Metric widget */
    .metric-container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      height: 100%;
    }
    
    .metric-value {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.25rem;
    }
    
    .metric-change {
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    
    .metric-change.positive {
      color: var(--success-color);
    }
    
    .metric-change.negative {
      color: var(--danger-color);
    }
    
    .metric-status-success .metric-value {
      color: var(--success-color);
    }
    
    .metric-status-warning .metric-value {
      color: var(--warning-color);
    }
    
    .metric-status-danger .metric-value {
      color: var(--danger-color);
    }
    
    .metric-status-info .metric-value {
      color: var(--info-color);
    }
    
    /* Table widget */
    .table-container {
      overflow-x: auto;
      height: 100%;
    }
    
    .dashboard-table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .dashboard-table th,
    .dashboard-table td {
      padding: 0.75rem;
      text-align: left;
      border-bottom: 1px solid var(--light-border);
    }
    
    .dark .dashboard-table th,
    .dark .dashboard-table td {
      border-bottom: 1px solid var(--dark-border);
    }
    
    .dashboard-table th {
      font-weight: 500;
    }
    
    .dashboard-table tr:last-child td {
      border-bottom: none;
    }
    
    /* List widget */
    .list-container {
      height: 100%;
      overflow-y: auto;
    }
    
    .dashboard-list {
      list-style: none;
    }
    
    .dashboard-list-item {
      padding: 0.75rem;
      border-bottom: 1px solid var(--light-border);
    }
    
    .dark .dashboard-list-item {
      border-bottom: 1px solid var(--dark-border);
    }
    
    .dashboard-list-item:last-child {
      border-bottom: none;
    }
    
    /* Footer styles */
    .dashboard-footer {
      background-color: var(--primary-color);
      color: white;
      padding: 1rem;
      text-align: center;
      margin-top: 2rem;
    }
    
    /* Responsive styles */
    @media (max-width: 768px) {
      .dashboard-grid {
        grid-template-columns: 1fr;
      }
      
      .widget {
        grid-column: 1 / -1 !important;
      }
    }
  </style>`;
  }
  
  /**
   * Generates the header
   * 
   * @param layout Dashboard layout configuration
   * @returns Header HTML
   */
  private generateHeader(layout: CSDashboardLayoutConfig): string {
    return `
    <header class="dashboard-header">
      <div>
        <h1 class="dashboard-title">${this.textUtils.escapeHtml(layout.title)}</h1>
        ${layout.description ? `<p class="dashboard-description">${this.textUtils.escapeHtml(layout.description)}</p>` : ''}
      </div>
      <div class="dashboard-controls">
        <button id="theme-toggle" class="dashboard-control">Toggle Theme</button>
        ${layout.autoRefresh ? `<button id="refresh-toggle" class="dashboard-control">Auto Refresh: ON</button>` : ''}
      </div>
    </header>`;
  }
  
  /**
   * Generates widgets
   * 
   * @param testResults Test results
   * @param layout Dashboard layout configuration
   * @returns Widgets HTML
   */
  private generateWidgets(
    testResults: CSTestResult[],
    layout: CSDashboardLayoutConfig
  ): string {
    // Sort widgets by position
    const sortedWidgets = [...layout.widgets].sort((a, b) => 
      (a.position || 0) - (b.position || 0)
    );
    
    let widgetsHtml = '';
    
    for (const widget of sortedWidgets) {
      const width = widget.width || 4; // Default to 4 columns
      const height = widget.height || 300; // Default to 300px
      
      let contentHtml = '';
      
      try {
        // Get widget data
        const data = widget.dataProvider ? widget.dataProvider(testResults) : null;
        
        // Generate content based on widget type
        switch (widget.type) {
          case 'chart':
            contentHtml = this.generateChartWidget(widget, data);
            break;
          case 'metric':
            contentHtml = this.generateMetricWidget(widget, data);
            break;
          case 'table':
            contentHtml = this.generateTableWidget(widget, data);
            break;
          case 'list':
            contentHtml = this.generateListWidget(widget, data);
            break;
          case 'custom':
            contentHtml = `<div id="custom-${this.textUtils.escapeHtml(widget.id)}" class="custom-container"></div>`;
            break;
          default:
            contentHtml = '<p>Unknown widget type</p>';
        }
      } catch (error) {
        this.logger.error(`Error generating widget ${widget.id}: ${error instanceof Error ? error.message : String(error)}`);
        contentHtml = `<div class="widget-error">Error generating widget: ${this.textUtils.escapeHtml(error instanceof Error ? error.message : String(error))}</div>`;
      }
      
      widgetsHtml += `
      <div id="widget-${this.textUtils.escapeHtml(widget.id)}" class="widget" style="grid-column: span ${width}; height: ${height}px;">
        <div class="widget-header">
          <h3 class="widget-title">${this.textUtils.escapeHtml(widget.title)}</h3>
          <div class="widget-actions">
            ${layout.enableConfiguration ? '<button class="widget-action widget-configure" title="Configure Widget">⚙️</button>' : ''}
            <button class="widget-action widget-refresh" title="Refresh Widget">🔄</button>
          </div>
        </div>
        <div class="widget-content">
          ${contentHtml}
        </div>
      </div>`;
    }
    
    return widgetsHtml;
  }
  
  /**
   * Generates a chart widget
   * 
   * @param widget Widget configuration
   * @param data Chart data
   * @returns Chart widget HTML
   */
  private generateChartWidget(widget: CSWidgetConfig, data: any): string {
    const chartType = widget.chartType || 'bar';
    const chartId = `chart-${widget.id}`;
    
    return `
    <div class="chart-container">
      <canvas id="${chartId}"></canvas>
      <script>
        window.dashboardData = window.dashboardData || {};
        window.dashboardData['${chartId}'] = ${JSON.stringify(data)};
      </script>
    </div>`;
  }
  
  /**
   * Generates a metric widget
   * 
   * @param widget Widget configuration
   * @param data Metric data
   * @returns Metric widget HTML
   */
  private generateMetricWidget(widget: CSWidgetConfig, data: any): string {
    if (!data) {
      return '<p>No data available</p>';
    }
    
    const value = data.value || '0';
    const change = data.change || '0';
    const status = data.status || 'info';
    const isPositive = change.startsWith('+');
    
    return `
    <div class="metric-container metric-status-${status}">
      <div class="metric-value">${value}</div>
      <div class="metric-change ${isPositive ? 'positive' : 'negative'}">
        ${isPositive ? '▲' : '▼'} ${change}
      </div>
    </div>`;
  }
  
  /**
   * Generates a table widget
   * 
   * @param widget Widget configuration
   * @param data Table data
   * @returns Table widget HTML
   */
  private generateTableWidget(widget: CSWidgetConfig, data: any): string {
    if (!data || !data.headers || !data.rows) {
      return '<p>No data available</p>';
    }
    
    const headers = data.headers.map((header: string) => 
      `<th>${this.textUtils.escapeHtml(header)}</th>`
    ).join('');
    
    const rows = data.rows.map((row: any[]) => {
      const cells = row.map((cell) => 
        `<td>${this.textUtils.escapeHtml(String(cell))}</td>`
      ).join('');
      
      return `<tr>${cells}</tr>`;
    }).join('');
    
    return `
    <div class="table-container">
      <table class="dashboard-table">
        <thead>
          <tr>${headers}</tr>
        </thead>
        <tbody>
          ${rows}
        </tbody>
      </table>
    </div>`;
  }
  
  /**
   * Generates a list widget
   * 
   * @param widget Widget configuration
   * @param data List data
   * @returns List widget HTML
   */
  private generateListWidget(widget: CSWidgetConfig, data: any): string {
    if (!data || !Array.isArray(data.items)) {
      return '<p>No data available</p>';
    }
    
    const items = data.items.map((item: string) => 
      `<li class="dashboard-list-item">${this.textUtils.escapeHtml(item)}</li>`
    ).join('');
    
    return `
    <div class="list-container">
      <ul class="dashboard-list">
        ${items}
      </ul>
    </div>`;
  }
  
  /**
   * Generates JavaScript for the dashboard
   * 
   * @param layout Dashboard layout configuration
   * @returns JavaScript code
   */
  private generateJavaScript(layout: CSDashboardLayoutConfig): string {
    return `
    // Load Chart.js
    function loadChartJs() {
      return new Promise((resolve, reject) => {
        if (window.Chart) {
          resolve(window.Chart);
          return;
        }
        
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js';
        script.integrity = 'sha256-ErZ09KkZnzjpqcane4SCyyHsKAXMvID9/xwbl/Aq1pc=';
        script.crossOrigin = 'anonymous';
        script.onload = () => resolve(window.Chart);
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    
    // Initialize charts
    async function initCharts() {
      try {
        await loadChartJs();
        
        document.querySelectorAll('canvas[id^="chart-"]').forEach(canvas => {
          const chartId = canvas.id;
          const data = window.dashboardData[chartId];
          
          if (!data) return;
          
          const chartType = chartId.split('-')[1];
          let type = 'bar';
          
          if (chartId.includes('doughnut') || chartId.includes('donut')) {
            type = 'doughnut';
          } else if (chartId.includes('pie')) {
            type = 'pie';
          } else if (chartId.includes('line')) {
            type = 'line';
          } else if (chartId.includes('area')) {
            type = 'line'; // Line chart with fill
            if (data.datasets) {
              data.datasets.forEach(dataset => {
                dataset.fill = true;
              });
            }
          } else if (chartId.includes('scatter')) {
            type = 'scatter';
          } else if (chartId.includes('radar')) {
            type = 'radar';
          }
          
          new Chart(canvas, {
            type,
            data,
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: 'bottom'
                }
              }
            }
          });
        });
      } catch (error) {
        console.error('Failed to initialize charts:', error);
      }
    }
    
    // Theme toggle
    function setupThemeToggle() {
      const themeToggle = document.getElementById('theme-toggle');
      if (themeToggle) {
        themeToggle.addEventListener('click', function() {
          document.body.classList.toggle('dark');
          document.body.classList.toggle('light');
          
          // Save theme preference
          const currentTheme = document.body.classList.contains('dark') ? 'dark' : 'light';
          localStorage.setItem('cstestforge-theme', currentTheme);
        });
        
        // Load theme preference
        const savedTheme = localStorage.getItem('cstestforge-theme');
        if (savedTheme) {
          document.body.classList.remove('light', 'dark');
          document.body.classList.add(savedTheme);
        }
      }
    }
    
    // Refresh functionality
    function setupRefresh() {
      const refreshToggle = document.getElementById('refresh-toggle');
      if (refreshToggle) {
        let autoRefreshEnabled = ${layout.autoRefresh ? 'true' : 'false'};
        let refreshInterval = null;
        
        function startAutoRefresh() {
          refreshInterval = setInterval(() => {
            location.reload();
          }, ${(layout.refreshInterval || 60) * 1000});
        }
        
        function stopAutoRefresh() {
          if (refreshInterval) {
            clearInterval(refreshInterval);
            refreshInterval = null;
          }
        }
        
        refreshToggle.addEventListener('click', function() {
          autoRefreshEnabled = !autoRefreshEnabled;
          
          if (autoRefreshEnabled) {
            startAutoRefresh();
            refreshToggle.textContent = 'Auto Refresh: ON';
          } else {
            stopAutoRefresh();
            refreshToggle.textContent = 'Auto Refresh: OFF';
          }
        });
        
        if (autoRefreshEnabled) {
          startAutoRefresh();
        }
      }
      
      // Widget refresh buttons
      document.querySelectorAll('.widget-refresh').forEach(button => {
        button.addEventListener('click', function() {
          const widget = this.closest('.widget');
          // Add refreshing state
          widget.classList.add('refreshing');
          
          // Simulated refresh (in a real implementation, this would fetch new data)
          setTimeout(() => {
            widget.classList.remove('refreshing');
          }, 1000);
        });
      });
    }
    
    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
      initCharts();
      setupThemeToggle();
      setupRefresh();
      
      // Initialize custom widgets
      ${this.generateCustomWidgetInitialization(layout)}
    });
    `;
  }
  
  /**
   * Generates initialization code for custom widgets
   * 
   * @param layout Dashboard layout configuration
   * @returns JavaScript code
   */
  private generateCustomWidgetInitialization(layout: CSDashboardLayoutConfig): string {
    const customWidgets = layout.widgets.filter(widget => widget.type === 'custom');
    
    if (customWidgets.length === 0) {
      return '';
    }
    
    return `
      // Custom widget initialization
      const customWidgets = ${JSON.stringify(customWidgets.map(widget => ({
        id: widget.id,
        config: widget.config || {}
      })))};
      
      for (const widget of customWidgets) {
        const container = document.getElementById('custom-' + widget.id);
        if (container && window.customWidgetRenderers && window.customWidgetRenderers[widget.id]) {
          window.customWidgetRenderers[widget.id](container, widget.config);
        }
      }
    `;
  }
}


/**
 * CSChart.ts
 * 
 * Chart generator for the CSTestForge reporting framework.
 * Creates various types of charts for visualizing test results.
 */

import { CSTestResult } from '../CSTestResult';
import { CSTestStatus, CSLogLevel } from '../CSReporter';
import { CSLogger } from '../../utils/CSLogger';
import { CSFileUtils } from '../../utils/CSFileUtils';
import { CSTextUtils } from '../../utils/CSTextUtils';

/**
 * Chart data configuration
 */
export interface CSChartDataConfig {
  /**
   * Chart labels
   */
  labels: string[];
  
  /**
   * Chart datasets
   */
  datasets: Array<{
    /**
     * Dataset label
     */
    label?: string;
    
    /**
     * Dataset data
     */
    data: Array<number>;
    
    /**
     * Background colors
     */
    backgroundColor?: string | string[];
    
    /**
     * Border colors
     */
    borderColor?: string | string[];
    
    /**
     * Border width
     */
    borderWidth?: number;
    
    /**
     * Point background colors (for line charts)
     */
    pointBackgroundColor?: string | string[];
    
    /**
     * Point radius (for line charts)
     */
    pointRadius?: number;
    
    /**
     * Fill area under line (for line charts)
     */
    fill?: boolean;
    
    /**
     * Tension between points (for line charts)
     */
    tension?: number;
    
    /**
     * Stack ID (for stacked charts)
     */
    stack?: string;
    
    /**
     * Y-axis ID (for charts with multiple axes)
     */
    yAxisID?: string;
    
    /**
     * Additional dataset configuration
     */
    [key: string]: any;
  }>;
}

/**
 * Chart options configuration
 */
export interface CSChartOptions {
  /**
   * Chart title
   */
  title?: {
    /**
     * Title text
     */
    text: string;
    
    /**
     * Display title
     */
    display?: boolean;
    
    /**
     * Title position
     */
    position?: 'top' | 'bottom' | 'left' | 'right';
    
    /**
     * Title font size
     */
    fontSize?: number;
    
    /**
     * Title font color
     */
    color?: string;
  };
  
  /**
   * Chart legend
   */
  legend?: {
    /**
     * Display legend
     */
    display?: boolean;
    
    /**
     * Legend position
     */
    position?: 'top' | 'bottom' | 'left' | 'right';
  };
  
  /**
   * Chart axes
   */
  scales?: {
    /**
     * X axis
     */
    x?: {
      /**
       * Axis title
       */
      title?: {
        /**
         * Title text
         */
        text: string;
        
        /**
         * Display title
         */
        display?: boolean;
      };
      
      /**
       * Axis type
       */
      type?: 'category' | 'linear' | 'logarithmic' | 'time';
      
      /**
       * Axis grid lines
       */
      grid?: {
        /**
         * Display grid lines
         */
        display?: boolean;
      };
      
      /**
       * Stacked axis
       */
      stacked?: boolean;
    };
    
    /**
     * Y axis
     */
    y?: {
      /**
       * Axis title
       */
      title?: {
        /**
         * Title text
         */
        text: string;
        
        /**
         * Display title
         */
        display?: boolean;
      };
      
      /**
       * Begin axis at zero
       */
      beginAtZero?: boolean;
      
      /**
       * Axis type
       */
      type?: 'category' | 'linear' | 'logarithmic' | 'time';
      
      /**
       * Axis grid lines
       */
      grid?: {
        /**
         * Display grid lines
         */
        display?: boolean;
      };
      
      /**
       * Stacked axis
       */
      stacked?: boolean;
    };
  };
  
  /**
   * Make chart responsive
   */
  responsive?: boolean;
  
  /**
   * Maintain aspect ratio
   */
  maintainAspectRatio?: boolean;
  
  /**
   * Additional options
   */
  [key: string]: any;
}

/**
 * Chart generation configuration
 */
export interface CSChartConfig {
  /**
   * Chart type
   */
  type: 'bar' | 'line' | 'pie' | 'doughnut' | 'area' | 'scatter' | 'bubble' | 'radar' | 'polarArea' | 'horizontalBar';
  
  /**
   * Chart data
   */
  data: CSChartDataConfig;
  
  /**
   * Chart options
   */
  options?: CSChartOptions;
  
  /**
   * Chart width
   */
  width?: number;
  
  /**
   * Chart height
   */
  height?: number;
  
  /**
   * Output format (default: 'svg')
   */
  format?: 'svg' | 'png' | 'html';
  
  /**
   * Include scripts for interactivity (only applicable for HTML output)
   */
  interactive?: boolean;
  
  /**
   * Chart theme
   */
  theme?: 'light' | 'dark';
}

/**
 * Class for generating charts
 */
export class CSChart {
  // Logger
  private logger: CSLogger;
  
  // File utils
  private fileUtils: CSFileUtils;
  
  // Text utils
  private textUtils: CSTextUtils;
  
  // Default chart colors
  private static readonly DEFAULT_COLORS = [
    '#4caf50', // Green (pass)
    '#f44336', // Red (fail)
    '#ff9800', // Orange (skip)
    '#9c27b0', // Purple (blocked)
    '#2196f3', // Blue (info)
    '#3f51b5', // Indigo
    '#009688', // Teal
    '#ff5722', // Deep Orange
    '#795548', // Brown
    '#607d8b', // Blue Grey
    '#e91e63', // Pink
    '#9e9e9e'  // Grey
  ];
  
  // Status colors
  private static readonly STATUS_COLORS = {
    [CSTestStatus.PASSED]: '#4caf50',
    [CSTestStatus.FAILED]: '#f44336',
    [CSTestStatus.SKIPPED]: '#ff9800',
    [CSTestStatus.WARNING]: '#ff9800',
    [CSTestStatus.INFO]: '#2196f3',
    [CSTestStatus.BLOCKED]: '#9c27b0',
    [CSTestStatus.IN_PROGRESS]: '#03a9f4',
    [CSTestStatus.NOT_EXECUTED]: '#9e9e9e'
  };
  
  /**
   * Constructor
   */
  constructor() {
    this.logger = new CSLogger('CSChart');
    this.fileUtils = new CSFileUtils();
    this.textUtils = new CSTextUtils();
  }
  
  /**
   * Generates a chart for test results
   * 
   * @param config Chart configuration
   * @param outputPath Output file path
   * @returns Output file path
   */
  public generateChart(config: CSChartConfig, outputPath: string): string {
    this.logger.debug(`Generating ${config.type} chart...`);
    
    try {
      // Set default options
      const options: CSChartOptions = {
        responsive: true,
        maintainAspectRatio: true,
        ...config.options
      };
      
      // Generate chart based on format
      let chartContent = '';
      
      switch (config.format || 'svg') {
        case 'svg':
          chartContent = this.generateSvgChart(config.type, config.data, options, config.width, config.height, config.theme);
          break;
        case 'html':
          chartContent = this.generateHtmlChart(config.type, config.data, options, config.width, config.height, config.theme, config.interactive);
          break;
        case 'png':
          // Not directly supported - would require a browser or Node canvas implementation
          // In a real-world implementation, this would integrate with a rendering engine
          throw new Error('PNG format is not supported in this implementation');
        default:
          throw new Error(`Unsupported format: ${config.format}`);
      }
      
      // Ensure directory exists
      const dir = outputPath.substring(0, outputPath.lastIndexOf('/'));
      this.fileUtils.createDirectory(dir);
      
      // Write chart to file
      this.fileUtils.writeTextFile(outputPath, chartContent);
      
      this.logger.debug(`Chart generated: ${outputPath}`);
      
      return outputPath;
    } catch (error) {
      this.logger.error(`Failed to generate chart: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to generate chart: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Creates a status distribution chart for test results
   * 
   * @param testResults Test results
   * @param outputPath Output file path
   * @param format Output format
   * @returns Output file path
   */
  public createStatusDistributionChart(
    testResults: CSTestResult[],
    outputPath: string,
    format: 'svg' | 'html' = 'svg'
  ): string {
    // Count test results by status
    const statusCounts = new Map<CSTestStatus, number>();
    
    for (const status of Object.values(CSTestStatus)) {
      statusCounts.set(status as CSTestStatus, 0);
    }
    
    for (const result of testResults) {
      const count = statusCounts.get(result.status) || 0;
      statusCounts.set(result.status, count + 1);
    }
    
    // Create labels and data
    const labels: string[] = [];
    const data: number[] = [];
    const colors: string[] = [];
    
    for (const [status, count] of statusCounts.entries()) {
      if (count > 0) {
        labels.push(status);
        data.push(count);
        colors.push(CSChart.STATUS_COLORS[status] || '#9e9e9e');
      }
    }
    
    // Create chart configuration
    const config: CSChartConfig = {
      type: 'doughnut',
      data: {
        labels,
        datasets: [{
          data,
          backgroundColor: colors,
          borderWidth: 1
        }]
      },
      options: {
        title: {
          text: 'Test Status Distribution',
          display: true
        }
      },
      format
    };
    
    return this.generateChart(config, outputPath);
  }
  
  /**
   * Creates a duration chart for test results
   * 
   * @param testResults Test results
   * @param outputPath Output file path
   * @param format Output format
   * @param limit Maximum number of tests to include
   * @returns Output file path
   */
  public createDurationChart(
    testResults: CSTestResult[],
    outputPath: string,
    format: 'svg' | 'html' = 'svg',
    limit: number = 10
  ): string {
    // Sort by duration (descending)
    const sortedResults = [...testResults].sort((a, b) => b.duration - a.duration);
    
    // Take top N
    const limitedResults = sortedResults.slice(0, limit);
    
    // Create labels and data
    const labels = limitedResults.map(result => result.name);
    const data = limitedResults.map(result => result.duration / 1000); // Convert to seconds
    const colors = limitedResults.map(result => CSChart.STATUS_COLORS[result.status] || '#9e9e9e');
    
    // Create chart configuration
    const config: CSChartConfig = {
      type: 'bar',
      data: {
        labels,
        datasets: [{
          label: 'Duration (seconds)',
          data,
          backgroundColor: colors,
          borderWidth: 1
        }]
      },
      options: {
        title: {
          text: 'Test Duration',
          display: true
        },
        scales: {
          y: {
            beginAtZero: true,
            title: {
              text: 'Duration (seconds)',
              display: true
            }
          },
          x: {
            title: {
              text: 'Test Name',
              display: true
            }
          }
        }
      },
      format
    };
    
    return this.generateChart(config, outputPath);
  }
  
  /**
   * Creates a step count chart for test results
   * 
   * @param testResults Test results
   * @param outputPath Output file path
   * @param format Output format
   * @param limit Maximum number of tests to include
   * @returns Output file path
   */
  public createStepCountChart(
    testResults: CSTestResult[],
    outputPath: string,
    format: 'svg' | 'html' = 'svg',
    limit: number = 10
  ): string {
    // Sort by step count (descending)
    const sortedResults = [...testResults].sort((a, b) => b.steps.length - a.steps.length);
    
    // Take top N
    const limitedResults = sortedResults.slice(0, limit);
    
    // Create labels and data
    const labels = limitedResults.map(result => result.name);
    const passedSteps = limitedResults.map(result => result.getPassedStepsCount());
    const failedSteps = limitedResults.map(result => result.getFailedStepsCount());
    const skippedSteps = limitedResults.map(result => result.getSkippedStepsCount());
    const otherSteps = limitedResults.map(result => 
      result.steps.length - result.getPassedStepsCount() - result.getFailedStepsCount() - result.getSkippedStepsCount()
    );
    
    // Create chart configuration
    const config: CSChartConfig = {
      type: 'bar',
      data: {
        labels,
        datasets: [
          {
            label: 'Passed Steps',
            data: passedSteps,
            backgroundColor: CSChart.STATUS_COLORS[CSTestStatus.PASSED],
            stack: 'Stack 0'
          },
          {
            label: 'Failed Steps',
            data: failedSteps,
            backgroundColor: CSChart.STATUS_COLORS[CSTestStatus.FAILED],
            stack: 'Stack 0'
          },
          {
            label: 'Skipped Steps',
            data: skippedSteps,
            backgroundColor: CSChart.STATUS_COLORS[CSTestStatus.SKIPPED],
            stack: 'Stack 0'
          },
          {
            label: 'Other Steps',
            data: otherSteps,
            backgroundColor: '#9e9e9e', // Grey
            stack: 'Stack 0'
          }
        ]
      },
      options: {
        title: {
          text: 'Test Step Count',
          display: true
        },
        scales: {
          y: {
            beginAtZero: true,
            stacked: true,
            title: {
              text: 'Number of Steps',
              display: true
            }
          },
          x: {
            stacked: true,
            title: {
              text: 'Test Name',
              display: true
            }
          }
        }
      },
      format
    };
    
    return this.generateChart(config, outputPath);
  }
  
  /**
   * Creates a timeline chart for test results
   * 
   * @param testResults Test results
   * @param outputPath Output file path
   * @param format Output format
   * @returns Output file path
   */
  public createTimelineChart(
    testResults: CSTestResult[],
    outputPath: string,
    format: 'svg' | 'html' = 'svg'
  ): string {
    // Sort by start time
    const sortedResults = [...testResults].sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
    
    // Get earliest and latest time
    if (sortedResults.length === 0) {
      throw new Error('No test results to create timeline chart');
    }
    
    const earliestTime = sortedResults[0].startTime.getTime();
    const latestEndTime = Math.max(...sortedResults.map(r => r.endTime ? r.endTime.getTime() : r.startTime.getTime() + r.duration));
    
    // Create timeline data
    const labels = sortedResults.map(result => result.name);
    const datasets = [
      {
        label: 'Test Execution Timeline',
        data: sortedResults.map(result => ({
          x: result.startTime.getTime() - earliestTime, // Start offset from earliest time
          y: labels.indexOf(result.name),
          duration: result.duration
        })),
        backgroundColor: sortedResults.map(result => CSChart.STATUS_COLORS[result.status] || '#9e9e9e')
      }
    ];
    
    // Create chart configuration - note that in a real implementation,
    // we would use a proper timeline chart type or plugin, but for this
    // implementation, we're using a horizontal bar chart as an approximation
    const config: CSChartConfig = {
      type: 'horizontalBar',
      data: {
        labels,
        datasets: [{
          label: 'Duration',
          data: sortedResults.map(result => result.duration / 1000), // Convert to seconds
          backgroundColor: sortedResults.map(result => CSChart.STATUS_COLORS[result.status] || '#9e9e9e')
        }]
      },
      options: {
        title: {
          text: 'Test Execution Timeline',
          display: true
        },
        scales: {
          x: {
            beginAtZero: true,
            title: {
              text: 'Duration (seconds)',
              display: true
            }
          }
        }
      },
      format
    };
    
    return this.generateChart(config, outputPath);
  }
  
  /**
   * Creates a log level distribution chart for test results
   * 
   * @param testResults Test results
   * @param outputPath Output file path
   * @param format Output format
   * @returns Output file path
   */
  public createLogLevelChart(
    testResults: CSTestResult[],
    outputPath: string,
    format: 'svg' | 'html' = 'svg'
  ): string {
    // Count logs by level
    const logCounts = new Map<CSLogLevel, number>();
    
    for (const level of Object.values(CSLogLevel)) {
      logCounts.set(level as CSLogLevel, 0);
    }
    
    for (const result of testResults) {
      for (const log of result.logs) {
        const count = logCounts.get(log.level) || 0;
        logCounts.set(log.level, count + 1);
      }
    }
    
    // Create labels and data
    const labels: string[] = [];
    const data: number[] = [];
    const colors: string[] = [];
    
    // Define log level colors
    const logLevelColors = {
      [CSLogLevel.ERROR]: '#f44336', // Red
      [CSLogLevel.FATAL]: '#d32f2f', // Dark Red
      [CSLogLevel.WARNING]: '#ff9800', // Orange
      [CSLogLevel.INFO]: '#2196f3', // Blue
      [CSLogLevel.DEBUG]: '#4caf50', // Green
      [CSLogLevel.TRACE]: '#9e9e9e' // Grey
    };
    
    for (const [level, count] of logCounts.entries()) {
      if (count > 0) {
        labels.push(level);
        data.push(count);
        colors.push(logLevelColors[level] || '#9e9e9e');
      }
    }
    
    // Create chart configuration
    const config: CSChartConfig = {
      type: 'pie',
      data: {
        labels,
        datasets: [{
          data,
          backgroundColor: colors,
          borderWidth: 1
        }]
      },
      options: {
        title: {
          text: 'Log Level Distribution',
          display: true
        }
      },
      format
    };
    
    return this.generateChart(config, outputPath);
  }
  
  /**
   * Creates a pass rate trend chart
   * 
   * @param testResultSets Multiple sets of test results for different time periods
   * @param labels Labels for each set of results
   * @param outputPath Output file path
   * @param format Output format
   * @returns Output file path
   */
  public createPassRateTrendChart(
    testResultSets: CSTestResult[][],
    labels: string[],
    outputPath: string,
    format: 'svg' | 'html' = 'svg'
  ): string {
    // Calculate pass rates for each set
    const passRates = testResultSets.map(results => {
      const total = results.length;
      if (total === 0) return 0;
      
      const passed = results.filter(result => result.status === CSTestStatus.PASSED).length;
      return (passed / total) * 100;
    });
    
    // Create chart configuration
    const config: CSChartConfig = {
      type: 'line',
      data: {
        labels,
        datasets: [{
          label: 'Pass Rate (%)',
          data: passRates,
          backgroundColor: 'rgba(76, 175, 80, 0.2)', // Light green
          borderColor: '#4caf50', // Green
          borderWidth: 2,
          pointBackgroundColor: '#4caf50',
          pointRadius: 4,
          fill: true,
          tension: 0.3
        }]
      },
      options: {
        title: {
          text: 'Pass Rate Trend',
          display: true
        },
        scales: {
          y: {
            beginAtZero: true,
            title: {
              text: 'Pass Rate (%)',
              display: true
            }
          }
        }
      },
      format
    };
    
    return this.generateChart(config, outputPath);
  }
  
  /**
   * Generates an SVG chart
   * 
   * @param type Chart type
   * @param data Chart data
   * @param options Chart options
   * @param width Chart width
   * @param height Chart height
   * @param theme Chart theme
   * @returns SVG chart content
   */
  private generateSvgChart(
    type: string,
    data: CSChartDataConfig,
    options: CSChartOptions,
    width?: number,
    height?: number,
    theme?: 'light' | 'dark'
  ): string {
    // This is a simplified implementation that generates a basic SVG chart
    // In a real implementation, this would use a proper charting library
    // or canvas rendering, but for this implementation, we'll create a basic
    // representation
    
    const w = width || 800;
    const h = height || 400;
    const padding = 40;
    const chartWidth = w - (padding * 2);
    const chartHeight = h - (padding * 2);
    
    const isDarkTheme = theme === 'dark';
    const backgroundColor = isDarkTheme ? '#1e1e1e' : '#ffffff';
    const textColor = isDarkTheme ? '#f5f5f5' : '#333333';
    const gridColor = isDarkTheme ? '#444444' : '#e0e0e0';
    
    let chartContent = '';
    
    switch (type) {
      case 'pie':
      case 'doughnut':
        chartContent = this.generateSvgPieChart(data, chartWidth, chartHeight, type === 'doughnut');
        break;
      case 'bar':
      case 'horizontalBar':
        chartContent = this.generateSvgBarChart(data, chartWidth, chartHeight, type === 'horizontalBar');
        break;
      case 'line':
      case 'area':
        chartContent = this.generateSvgLineChart(data, chartWidth, chartHeight, type === 'area');
        break;
      default:
        chartContent = `<text x="${w/2}" y="${h/2}" text-anchor="middle" fill="${textColor}">
          Chart type '${type}' is not supported in SVG output
        </text>`;
    }
    
    const title = options.title?.text 
      ? `<text x="${w/2}" y="20" text-anchor="middle" font-weight="bold" fill="${textColor}">
           ${this.textUtils.escapeHtml(options.title.text)}
         </text>` 
      : '';
    
    return `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg">
  <rect width="${w}" height="${h}" fill="${backgroundColor}" />
  ${title}
  <g transform="translate(${padding}, ${padding})">
    ${chartContent}
  </g>
</svg>`;
  }
  
  /**
   * Generates an SVG pie/doughnut chart
   * 
   * @param data Chart data
   * @param width Chart width
   * @param height Chart height
   * @param isDoughnut Whether to create a doughnut chart
   * @returns SVG chart content
   */
  private generateSvgPieChart(
    data: CSChartDataConfig,
    width: number,
    height: number,
    isDoughnut: boolean
  ): string {
    const dataset = data.datasets[0];
    if (!dataset || !dataset.data || dataset.data.length === 0) {
      return '';
    }
    
    const radius = Math.min(width, height) / 2;
    const cx = width / 2;
    const cy = height / 2;
    const innerRadius = isDoughnut ? radius * 0.5 : 0;
    
    // Calculate total
    const total = dataset.data.reduce((sum, value) => sum + value, 0);
    
    // Calculate slice angles
    let startAngle = 0;
    const slices: Array<{
      startAngle: number;
      endAngle: number;
      color: string;
      value: number;
      label: string;
    }> = [];
    
    dataset.data.forEach((value, i) => {
      const angle = (value / total) * (Math.PI * 2);
      const endAngle = startAngle + angle;
      const color = Array.isArray(dataset.backgroundColor) 
        ? dataset.backgroundColor[i] || CSChart.DEFAULT_COLORS[i % CSChart.DEFAULT_COLORS.length]
        : (dataset.backgroundColor || CSChart.DEFAULT_COLORS[i % CSChart.DEFAULT_COLORS.length]);
      
      slices.push({
        startAngle,
        endAngle,
        color,
        value,
        label: data.labels[i] || `Slice ${i+1}`
      });
      
      startAngle = endAngle;
    });
    
    // Generate SVG path elements for slices
    let paths = '';
    let labels = '';
    
    slices.forEach((slice, i) => {
      // Calculate path coordinates
      const startX = cx + Math.cos(slice.startAngle) * radius;
      const startY = cy + Math.sin(slice.startAngle) * radius;
      const endX = cx + Math.cos(slice.endAngle) * radius;
      const endY = cy + Math.sin(slice.endAngle) * radius;
      
      const startX2 = cx + Math.cos(slice.startAngle) * innerRadius;
      const startY2 = cy + Math.sin(slice.startAngle) * innerRadius;
      const endX2 = cx + Math.cos(slice.endAngle) * innerRadius;
      const endY2 = cy + Math.sin(slice.endAngle) * innerRadius;
      
      const largeArcFlag = slice.endAngle - slice.startAngle > Math.PI ? 1 : 0;
      
      // Create slice path
      let path = '';
      
      if (isDoughnut) {
        // Doughnut slice with inner and outer arcs
        path = `M ${startX} ${startY} ` + // Move to start point
               `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY} ` + // Outer arc
               `L ${endX2} ${endY2} ` + // Line to inner radius
               `A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${startX2} ${startY2} ` + // Inner arc (reverse direction)
               `Z`; // Close path
      } else {
        // Regular pie slice
        path = `M ${cx} ${cy} ` + // Move to center
               `L ${startX} ${startY} ` + // Line to start point
               `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY} ` + // Arc
               `Z`; // Close path back to center
      }
      
      // Add path to SVG
      paths += `<path d="${path}" fill="${slice.color}" stroke="white" stroke-width="1" />`;
      
      // Calculate label position (middle of the slice)
      const midAngle = (slice.startAngle + slice.endAngle) / 2;
      const labelRadius = radius * 0.7; // Position label at 70% of radius
      const labelX = cx + Math.cos(midAngle) * labelRadius;
      const labelY = cy + Math.sin(midAngle) * labelRadius;
      
      // Add label if slice is large enough
      const slicePercentage = (slice.value / total) * 100;
      if (slicePercentage >= 5) { // Only show label if slice is at least 5%
        labels += `<text x="${labelX}" y="${labelY}" text-anchor="middle" fill="white" font-size="12" font-weight="bold">
                    ${slicePercentage.toFixed(1)}%
                  </text>`;
      }
    });
    
    // Generate legend
    let legend = '';
    const legendItemHeight = 20;
    const legendX = width - 120;
    const legendY = 10;
    
    slices.forEach((slice, i) => {
      const itemY = legendY + (i * legendItemHeight);
      
      legend += `
        <rect x="${legendX}" y="${itemY}" width="12" height="12" fill="${slice.color}" />
        <text x="${legendX + 20}" y="${itemY + 10}" font-size="12" fill="black">${this.textUtils.escapeHtml(slice.label)} (${slice.value})</text>
      `;
    });
    
    return `${paths}${labels}
            <g class="legend">${legend}</g>`;
  }
  
  /**
   * Generates an SVG bar chart
   * 
   * @param data Chart data
   * @param width Chart width
   * @param height Chart height
   * @param isHorizontal Whether to create a horizontal bar chart
   * @returns SVG chart content
   */
  private generateSvgBarChart(
    data: CSChartDataConfig,
    width: number,
    height: number,
    isHorizontal: boolean
  ): string {
    const dataset = data.datasets[0];
    if (!dataset || !dataset.data || dataset.data.length === 0) {
      return '';
    }
    
    const labels = data.labels || [];
    const values = dataset.data;
    const barCount = values.length;
    
    // Calculate dimensions
    const chartWidth = isHorizontal ? width - 100 : width;
    const chartHeight = isHorizontal ? height : height - 60;
    const maxValue = Math.max(...values);
    const padding = 0.2; // Padding between bars as a percentage of bar width
    
    if (isHorizontal) {
      // Horizontal bar chart
      const barHeight = chartHeight / (barCount * (1 + padding));
      const gap = barHeight * padding;
      
      let bars = '';
      let axisLabels = '';
      
      values.forEach((value, i) => {
        const y = i * (barHeight + gap);
        const barWidth = (value / maxValue) * chartWidth;
        const color = Array.isArray(dataset.backgroundColor) 
          ? dataset.backgroundColor[i] || CSChart.DEFAULT_COLORS[i % CSChart.DEFAULT_COLORS.length]
          : (dataset.backgroundColor || CSChart.DEFAULT_COLORS[i % CSChart.DEFAULT_COLORS.length]);
        
        bars += `<rect x="0" y="${y}" width="${barWidth}" height="${barHeight}" fill="${color}" />`;
        bars += `<text x="${barWidth + 5}" y="${y + barHeight/2 + 5}" font-size="12" fill="black">${value}</text>`;
        
        // Y-axis labels (test names)
        axisLabels += `<text x="-5" y="${y + barHeight/2 + 5}" text-anchor="end" font-size="12" fill="black">
                          ${this.textUtils.escapeHtml(labels[i] || `Item ${i+1}`)}
                        </text>`;
      });
      
      // X-axis
      const xAxis = `<line x1="0" y1="${chartHeight}" x2="${chartWidth}" y2="${chartHeight}" stroke="black" stroke-width="1" />`;
      
      // X-axis ticks
      let xTicks = '';
      const tickCount = 5;
      for (let i = 0; i <= tickCount; i++) {
        const x = (i / tickCount) * chartWidth;
        const tickValue = Math.round((i / tickCount) * maxValue);
        xTicks += `
          <line x1="${x}" y1="${chartHeight}" x2="${x}" y2="${chartHeight + 5}" stroke="black" stroke-width="1" />
          <text x="${x}" y="${chartHeight + 20}" text-anchor="middle" font-size="12" fill="black">${tickValue}</text>
        `;
      }
      
      return `<g transform="translate(60, 0)">
                ${xAxis}${xTicks}
                ${bars}
                ${axisLabels}
              </g>`;
    } else {
      // Vertical bar chart
      const barWidth = chartWidth / (barCount * (1 + padding));
      const gap = barWidth * padding;
      
      let bars = '';
      let axisLabels = '';
      
      values.forEach((value, i) => {
        const x = i * (barWidth + gap);
        const barHeight = (value / maxValue) * chartHeight;
        const y = chartHeight - barHeight;
        const color = Array.isArray(dataset.backgroundColor) 
          ? dataset.backgroundColor[i] || CSChart.DEFAULT_COLORS[i % CSChart.DEFAULT_COLORS.length]
          : (dataset.backgroundColor || CSChart.DEFAULT_COLORS[i % CSChart.DEFAULT_COLORS.length]);
        
        bars += `<rect x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="${color}" />`;
        bars += `<text x="${x + barWidth/2}" y="${y - 5}" text-anchor="middle" font-size="12" fill="black">${value}</text>`;
        
        // X-axis labels
        axisLabels += `<text x="${x + barWidth/2}" y="${chartHeight + 20}" text-anchor="middle" font-size="12" fill="black" 
                        transform="rotate(45, ${x + barWidth/2}, ${chartHeight + 20})" style="max-width: ${barWidth*2}px">
                        ${this.textUtils.escapeHtml(labels[i] || `Item ${i+1}`)}
                      </text>`;
      });
      
      // X and Y axes
      const axes = `
        <line x1="0" y1="${chartHeight}" x2="${chartWidth}" y2="${chartHeight}" stroke="black" stroke-width="1" />
        <line x1="0" y1="0" x2="0" y2="${chartHeight}" stroke="black" stroke-width="1" />
      `;
      
      // Y-axis ticks
      let yTicks = '';
      const tickCount = 5;
      for (let i = 0; i <= tickCount; i++) {
        const y = chartHeight - (i / tickCount) * chartHeight;
        const tickValue = Math.round((i / tickCount) * maxValue);
        yTicks += `
          <line x1="0" y1="${y}" x2="-5" y2="${y}" stroke="black" stroke-width="1" />
          <text x="-10" y="${y + 5}" text-anchor="end" font-size="12" fill="black">${tickValue}</text>
        `;
      }
      
      return `${axes}${yTicks}
              ${bars}
              ${axisLabels}`;
    }
  }
  
  /**
   * Generates an SVG line chart
   * 
   * @param data Chart data
   * @param width Chart width
   * @param height Chart height
   * @param isArea Whether to create an area chart
   * @returns SVG chart content
   */
  private generateSvgLineChart(
    data: CSChartDataConfig,
    width: number,
    height: number,
    isArea: boolean
  ): string {
    const dataset = data.datasets[0];
    if (!dataset || !dataset.data || dataset.data.length === 0) {
      return '';
    }
    
    const labels = data.labels || [];
    const values = dataset.data;
    const pointCount = values.length;
    
    // Calculate dimensions
    const chartWidth = width - 60;
    const chartHeight = height - 40;
    const maxValue = Math.max(...values);
    const minValue = Math.min(0, ...values); // Ensure we include 0 in the range
    const valueRange = maxValue - minValue;
    
    // Calculate point positions
    const points = values.map((value, i) => ({
      x: (i / (pointCount - 1)) * chartWidth,
      y: chartHeight - ((value - minValue) / valueRange) * chartHeight
    }));
    
    // Generate path
    let path = 'M ' + points.map(p => `${p.x} ${p.y}`).join(' L ');
    
    // For area chart, add points to close the path
    if (isArea) {
      path += ` L ${chartWidth} ${chartHeight} L 0 ${chartHeight} Z`;
    }
    
    const lineColor = dataset.borderColor || CSChart.DEFAULT_COLORS[0];
    const fillColor = isArea 
      ? (dataset.backgroundColor || `${lineColor}33`) // 33 is 20% opacity in hex
      : 'none';
    
    const strokeWidth = dataset.borderWidth || 2;
    
    // Draw points
    let pointsStr = '';
    points.forEach((point, i) => {
      const pointColor = dataset.pointBackgroundColor || lineColor;
      const pointRadius = dataset.pointRadius || 4;
      
      pointsStr += `<circle cx="${point.x}" cy="${point.y}" r="${pointRadius}" fill="${pointColor}" />`;
      
      // Add value label above each point
      pointsStr += `<text x="${point.x}" y="${point.y - 15}" text-anchor="middle" font-size="12" fill="black">${values[i]}</text>`;
    });
    
    // X and Y axes
    const axes = `
      <line x1="0" y1="${chartHeight}" x2="${chartWidth}" y2="${chartHeight}" stroke="black" stroke-width="1" />
      <line x1="0" y1="0" x2="0" y2="${chartHeight}" stroke="black" stroke-width="1" />
    `;
    
    // Y-axis ticks
    let yTicks = '';
    const tickCount = 5;
    for (let i = 0; i <= tickCount; i++) {
      const y = chartHeight - (i / tickCount) * chartHeight;
      const tickValue = Math.round(minValue + (i / tickCount) * valueRange);
      yTicks += `
        <line x1="0" y1="${y}" x2="-5" y2="${y}" stroke="black" stroke-width="1" />
        <text x="-10" y="${y + 5}" text-anchor="end" font-size="12" fill="black">${tickValue}</text>
      `;
    }
    
    // X-axis labels
    let xLabels = '';
    // If we have less than 10 labels, show all of them
    const labelInterval = Math.ceil(labels.length / 10);
    
    points.forEach((point, i) => {
      if (i % labelInterval === 0 || i === points.length - 1) {
        xLabels += `<text x="${point.x}" y="${chartHeight + 20}" text-anchor="middle" font-size="12" fill="black">
                      ${this.textUtils.escapeHtml(labels[i] || `Point ${i+1}`)}
                    </text>`;
      }
    });
    
    return `<g transform="translate(40, 10)">
              ${axes}${yTicks}
              <path d="${path}" fill="${fillColor}" stroke="${lineColor}" stroke-width="${strokeWidth}" />
              ${pointsStr}
              ${xLabels}
            </g>`;
  }
  
  /**
   * Generates an HTML chart
   * 
   * @param type Chart type
   * @param data Chart data
   * @param options Chart options
   * @param width Chart width
   * @param height Chart height
   * @param theme Chart theme
   * @param interactive Whether to include scripts for interactivity
   * @returns HTML chart content
   */
  private generateHtmlChart(
    type: string,
    data: CSChartDataConfig,
    options: CSChartOptions,
    width?: number,
    height?: number,
    theme?: 'light' | 'dark',
    interactive: boolean = true
  ): string {
    const w = width || 800;
    const h = height || 400;
    const isDarkTheme = theme === 'dark';
    const backgroundColor = isDarkTheme ? '#1e1e1e' : '#ffffff';
    const textColor = isDarkTheme ? '#f5f5f5' : '#333333';
    
    const chartId = `chart-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    
    let chartType = type;
    
    // Map our chart types to Chart.js types
    if (type === 'area') {
      chartType = 'line';
      if (data.datasets) {
        data.datasets.forEach(dataset => {
          dataset.fill = true;
        });
      }
    } else if (type === 'horizontalBar') {
      // Chart.js v3+ uses 'bar' with 'indexAxis: y' for horizontal bars
      chartType = 'bar';
      if (!options.indexAxis) {
        options.indexAxis = 'y';
      }
    }
    
    const chartConfig = {
      type: chartType,
      data,
      options
    };
    
    // Convert chart configuration to JSON with proper escaping
    const chartConfigJson = JSON.stringify(chartConfig)
      .replace(/</g, '\\u003c')
      .replace(/>/g, '\\u003e')
      .replace(/&/g, '\\u0026')
      .replace(/'/g, '\\u0027')
      .replace(/"/g, '\\"');
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CSTestForge Chart</title>
  <style>
    body {
      background-color: ${backgroundColor};
      color: ${textColor};
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      margin: 0;
      padding: 20px;
    }
    
    .chart-container {
      width: ${w}px;
      height: ${h}px;
      margin: 0 auto;
    }
  </style>
  ${interactive ? '<script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>' : ''}
</head>
<body>
  <div class="chart-container">
    <canvas id="${chartId}"></canvas>
  </div>
  
  ${interactive ? `<script>
    // Initialize chart
    document.addEventListener('DOMContentLoaded', function() {
      const ctx = document.getElementById('${chartId}').getContext('2d');
      const config = JSON.parse("${chartConfigJson}");
      new Chart(ctx, config);
    });
  </script>` : ''}
</body>
</html>`;
  }
}


/**
 * CSMetric.ts
 * 
 * Metric calculator for the CSTestForge reporting framework.
 * Calculates various metrics from test results for reporting and analysis.
 */

import { CSTestResult } from '../CSTestResult';
import { CSTestStep } from '../CSTestStep';
import { CSTestStatus, CSLogLevel } from '../CSReporter';
import { CSLogger } from '../../utils/CSLogger';

/**
 * Metric value with context
 */
export interface CSMetricValue {
  /**
   * Metric name
   */
  name: string;
  
  /**
   * Metric value
   */
  value: number;
  
  /**
   * Metric unit
   */
  unit?: string;
  
  /**
   * Metric description
   */
  description?: string;
  
  /**
   * Metric status
   */
  status?: 'success' | 'warning' | 'danger' | 'info';
  
  /**
   * Threshold for warning status
   */
  warningThreshold?: number;
  
  /**
   * Threshold for danger status
   */
  dangerThreshold?: number;
  
  /**
   * Whether higher values are better
   */
  higherIsBetter?: boolean;
  
  /**
   * Previous value for comparison
   */
  previousValue?: number;
  
  /**
   * Change from previous value
   */
  change?: number;
  
  /**
   * Change percentage from previous value
   */
  changePercentage?: number;
  
  /**
   * Metric trend direction
   */
  trend?: 'up' | 'down' | 'stable';
  
  /**
   * Metric category
   */
  category?: string;
  
  /**
   * Additional metric data
   */
  data?: any;
}

/**
 * Metric calculation options
 */
export interface CSMetricOptions {
  /**
   * Test results to compare against
   */
  previousResults?: CSTestResult[];
  
  /**
   * Warning threshold (0-100 for percentages)
   */
  warningThreshold?: number;
  
  /**
   * Danger threshold (0-100 for percentages)
   */
  dangerThreshold?: number;
  
  /**
   * Whether to include detailed metrics
   */
  detailed?: boolean;
  
  /**
   * Time period for performance metrics
   */
  timePeriod?: 'day' | 'week' | 'month' | 'quarter' | 'year';
  
  /**
   * Metrics to include (default: all)
   */
  include?: string[];
  
  /**
   * Metrics to exclude
   */
  exclude?: string[];
}

/**
 * Class for calculating metrics from test results
 */
export class CSMetric {
  // Logger
  private logger: CSLogger;
  
  /**
   * Constructor
   */
  constructor() {
    this.logger = new CSLogger('CSMetric');
  }
  
  /**
   * Calculates metrics from test results
   * 
   * @param testResults Test results
   * @param options Metric calculation options
   * @returns Calculated metrics
   */
  public calculateMetrics(
    testResults: CSTestResult[],
    options?: CSMetricOptions
  ): Map<string, CSMetricValue> {
    this.logger.debug('Calculating metrics from test results...');
    
    const metrics = new Map<string, CSMetricValue>();
    
    try {
      // Basic metrics
      this.calculateBasicMetrics(testResults, metrics, options);
      
      // Performance metrics
      this.calculatePerformanceMetrics(testResults, metrics, options);
      
      // Quality metrics
      this.calculateQualityMetrics(testResults, metrics, options);
      
      // Stability metrics
      this.calculateStabilityMetrics(testResults, metrics, options);
      
      // Compare with previous results
      if (options?.previousResults) {
        this.compareWithPreviousResults(metrics, options.previousResults, testResults);
      }
      
      // Filter metrics if needed
      if (options?.include || options?.exclude) {
        this.filterMetrics(metrics, options.include, options.exclude);
      }
      
      this.logger.debug(`Calculated ${metrics.size} metrics`);
      
      return metrics;
    } catch (error) {
      this.logger.error(`Error calculating metrics: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Error calculating metrics: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Calculates basic metrics
   * 
   * @param testResults Test results
   * @param metrics Metrics map to populate
   * @param options Metric calculation options
   */
  private calculateBasicMetrics(
    testResults: CSTestResult[],
    metrics: Map<string, CSMetricValue>,
    options?: CSMetricOptions
  ): void {
    // Total tests
    const totalTests = testResults.length;
    metrics.set('totalTests', {
      name: 'Total Tests',
      value: totalTests,
      unit: 'tests',
      description: 'Total number of tests executed',
      status: 'info',
      category: 'basic'
    });
    
    // Passed tests
    const passedTests = testResults.filter(r => r.status === CSTestStatus.PASSED).length;
    metrics.set('passedTests', {
      name: 'Passed Tests',
      value: passedTests,
      unit: 'tests',
      description: 'Number of passed tests',
      status: 'success',
      category: 'basic'
    });
    
    // Failed tests
    const failedTests = testResults.filter(r => r.status === CSTestStatus.FAILED).length;
    metrics.set('failedTests', {
      name: 'Failed Tests',
      value: failedTests,
      unit: 'tests',
      description: 'Number of failed tests',
      status: 'danger',
      category: 'basic'
    });
    
    // Skipped tests
    const skippedTests = testResults.filter(r => r.status === CSTestStatus.SKIPPED).length;
    metrics.set('skippedTests', {
      name: 'Skipped Tests',
      value: skippedTests,
      unit: 'tests',
      description: 'Number of skipped tests',
      status: 'warning',
      category: 'basic'
    });
    
    // Other tests
    const otherTests = totalTests - passedTests - failedTests - skippedTests;
    metrics.set('otherTests', {
      name: 'Other Tests',
      value: otherTests,
      unit: 'tests',
      description: 'Number of tests with other statuses',
      status: 'info',
      category: 'basic'
    });
    
    // Pass rate
    const passRate = totalTests > 0 ? (passedTests / totalTests) * 100 : 0;
    
    // Determine status based on thresholds
    let passRateStatus: 'success' | 'warning' | 'danger' | 'info' = 'info';
    const warningThreshold = options?.warningThreshold !== undefined ? options.warningThreshold : 80;
    const dangerThreshold = options?.dangerThreshold !== undefined ? options.dangerThreshold : 60;
    
    if (passRate >= warningThreshold) {
      passRateStatus = 'success';
    } else if (passRate >= dangerThreshold) {
      passRateStatus = 'warning';
    } else {
      passRateStatus = 'danger';
    }
    
    metrics.set('passRate', {
      name: 'Pass Rate',
      value: passRate,
      unit: '%',
      description: 'Percentage of tests that passed',
      status: passRateStatus,
      warningThreshold,
      dangerThreshold,
      higherIsBetter: true,
      category: 'basic'
    });
    
    // Total steps
    const totalSteps = testResults.reduce((sum, r) => sum + r.steps.length, 0);
    metrics.set('totalSteps', {
      name: 'Total Steps',
      value: totalSteps,
      unit: 'steps',
      description: 'Total number of test steps executed',
      status: 'info',
      category: 'basic'
    });
    
    // Passed steps
    const passedSteps = testResults.reduce((sum, r) => sum + r.getPassedStepsCount(), 0);
    metrics.set('passedSteps', {
      name: 'Passed Steps',
      value: passedSteps,
      unit: 'steps',
      description: 'Number of passed test steps',
      status: 'success',
      category: 'basic'
    });
    
    // Failed steps
    const failedSteps = testResults.reduce((sum, r) => sum + r.getFailedStepsCount(), 0);
    metrics.set('failedSteps', {
      name: 'Failed Steps',
      value: failedSteps,
      unit: 'steps',
      description: 'Number of failed test steps',
      status: 'danger',
      category: 'basic'
    });
    
    // Total duration
    const totalDuration = testResults.reduce((sum, r) => sum + r.duration, 0);
    metrics.set('totalDuration', {
      name: 'Total Duration',
      value: totalDuration,
      unit: 'ms',
      description: 'Total execution time of all tests',
      status: 'info',
      category: 'basic'
    });
    
    // Average duration
    const avgDuration = totalTests > 0 ? totalDuration / totalTests : 0;
    metrics.set('averageDuration', {
      name: 'Average Duration',
      value: avgDuration,
      unit: 'ms',
      description: 'Average execution time per test',
      status: 'info',
      category: 'basic'
    });
    
    // Total step count
    const totalStepCount = testResults.reduce((sum, r) => sum + r.steps.length, 0);
    metrics.set('totalStepCount', {
      name: 'Total Step Count',
      value: totalStepCount,
      unit: 'steps',
      description: 'Total number of steps across all tests',
      status: 'info',
      category: 'basic'
    });
    
    // Average steps per test
    const avgSteps = totalTests > 0 ? totalStepCount / totalTests : 0;
    metrics.set('averageSteps', {
      name: 'Average Steps',
      value: avgSteps,
      unit: 'steps/test',
      description: 'Average number of steps per test',
      status: 'info',
      category: 'basic'
    });
  }
  
  /**
   * Calculates performance metrics
   * 
   * @param testResults Test results
   * @param metrics Metrics map to populate
   * @param options Metric calculation options
   */
  private calculatePerformanceMetrics(
    testResults: CSTestResult[],
    metrics: Map<string, CSMetricValue>,
    options?: CSMetricOptions
  ): void {
    // Collect performance metrics from test results
    const loadTimes: number[] = [];
    const responseTimes: number[] = [];
    const cpuUsages: number[] = [];
    const memoryUsages: number[] = [];
    
    for (const result of testResults) {
      if (result.metrics.loadTime !== undefined) {
        loadTimes.push(result.metrics.loadTime);
      }
      
      if (result.metrics.responseTime !== undefined) {
        responseTimes.push(result.metrics.responseTime);
      }
      
      if (result.metrics.cpuUsage !== undefined) {
        cpuUsages.push(result.metrics.cpuUsage);
      }
      
      if (result.metrics.memoryUsage !== undefined) {
        memoryUsages.push(result.metrics.memoryUsage);
      }
    }
    
    // Average load time
    if (loadTimes.length > 0) {
      const avgLoadTime = loadTimes.reduce((sum, time) => sum + time, 0) / loadTimes.length;
      metrics.set('averageLoadTime', {
        name: 'Average Load Time',
        value: avgLoadTime,
        unit: 'ms',
        description: 'Average page load time',
        status: 'info',
        higherIsBetter: false,
        category: 'performance'
      });
    }
    
    // Average response time
    if (responseTimes.length > 0) {
      const avgResponseTime = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;
      metrics.set('averageResponseTime', {
        name: 'Average Response Time',
        value: avgResponseTime,
        unit: 'ms',
        description: 'Average server response time',
        status: 'info',
        higherIsBetter: false,
        category: 'performance'
      });
    }
    
    // Average CPU usage
    if (cpuUsages.length > 0) {
      const avgCpuUsage = cpuUsages.reduce((sum, usage) => sum + usage, 0) / cpuUsages.length;
      metrics.set('averageCpuUsage', {
        name: 'Average CPU Usage',
        value: avgCpuUsage,
        unit: '%',
        description: 'Average CPU usage during tests',
        status: 'info',
        higherIsBetter: false,
        category: 'performance'
      });
    }
    
    // Average memory usage
    if (memoryUsages.length > 0) {
      const avgMemoryUsage = memoryUsages.reduce((sum, usage) => sum + usage, 0) / memoryUsages.length;
      metrics.set('averageMemoryUsage', {
        name: 'Average Memory Usage',
        value: avgMemoryUsage,
        unit: 'MB',
        description: 'Average memory usage during tests',
        status: 'info',
        higherIsBetter: false,
        category: 'performance'
      });
    }
    
    // Test execution rate
    const totalDuration = testResults.reduce((sum, r) => sum + r.duration, 0);
    const durationInMinutes = totalDuration / 60000; // Convert ms to minutes
    const executionRate = durationInMinutes > 0 ? testResults.length / durationInMinutes : 0;
    
    metrics.set('executionRate', {
      name: 'Execution Rate',
      value: executionRate,
      unit: 'tests/min',
      description: 'Number of tests executed per minute',
      status: 'info',
      higherIsBetter: true,
      category: 'performance'
    });
    
    // Step execution rate
    const totalSteps = testResults.reduce((sum, r) => sum + r.steps.length, 0);
    const stepExecutionRate = durationInMinutes > 0 ? totalSteps / durationInMinutes : 0;
    
    metrics.set('stepExecutionRate', {
      name: 'Step Execution Rate',
      value: stepExecutionRate,
      unit: 'steps/min',
      description: 'Number of steps executed per minute',
      status: 'info',
      higherIsBetter: true,
      category: 'performance'
    });
  }
  
  /**
   * Calculates quality metrics
   * 
   * @param testResults Test results
   * @param metrics Metrics map to populate
   * @param options Metric calculation options
   */
  private calculateQualityMetrics(
    testResults: CSTestResult[],
    metrics: Map<string, CSMetricValue>,
    options?: CSMetricOptions
  ): void {
    // Failed test percentage
    const totalTests = testResults.length;
    const failedTests = testResults.filter(r => r.status === CSTestStatus.FAILED).length;
    const failureRate = totalTests > 0 ? (failedTests / totalTests) * 100 : 0;
    
    // Determine status based on thresholds (inverse of pass rate)
    let failureRateStatus: 'success' | 'warning' | 'danger' | 'info' = 'info';
    const warningThreshold = 100 - (options?.warningThreshold !== undefined ? options.warningThreshold : 80);
    const dangerThreshold = 100 - (options?.dangerThreshold !== undefined ? options.dangerThreshold : 60);
    
    if (failureRate <= warningThreshold) {
      failureRateStatus = 'success';
    } else if (failureRate <= dangerThreshold) {
      failureRateStatus = 'warning';
    } else {
      failureRateStatus = 'danger';
    }
    
    metrics.set('failureRate', {
      name: 'Failure Rate',
      value: failureRate,
      unit: '%',
      description: 'Percentage of tests that failed',
      status: failureRateStatus,
      warningThreshold,
      dangerThreshold,
      higherIsBetter: false,
      category: 'quality'
    });
    
    // Average assertions per test
    let totalAssertions = 0;
    for (const result of testResults) {
      for (const step of result.steps) {
        if (step.assertion) {
          totalAssertions++;
        }
      }
    }
    
    const avgAssertions = totalTests > 0 ? totalAssertions / totalTests : 0;
    metrics.set('averageAssertions', {
      name: 'Average Assertions',
      value: avgAssertions,
      unit: 'assertions/test',
      description: 'Average number of assertions per test',
      status: 'info',
      higherIsBetter: true,
      category: 'quality'
    });
    
    // Error rate (percentage of steps with errors)
    const totalSteps = testResults.reduce((sum, r) => sum + r.steps.length, 0);
    let stepsWithErrors = 0;
    
    for (const result of testResults) {
      for (const step of result.steps) {
        if (step.error) {
          stepsWithErrors++;
        }
      }
    }
    
    const errorRate = totalSteps > 0 ? (stepsWithErrors / totalSteps) * 100 : 0;
    
    let errorRateStatus: 'success' | 'warning' | 'danger' | 'info' = 'info';
    const errorWarningThreshold = 5; // 5% error rate warning
    const errorDangerThreshold = 10; // 10% error rate danger
    
    if (errorRate <= errorWarningThreshold) {
      errorRateStatus = 'success';
    } else if (errorRate <= errorDangerThreshold) {
      errorRateStatus = 'warning';
    } else {
      errorRateStatus = 'danger';
    }
    
    metrics.set('errorRate', {
      name: 'Error Rate',
      value: errorRate,
      unit: '%',
      description: 'Percentage of steps with errors',
      status: errorRateStatus,
      warningThreshold: errorWarningThreshold,
      dangerThreshold: errorDangerThreshold,
      higherIsBetter: false,
      category: 'quality'
    });
    
    // Step failure rate
    const failedSteps = testResults.reduce((sum, r) => sum + r.getFailedStepsCount(), 0);
    const stepFailureRate = totalSteps > 0 ? (failedSteps / totalSteps) * 100 : 0;
    
    let stepFailureRateStatus: 'success' | 'warning' | 'danger' | 'info' = 'info';
    const stepFailureWarningThreshold = 5; // 5% step failure warning
    const stepFailureDangerThreshold = 10; // 10% step failure danger
    
    if (stepFailureRate <= stepFailureWarningThreshold) {
      stepFailureRateStatus = 'success';
    } else if (stepFailureRate <= stepFailureDangerThreshold) {
      stepFailureRateStatus = 'warning';
    } else {
      stepFailureRateStatus = 'danger';
    }
    
    metrics.set('stepFailureRate', {
      name: 'Step Failure Rate',
      value: stepFailureRate,
      unit: '%',
      description: 'Percentage of steps that failed',
      status: stepFailureRateStatus,
      warningThreshold: stepFailureWarningThreshold,
      dangerThreshold: stepFailureDangerThreshold,
      higherIsBetter: false,
      category: 'quality'
    });
    
    // Critical failure rate (tests with critical failures)
    const criticalFailures = testResults.filter(r => 
      r.status === CSTestStatus.FAILED && 
      (r.failure?.message?.toLowerCase().includes('critical') || 
       r.logs.some(log => 
         log.level === CSLogLevel.ERROR && 
         log.message.toLowerCase().includes('critical')
       ))
    ).length;
    
    const criticalFailureRate = totalTests > 0 ? (criticalFailures / totalTests) * 100 : 0;
    
    let criticalFailureRateStatus: 'success' | 'warning' | 'danger' | 'info' = 'info';
    const criticalFailureWarningThreshold = 1; // 1% critical failure warning
    const criticalFailureDangerThreshold = 5; // 5% critical failure danger
    
    if (criticalFailureRate <= criticalFailureWarningThreshold) {
      criticalFailureRateStatus = 'success';
    } else if (criticalFailureRate <= criticalFailureDangerThreshold) {
      criticalFailureRateStatus = 'warning';
    } else {
      criticalFailureRateStatus = 'danger';
    }
    
    metrics.set('criticalFailureRate', {
      name: 'Critical Failure Rate',
      value: criticalFailureRate,
      unit: '%',
      description: 'Percentage of tests with critical failures',
      status: criticalFailureRateStatus,
      warningThreshold: criticalFailureWarningThreshold,
      dangerThreshold: criticalFailureDangerThreshold,
      higherIsBetter: false,
      category: 'quality'
    });
  }
  
  /**
   * Calculates stability metrics
   * 
   * @param testResults Test results
   * @param metrics Metrics map to populate
   * @param options Metric calculation options
   */
  private calculateStabilityMetrics(
    testResults: CSTestResult[],
    metrics: Map<string, CSMetricValue>,
    options?: CSMetricOptions
  ): void {
    // Flaky test rate (tests with retries)
    const totalTests = testResults.length;
    const testsWithRetries = testResults.filter(r => r.retryCount > 0).length;
    const flakyTestRate = totalTests > 0 ? (testsWithRetries / totalTests) * 100 : 0;
    
    let flakyTestRateStatus: 'success' | 'warning' | 'danger' | 'info' = 'info';
    const flakyTestWarningThreshold = 5; // 5% flaky test warning
    const flakyTestDangerThreshold = 10; // 10% flaky test danger
    
    if (flakyTestRate <= flakyTestWarningThreshold) {
      flakyTestRateStatus = 'success';
    } else if (flakyTestRate <= flakyTestDangerThreshold) {
      flakyTestRateStatus = 'warning';
    } else {
      flakyTestRateStatus = 'danger';
    }
    
    metrics.set('flakyTestRate', {
      name: 'Flaky Test Rate',
      value: flakyTestRate,
      unit: '%',
      description: 'Percentage of tests that required retries',
      status: flakyTestRateStatus,
      warningThreshold: flakyTestWarningThreshold,
      dangerThreshold: flakyTestDangerThreshold,
      higherIsBetter: false,
      category: 'stability'
    });
    
    // Average retry count
    const totalRetries = testResults.reduce((sum, r) => sum + r.retryCount, 0);
    const avgRetries = totalTests > 0 ? totalRetries / totalTests : 0;
    
    metrics.set('averageRetries', {
      name: 'Average Retries',
      value: avgRetries,
      unit: 'retries/test',
      description: 'Average number of retries per test',
      status: 'info',
      higherIsBetter: false,
      category: 'stability'
    });
    
    // Step duration variability
    // Calculate coefficient of variation for step durations
    const stepDurations: number[] = [];
    for (const result of testResults) {
      for (const step of result.steps) {
        stepDurations.push(step.duration);
      }
    }
    
    if (stepDurations.length > 0) {
      const avgStepDuration = stepDurations.reduce((sum, d) => sum + d, 0) / stepDurations.length;
      
      // Calculate standard deviation
      const squaredDiffs = stepDurations.map(d => Math.pow(d - avgStepDuration, 2));
      const variance = squaredDiffs.reduce((sum, d) => sum + d, 0) / stepDurations.length;
      const stdDev = Math.sqrt(variance);
      
      // Coefficient of variation (CV) as a percentage
      const cv = (stdDev / avgStepDuration) * 100;
      
      let cvStatus: 'success' | 'warning' | 'danger' | 'info' = 'info';
      const cvWarningThreshold = 50; // 50% CV warning
      const cvDangerThreshold = 100; // 100% CV danger
      
      if (cv <= cvWarningThreshold) {
        cvStatus = 'success';
      } else if (cv <= cvDangerThreshold) {
        cvStatus = 'warning';
      } else {
        cvStatus = 'danger';
      }
      
      metrics.set('stepDurationVariability', {
        name: 'Step Duration Variability',
        value: cv,
        unit: '%',
        description: 'Coefficient of variation for step durations',
        status: cvStatus,
        warningThreshold: cvWarningThreshold,
        dangerThreshold: cvDangerThreshold,
        higherIsBetter: false,
        category: 'stability'
      });
    }
    
    // Test pattern failures
    // Tests that fail at a consistent step
    const testPatterns = new Map<string, Map<number, number>>();
    
    for (const result of testResults) {
      if (result.status === CSTestStatus.FAILED) {
        // Get the index of the first failed step
        const firstFailedStepIndex = result.steps.findIndex(step => step.status === CSTestStatus.FAILED);
        
        if (firstFailedStepIndex !== -1) {
          if (!testPatterns.has(result.name)) {
            testPatterns.set(result.name, new Map<number, number>());
          }
          
          const testPattern = testPatterns.get(result.name)!;
          const count = testPattern.get(firstFailedStepIndex) || 0;
          testPattern.set(firstFailedStepIndex, count + 1);
        }
      }
    }
    
    // Count tests with consistent failure patterns
    let testsWithConsistentFailures = 0;
    for (const [testName, failurePattern] of testPatterns.entries()) {
      // If a test has failed multiple times at the same step
      for (const [stepIndex, count] of failurePattern.entries()) {
        if (count > 1) {
          testsWithConsistentFailures++;
          break;
        }
      }
    }
    
    // Calculate rate of tests with consistent failure patterns
    const consistentFailureRate = totalTests > 0 ? (testsWithConsistentFailures / totalTests) * 100 : 0;
    
    metrics.set('consistentFailureRate', {
      name: 'Consistent Failure Rate',
      value: consistentFailureRate,
      unit: '%',
      description: 'Percentage of tests with consistent failure patterns',
      status: 'info',
      higherIsBetter: false,
      category: 'stability'
    });
  }
  
  /**
   * Compares current metrics with previous results
   * 
   * @param metrics Metrics map to update
   * @param previousResults Previous test results
   * @param currentResults Current test results
   */
  private compareWithPreviousResults(
    metrics: Map<string, CSMetricValue>,
    previousResults: CSTestResult[],
    currentResults: CSTestResult[]
  ): void {
    // Calculate metrics for previous results
    const previousMetrics = new Map<string, CSMetricValue>();
    this.calculateBasicMetrics(previousResults, previousMetrics);
    this.calculatePerformanceMetrics(previousResults, previousMetrics);
    this.calculateQualityMetrics(previousResults, previousMetrics);
    this.calculateStabilityMetrics(previousResults, previousMetrics);
    
    // Compare and update metrics
    for (const [key, metric] of metrics.entries()) {
      const previousMetric = previousMetrics.get(key);
      
      if (previousMetric) {
        const previousValue = previousMetric.value;
        const currentValue = metric.value;
        const change = currentValue - previousValue;
        
        // Calculate change percentage
        const changePercentage = previousValue !== 0 ? (change / previousValue) * 100 : 0;
        
        // Determine trend
        let trend: 'up' | 'down' | 'stable' = 'stable';
        
        if (Math.abs(changePercentage) < 1) {
          trend = 'stable';
        } else if (changePercentage > 0) {
          trend = 'up';
        } else {
          trend = 'down';
        }
        
        // Update metric with comparison data
        metrics.set(key, {
          ...metric,
          previousValue,
          change,
          changePercentage,
          trend
        });
      }
    }
  }
  
  /**
   * Filters metrics based on include/exclude lists
   * 
   * @param metrics Metrics map to filter
   * @param include Metrics to include
   * @param exclude Metrics to exclude
   */
  private filterMetrics(
    metrics: Map<string, CSMetricValue>,
    include?: string[],
    exclude?: string[]
  ): void {
    if (include && include.length > 0) {
      // Keep only included metrics
      for (const key of Array.from(metrics.keys())) {
        if (!include.includes(key)) {
          metrics.delete(key);
        }
      }
    }
    
    if (exclude && exclude.length > 0) {
      // Remove excluded metrics
      for (const key of exclude) {
        metrics.delete(key);
      }
    }
  }
  
  /**
   * Formats a metric value for display
   * 
   * @param metric Metric to format
   * @returns Formatted metric value
   */
  public formatMetricValue(metric: CSMetricValue): string {
    const { value, unit } = metric;
    
    if (unit === '%') {
      return `${value.toFixed(2)}%`;
    } else if (unit === 'ms') {
      if (value > 1000) {
        return `${(value / 1000).toFixed(2)}s`;
      }
      return `${value.toFixed(0)}ms`;
    } else if (unit === 'MB') {
      return `${value.toFixed(2)} MB`;
    } else if (value % 1 === 0) {
      return `${value.toFixed(0)}${unit ? ` ${unit}` : ''}`;
    } else {
      return `${value.toFixed(2)}${unit ? ` ${unit}` : ''}`;
    }
  }
  
  /**
   * Exports metrics to a JSON file
   * 
   * @param metrics Metrics to export
   * @param filePath Output file path
   * @returns Output file path
   */
  public exportMetricsToJson(metrics: Map<string, CSMetricValue>, filePath: string): string {
    // Convert metrics map to object
    const metricsObject: Record<string, CSMetricValue> = {};
    
    for (const [key, metric] of metrics.entries()) {
      metricsObject[key] = metric;
    }
    
    try {
      // Ensure directory exists
      const dir = filePath.substring(0, filePath.lastIndexOf('/'));
      this.fileUtils.createDirectory(dir);
      
      // Write metrics to file
      this.fileUtils.writeJsonFile(filePath, metricsObject);
      
      this.logger.debug(`Metrics exported to: ${filePath}`);
      
      return filePath;
    } catch (error) {
      this.logger.error(`Failed to export metrics: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Failed to export metrics: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Gets metric categories
   * 
   * @param metrics Metrics map
   * @returns Array of unique categories
   */
  public getMetricCategories(metrics: Map<string, CSMetricValue>): string[] {
    const categories = new Set<string>();
    
    for (const metric of metrics.values()) {
      if (metric.category) {
        categories.add(metric.category);
      }
    }
    
    return Array.from(categories);
  }
  
  /**
   * Gets metrics by category
   * 
   * @param metrics Metrics map
   * @param category Category to filter by
   * @returns Filtered metrics map
   */
  public getMetricsByCategory(metrics: Map<string, CSMetricValue>, category: string): Map<string, CSMetricValue> {
    const filteredMetrics = new Map<string, CSMetricValue>();
    
    for (const [key, metric] of metrics.entries()) {
      if (metric.category === category) {
        filteredMetrics.set(key, metric);
      }
    }
    
    return filteredMetrics;
  }
}


/**
 * CSTestListener.ts
 * 
 * Test listener for the CSTestForge reporting framework.
 * Listens for test events and updates reports accordingly.
 */

import { CSTestResult } from '../CSTestResult';
import { CSTestStep } from '../CSTestStep';
import { CSTestStatus, CSLogLevel, CSReporter } from '../CSReporter';
import { CSLogger } from '../../utils/CSLogger';
import { CSFileUtils } from '../../utils/CSFileUtils';
import { CSScreenshotManager } from '../../utils/CSScreenshotManager';

/**
 * Event data for test start event
 */
export interface CSTestStartEventData {
  /**
   * Test name
   */
  testName: string;
  
  /**
   * Test suite name
   */
  suiteName?: string;
  
  /**
   * Test description
   */
  description?: string;
  
  /**
   * Test tags
   */
  tags?: string[];
  
  /**
   * Test start time
   */
  startTime: Date;
  
  /**
   * Additional test data
   */
  [key: string]: any;
}

/**
 * Event data for test end event
 */
export interface CSTestEndEventData {
  /**
   * Test name
   */
  testName: string;
  
  /**
   * Test status
   */
  status: CSTestStatus;
  
  /**
   * Status message
   */
  message?: string;
  
  /**
   * Test end time
   */
  endTime: Date;
  
  /**
   * Test duration
   */
  duration?: number;
  
  /**
   * Test failure
   */
  failure?: {
    /**
     * Error message
     */
    message: string;
    
    /**
     * Error stack trace
     */
    stackTrace?: string;
    
    /**
     * Error type
     */
    type?: string;
  };
  
  /**
   * Additional test data
   */
  [key: string]: any;
}

/**
 * Event data for test step event
 */
export interface CSTestStepEventData {
  /**
   * Test name
   */
  testName: string;
  
  /**
   * Step name
   */
  stepName: string;
  
  /**
   * Step description
   */
  description?: string;
  
  /**
   * Step status
   */
  status: CSTestStatus;
  
  /**
   * Step start time
   */
  startTime: Date;
  
  /**
   * Step end time
   */
  endTime?: Date;
  
  /**
   * Step duration
   */
  duration?: number;
  
  /**
   * Step action type
   */
  actionType?: string;
  
  /**
   * Step parameters
   */
  parameters?: Record<string, any>;
  
  /**
   * Step assertion
   */
  assertion?: {
    /**
     * Assertion type
     */
    type: string;
    
    /**
     * Expected value
     */
    expected: any;
    
    /**
     * Actual value
     */
    actual: any;
    
    /**
     * Whether the assertion passed
     */
    passed: boolean;
    
    /**
     * Assertion message
     */
    message?: string;
  };
  
  /**
   * Step error
   */
  error?: {
    /**
     * Error message
     */
    message: string;
    
    /**
     * Error stack trace
     */
    stackTrace?: string;
    
    /**
     * Error type
     */
    type?: string;
  };
  
  /**
   * Element selector
   */
  selector?: string;
  
  /**
   * Element locator
   */
  locator?: {
    /**
     * Locator type (e.g., 'css', 'xpath', 'id')
     */
    type: string;
    
    /**
     * Locator value
     */
    value: string;
  };
  
  /**
   * Parent step ID
   */
  parentStepId?: string;
  
  /**
   * Additional step data
   */
  [key: string]: any;
}

/**
 * Event data for log event
 */
export interface CSLogEventData {
  /**
   * Test name
   */
  testName: string;
  
  /**
   * Log level
   */
  level: CSLogLevel;
  
  /**
   * Log message
   */
  message: string;
  
  /**
   * Log timestamp
   */
  timestamp: Date;
  
  /**
   * Additional details
   */
  details?: any;
}

/**
 * Event data for screenshot event
 */
export interface CSScreenshotEventData {
  /**
   * Test name
   */
  testName: string;
  
  /**
   * Screenshot path
   */
  path: string;
  
  /**
   * Screenshot timestamp
   */
  timestamp: Date;
  
  /**
   * Screenshot description
   */
  description?: string;
  
  /**
   * Step name (if associated with a step)
   */
  stepName?: string;
}

/**
 * Test listener options
 */
export interface CSTestListenerOptions {
  /**
   * Reporter instance
   */
  reporter?: CSReporter;
  
  /**
   * Output directory for reports
   */
  outputDir?: string;
  
  /**
   * Whether to save screenshots
   */
  saveScreenshots?: boolean;
  
  /**
   * Screenshot directory
   */
  screenshotDir?: string;
  
  /**
   * Whether to take screenshots on test failures
   */
  screenshotOnFailure?: boolean;
  
  /**
   * Whether to take screenshots on step failures
   */
  screenshotOnStepFailure?: boolean;
  
  /**
   * Screenshot quality (0-100)
   */
  screenshotQuality?: number;
  
  /**
   * Whether to include full page in screenshots
   */
  fullPageScreenshots?: boolean;
  
  /**
   * Maximum number of screenshots per test
   */
  maxScreenshotsPerTest?: number;
  
  /**
   * Event handlers
   */
  handlers?: {
    /**
     * Test start handler
     */
    onTestStart?: (event: CSTestStartEventData) => void;
    
    /**
     * Test end handler
     */
    onTestEnd?: (event: CSTestEndEventData, result: CSTestResult) => void;
    
    /**
     * Test step handler
     */
    onTestStep?: (event: CSTestStepEventData) => void;
    
    /**
     * Log handler
     */
    onLog?: (event: CSLogEventData) => void;
    
    /**
     * Screenshot handler
     */
    onScreenshot?: (event: CSScreenshotEventData) => void;
  };
}

/**
 * Class for listening to test events and updating reports
 */
export class CSTestListener {
  // Logger
  private logger: CSLogger;
  
  // Reporter
  private reporter: CSReporter | null;
  
  // File utils
  private fileUtils: CSFileUtils;
  
  // Screenshot manager
  private screenshotManager: CSScreenshotManager;
  
  // Options
  private options: CSTestListenerOptions;
  
  // Current test
  private currentTest: string | null = null;
  
  // Screenshot count for current test
  private screenshotCount: number = 0;
  
  // Event handlers
  private handlers: {
    onTestStart?: (event: CSTestStartEventData) => void;
    onTestEnd?: (event: CSTestEndEventData, result: CSTestResult) => void;
    onTestStep?: (event: CSTestStepEventData) => void;
    onLog?: (event: CSLogEventData) => void;
    onScreenshot?: (event: CSScreenshotEventData) => void;
  };
  
  // Default options
  private static readonly DEFAULT_OPTIONS: CSTestListenerOptions = {
    outputDir: './reports',
    saveScreenshots: true,
    screenshotDir: './reports/screenshots',
    screenshotOnFailure: true,
    screenshotOnStepFailure: true,
    screenshotQuality: 80,
    fullPageScreenshots: false,
    maxScreenshotsPerTest: 20
  };
  
  /**
   * Constructor
   * 
   * @param options Test listener options
   */
  constructor(options?: CSTestListenerOptions) {
    this.logger = new CSLogger('CSTestListener');
    this.fileUtils = new CSFileUtils();
    this.screenshotManager = new CSScreenshotManager();
    
    // Merge options with defaults
    this.options = {
      ...CSTestListener.DEFAULT_OPTIONS,
      ...options
    };
    
    // Store reporter
    this.reporter = options?.reporter || null;
    
    // Store handlers
    this.handlers = options?.handlers || {};
    
    // Create output directory
    this.createOutputDirectory();
  }
  
  /**
   * Creates output directory
   */
  private createOutputDirectory(): void {
    try {
      // Create output directory
      if (this.options.outputDir) {
        this.fileUtils.createDirectory(this.options.outputDir);
      }
      
      // Create screenshot directory
      if (this.options.saveScreenshots && this.options.screenshotDir) {
        this.fileUtils.createDirectory(this.options.screenshotDir);
      }
      
      this.logger.debug('Output directories created');
    } catch (error) {
      this.logger.error(`Failed to create output directories: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Handles test start event
   * 
   * @param event Test start event data
   */
  public onTestStart(event: CSTestStartEventData): void {
    this.logger.debug(`Test started: ${event.testName}`);
    
    try {
      // Reset screenshot count
      this.screenshotCount = 0;
      
      // Store current test
      this.currentTest = event.testName;
      
      // Start test in reporter
      if (this.reporter) {
        this.reporter.startTest(
          event.testName,
          event.description,
          event.tags
        );
      }
      
      // Call custom handler
      if (this.handlers.onTestStart) {
        this.handlers.onTestStart(event);
      }
    } catch (error) {
      this.logger.error(`Error handling test start event: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Handles test end event
   * 
   * @param event Test end event data
   * @returns Test result
   */
  public onTestEnd(event: CSTestEndEventData): CSTestResult | null {
    this.logger.debug(`Test ended: ${event.testName} with status ${event.status}`);
    
    try {
      // Take screenshot on failure
      if (event.status === CSTestStatus.FAILED && this.options.screenshotOnFailure) {
        this.takeScreenshot({
          testName: event.testName,
          timestamp: new Date(),
          description: 'Test failure'
        });
      }
      
      // End test in reporter
      let result: CSTestResult | null = null;
      
      if (this.reporter) {
        result = this.reporter.endTest(
          event.status,
          event.message
        );
      }
      
      // Reset current test
      this.currentTest = null;
      
      // Call custom handler
      if (this.handlers.onTestEnd && result) {
        this.handlers.onTestEnd(event, result);
      }
      
      return result;
    } catch (error) {
      this.logger.error(`Error handling test end event: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Handles test step event
   * 
   * @param event Test step event data
   * @returns Test step
   */
  public onTestStep(event: CSTestStepEventData): CSTestStep | null {
    this.logger.debug(`Test step: ${event.testName} - ${event.stepName} with status ${event.status}`);
    
    try {
      // Take screenshot on step failure
      if (event.status === CSTestStatus.FAILED && this.options.screenshotOnStepFailure) {
        this.takeScreenshot({
          testName: event.testName,
          timestamp: new Date(),
          description: `Step failure: ${event.stepName}`,
          stepName: event.stepName
        });
      }
      
      // Add step in reporter
      let step: CSTestStep | null = null;
      
      if (this.reporter) {
        step = this.reporter.addStep(
          event.stepName,
          event.status,
          event.description,
          false // Don't take screenshot here, we'll handle it separately
        );
        
        // Update step details if available
        if (step) {
          if (event.assertion) {
            step.setAssertion(
              event.assertion.type,
              event.assertion.expected,
              event.assertion.actual,
              event.assertion.passed,
              event.assertion.message
            );
          }
          
          if (event.error) {
            step.setError(
              event.error.message,
              event.error.stackTrace,
              event.error.type
            );
          }
          
          if (event.actionType) {
            step.actionType = event.actionType;
          }
          
          if (event.parameters) {
            step.parameters = event.parameters;
          }
          
          if (event.selector) {
            step.selector = event.selector;
          }
          
          if (event.locator) {
            step.locator = event.locator;
          }
          
          if (event.parentStepId) {
            step.parentId = event.parentStepId;
          }
        }
      }
      
      // Call custom handler
      if (this.handlers.onTestStep) {
        this.handlers.onTestStep(event);
      }
      
      return step;
    } catch (error) {
      this.logger.error(`Error handling test step event: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Handles log event
   * 
   * @param event Log event data
   */
  public onLog(event: CSLogEventData): void {
    this.logger.debug(`Log: ${event.testName} - ${event.level} - ${event.message}`);
    
    try {
      // Add log in reporter
      if (this.reporter) {
        this.reporter.log(
          event.level,
          event.message,
          event.details
        );
      }
      
      // Call custom handler
      if (this.handlers.onLog) {
        this.handlers.onLog(event);
      }
    } catch (error) {
      this.logger.error(`Error handling log event: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Handles screenshot event
   * 
   * @param event Screenshot event data
   * @returns Screenshot path
   */
  public onScreenshot(event: CSScreenshotEventData): string | null {
    this.logger.debug(`Screenshot: ${event.testName} - ${event.description || 'Screenshot'}`);
    
    try {
      let screenshotPath = event.path;
      
      // Save screenshot if not already saved
      if (!this.fileUtils.fileExists(screenshotPath) && this.options.saveScreenshots) {
        screenshotPath = this.takeScreenshot(event);
      }
      
      // Add screenshot in reporter
      if (this.reporter && screenshotPath) {
        const testResult = this.reporter.getCurrentTestResult();
        
        if (testResult) {
          // Add to test screenshots
          testResult.screenshots.push({
            path: screenshotPath,
            timestamp: event.timestamp,
            description: event.description || ''
          });
          
          // Add to step screenshots if step name is provided
          if (event.stepName) {
            const step = testResult.steps.find(s => s.name === event.stepName);
            
            if (step) {
              step.addScreenshot(screenshotPath);
            }
          }
        }
      }
      
      // Call custom handler
      if (this.handlers.onScreenshot) {
        this.handlers.onScreenshot(event);
      }
      
      return screenshotPath;
    } catch (error) {
      this.logger.error(`Error handling screenshot event: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Takes a screenshot
   * 
   * @param options Screenshot options
   * @returns Screenshot path
   */
  private takeScreenshot(options: {
    testName: string;
    timestamp: Date;
    description?: string;
    stepName?: string;
  }): string | null {
    // Check if we've reached the maximum number of screenshots
    if (this.screenshotCount >= (this.options.maxScreenshotsPerTest || 20)) {
      this.logger.warning(`Maximum number of screenshots reached for test: ${options.testName}`);
      return null;
    }
    
    // Increment screenshot count
    this.screenshotCount++;
    
    // Generate screenshot filename
    const timestamp = options.timestamp.toISOString().replace(/:/g, '-').replace(/\./g, '-');
    const filename = `${this.sanitizeFilename(options.testName)}_${timestamp}${options.description ? `_${this.sanitizeFilename(options.description)}` : ''}.png`;
    const screenshotPath = `${this.options.screenshotDir}/${filename}`;
    
    try {
      // Take screenshot
      const path = this.screenshotManager.takeScreenshot({
        path: screenshotPath,
        fullPage: this.options.fullPageScreenshots,
        quality: this.options.screenshotQuality
      });
      
      this.logger.debug(`Screenshot taken: ${path}`);
      
      return path;
    } catch (error) {
      this.logger.error(`Failed to take screenshot: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }
  
  /**
   * Sanitizes a filename
   * 
   * @param filename Filename to sanitize
   * @returns Sanitized filename
   */
  private sanitizeFilename(filename: string): string {
    return filename
      .replace(/[^a-zA-Z0-9_-]/g, '_') // Replace invalid characters with underscore
      .replace(/_+/g, '_') // Replace multiple underscores with a single underscore
      .substring(0, 100); // Limit length
  }
  
  /**
   * Sets the reporter
   * 
   * @param reporter Reporter instance
   */
  public setReporter(reporter: CSReporter): void {
    this.reporter = reporter;
  }
  
  /**
   * Gets the reporter
   * 
   * @returns Reporter instance
   */
  public getReporter(): CSReporter | null {
    return this.reporter;
  }
  
  /**
   * Sets a handler
   * 
   * @param eventType Event type
   * @param handler Event handler
   */
  public setHandler(
    eventType: 'onTestStart' | 'onTestEnd' | 'onTestStep' | 'onLog' | 'onScreenshot',
    handler: Function
  ): void {
    (this.handlers as any)[eventType] = handler;
  }
  
  /**
   * Removes a handler
   * 
   * @param eventType Event type
   */
  public removeHandler(
    eventType: 'onTestStart' | 'onTestEnd' | 'onTestStep' | 'onLog' | 'onScreenshot'
  ): void {
    delete (this.handlers as any)[eventType];
  }
  
  /**
   * Sets an option
   * 
   * @param option Option name
   * @param value Option value
   */
  public setOption<K extends keyof CSTestListenerOptions>(
    option: K,
    value: CSTestListenerOptions[K]
  ): void {
    (this.options as any)[option] = value;
    
    // Update directories if needed
    if (option === 'outputDir' || option === 'screenshotDir') {
      this.createOutputDirectory();
    }
  }
  
  /**
   * Gets an option
   * 
   * @param option Option name
   * @returns Option value
   */
  public getOption<K extends keyof CSTestListenerOptions>(option: K): CSTestListenerOptions[K] {
    return this.options[option];
  }
  
  /**
   * Gets the current test
   * 
   * @returns Current test name
   */
  public getCurrentTest(): string | null {
    return this.currentTest;
  }
  
  /**
   * Creates a test listener from a configuration object
   * 
   * @param config Test listener configuration
   * @returns Test listener instance
   */
  public static fromConfig(config: Record<string, any>): CSTestListener {
    const options: CSTestListenerOptions = {
      outputDir: config.outputDir || CSTestListener.DEFAULT_OPTIONS.outputDir,
      saveScreenshots: config.saveScreenshots !== undefined ? config.saveScreenshots : CSTestListener.DEFAULT_OPTIONS.saveScreenshots,
      screenshotDir: config.screenshotDir || CSTestListener.DEFAULT_OPTIONS.screenshotDir,
      screenshotOnFailure: config.screenshotOnFailure !== undefined ? config.screenshotOnFailure : CSTestListener.DEFAULT_OPTIONS.screenshotOnFailure,
      screenshotOnStepFailure: config.screenshotOnStepFailure !== undefined ? config.screenshotOnStepFailure : CSTestListener.DEFAULT_OPTIONS.screenshotOnStepFailure,
      screenshotQuality: config.screenshotQuality || CSTestListener.DEFAULT_OPTIONS.screenshotQuality,
      fullPageScreenshots: config.fullPageScreenshots !== undefined ? config.fullPageScreenshots : CSTestListener.DEFAULT_OPTIONS.fullPageScreenshots,
      maxScreenshotsPerTest: config.maxScreenshotsPerTest || CSTestListener.DEFAULT_OPTIONS.maxScreenshotsPerTest
    };
    
    return new CSTestListener(options);
  }
}


/**
 * Slider.tsx
 * 
 * Custom slider component for the CSTestForge framework.
 * Provides a customizable slider with range support, tooltips, and marks.
 */

import React, { useState, useRef, useEffect, useCallback } from 'react';
import './Slider.scss';

/**
 * Mark interface for displaying marks on the slider
 */
export interface SliderMark {
  /**
   * Value of the mark
   */
  value: number;
  
  /**
   * Label for the mark
   */
  label?: string;
}

/**
 * Slider props interface
 */
export interface SliderProps {
  /**
   * Minimum value
   */
  min: number;
  
  /**
   * Maximum value
   */
  max: number;
  
  /**
   * Current value (controlled component)
   */
  value?: number | [number, number];
  
  /**
   * Default value (uncontrolled component)
   */
  defaultValue?: number | [number, number];
  
  /**
   * Step size
   */
  step?: number;
  
  /**
   * Whether the slider is disabled
   */
  disabled?: boolean;
  
  /**
   * Orientation of the slider
   */
  orientation?: 'horizontal' | 'vertical';
  
  /**
   * Whether to display a tooltip when dragging
   */
  tooltip?: boolean;
  
  /**
   * Whether to always show the tooltip
   */
  tooltipAlways?: boolean;
  
  /**
   * Custom tooltip formatter
   */
  tooltipFormatter?: (value: number) => string;
  
  /**
   * Whether to display marks
   */
  marks?: boolean | SliderMark[];
  
  /**
   * Whether the slider is a range slider
   */
  range?: boolean;
  
  /**
   * Track color
   */
  trackColor?: string;
  
  /**
   * Track style
   */
  trackStyle?: React.CSSProperties;
  
  /**
   * Handle style
   */
  handleStyle?: React.CSSProperties;
  
  /**
   * Rail style
   */
  railStyle?: React.CSSProperties;
  
  /**
   * Mark style
   */
  markStyle?: React.CSSProperties;
  
  /**
   * Whether to reverse the slider direction
   */
  reverse?: boolean;
  
  /**
   * Additional CSS class
   */
  className?: string;
  
  /**
   * Additional style
   */
  style?: React.CSSProperties;
  
  /**
   * Callback when the value changes
   */
  onChange?: (value: number | [number, number]) => void;
  
  /**
   * Callback when the user starts dragging
   */
  onDragStart?: (value: number | [number, number]) => void;
  
  /**
   * Callback when the user stops dragging
   */
  onDragEnd?: (value: number | [number, number]) => void;
}

/**
 * Slider component
 */
const Slider: React.FC<SliderProps> = ({
  min = 0,
  max = 100,
  value,
  defaultValue,
  step = 1,
  disabled = false,
  orientation = 'horizontal',
  tooltip = true,
  tooltipAlways = false,
  tooltipFormatter,
  marks = false,
  range = false,
  trackColor = '#C54B8C', // Primary brand color
  trackStyle,
  handleStyle,
  railStyle,
  markStyle,
  reverse = false,
  className = '',
  style,
  onChange,
  onDragStart,
  onDragEnd
}) => {
  // Slider container reference
  const sliderRef = useRef<HTMLDivElement>(null);
  
  // State for dragging
  const [dragging, setDragging] = useState(false);
  const [activeHandle, setActiveHandle] = useState<'min' | 'max' | null>(null);
  
  // Initial values
  const initialValue = value !== undefined ? value : (
    defaultValue !== undefined ? defaultValue : (range ? [min, max] : min)
  );
  
  // State for internal value
  const [internalValue, setInternalValue] = useState<number | [number, number]>(initialValue);
  
  // Derive min and max values for range slider
  const minValue = range ? (internalValue as [number, number])[0] : min;
  const maxValue = range ? (internalValue as [number, number])[1] : (internalValue as number);
  
  // Generate marks array if boolean true is provided
  const marksArray = marks === true
    ? Array.from({ length: Math.floor((max - min) / step) + 1 }, (_, i) => ({
        value: min + i * step
      }))
    : Array.isArray(marks) ? marks : [];
    
  // Format tooltip value
  const formatTooltip = (val: number): string => {
    if (tooltipFormatter) {
      return tooltipFormatter(val);
    }
    return val.toString();
  };
  
  // Calculate position as percentage
  const valueToPercent = (val: number): number => {
    const percent = ((val - min) / (max - min)) * 100;
    return reverse ? 100 - percent : percent;
  };
  
  // Convert percentage to value
  const percentToValue = (percent: number): number => {
    const adjustedPercent = reverse ? 100 - percent : percent;
    let val = min + (adjustedPercent / 100) * (max - min);
    
    // Snap to step
    if (step > 0) {
      val = Math.round(val / step) * step;
    }
    
    // Clamp to min/max
    val = Math.max(min, Math.min(max, val));
    
    return val;
  };
  
  // Get percentage from mouse/touch position
  const getPercentFromPosition = useCallback((clientX: number, clientY: number): number => {
    if (!sliderRef.current) return 0;
    
    const rect = sliderRef.current.getBoundingClientRect();
    
    if (orientation === 'horizontal') {
      return ((clientX - rect.left) / rect.width) * 100;
    } else {
      return ((rect.bottom - clientY) / rect.height) * 100;
    }
  }, [orientation]);
  
  // Handle mouse down
  const handleMouseDown = useCallback((e: React.MouseEvent, handle?: 'min' | 'max') => {
    if (disabled) return;
    
    // Prevent text selection during drag
    e.preventDefault();
    
    const percent = getPercentFromPosition(e.clientX, e.clientY);
    const newValue = percentToValue(percent);
    
    if (range) {
      // For range slider, determine which handle to move
      const rangeValue = internalValue as [number, number];
      const minPercent = valueToPercent(rangeValue[0]);
      const maxPercent = valueToPercent(rangeValue[1]);
      
      if (handle === 'min') {
        // Min handle explicitly clicked
        setActiveHandle('min');
        setInternalValue([newValue, rangeValue[1]]);
        onChange?.([newValue, rangeValue[1]]);
      } else if (handle === 'max') {
        // Max handle explicitly clicked
        setActiveHandle('max');
        setInternalValue([rangeValue[0], newValue]);
        onChange?.([rangeValue[0], newValue]);
      } else {
        // Rail clicked, determine closest handle
        const minDiff = Math.abs(percent - minPercent);
        const maxDiff = Math.abs(percent - maxPercent);
        
        if (minDiff <= maxDiff) {
          setActiveHandle('min');
          setInternalValue([newValue, rangeValue[1]]);
          onChange?.([newValue, rangeValue[1]]);
        } else {
          setActiveHandle('max');
          setInternalValue([rangeValue[0], newValue]);
          onChange?.([rangeValue[0], newValue]);
        }
      }
    } else {
      // For single slider
      setActiveHandle('max');
      setInternalValue(newValue);
      onChange?.(newValue);
    }
    
    setDragging(true);
    onDragStart?.(internalValue);
    
    // Add event listeners for drag
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }, [disabled, getPercentFromPosition, internalValue, onChange, onDragStart, percentToValue, range, valueToPercent]);
  
  // Handle mouse move
  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (!dragging) return;
    
    const percent = getPercentFromPosition(e.clientX, e.clientY);
    const newValue = percentToValue(percent);
    
    if (range && activeHandle) {
      const rangeValue = internalValue as [number, number];
      
      if (activeHandle === 'min') {
        // Ensure min value doesn't exceed max value
        const minVal = Math.min(newValue, rangeValue[1]);
        setInternalValue([minVal, rangeValue[1]]);
        onChange?.([minVal, rangeValue[1]]);
      } else {
        // Ensure max value doesn't fall below min value
        const maxVal = Math.max(newValue, rangeValue[0]);
        setInternalValue([rangeValue[0], maxVal]);
        onChange?.([rangeValue[0], maxVal]);
      }
    } else {
      setInternalValue(newValue);
      onChange?.(newValue);
    }
  }, [activeHandle, dragging, getPercentFromPosition, internalValue, onChange, percentToValue, range]);
  
  // Handle mouse up
  const handleMouseUp = useCallback(() => {
    setDragging(false);
    setActiveHandle(null);
    onDragEnd?.(internalValue);
    
    // Remove event listeners
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
  }, [internalValue, onDragEnd, handleMouseMove]);
  
  // Handle mark click
  const handleMarkClick = useCallback((markValue: number) => {
    if (disabled) return;
    
    if (range) {
      const rangeValue = internalValue as [number, number];
      
      // Determine which handle to move
      const minDiff = Math.abs(markValue - rangeValue[0]);
      const maxDiff = Math.abs(markValue - rangeValue[1]);
      
      if (minDiff <= maxDiff) {
        setInternalValue([markValue, rangeValue[1]]);
        onChange?.([markValue, rangeValue[1]]);
      } else {
        setInternalValue([rangeValue[0], markValue]);
        onChange?.([rangeValue[0], markValue]);
      }
    } else {
      setInternalValue(markValue);
      onChange?.(markValue);
    }
  }, [disabled, internalValue, onChange, range]);
  
  // Update internal value when controlled value changes
  useEffect(() => {
    if (value !== undefined) {
      setInternalValue(value);
    }
  }, [value]);
  
  // Clean up event listeners
  useEffect(() => {
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [handleMouseMove, handleMouseUp]);
  
  // Calculate track style
  const getTrackStyle = (): React.CSSProperties => {
    if (orientation === 'horizontal') {
      const start = range ? valueToPercent(minValue) : 0;
      const end = valueToPercent(maxValue);
      
      return {
        left: `${Math.min(start, end)}%`,
        width: `${Math.abs(end - start)}%`,
        backgroundColor: trackColor,
        ...trackStyle
      };
    } else {
      const start = range ? valueToPercent(minValue) : 0;
      const end = valueToPercent(maxValue);
      
      return {
        bottom: `${Math.min(start, end)}%`,
        height: `${Math.abs(end - start)}%`,
        backgroundColor: trackColor,
        ...trackStyle
      };
    }
  };
  
  // Calculate handle positions
  const getHandleStyle = (handle: 'min' | 'max'): React.CSSProperties => {
    const value = handle === 'min' ? minValue : maxValue;
    const percent = valueToPercent(value);
    
    if (orientation === 'horizontal') {
      return {
        left: `${percent}%`,
        ...handleStyle
      };
    } else {
      return {
        bottom: `${percent}%`,
        ...handleStyle
      };
    }
  };
  
  // Calculate mark positions
  const getMarkStyle = (markValue: number): React.CSSProperties => {
    const percent = valueToPercent(markValue);
    const active = range
      ? markValue >= minValue && markValue <= maxValue
      : markValue <= maxValue;
    
    if (orientation === 'horizontal') {
      return {
        left: `${percent}%`,
        backgroundColor: active ? trackColor : undefined,
        ...markStyle
      };
    } else {
      return {
        bottom: `${percent}%`,
        backgroundColor: active ? trackColor : undefined,
        ...markStyle
      };
    }
  };
  
  // Get mark label position
  const getMarkLabelStyle = (markValue: number): React.CSSProperties => {
    const percent = valueToPercent(markValue);
    
    if (orientation === 'horizontal') {
      return {
        left: `${percent}%`
      };
    } else {
      return {
        bottom: `${percent}%`
      };
    }
  };
  
  // Render component
  return (
    <div
      ref={sliderRef}
      className={`cs-slider cs-slider-${orientation} ${className} ${disabled ? 'cs-slider-disabled' : ''}`}
      style={style}
    >
      {/* Rail (background) */}
      <div
        className="cs-slider-rail"
        style={railStyle}
        onMouseDown={(e) => handleMouseDown(e)}
      />
      
      {/* Track (filled area) */}
      <div
        className="cs-slider-track"
        style={getTrackStyle()}
      />
      
      {/* Marks */}
      {marksArray.length > 0 && (
        <div className="cs-slider-marks">
          {marksArray.map((mark) => (
            <div key={mark.value}>
              <span
                className="cs-slider-mark"
                style={getMarkStyle(mark.value)}
                onClick={() => handleMarkClick(mark.value)}
              />
              
              {mark.label && (
                <span
                  className="cs-slider-mark-label"
                  style={getMarkLabelStyle(mark.value)}
                >
                  {mark.label}
                </span>
              )}
            </div>
          ))}
        </div>
      )}
      
      {/* Handles */}
      {range && (
        <div
          className={`cs-slider-handle cs-slider-handle-min ${activeHandle === 'min' ? 'cs-slider-handle-active' : ''}`}
          style={getHandleStyle('min')}
          onMouseDown={(e) => handleMouseDown(e, 'min')}
        >
          {(tooltip && (dragging || tooltipAlways) && activeHandle === 'min') && (
            <div className="cs-slider-tooltip">
              {formatTooltip(minValue)}
            </div>
          )}
        </div>
      )}
      
      <div
        className={`cs-slider-handle cs-slider-handle-max ${activeHandle === 'max' ? 'cs-slider-handle-active' : ''}`}
        style={getHandleStyle('max')}
        onMouseDown={(e) => handleMouseDown(e, 'max')}
      >
        {(tooltip && (dragging || tooltipAlways) && activeHandle === 'max') && (
          <div className="cs-slider-tooltip">
            {formatTooltip(maxValue)}
          </div>
        )}
      </div>
    </div>
  );
};

export default Slider;



/**
 * Slider.scss
 * 
 * Styles for the custom Slider component.
 */

// Variables
$primary-color: #C54B8C; // CSTestForge primary brand color
$disabled-color: #CCCCCC;
$rail-color: #E0E0E0;
$handle-color: #FFFFFF;
$handle-border-color: #D1D1D1;
$tooltip-bg: #333333;
$tooltip-text: #FFFFFF;

.cs-slider {
  position: relative;
  box-sizing: border-box;
  touch-action: none;
  
  // Common styles for both orientations
  &:hover {
    .cs-slider-handle {
      border-color: $primary-color;
      box-shadow: 0 0 0 3px rgba($primary-color, 0.2);
    }
  }
  
  // Horizontal orientation
  &.cs-slider-horizontal {
    height: 40px;
    padding: 10px 0;
    width: 100%;
    
    .cs-slider-rail {
      position: absolute;
      width: 100%;
      height: 4px;
      background-color: $rail-color;
      border-radius: 2px;
    }
    
    .cs-slider-track {
      position: absolute;
      height: 4px;
      border-radius: 2px;
      transition: background-color 0.3s;
    }
    
    .cs-slider-handle {
      position: absolute;
      width: 16px;
      height: 16px;
      margin-top: -6px;
      margin-left: -8px;
      border-radius: 50%;
      background-color: $handle-color;
      border: 1px solid $handle-border-color;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      transition: border-color 0.3s, box-shadow 0.3s;
      
      &.cs-slider-handle-active {
        border-color: $primary-color;
        box-shadow: 0 0 0 5px rgba($primary-color, 0.1);
      }
      
      .cs-slider-tooltip {
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%) translateY(-8px);
        padding: 4px 8px;
        background-color: $tooltip-bg;
        color: $tooltip-text;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        margin-bottom: 6px;
        
        &::after {
          content: '';
          position: absolute;
          top: 100%;
          left: 50%;
          margin-left: -4px;
          width: 0;
          height: 0;
          border-left: 4px solid transparent;
          border-right: 4px solid transparent;
          border-top: 4px solid $tooltip-bg;
        }
      }
    }
    
    .cs-slider-marks {
      position: absolute;
      top: 18px;
      left: 0;
      width: 100%;
      
      .cs-slider-mark {
        position: absolute;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: $rail-color;
        transform: translateX(-50%);
        cursor: pointer;
        
        &:hover {
          background-color: darken($rail-color, 10%);
        }
      }
      
      .cs-slider-mark-label {
        position: absolute;
        transform: translateX(-50%);
        margin-top: 10px;
        font-size: 12px;
        color: #666666;
        white-space: nowrap;
      }
    }
  }
  
  // Vertical orientation
  &.cs-slider-vertical {
    width: 40px;
    height: 100%;
    min-height: 100px;
    padding: 0 10px;
    
    .cs-slider-rail {
      position: absolute;
      left: 18px;
      width: 4px;
      height: 100%;
      background-color: $rail-color;
      border-radius: 2px;
    }
    
    .cs-slider-track {
      position: absolute;
      left: 18px;
      width: 4px;
      border-radius: 2px;
      transition: background-color 0.3s;
    }
    
    .cs-slider-handle {
      position: absolute;
      width: 16px;
      height: 16px;
      margin-bottom: -8px;
      margin-left: -6px;
      left: 20px;
      border-radius: 50%;
      background-color: $handle-color;
      border: 1px solid $handle-border-color;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      transition: border-color 0.3s, box-shadow 0.3s;
      
      &.cs-slider-handle-active {
        border-color: $primary-color;
        box-shadow: 0 0 0 5px rgba($primary-color, 0.1);
      }
      
      .cs-slider-tooltip {
        position: absolute;
        right: 100%;
        top: 50%;
        transform: translateY(-50%) translateX(-8px);
        padding: 4px 8px;
        background-color: $tooltip-bg;
        color: $tooltip-text;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        margin-right: 6px;
        
        &::after {
          content: '';
          position: absolute;
          left: 100%;
          top: 50%;
          margin-top: -4px;
          width: 0;
          height: 0;
          border-top: 4px solid transparent;
          border-bottom: 4px solid transparent;
          border-left: 4px solid $tooltip-bg;
        }
      }
    }
    
    .cs-slider-marks {
      position: absolute;
      left: 28px;
      height: 100%;
      
      .cs-slider-mark {
        position: absolute;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: $rail-color;
        transform: translateY(50%);
        cursor: pointer;
        
        &:hover {
          background-color: darken($rail-color, 10%);
        }
      }
      
      .cs-slider-mark-label {
        position: absolute;
        transform: translateY(50%);
        margin-left: 12px;
        font-size: 12px;
        color: #666666;
        white-space: nowrap;
      }
    }
  }
  
  // Disabled state
  &.cs-slider-disabled {
    opacity: 0.5;
    cursor: not-allowed;
    
    .cs-slider-rail,
    .cs-slider-track,
    .cs-slider-handle,
    .cs-slider-mark {
      cursor: not-allowed;
    }
    
    .cs-slider-track {
      background-color: $disabled-color;
    }
    
    .cs-slider-handle {
      border-color: $disabled-color;
      box-shadow: none;
      
      &:hover,
      &:focus,
      &.cs-slider-handle-active {
        border-color: $disabled-color;
        box-shadow: none;
      }
    }
  }
}

// Dark mode styles
.dark-theme {
  .cs-slider {
    .cs-slider-rail {
      background-color: #444444;
    }
    
    .cs-slider-handle {
      background-color: #2A2A2A;
      border-color: #555555;
    }
    
    .cs-slider-marks {
      .cs-slider-mark {
        background-color: #444444;
        
        &:hover {
          background-color: lighten(#444444, 10%);
        }
      }
      
      .cs-slider-mark-label {
        color: #BBBBBB;
      }
    }
  }
}

// Responsive styles
@media screen and (max-width: 768px) {
  .cs-slider {
    &.cs-slider-horizontal {
      height: 30px;
      
      .cs-slider-marks {
        .cs-slider-mark-label {
          font-size: 10px;
        }
      }
    }
    
    &.cs-slider-vertical {
      width: 30px;
      
      .cs-slider-marks {
        .cs-slider-mark-label {
          font-size: 10px;
        }
      }
    }
  }
}


