WebDriverManager.ts
-----------------------------
import {
  WebDriver,
  Builder,
  Capabilities,
  logging,
  WebElement,
  By,
  until,
  Chrome,
  Firefox,
  Edge,
  Safari,
  ChromeOptions,
  FirefoxOptions,
  EdgeOptions
} from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome';
import * as firefox from 'selenium-webdriver/firefox';
import * as edge from 'selenium-webdriver/edge';
import * as safari from 'selenium-webdriver/safari';
import * as fs from 'fs';
import * as path from 'path';
import { ConfigurationManager } from '../../core/config/ConfigurationManager';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSConstants } from '../../core/utils/CSConstants';
import { CSEncryptionUtils } from '../../core/utils/CSEncryptionUtils';
import { CSFileUtils } from '../../core/utils/CSFileUtils';
import { BrowserType, DriverOptions, WebDriverManagerConfig, ProxyConfig } from '../types/WebDriverTypes';

/**
 * WebDriverManager is responsible for creating and managing WebDriver instances.
 * It provides a unified API for creating WebDriver instances for different browsers,
 * with support for local and remote execution, custom capabilities, proxy settings,
 * and other advanced configuration options.
 */
export class WebDriverManager {
  private static instance: WebDriverManager;
  private config: WebDriverManagerConfig;
  private logger: CSLogger;
  private drivers: Map<string, WebDriver>;
  private driverCapabilities: Map<BrowserType, Capabilities>;
  private configurationManager: ConfigurationManager;
  private static readonly DEFAULT_IMPLICIT_WAIT = 0;
  private static readonly DEFAULT_PAGE_LOAD_TIMEOUT = 60000;
  private static readonly DEFAULT_SCRIPT_TIMEOUT = 30000;
  private static readonly DEFAULT_BROWSER = BrowserType.CHROME;
  private static readonly DEFAULT_REMOTE_URL = 'http://localhost:4444/wd/hub';
  private static readonly BROWSER_BINARY_ENV_VAR_PREFIX = 'CS_BROWSER_BINARY_';

  /**
   * Private constructor to enforce singleton pattern
   */
  private constructor() {
    this.logger = new CSLogger('WebDriverManager');
    this.drivers = new Map<string, WebDriver>();
    this.driverCapabilities = new Map<BrowserType, Capabilities>();
    this.configurationManager = ConfigurationManager.getInstance();
    this.config = this.loadConfiguration();
    this.initializeDefaultCapabilities();
  }

  /**
   * Gets the singleton instance of WebDriverManager
   * @returns The WebDriverManager instance
   */
  public static getInstance(): WebDriverManager {
    if (!WebDriverManager.instance) {
      WebDriverManager.instance = new WebDriverManager();
    }
    return WebDriverManager.instance;
  }

  /**
   * Loads the WebDriverManager configuration from the framework configuration
   * @returns The WebDriverManager configuration
   */
  private loadConfiguration(): WebDriverManagerConfig {
    const frameworkConfig = this.configurationManager.getFrameworkConfig();
    
    // If no webdriver configuration is found, create a default configuration
    if (!frameworkConfig.webdriver) {
      this.logger.warn('No WebDriver configuration found, using defaults');
      return {
        defaultBrowser: WebDriverManager.DEFAULT_BROWSER,
        useRemote: false,
        remoteUrl: WebDriverManager.DEFAULT_REMOTE_URL,
        timeouts: {
          implicit: WebDriverManager.DEFAULT_IMPLICIT_WAIT,
          pageLoad: WebDriverManager.DEFAULT_PAGE_LOAD_TIMEOUT,
          script: WebDriverManager.DEFAULT_SCRIPT_TIMEOUT
        },
        autoQuit: true,
        screenshotsOnFailure: true,
        screenshotDirectory: './screenshots',
        downloadsDirectory: './downloads',
        logPerformance: false,
        recordVideo: false,
        videoDirectory: './videos',
        proxySettings: null,
        browserOptions: {}
      };
    }

    return {
      defaultBrowser: frameworkConfig.webdriver.defaultBrowser || WebDriverManager.DEFAULT_BROWSER,
      useRemote: frameworkConfig.webdriver.useRemote || false,
      remoteUrl: frameworkConfig.webdriver.remoteUrl || WebDriverManager.DEFAULT_REMOTE_URL,
      timeouts: {
        implicit: frameworkConfig.webdriver.timeouts?.implicit || WebDriverManager.DEFAULT_IMPLICIT_WAIT,
        pageLoad: frameworkConfig.webdriver.timeouts?.pageLoad || WebDriverManager.DEFAULT_PAGE_LOAD_TIMEOUT,
        script: frameworkConfig.webdriver.timeouts?.script || WebDriverManager.DEFAULT_SCRIPT_TIMEOUT
      },
      autoQuit: frameworkConfig.webdriver.autoQuit !== undefined ? frameworkConfig.webdriver.autoQuit : true,
      screenshotsOnFailure: frameworkConfig.webdriver.screenshotsOnFailure !== undefined ? 
        frameworkConfig.webdriver.screenshotsOnFailure : true,
      screenshotDirectory: frameworkConfig.webdriver.screenshotDirectory || './screenshots',
      downloadsDirectory: frameworkConfig.webdriver.downloadsDirectory || './downloads',
      logPerformance: frameworkConfig.webdriver.logPerformance || false,
      recordVideo: frameworkConfig.webdriver.recordVideo || false,
      videoDirectory: frameworkConfig.webdriver.videoDirectory || './videos',
      proxySettings: frameworkConfig.webdriver.proxySettings || null,
      browserOptions: frameworkConfig.webdriver.browserOptions || {}
    };
  }

  /**
   * Initializes the default capabilities for each supported browser
   */
  private initializeDefaultCapabilities(): void {
    // Chrome
    const chromeCapabilities = Capabilities.chrome();
    this.driverCapabilities.set(BrowserType.CHROME, chromeCapabilities);

    // Firefox
    const firefoxCapabilities = Capabilities.firefox();
    this.driverCapabilities.set(BrowserType.FIREFOX, firefoxCapabilities);

    // Edge
    const edgeCapabilities = Capabilities.edge();
    this.driverCapabilities.set(BrowserType.EDGE, edgeCapabilities);

    // Safari
    const safariCapabilities = Capabilities.safari();
    this.driverCapabilities.set(BrowserType.SAFARI, safariCapabilities);

    // Internet Explorer
    const ieCapabilities = Capabilities.ie();
    this.driverCapabilities.set(BrowserType.IE, ieCapabilities);

    this.logger.debug('Default capabilities initialized for all supported browsers');
  }

  /**
   * Gets a WebDriver instance, creating a new one if necessary
   * @param options The driver options (optional)
   * @returns A WebDriver instance
   */
  public async getDriver(options?: DriverOptions): Promise<WebDriver> {
    const driverOptions = this.mergeWithDefaultOptions(options);
    const driverId = this.generateDriverId(driverOptions);

    // Check if a driver with the same ID already exists
    if (this.drivers.has(driverId) && !driverOptions.forceNewDriver) {
      this.logger.debug(`Returning existing driver with ID ${driverId}`);
      return this.drivers.get(driverId)!;
    }

    // Create a new driver
    this.logger.info(`Creating new WebDriver for ${driverOptions.browser}`);
    const driver = await this.createDriver(driverOptions);
    
    // Configure the new driver
    await this.configureDriver(driver, driverOptions);
    
    // Store the driver for later reuse
    this.drivers.set(driverId, driver);
    
    return driver;
  }

  /**
   * Merges the provided options with the default options
   * @param options The options to merge with the defaults
   * @returns The merged options
   */
  private mergeWithDefaultOptions(options?: DriverOptions): DriverOptions {
    const mergedOptions: DriverOptions = {
      browser: options?.browser || this.config.defaultBrowser,
      remote: options?.remote !== undefined ? options.remote : this.config.useRemote,
      remoteUrl: options?.remoteUrl || this.config.remoteUrl,
      capabilities: options?.capabilities || {},
      timeouts: {
        implicit: options?.timeouts?.implicit !== undefined ? 
          options.timeouts.implicit : this.config.timeouts.implicit,
        pageLoad: options?.timeouts?.pageLoad !== undefined ? 
          options.timeouts.pageLoad : this.config.timeouts.pageLoad,
        script: options?.timeouts?.script !== undefined ? 
          options.timeouts.script : this.config.timeouts.script
      },
      proxySettings: options?.proxySettings || this.config.proxySettings,
      autoQuit: options?.autoQuit !== undefined ? options.autoQuit : this.config.autoQuit,
      forceNewDriver: options?.forceNewDriver || false,
      headless: options?.headless || false,
      incognito: options?.incognito || false,
      arguments: options?.arguments || [],
      binary: options?.binary || this.getBrowserBinaryFromEnv(options?.browser || this.config.defaultBrowser),
      extensions: options?.extensions || [],
      userProfile: options?.userProfile || null,
      experimentalOptions: options?.experimentalOptions || {},
      downloadDirectory: options?.downloadDirectory || this.config.downloadsDirectory,
      logPerformance: options?.logPerformance !== undefined ? 
        options.logPerformance : this.config.logPerformance,
      debugPort: options?.debugPort || null,
      recordVideo: options?.recordVideo !== undefined ? 
        options.recordVideo : this.config.recordVideo,
      videoDirectory: options?.videoDirectory || this.config.videoDirectory,
      sessionId: options?.sessionId || null,
      browserVersion: options?.browserVersion || 'latest',
      platformName: options?.platformName || 'any',
    };

    // Apply any browser-specific options from configuration
    const browserOptions = this.config.browserOptions[mergedOptions.browser];
    if (browserOptions) {
      mergedOptions.arguments = [...(browserOptions.arguments || []), ...mergedOptions.arguments];
      mergedOptions.experimentalOptions = {
        ...(browserOptions.experimentalOptions || {}),
        ...mergedOptions.experimentalOptions
      };
      if (browserOptions.headless !== undefined && mergedOptions.headless === false) {
        mergedOptions.headless = browserOptions.headless;
      }
      if (browserOptions.incognito !== undefined && mergedOptions.incognito === false) {
        mergedOptions.incognito = browserOptions.incognito;
      }
      if (browserOptions.binary && !mergedOptions.binary) {
        mergedOptions.binary = browserOptions.binary;
      }
    }

    return mergedOptions;
  }

  /**
   * Gets the browser binary path from environment variables
   * @param browser The browser type
   * @returns The binary path, or undefined if not set
   */
  private getBrowserBinaryFromEnv(browser: BrowserType): string | undefined {
    const envVarName = `${WebDriverManager.BROWSER_BINARY_ENV_VAR_PREFIX}${browser.toUpperCase()}`;
    const binaryPath = process.env[envVarName];
    if (binaryPath && fs.existsSync(binaryPath)) {
      this.logger.debug(`Using browser binary from environment variable ${envVarName}: ${binaryPath}`);
      return binaryPath;
    }
    return undefined;
  }

  /**
   * Generates a unique ID for a driver based on its options
   * @param options The driver options
   * @returns A unique driver ID
   */
  private generateDriverId(options: DriverOptions): string {
    // Create a simplified options object for ID generation
    const idOptions = {
      browser: options.browser,
      remote: options.remote,
      remoteUrl: options.remote ? options.remoteUrl : undefined,
      headless: options.headless,
      incognito: options.incognito,
      userProfile: options.userProfile,
      sessionId: options.sessionId,
      browserVersion: options.browserVersion,
      platformName: options.platformName
    };
    
    // Generate a hash of the options
    const optionsString = JSON.stringify(idOptions);
    return `${options.browser}-${CSEncryptionUtils.hash(optionsString)}`;
  }

  /**
   * Creates a new WebDriver instance based on the provided options
   * @param options The driver options
   * @returns A new WebDriver instance
   */
  private async createDriver(options: DriverOptions): Promise<WebDriver> {
    try {
      let builder = new Builder();
      
      // Get the base capabilities for the browser
      const baseCapabilities = this.driverCapabilities.get(options.browser) || 
                               Capabilities.chrome();
      
      // Create a copy of the base capabilities
      const capabilities = Object.assign({}, baseCapabilities);
      
      // Add platform and browser version if specified
      if (options.platformName && options.platformName !== 'any') {
        capabilities.setPlatform(options.platformName);
      }
      if (options.browserVersion && options.browserVersion !== 'latest') {
        capabilities.setBrowserVersion(options.browserVersion);
      }
      
      // Add custom capabilities
      for (const [key, value] of Object.entries(options.capabilities)) {
        capabilities.set(key, value);
      }
      
      // Configure logging preferences if performance logging is enabled
      if (options.logPerformance) {
        const loggingPrefs = new logging.Preferences();
        loggingPrefs.setLevel(logging.Type.PERFORMANCE, logging.Level.ALL);
        capabilities.set('goog:loggingPrefs', loggingPrefs);
      }
      
      // Set the capabilities on the builder
      builder = builder.withCapabilities(capabilities);
      
      // Configure for remote or local execution
      if (options.remote) {
        builder = builder.usingServer(options.remoteUrl);
        
        // If a session ID is provided, attach to an existing session
        if (options.sessionId) {
          this.logger.info(`Attaching to existing remote session: ${options.sessionId}`);
          capabilities.set('webdriver.remote.sessionid', options.sessionId);
        }
      } else {
        // Configure browser-specific options for local execution
        builder = this.configureBrowserOptions(builder, options);
      }
      
      // Build and return the WebDriver instance
      const driver = await builder.build();
      this.logger.info(`Created new WebDriver instance for ${options.browser}`);
      return driver;
    } catch (error) {
      this.logger.error(`Error creating WebDriver: ${error}`);
      throw new Error(`Failed to create WebDriver: ${error}`);
    }
  }

  /**
   * Configures browser-specific options for the WebDriver builder
   * @param builder The WebDriver builder
   * @param options The driver options
   * @returns The configured builder
   */
  private configureBrowserOptions(builder: Builder, options: DriverOptions): Builder {
    switch (options.browser) {
      case BrowserType.CHROME:
        return this.configureChromeOptions(builder, options);
      case BrowserType.FIREFOX:
        return this.configureFirefoxOptions(builder, options);
      case BrowserType.EDGE:
        return this.configureEdgeOptions(builder, options);
      case BrowserType.SAFARI:
        return this.configureSafariOptions(builder, options);
      case BrowserType.IE:
        return this.configureIEOptions(builder, options);
      default:
        this.logger.warn(`Unsupported browser: ${options.browser}, using Chrome options`);
        return this.configureChromeOptions(builder, options);
    }
  }

  /**
   * Configures Chrome-specific options
   * @param builder The WebDriver builder
   * @param options The driver options
   * @returns The configured builder
   */
  private configureChromeOptions(builder: Builder, options: DriverOptions): Builder {
    const chromeOptions = new chrome.Options();
    
    // Configure headless mode
    if (options.headless) {
      chromeOptions.headless();
    }
    
    // Configure incognito mode
    if (options.incognito) {
      chromeOptions.addArguments('--incognito');
    }
    
    // Add custom arguments
    if (options.arguments && options.arguments.length > 0) {
      chromeOptions.addArguments(...options.arguments);
    }
    
    // Set binary path if specified
    if (options.binary) {
      chromeOptions.setChromeBinaryPath(options.binary);
    }
    
    // Add extensions if specified
    if (options.extensions && options.extensions.length > 0) {
      for (const extension of options.extensions) {
        if (fs.existsSync(extension)) {
          chromeOptions.addExtensions(extension);
        } else {
          this.logger.warn(`Chrome extension not found: ${extension}`);
        }
      }
    }
    
    // Set user profile if specified
    if (options.userProfile) {
      chromeOptions.addArguments(`--user-data-dir=${options.userProfile}`);
    }
    
    // Add experimental options
    if (options.experimentalOptions) {
      for (const [key, value] of Object.entries(options.experimentalOptions)) {
        chromeOptions.addArguments(`--${key}=${value}`);
      }
    }
    
    // Configure download directory
    if (options.downloadDirectory) {
      CSFileUtils.ensureDirectoryExists(options.downloadDirectory);
      chromeOptions.setUserPreferences({
        'download.default_directory': path.resolve(options.downloadDirectory),
        'download.prompt_for_download': false,
        'download.directory_upgrade': true
      });
    }
    
    // Configure proxy if specified
    if (options.proxySettings) {
      this.configureProxy(chromeOptions, options.proxySettings);
    }
    
    // Configure remote debugging if specified
    if (options.debugPort) {
      chromeOptions.addArguments(`--remote-debugging-port=${options.debugPort}`);
    }
    
    return builder.setChromeOptions(chromeOptions);
  }

  /**
   * Configures Firefox-specific options
   * @param builder The WebDriver builder
   * @param options The driver options
   * @returns The configured builder
   */
  private configureFirefoxOptions(builder: Builder, options: DriverOptions): Builder {
    const firefoxOptions = new firefox.Options();
    
    // Configure headless mode
    if (options.headless) {
      firefoxOptions.headless();
    }
    
    // Configure private browsing
    if (options.incognito) {
      firefoxOptions.setPreference('browser.privatebrowsing.autostart', true);
    }
    
    // Add custom arguments
    if (options.arguments && options.arguments.length > 0) {
      firefoxOptions.addArguments(...options.arguments);
    }
    
    // Set binary path if specified
    if (options.binary) {
      firefoxOptions.setBinary(options.binary);
    }
    
    // Add extensions if specified
    if (options.extensions && options.extensions.length > 0) {
      for (const extension of options.extensions) {
        if (fs.existsSync(extension)) {
          firefoxOptions.addExtensions(extension);
        } else {
          this.logger.warn(`Firefox extension not found: ${extension}`);
        }
      }
    }
    
    // Set user profile if specified
    if (options.userProfile) {
      firefoxOptions.setProfile(options.userProfile);
    }
    
    // Configure download directory
    if (options.downloadDirectory) {
      CSFileUtils.ensureDirectoryExists(options.downloadDirectory);
      firefoxOptions.setPreference('browser.download.folderList', 2);
      firefoxOptions.setPreference('browser.download.manager.showWhenStarting', false);
      firefoxOptions.setPreference('browser.download.dir', path.resolve(options.downloadDirectory));
      firefoxOptions.setPreference('browser.helperApps.neverAsk.saveToDisk', 
        'application/octet-stream,application/pdf,application/x-pdf,application/vnd.pdf,text/csv,application/zip,application/x-zip,application/x-zip-compressed');
    }
    
    // Add experimental preferences
    if (options.experimentalOptions) {
      for (const [key, value] of Object.entries(options.experimentalOptions)) {
        firefoxOptions.setPreference(key, value);
      }
    }
    
    // Configure proxy if specified
    if (options.proxySettings) {
      this.configureProxyForFirefox(firefoxOptions, options.proxySettings);
    }
    
    // Configure remote debugging if specified
    if (options.debugPort) {
      firefoxOptions.setPreference('devtools.debugger.remote-port', options.debugPort);
      firefoxOptions.setPreference('devtools.debugger.remote-enabled', true);
    }
    
    return builder.setFirefoxOptions(firefoxOptions);
  }

  /**
   * Configures Edge-specific options
   * @param builder The WebDriver builder
   * @param options The driver options
   * @returns The configured builder
   */
  private configureEdgeOptions(builder: Builder, options: DriverOptions): Builder {
    const edgeOptions = new edge.Options();
    
    // Configure headless mode
    if (options.headless) {
      edgeOptions.headless();
    }
    
    // Configure InPrivate browsing
    if (options.incognito) {
      edgeOptions.addArguments('--inprivate');
    }
    
    // Add custom arguments
    if (options.arguments && options.arguments.length > 0) {
      edgeOptions.addArguments(...options.arguments);
    }
    
    // Set binary path if specified
    if (options.binary) {
      edgeOptions.setEdgeChromiumBinaryPath(options.binary);
    }
    
    // Add extensions if specified
    if (options.extensions && options.extensions.length > 0) {
      for (const extension of options.extensions) {
        if (fs.existsSync(extension)) {
          edgeOptions.addExtensions(extension);
        } else {
          this.logger.warn(`Edge extension not found: ${extension}`);
        }
      }
    }
    
    // Set user profile if specified
    if (options.userProfile) {
      edgeOptions.addArguments(`--user-data-dir=${options.userProfile}`);
    }
    
    // Add experimental options
    if (options.experimentalOptions) {
      for (const [key, value] of Object.entries(options.experimentalOptions)) {
        edgeOptions.addArguments(`--${key}=${value}`);
      }
    }
    
    // Configure download directory
    if (options.downloadDirectory) {
      CSFileUtils.ensureDirectoryExists(options.downloadDirectory);
      edgeOptions.setUserPreferences({
        'download.default_directory': path.resolve(options.downloadDirectory),
        'download.prompt_for_download': false,
        'download.directory_upgrade': true
      });
    }
    
    // Configure proxy if specified
    if (options.proxySettings) {
      this.configureProxy(edgeOptions, options.proxySettings);
    }
    
    // Configure remote debugging if specified
    if (options.debugPort) {
      edgeOptions.addArguments(`--remote-debugging-port=${options.debugPort}`);
    }
    
    return builder.setEdgeOptions(edgeOptions);
  }

  /**
   * Configures Safari-specific options
   * @param builder The WebDriver builder
   * @param options The driver options
   * @returns The configured builder
   */
  private configureSafariOptions(builder: Builder, options: DriverOptions): Builder {
    const safariOptions = new safari.Options();
    
    // Safari doesn't support headless mode, so we warn if it's requested
    if (options.headless) {
      this.logger.warn('Safari does not support headless mode, ignoring headless option');
    }
    
    // Safari doesn't support incognito mode via WebDriver, so we warn if it's requested
    if (options.incognito) {
      this.logger.warn('Safari does not support private browsing mode via WebDriver, ignoring incognito option');
    }
    
    // Safari doesn't support custom arguments, so we warn if they're provided
    if (options.arguments && options.arguments.length > 0) {
      this.logger.warn('Safari does not support custom arguments, ignoring arguments option');
    }
    
    // Safari doesn't support setting binary path, so we warn if it's specified
    if (options.binary) {
      this.logger.warn('Safari does not support setting binary path, ignoring binary option');
    }
    
    // Safari doesn't support adding extensions via WebDriver, so we warn if they're provided
    if (options.extensions && options.extensions.length > 0) {
      this.logger.warn('Safari does not support adding extensions via WebDriver, ignoring extensions option');
    }
    
    // Safari doesn't support setting user profile, so we warn if it's specified
    if (options.userProfile) {
      this.logger.warn('Safari does not support setting user profile, ignoring userProfile option');
    }
    
    // Safari doesn't support experimental options, so we warn if they're provided
    if (options.experimentalOptions && Object.keys(options.experimentalOptions).length > 0) {
      this.logger.warn('Safari does not support experimental options, ignoring experimentalOptions option');
    }
    
    // Safari doesn't support configuring download directory, so we warn if it's specified
    if (options.downloadDirectory) {
      this.logger.warn('Safari does not support configuring download directory, ignoring downloadDirectory option');
    }
    
    // Safari doesn't support proxy configuration via WebDriver, so we warn if it's specified
    if (options.proxySettings) {
      this.logger.warn('Safari does not support proxy configuration via WebDriver, ignoring proxySettings option');
    }
    
    // Safari doesn't support remote debugging via WebDriver, so we warn if it's specified
    if (options.debugPort) {
      this.logger.warn('Safari does not support remote debugging via WebDriver, ignoring debugPort option');
    }
    
    // Set Technology Preview mode if experimentalOptions includes "technologyPreview"
    if (options.experimentalOptions && options.experimentalOptions.technologyPreview) {
      safariOptions.setTechnologyPreview(true);
    }
    
    return builder.setSafariOptions(safariOptions);
  }

  /**
   * Configures Internet Explorer-specific options
   * @param builder The WebDriver builder
   * @param options The driver options
   * @returns The configured builder
   */
  private configureIEOptions(builder: Builder, options: DriverOptions): Builder {
    // IE doesn't have a dedicated Options class in selenium-webdriver,
    // so we set options via capabilities
    const capabilities = new Capabilities();
    
    // IE doesn't support headless mode, so we warn if it's requested
    if (options.headless) {
      this.logger.warn('Internet Explorer does not support headless mode, ignoring headless option');
    }
    
    // IE doesn't support incognito mode via WebDriver, so we warn if it's requested
    if (options.incognito) {
      this.logger.warn('Internet Explorer does not support InPrivate browsing via WebDriver, ignoring incognito option');
    }
    
    // Set common IE options
    capabilities.set('ie.ensureCleanSession', true);
    capabilities.set('ignoreProtectedModeSettings', true);
    capabilities.set('ignoreZoomSetting', true);
    
    // Add custom capabilities
    for (const [key, value] of Object.entries(options.capabilities)) {
      capabilities.set(key, value);
    }
    
    // Configure proxy if specified
    if (options.proxySettings) {
      this.configureProxyCapabilities(capabilities, options.proxySettings);
    }
    
    return builder.withCapabilities(capabilities);
  }

  /**
   * Configures proxy settings for Chrome, Edge, and IE
   * @param options The browser options
   * @param proxyConfig The proxy configuration
   */
  private configureProxy(options: ChromeOptions | EdgeOptions, proxyConfig: ProxyConfig): void {
    if (proxyConfig.type === 'manual') {
      // Manual proxy configuration
      const proxyString = this.buildProxyString(proxyConfig);
      options.addArguments(`--proxy-server=${proxyString}`);
      
      // Add proxy bypass list if specified
      if (proxyConfig.bypass) {
        options.addArguments(`--proxy-bypass-list=${proxyConfig.bypass.join(';')}`);
      }
    } else if (proxyConfig.type === 'pac') {
      // PAC proxy configuration
      options.addArguments(`--proxy-pac-url=${proxyConfig.pacUrl}`);
    } else if (proxyConfig.type === 'autodetect') {
      // Auto-detect proxy configuration
      options.addArguments('--proxy-auto-detect');
    } else if (proxyConfig.type === 'system') {
      // System proxy configuration
      // Chrome and Edge use system proxy by default, so no need to set anything
    } else if (proxyConfig.type === 'direct') {
      // Direct connection (no proxy)
      options.addArguments('--no-proxy-server');
    }
  }

  /**
   * Configures proxy settings for Firefox
   * @param options The Firefox options
   * @param proxyConfig The proxy configuration
   */
  private configureProxyForFirefox(options: FirefoxOptions, proxyConfig: ProxyConfig): void {
    if (proxyConfig.type === 'manual') {
      // Manual proxy configuration
      if (proxyConfig.http) {
        const [host, port] = proxyConfig.http.split(':');
        options.setPreference('network.proxy.http', host);
        options.setPreference('network.proxy.http_port', parseInt(port, 10));
      }
      
      if (proxyConfig.https) {
        const [host, port] = proxyConfig.https.split(':');
        options.setPreference('network.proxy.ssl', host);
        options.setPreference('network.proxy.ssl_port', parseInt(port, 10));
      }
      
      if (proxyConfig.ftp) {
        const [host, port] = proxyConfig.ftp.split(':');
        options.setPreference('network.proxy.ftp', host);
        options.setPreference('network.proxy.ftp_port', parseInt(port, 10));
      }
      
      if (proxyConfig.socks) {
        const [host, port] = proxyConfig.socks.split(':');
        options.setPreference('network.proxy.socks', host);
        options.setPreference('network.proxy.socks_port', parseInt(port, 10));
        
        if (proxyConfig.socksVersion) {
          options.setPreference('network.proxy.socks_version', proxyConfig.socksVersion);
        }
      }
      
      options.setPreference('network.proxy.type', 1); // 1 = manual proxy configuration
      
      // Set proxy bypass list if specified
      if (proxyConfig.bypass) {
        options.setPreference('network.proxy.no_proxies_on', proxyConfig.bypass.join(', '));
      }
    } else if (proxyConfig.type === 'pac') {
      // PAC proxy configuration
      options.setPreference('network.proxy.type', 2); // 2 = PAC proxy configuration
      options.setPreference('network.proxy.autoconfig_url', proxyConfig.pacUrl);
    } else if (proxyConfig.type === 'autodetect') {
      // Auto-detect proxy configuration
      options.setPreference('network.proxy.type', 4); // 4 = auto-detect proxy configuration
    } else if (proxyConfig.type === 'system') {
      // System proxy configuration
      options.setPreference('network.proxy.type', 5); // 5 = system proxy configuration
    } else if (proxyConfig.type === 'direct') {
      // Direct connection (no proxy)
      options.setPreference('network.proxy.type', 0); // 0 = no proxy
    }
  }

  /**
   * Configures proxy settings via capabilities (for IE and remote WebDriver)
   * @param capabilities The capabilities
   * @param proxyConfig The proxy configuration
   */
  private configureProxyCapabilities(capabilities: Capabilities, proxyConfig: ProxyConfig): void {
    if (proxyConfig.type === 'manual') {
      const proxy: any = {
        proxyType: 'manual'
      };
      
      if (proxyConfig.http) {
        proxy.httpProxy = proxyConfig.http;
      }
      
      if (proxyConfig.https) {
        proxy.sslProxy = proxyConfig.https;
      }
      
      if (proxyConfig.ftp) {
        proxy.ftpProxy = proxyConfig.ftp;
      }
      
      if (proxyConfig.socks) {
        proxy.socksProxy = proxyConfig.socks;
        if (proxyConfig.socksVersion) {
          proxy.socksVersion = proxyConfig.socksVersion;
        }
      }
      
      if (proxyConfig.bypass) {
        proxy.noProxy = proxyConfig.bypass.join(',');
      }
      
      capabilities.set('proxy', proxy);
    } else if (proxyConfig.type === 'pac') {
      capabilities.set('proxy', {
        proxyType: 'pac',
        proxyAutoconfigUrl: proxyConfig.pacUrl
      });
    } else if (proxyConfig.type === 'autodetect') {
      capabilities.set('proxy', {
        proxyType: 'autodetect'
      });
    } else if (proxyConfig.type === 'system') {
      capabilities.set('proxy', {
        proxyType: 'system'
      });
    } else if (proxyConfig.type === 'direct') {
      capabilities.set('proxy', {
        proxyType: 'direct'
      });
    }
  }

  /**
   * Builds a proxy string from the proxy configuration
   * @param proxyConfig The proxy configuration
   * @returns The proxy string
   */
  private buildProxyString(proxyConfig: ProxyConfig): string {
    const parts: string[] = [];
    
    if (proxyConfig.http) {
      parts.push(`http=${proxyConfig.http}`);
    }
    
    if (proxyConfig.https) {
      parts.push(`https=${proxyConfig.https}`);
    }
    
    if (proxyConfig.ftp) {
      parts.push(`ftp=${proxyConfig.ftp}`);
    }
    
    if (proxyConfig.socks) {
      const socksVersion = proxyConfig.socksVersion || 5;
      parts.push(`socks${socksVersion}=${proxyConfig.socks}`);
    }
    
    // If specific protocols were configured, return them
    if (parts.length > 0) {
      return parts.join(';');
    }
    
    // If no specific protocols were configured but a proxy is required,
    // use the first available proxy for all protocols
    const proxy = proxyConfig.http || proxyConfig.https || proxyConfig.ftp || proxyConfig.socks;
    return proxy || '';
  }

  /**
   * Configures a WebDriver instance with the specified options
   * @param driver The WebDriver instance
   * @param options The driver options
   */
  private async configureDriver(driver: WebDriver, options: DriverOptions): Promise<void> {
    try {
      // Set timeouts
      const timeouts = driver.manage().timeouts();
      if (options.timeouts.implicit !== undefined) {
        await timeouts.implicitlyWait(options.timeouts.implicit);
      }
      if (options.timeouts.pageLoad !== undefined) {
        await timeouts.pageLoad(options.timeouts.pageLoad);
      }
      if (options.timeouts.script !== undefined) {
        await timeouts.setScriptTimeout(options.timeouts.script);
      }
      
      // Configure window
      const window = driver.manage().window();
      
      // Maximize window by default for better element visibility
      await window.maximize();
      
      this.logger.debug('WebDriver configured successfully');
    } catch (error) {
      this.logger.error(`Error configuring WebDriver: ${error}`);
      // Continue without failing the entire process
    }
  }

  /**
   * Quits a specific WebDriver instance
   * @param driverId The ID of the driver to quit
   */
  public async quitDriver(driverId: string): Promise<void> {
    try {
      if (this.drivers.has(driverId)) {
        const driver = this.drivers.get(driverId)!;
        this.logger.info(`Quitting WebDriver with ID ${driverId}`);
        await driver.quit();
        this.drivers.delete(driverId);
      }
    } catch (error) {
      this.logger.error(`Error quitting WebDriver with ID ${driverId}: ${error}`);
      // Remove the driver from the map even if quit fails
      this.drivers.delete(driverId);
    }
  }

  /**
   * Quits all WebDriver instances
   */
  public async quitAllDrivers(): Promise<void> {
    const driverIds = Array.from(this.drivers.keys());
    this.logger.info(`Quitting all WebDrivers (${driverIds.length} instances)`);
    
    for (const driverId of driverIds) {
      await this.quitDriver(driverId);
    }
    
    this.logger.info('All WebDrivers quit successfully');
  }

  /**
   * Takes a screenshot of the current browser window
   * @param driver The WebDriver instance
   * @param fileName The name of the screenshot file (optional)
   * @returns The path to the screenshot file
   */
  public async takeScreenshot(driver: WebDriver, fileName?: string): Promise<string> {
    try {
      // Create screenshots directory if it doesn't exist
      CSFileUtils.ensureDirectoryExists(this.config.screenshotDirectory);
      
      // Generate a filename if not provided
      const timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\./g, '-');
      const screenshotName = fileName || `screenshot-${timestamp}.png`;
      const screenshotPath = path.join(this.config.screenshotDirectory, screenshotName);
      
      // Take a screenshot
      const screenshotData = await driver.takeScreenshot();
      
      // Save the screenshot
      fs.writeFileSync(screenshotPath, screenshotData, 'base64');
      
      this.logger.debug(`Screenshot saved to ${screenshotPath}`);
      return screenshotPath;
    } catch (error) {
      this.logger.error(`Error taking screenshot: ${error}`);
      throw new Error(`Failed to take screenshot: ${error}`);
    }
  }

  /**
   * Gets the browser type for a WebDriver instance
   * @param driver The WebDriver instance
   * @returns The browser type
   */
  public async getBrowserType(driver: WebDriver): Promise<BrowserType> {
    try {
      const capabilities = await driver.getCapabilities();
      const browserName = capabilities.getBrowserName().toLowerCase();
      
      if (browserName.includes('chrome')) {
        return BrowserType.CHROME;
      } else if (browserName.includes('firefox')) {
        return BrowserType.FIREFOX;
      } else if (browserName.includes('microsoftedge') || browserName.includes('edge')) {
        return BrowserType.EDGE;
      } else if (browserName.includes('safari')) {
        return BrowserType.SAFARI;
      } else if (browserName.includes('internet explorer') || browserName.includes('ie')) {
        return BrowserType.IE;
      } else {
        this.logger.warn(`Unknown browser type: ${browserName}, assuming Chrome`);
        return BrowserType.CHROME;
      }
    } catch (error) {
      this.logger.error(`Error getting browser type: ${error}`);
      return BrowserType.CHROME; // Default to Chrome
    }
  }

  /**
   * Updates the capabilities for a specific browser
   * @param browser The browser type
   * @param capabilities The capabilities to set
   */
  public updateCapabilities(browser: BrowserType, capabilities: Capabilities): void {
    this.driverCapabilities.set(browser, capabilities);
    this.logger.debug(`Updated capabilities for ${browser}`);
  }

  /**
   * Gets the capabilities for a specific browser
   * @param browser The browser type
   * @returns The capabilities
   */
  public getCapabilities(browser: BrowserType): Capabilities {
    return this.driverCapabilities.get(browser) || Capabilities.chrome();
  }

  /**
   * Gets the current WebDriverManager configuration
   * @returns The WebDriverManager configuration
   */
  public getConfig(): WebDriverManagerConfig {
    return this.config;
  }

  /**
   * Updates the WebDriverManager configuration
   * @param config The new configuration
   */
  public updateConfig(config: Partial<WebDriverManagerConfig>): void {
    this.config = { ...this.config, ...config };
    this.logger.debug('WebDriverManager configuration updated');
  }

  /**
   * Gets all active WebDriver instances
   * @returns A map of driver IDs to WebDriver instances
   */
  public getActiveDrivers(): Map<string, WebDriver> {
    return new Map(this.drivers);
  }

  /**
   * Gets the current session ID for a WebDriver instance
   * @param driver The WebDriver instance
   * @returns The session ID
   */
  public async getSessionId(driver: WebDriver): Promise<string> {
    try {
      const session = await driver.getSession();
      return session.getId();
    } catch (error) {
      this.logger.error(`Error getting session ID: ${error}`);
      return '';
    }
  }

  /**
   * Refreshes the current page
   * @param driver The WebDriver instance
   */
  public async refreshPage(driver: WebDriver): Promise<void> {
    try {
      await driver.navigate().refresh();
    } catch (error) {
      this.logger.error(`Error refreshing page: ${error}`);
      throw new Error(`Failed to refresh page: ${error}`);
    }
  }

  /**
   * Navigates to a URL
   * @param driver The WebDriver instance
   * @param url The URL to navigate to
   */
  public async navigateTo(driver: WebDriver, url: string): Promise<void> {
    try {
      await driver.get(url);
    } catch (error) {
      this.logger.error(`Error navigating to ${url}: ${error}`);
      throw new Error(`Failed to navigate to ${url}: ${error}`);
    }
  }

  /**
   * Gets the current URL
   * @param driver The WebDriver instance
   * @returns The current URL
   */
  public async getCurrentUrl(driver: WebDriver): Promise<string> {
    try {
      return await driver.getCurrentUrl();
    } catch (error) {
      this.logger.error(`Error getting current URL: ${error}`);
      throw new Error(`Failed to get current URL: ${error}`);
    }
  }

  /**
   * Gets the title of the current page
   * @param driver The WebDriver instance
   * @returns The page title
   */
  public async getTitle(driver: WebDriver): Promise<string> {
    try {
      return await driver.getTitle();
    } catch (error) {
      this.logger.error(`Error getting page title: ${error}`);
      throw new Error(`Failed to get page title: ${error}`);
    }
  }

  /**
   * Executes JavaScript in the browser
   * @param driver The WebDriver instance
   * @param script The JavaScript to execute
   * @param args The arguments to pass to the script
   * @returns The result of the script execution
   */
  public async executeScript<T>(driver: WebDriver, script: string, ...args: any[]): Promise<T> {
    try {
      return await driver.executeScript<T>(script, ...args);
    } catch (error) {
      this.logger.error(`Error executing script: ${error}`);
      throw new Error(`Failed to execute script: ${error}`);
    }
  }

  /**
   * Executes asynchronous JavaScript in the browser
   * @param driver The WebDriver instance
   * @param script The JavaScript to execute
   * @param args The arguments to pass to the script
   * @returns The result of the script execution
   */
  public async executeAsyncScript<T>(driver: WebDriver, script: string, ...args: any[]): Promise<T> {
    try {
      return await driver.executeAsyncScript<T>(script, ...args);
    } catch (error) {
      this.logger.error(`Error executing async script: ${error}`);
      throw new Error(`Failed to execute async script: ${error}`);
    }
  }

  /**
   * Gets the performance logs from the browser
   * @param driver The WebDriver instance
   * @returns The performance logs
   */
  public async getPerformanceLogs(driver: WebDriver): Promise<logging.Entry[]> {
    try {
      return await driver.manage().logs().get(logging.Type.PERFORMANCE);
    } catch (error) {
      this.logger.error(`Error getting performance logs: ${error}`);
      return [];
    }
  }

  /**
   * Registers shutdown hooks to quit WebDriver instances when the process exits
   */
  public registerShutdownHooks(): void {
    // Register shutdown hook for SIGINT (Ctrl+C)
    process.on('SIGINT', async () => {
      this.logger.info('SIGINT received, quitting all WebDrivers');
      await this.quitAllDrivers();
      process.exit(0);
    });
    
    // Register shutdown hook for SIGTERM
    process.on('SIGTERM', async () => {
      this.logger.info('SIGTERM received, quitting all WebDrivers');
      await this.quitAllDrivers();
      process.exit(0);
    });
    
    // Register shutdown hook for uncaught exceptions
    process.on('uncaughtException', async (error) => {
      this.logger.error(`Uncaught exception: ${error}`);
      await this.quitAllDrivers();
      process.exit(1);
    });
    
    this.logger.debug('WebDriver shutdown hooks registered');
  }
}


WebDriverTypes.ts
----------------------------

import { Capabilities } from 'selenium-webdriver';

/**
 * Enumeration of supported browser types
 */
export enum BrowserType {
  CHROME = 'chrome',
  FIREFOX = 'firefox',
  EDGE = 'edge',
  SAFARI = 'safari',
  IE = 'ie'
}

/**
 * Options for configuring a WebDriver instance
 */
export interface DriverOptions {
  /**
   * The browser type to use (defaults to the configured default browser)
   */
  browser?: BrowserType;
  
  /**
   * Whether to use a remote WebDriver (defaults to the configured remote setting)
   */
  remote?: boolean;
  
  /**
   * The URL of the remote WebDriver server (defaults to the configured remote URL)
   */
  remoteUrl?: string;
  
  /**
   * Custom capabilities to add to the WebDriver
   */
  capabilities?: Record<string, any>;
  
  /**
   * WebDriver timeouts
   */
  timeouts?: {
    /**
     * Implicit wait timeout in milliseconds
     */
    implicit?: number;
    
    /**
     * Page load timeout in milliseconds
     */
    pageLoad?: number;
    
    /**
     * Script execution timeout in milliseconds
     */
    script?: number;
  };
  
  /**
   * Proxy configuration
   */
  proxySettings?: ProxyConfig;
  
  /**
   * Whether to automatically quit the WebDriver when the process exits
   */
  autoQuit?: boolean;
  
  /**
   * Whether to force the creation of a new WebDriver instance instead of reusing an existing one
   */
  forceNewDriver?: boolean;
  
  /**
   * Whether to run the browser in headless mode
   */
  headless?: boolean;
  
  /**
   * Whether to run the browser in incognito/private browsing mode
   */
  incognito?: boolean;
  
  /**
   * Custom command-line arguments to pass to the browser
   */
  arguments?: string[];
  
  /**
   * Path to the browser binary
   */
  binary?: string;
  
  /**
   * Paths to browser extensions to install
   */
  extensions?: string[];
  
  /**
   * Path to a user profile to use
   */
  userProfile?: string;
  
  /**
   * Experimental browser options
   */
  experimentalOptions?: Record<string, any>;
  
  /**
   * Directory to store downloaded files
   */
  downloadDirectory?: string;
  
  /**
   * Whether to log browser performance metrics
   */
  logPerformance?: boolean;
  
  /**
   * Port for remote debugging
   */
  debugPort?: number;
  
  /**
   * Whether to record video of the browser session
   */
  recordVideo?: boolean;
  
  /**
   * Directory to store recorded videos
   */
  videoDirectory?: string;
  
  /**
   * Session ID for attaching to an existing session
   */
  sessionId?: string;
  
  /**
   * Browser version to use
   */
  browserVersion?: string;
  
  /**
   * Platform name to use
   */
  platformName?: string;
}

/**
 * Proxy configuration
 */
export interface ProxyConfig {
  /**
   * Type of proxy configuration
   * - 'direct': No proxy
   * - 'manual': Manual proxy configuration
   * - 'pac': PAC file configuration
   * - 'autodetect': Auto-detect proxy settings
   * - 'system': Use system proxy settings
   */
  type: 'direct' | 'manual' | 'pac' | 'autodetect' | 'system';
  
  /**
   * HTTP proxy address (host:port)
   */
  http?: string;
  
  /**
   * HTTPS proxy address (host:port)
   */
  https?: string;
  
  /**
   * FTP proxy address (host:port)
   */
  ftp?: string;
  
  /**
   * SOCKS proxy address (host:port)
   */
  socks?: string;
  
  /**
   * SOCKS proxy version (4 or 5)
   */
  socksVersion?: number;
  
  /**
   * PAC file URL (for pac proxy type)
   */
  pacUrl?: string;
  
  /**
   * List of hosts to bypass the proxy
   */
  bypass?: string[];
}

/**
 * Browser-specific options
 */
export interface BrowserOptions {
  /**
   * Whether to run the browser in headless mode
   */
  headless?: boolean;
  
  /**
   * Whether to run the browser in incognito/private browsing mode
   */
  incognito?: boolean;
  
  /**
   * Custom command-line arguments to pass to the browser
   */
  arguments?: string[];
  
  /**
   * Path to the browser binary
   */
  binary?: string;
  
  /**
   * Experimental browser options
   */
  experimentalOptions?: Record<string, any>;
}

/**
 * WebDriverManager configuration
 */
export interface WebDriverManagerConfig {
  /**
   * The default browser to use
   */
  defaultBrowser: BrowserType;
  
  /**
   * Whether to use a remote WebDriver by default
   */
  useRemote: boolean;
  
  /**
   * The default URL of the remote WebDriver server
   */
  remoteUrl: string;
  
  /**
   * Default WebDriver timeouts
   */
  timeouts: {
    /**
     * Implicit wait timeout in milliseconds
     */
    implicit: number;
    
    /**
     * Page load timeout in milliseconds
     */
    pageLoad: number;
    
    /**
     * Script execution timeout in milliseconds
     */
    script: number;
  };
  
  /**
   * Whether to automatically quit the WebDriver when the process exits
   */
  autoQuit: boolean;
  
  /**
   * Whether to take screenshots on test failure
   */
  screenshotsOnFailure: boolean;
  
  /**
   * Directory to store screenshots
   */
  screenshotDirectory: string;
  
  /**
   * Directory to store downloaded files
   */
  downloadsDirectory: string;
  
  /**
   * Whether to log browser performance metrics
   */
  logPerformance: boolean;
  
  /**
   * Whether to record video of the browser session
   */
  recordVideo: boolean;
  
  /**
   * Directory to store recorded videos
   */
  videoDirectory: string;
  
  /**
   * Default proxy settings
   */
  proxySettings: ProxyConfig | null;
  
  /**
   * Browser-specific options
   */
  browserOptions: {
    [key in BrowserType]?: BrowserOptions;
  };
}

/**
 * Browser capabilities provider
 */
export interface CapabilitiesProvider {
  /**
   * Gets the capabilities for a specific browser
   * @param browser The browser type
   * @returns The capabilities
   */
  getCapabilities(browser: BrowserType): Capabilities;
  
  /**
   * Updates the capabilities for a specific browser
   * @param browser The browser type
   * @param capabilities The capabilities to set
   */
  updateCapabilities(browser: BrowserType, capabilities: Capabilities): void;
}



BrowserManager.ts
----------------------------

import {
  WebDriver,
  WebElement,
  By,
  until,
  Condition,
  Actions,
  Key,
  logging
} from 'selenium-webdriver';
import { WebDriverManager } from './WebDriverManager';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSEncryptionUtils } from '../../core/utils/CSEncryptionUtils';
import { CSScreenshotManager } from '../../core/utils/CSScreenshotManager';
import { CSFileUtils } from '../../core/utils/CSFileUtils';
import { BrowserType, DriverOptions } from '../types/WebDriverTypes';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Options for browser navigation
 */
export interface NavigationOptions {
  /**
   * The timeout for the navigation in milliseconds
   */
  timeout?: number;
  
  /**
   * Whether to wait for the page to load completely
   */
  waitForPageLoad?: boolean;
  
  /**
   * Whether to wait for network idle
   */
  waitForNetworkIdle?: boolean;
  
  /**
   * The maximum time to wait for network idle in milliseconds
   */
  networkIdleTimeout?: number;
  
  /**
   * The maximum number of inflight requests to consider the network as idle
   */
  networkIdleInflight?: number;
  
  /**
   * Whether to clear the browser cache before navigation
   */
  clearCache?: boolean;
  
  /**
   * Whether to clear browser cookies before navigation
   */
  clearCookies?: boolean;
  
  /**
   * Custom headers to set for the navigation
   */
  headers?: Record<string, string>;
}

/**
 * Options for taking screenshots
 */
export interface ScreenshotOptions {
  /**
   * The path where to save the screenshot
   */
  path?: string;
  
  /**
   * The file name for the screenshot
   */
  fileName?: string;
  
  /**
   * Whether to capture a full page screenshot (not just viewport)
   */
  fullPage?: boolean;
  
  /**
   * The format of the screenshot (png or jpeg)
   */
  format?: 'png' | 'jpeg';
  
  /**
   * The quality of the screenshot (0-100, jpeg only)
   */
  quality?: number;
  
  /**
   * The timeout for taking the screenshot in milliseconds
   */
  timeout?: number;
  
  /**
   * Whether to hide scrollbars in the screenshot
   */
  hideScrollbars?: boolean;
  
  /**
   * Specific element to screenshot instead of entire page
   */
  element?: WebElement;
}

/**
 * Window state for browser windows
 */
export enum WindowState {
  NORMAL = 'normal',
  MAXIMIZED = 'maximized',
  MINIMIZED = 'minimized',
  FULLSCREEN = 'fullscreen'
}

/**
 * Coordinates for mouse actions
 */
export interface Coordinates {
  x: number;
  y: number;
}

/**
 * Cookie options
 */
export interface CookieOptions {
  /**
   * The name of the cookie
   */
  name: string;
  
  /**
   * The value of the cookie
   */
  value: string;
  
  /**
   * The domain of the cookie
   */
  domain?: string;
  
  /**
   * The path of the cookie
   */
  path?: string;
  
  /**
   * Whether the cookie is secure
   */
  secure?: boolean;
  
  /**
   * Whether the cookie is HTTP only
   */
  httpOnly?: boolean;
  
  /**
   * The expiration date of the cookie
   */
  expiry?: Date;
  
  /**
   * The same-site attribute of the cookie
   */
  sameSite?: 'Strict' | 'Lax' | 'None';
}

/**
 * Browser window information
 */
export interface WindowInfo {
  /**
   * The handle of the window
   */
  handle: string;
  
  /**
   * The title of the window
   */
  title: string;
  
  /**
   * The URL of the window
   */
  url: string;
}

/**
 * Network condition emulation settings
 */
export interface NetworkConditions {
  /**
   * Download throughput in bytes per second (0 for unlimited)
   */
  download: number;
  
  /**
   * Upload throughput in bytes per second (0 for unlimited)
   */
  upload: number;
  
  /**
   * Latency in milliseconds
   */
  latency: number;
}

/**
 * Options for file upload
 */
export interface FileUploadOptions {
  /**
   * The element to upload files to (must be an input[type=file])
   */
  element: WebElement | By;
  
  /**
   * The path(s) to the file(s) to upload
   */
  filePaths: string[];
  
  /**
   * Whether to verify the upload was successful
   */
  verify?: boolean;
  
  /**
   * The timeout for the file upload in milliseconds
   */
  timeout?: number;
}

/**
 * BrowserManager provides a high-level API for browser automation,
 * wrapping WebDriver functionality with enhanced features and simplified methods.
 */
export class BrowserManager {
  private driver: WebDriver;
  private logger: CSLogger;
  private webDriverManager: WebDriverManager;
  private screenshotManager: CSScreenshotManager;
  private mainWindowHandle: string;
  private lastNavigationStartTime: number = 0;
  private performanceLogging: boolean = false;
  private networkRequests: Record<string, any>[] = [];
  private windowHandleStack: string[] = [];
  private browserType: BrowserType;
  private defaultNavigationOptions: NavigationOptions = {
    timeout: 60000,
    waitForPageLoad: true,
    waitForNetworkIdle: false,
    networkIdleTimeout: 5000,
    networkIdleInflight: 2,
    clearCache: false,
    clearCookies: false
  };

  /**
   * Creates a new BrowserManager instance
   * @param driver The WebDriver instance to manage (if not provided, a new one will be created)
   * @param options Options for creating a new WebDriver (if driver is not provided)
   */
  constructor(driver?: WebDriver, options?: DriverOptions) {
    this.logger = new CSLogger('BrowserManager');
    this.webDriverManager = WebDriverManager.getInstance();
    this.screenshotManager = new CSScreenshotManager();
    
    if (driver) {
      this.driver = driver;
      this.logger.debug('Using provided WebDriver instance');
    } else {
      // The driver will be initialized in the initialize method
      this.logger.debug('No WebDriver provided, will create a new one during initialization');
    }
  }

  /**
   * Initializes the BrowserManager
   * @param options Options for creating a new WebDriver (if driver is not provided in constructor)
   * @returns This BrowserManager instance
   */
  public async initialize(options?: DriverOptions): Promise<BrowserManager> {
    try {
      if (!this.driver) {
        this.logger.info('Creating new WebDriver instance');
        this.driver = await this.webDriverManager.getDriver(options);
      }
      
      // Store the main window handle for later use
      this.mainWindowHandle = await this.driver.getWindowHandle();
      this.logger.debug(`Main window handle: ${this.mainWindowHandle}`);
      
      // Initialize window handle stack
      this.windowHandleStack = [this.mainWindowHandle];
      
      // Detect browser type
      this.browserType = await this.webDriverManager.getBrowserType(this.driver);
      this.logger.debug(`Browser type: ${this.browserType}`);
      
      // Check if performance logging is enabled
      const config = this.webDriverManager.getConfig();
      this.performanceLogging = config.logPerformance;
      if (this.performanceLogging) {
        this.logger.debug('Performance logging is enabled');
        
        // Start collecting network requests if using Chrome
        if (this.browserType === BrowserType.CHROME) {
          await this.startNetworkMonitoring();
        }
      }
      
      return this;
    } catch (error) {
      this.logger.error(`Error initializing BrowserManager: ${error}`);
      throw new Error(`Failed to initialize BrowserManager: ${error}`);
    }
  }

  /**
   * Gets the WebDriver instance
   * @returns The WebDriver instance
   */
  public getDriver(): WebDriver {
    return this.driver;
  }

  /**
   * Gets the browser type
   * @returns The browser type
   */
  public getBrowserType(): BrowserType {
    return this.browserType;
  }

  /**
   * Sets the default navigation options
   * @param options The default navigation options
   */
  public setDefaultNavigationOptions(options: NavigationOptions): void {
    this.defaultNavigationOptions = {
      ...this.defaultNavigationOptions,
      ...options
    };
    this.logger.debug('Default navigation options updated', this.defaultNavigationOptions);
  }

  /**
   * Navigates to a URL
   * @param url The URL to navigate to
   * @param options Navigation options
   */
  public async navigateTo(url: string, options?: NavigationOptions): Promise<void> {
    const mergedOptions = { ...this.defaultNavigationOptions, ...options };
    this.logger.info(`Navigating to ${url}`);
    
    try {
      // Clear cache and cookies if requested
      if (mergedOptions.clearCache) {
        await this.clearCache();
      }
      
      if (mergedOptions.clearCookies) {
        await this.clearCookies();
      }
      
      // Set custom headers if provided
      if (mergedOptions.headers && Object.keys(mergedOptions.headers).length > 0) {
        await this.setHeaders(mergedOptions.headers);
      }
      
      // Record navigation start time for performance metrics
      this.lastNavigationStartTime = Date.now();
      this.networkRequests = [];
      
      // Navigate to the URL
      await this.driver.get(url);
      
      // Wait for page to load if requested
      if (mergedOptions.waitForPageLoad) {
        await this.waitForPageLoad(mergedOptions.timeout);
      }
      
      // Wait for network idle if requested
      if (mergedOptions.waitForNetworkIdle) {
        await this.waitForNetworkIdle(
          mergedOptions.networkIdleInflight || 2,
          mergedOptions.networkIdleTimeout || 5000
        );
      }
      
      this.logger.debug(`Successfully navigated to ${url}`);
    } catch (error) {
      this.logger.error(`Error navigating to ${url}: ${error}`);
      throw new Error(`Failed to navigate to ${url}: ${error}`);
    }
  }

  /**
   * Refreshes the current page
   * @param options Navigation options
   */
  public async refresh(options?: NavigationOptions): Promise<void> {
    const mergedOptions = { ...this.defaultNavigationOptions, ...options };
    this.logger.info('Refreshing page');
    
    try {
      // Record navigation start time for performance metrics
      this.lastNavigationStartTime = Date.now();
      this.networkRequests = [];
      
      // Refresh the page
      await this.driver.navigate().refresh();
      
      // Wait for page to load if requested
      if (mergedOptions.waitForPageLoad) {
        await this.waitForPageLoad(mergedOptions.timeout);
      }
      
      // Wait for network idle if requested
      if (mergedOptions.waitForNetworkIdle) {
        await this.waitForNetworkIdle(
          mergedOptions.networkIdleInflight || 2,
          mergedOptions.networkIdleTimeout || 5000
        );
      }
      
      this.logger.debug('Page refreshed successfully');
    } catch (error) {
      this.logger.error(`Error refreshing page: ${error}`);
      throw new Error(`Failed to refresh page: ${error}`);
    }
  }

  /**
   * Navigates back in the browser history
   * @param options Navigation options
   */
  public async back(options?: NavigationOptions): Promise<void> {
    const mergedOptions = { ...this.defaultNavigationOptions, ...options };
    this.logger.info('Navigating back');
    
    try {
      // Record navigation start time for performance metrics
      this.lastNavigationStartTime = Date.now();
      this.networkRequests = [];
      
      // Navigate back
      await this.driver.navigate().back();
      
      // Wait for page to load if requested
      if (mergedOptions.waitForPageLoad) {
        await this.waitForPageLoad(mergedOptions.timeout);
      }
      
      // Wait for network idle if requested
      if (mergedOptions.waitForNetworkIdle) {
        await this.waitForNetworkIdle(
          mergedOptions.networkIdleInflight || 2,
          mergedOptions.networkIdleTimeout || 5000
        );
      }
      
      this.logger.debug('Navigated back successfully');
    } catch (error) {
      this.logger.error(`Error navigating back: ${error}`);
      throw new Error(`Failed to navigate back: ${error}`);
    }
  }

  /**
   * Navigates forward in the browser history
   * @param options Navigation options
   */
  public async forward(options?: NavigationOptions): Promise<void> {
    const mergedOptions = { ...this.defaultNavigationOptions, ...options };
    this.logger.info('Navigating forward');
    
    try {
      // Record navigation start time for performance metrics
      this.lastNavigationStartTime = Date.now();
      this.networkRequests = [];
      
      // Navigate forward
      await this.driver.navigate().forward();
      
      // Wait for page to load if requested
      if (mergedOptions.waitForPageLoad) {
        await this.waitForPageLoad(mergedOptions.timeout);
      }
      
      // Wait for network idle if requested
      if (mergedOptions.waitForNetworkIdle) {
        await this.waitForNetworkIdle(
          mergedOptions.networkIdleInflight || 2,
          mergedOptions.networkIdleTimeout || 5000
        );
      }
      
      this.logger.debug('Navigated forward successfully');
    } catch (error) {
      this.logger.error(`Error navigating forward: ${error}`);
      throw new Error(`Failed to navigate forward: ${error}`);
    }
  }

  /**
   * Gets the current URL
   * @returns The current URL
   */
  public async getCurrentUrl(): Promise<string> {
    try {
      return await this.driver.getCurrentUrl();
    } catch (error) {
      this.logger.error(`Error getting current URL: ${error}`);
      throw new Error(`Failed to get current URL: ${error}`);
    }
  }

  /**
   * Gets the title of the current page
   * @returns The page title
   */
  public async getTitle(): Promise<string> {
    try {
      return await this.driver.getTitle();
    } catch (error) {
      this.logger.error(`Error getting page title: ${error}`);
      throw new Error(`Failed to get page title: ${error}`);
    }
  }

  /**
   * Gets the page source of the current page
   * @returns The page source
   */
  public async getPageSource(): Promise<string> {
    try {
      return await this.driver.getPageSource();
    } catch (error) {
      this.logger.error(`Error getting page source: ${error}`);
      throw new Error(`Failed to get page source: ${error}`);
    }
  }

  /**
   * Waits for a specific condition to be met
   * @param condition The condition to wait for
   * @param timeout The timeout in milliseconds
   * @param message Optional message for timeout error
   * @returns The value returned by the condition
   */
  public async waitFor<T>(condition: Condition<T> | Function, timeout?: number, message?: string): Promise<T> {
    try {
      const timeoutMs = timeout || this.defaultNavigationOptions.timeout || 30000;
      
      // If condition is a function, convert it to a Condition
      if (typeof condition === 'function') {
        const conditionFn = condition as Function;
        condition = new Condition<T>(message || 'Custom condition', conditionFn as () => Promise<T>);
      }
      
      return await this.driver.wait(condition as Condition<T>, timeoutMs, message);
    } catch (error) {
      this.logger.error(`Error waiting for condition: ${error}`);
      throw new Error(`Failed to wait for condition${message ? ` "${message}"` : ''}: ${error}`);
    }
  }

  /**
   * Waits for the page to load completely
   * @param timeout The timeout in milliseconds
   */
  public async waitForPageLoad(timeout?: number): Promise<void> {
    const timeoutMs = timeout || this.defaultNavigationOptions.timeout || 30000;
    this.logger.debug(`Waiting for page to load (timeout: ${timeoutMs}ms)`);
    
    try {
      // Wait for document.readyState to be 'complete'
      await this.driver.wait(async () => {
        const readyState = await this.driver.executeScript('return document.readyState');
        return readyState === 'complete';
      }, timeoutMs, 'Page load timeout');
      
      this.logger.debug('Page loaded successfully');
    } catch (error) {
      this.logger.error(`Error waiting for page load: ${error}`);
      throw new Error(`Failed to wait for page load: ${error}`);
    }
  }

  /**
   * Waits for network activity to become idle
   * @param maxInflight Maximum number of inflight requests to consider the network as idle
   * @param timeout The timeout in milliseconds
   */
  public async waitForNetworkIdle(maxInflight?: number, timeout?: number): Promise<void> {
    const maxInflightRequests = maxInflight || 2;
    const timeoutMs = timeout || 5000;
    this.logger.debug(`Waiting for network idle (max inflight: ${maxInflightRequests}, timeout: ${timeoutMs}ms)`);
    
    if (this.browserType !== BrowserType.CHROME) {
      this.logger.warn('Network idle monitoring is only available for Chrome, skipping');
      return;
    }
    
    // We need to implement this differently depending on whether we have performance logging
    if (this.performanceLogging) {
      // Use collected network requests to determine idle state
      await this.waitForNetworkIdleUsingPerformanceLogs(maxInflightRequests, timeoutMs);
    } else {
      // Fall back to a JavaScript-based approach
      await this.waitForNetworkIdleUsingJavaScript(maxInflightRequests, timeoutMs);
    }
    
    this.logger.debug('Network is idle');
  }

  /**
   * Waits for network activity to become idle using performance logs
   * @param maxInflight Maximum number of inflight requests to consider the network as idle
   * @param timeout The timeout in milliseconds
   */
  private async waitForNetworkIdleUsingPerformanceLogs(maxInflight: number, timeout: number): Promise<void> {
    try {
      const startTime = Date.now();
      let inflightRequests = this.getInflightRequestCount();
      let lastChangeTime = startTime;
      
      // Wait for inflight requests to drop below the threshold
      // and remain there for at least 500ms
      while (true) {
        // Check if we've exceeded the timeout
        if (Date.now() - startTime > timeout) {
          this.logger.warn(`Network idle timeout (${timeout}ms) exceeded, continuing`);
          return;
        }
        
        // Update network requests
        await this.updateNetworkRequests();
        
        // Get current inflight count
        const currentInflight = this.getInflightRequestCount();
        
        // If count changed, update last change time
        if (currentInflight !== inflightRequests) {
          inflightRequests = currentInflight;
          lastChangeTime = Date.now();
        }
        
        // If below threshold and stable for 500ms, we're done
        if (inflightRequests <= maxInflight && Date.now() - lastChangeTime >= 500) {
          return;
        }
        
        // Wait a bit before checking again
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    } catch (error) {
      this.logger.error(`Error waiting for network idle: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Waits for network activity to become idle using JavaScript
   * @param maxInflight Maximum number of inflight requests to consider the network as idle
   * @param timeout The timeout in milliseconds
   */
  private async waitForNetworkIdleUsingJavaScript(maxInflight: number, timeout: number): Promise<void> {
    try {
      // Inject the network monitoring script if it hasn't been injected yet
      await this.injectNetworkMonitoringScript();
      
      const startTime = Date.now();
      
      // Wait for window.__networkIdle to be true
      await this.driver.wait(async () => {
        const result = await this.driver.executeScript(`
          return {
            idle: window.__networkIdle === true,
            inflight: window.__inflightRequests || 0
          };
        `);
        
        const idle = result.idle;
        const inflight = result.inflight;
        
        // Return true if idle or inflight is below threshold
        return idle || inflight <= maxInflight;
      }, timeout, 'Network idle timeout');
    } catch (error) {
      this.logger.error(`Error waiting for network idle: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Injects the network monitoring script into the page
   */
  private async injectNetworkMonitoringScript(): Promise<void> {
    try {
      await this.driver.executeScript(`
        // Skip if already injected
        if (window.__networkMonitorInjected) return;
        
        window.__networkMonitorInjected = true;
        window.__inflightRequests = 0;
        window.__networkIdle = true;
        window.__requestLog = [];
        
        // Store original methods
        const originalFetch = window.fetch;
        const originalOpen = XMLHttpRequest.prototype.open;
        const originalSend = XMLHttpRequest.prototype.send;
        
        // Define network idle checker
        const updateNetworkIdle = () => {
          window.__networkIdle = window.__inflightRequests <= 0;
        };
        
        // Intercept fetch
        window.fetch = function(...args) {
          window.__inflightRequests++;
          window.__networkIdle = false;
          window.__requestLog.push({
            type: 'fetch',
            url: args[0],
            timestamp: Date.now(),
            status: 'pending'
          });
          
          return originalFetch.apply(this, args)
            .then(response => {
              window.__inflightRequests--;
              updateNetworkIdle();
              return response;
            })
            .catch(error => {
              window.__inflightRequests--;
              updateNetworkIdle();
              throw error;
            });
        };
        
        // Intercept XMLHttpRequest
        XMLHttpRequest.prototype.open = function(method, url, ...args) {
          this.__url = url;
          return originalOpen.apply(this, [method, url, ...args]);
        };
        
        XMLHttpRequest.prototype.send = function(...args) {
          window.__inflightRequests++;
          window.__networkIdle = false;
          window.__requestLog.push({
            type: 'xhr',
            url: this.__url,
            timestamp: Date.now(),
            status: 'pending'
          });
          
          // Track readystatechange
          this.addEventListener('readystatechange', function() {
            if (this.readyState === 4) {
              window.__inflightRequests--;
              updateNetworkIdle();
            }
          });
          
          return originalSend.apply(this, args);
        };
      `);
      
      this.logger.debug('Network monitoring script injected');
    } catch (error) {
      this.logger.error(`Error injecting network monitoring script: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Updates the network requests from performance logs
   */
  private async updateNetworkRequests(): Promise<void> {
    if (!this.performanceLogging || this.browserType !== BrowserType.CHROME) {
      return;
    }
    
    try {
      const logs = await this.driver.manage().logs().get(logging.Type.PERFORMANCE);
      
      for (const entry of logs) {
        const message = JSON.parse(entry.message).message;
        
        // Only process network events
        if (message.method && message.method.startsWith('Network.')) {
          // Process each network event
          this.processNetworkEvent(message);
        }
      }
    } catch (error) {
      this.logger.error(`Error updating network requests: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Processes a network event from performance logs
   * @param event The network event
   */
  private processNetworkEvent(event: any): void {
    const method = event.method;
    const params = event.params;
    
    // Handle different network events
    if (method === 'Network.requestWillBeSent') {
      const requestId = params.requestId;
      const url = params.request.url;
      
      // Add to network requests
      this.networkRequests.push({
        id: requestId,
        url: url,
        startTime: Date.now(),
        status: 'pending'
      });
    } else if (method === 'Network.responseReceived') {
      const requestId = params.requestId;
      const status = params.response.status;
      
      // Update the request status
      const request = this.networkRequests.find(r => r.id === requestId);
      if (request) {
        request.status = 'received';
        request.statusCode = status;
      }
    } else if (method === 'Network.loadingFinished') {
      const requestId = params.requestId;
      
      // Update the request status
      const request = this.networkRequests.find(r => r.id === requestId);
      if (request) {
        request.status = 'finished';
        request.endTime = Date.now();
      }
    } else if (method === 'Network.loadingFailed') {
      const requestId = params.requestId;
      
      // Update the request status
      const request = this.networkRequests.find(r => r.id === requestId);
      if (request) {
        request.status = 'failed';
        request.errorText = params.errorText;
        request.endTime = Date.now();
      }
    }
  }

  /**
   * Gets the count of inflight requests
   * @returns The number of inflight requests
   */
  private getInflightRequestCount(): number {
    return this.networkRequests.filter(r => r.status === 'pending').length;
  }

  /**
   * Starts monitoring network requests
   */
  private async startNetworkMonitoring(): Promise<void> {
    if (this.browserType !== BrowserType.CHROME) {
      this.logger.warn('Network monitoring is only available for Chrome, skipping');
      return;
    }
    
    try {
      // Enable Network domain for Chrome DevTools Protocol
      await this.driver.executeScript(`
        window.__networkRequests = [];
        window.__inflightRequests = 0;
        window.__networkIdle = true;
      `);
      
      this.logger.debug('Network monitoring started');
    } catch (error) {
      this.logger.error(`Error starting network monitoring: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Gets the network requests collected so far
   * @returns The network requests
   */
  public async getNetworkRequests(): Promise<any[]> {
    return this.networkRequests.slice();
  }

  /**
   * Gets the performance metrics of the page
   * @returns The performance metrics
   */
  public async getPerformanceMetrics(): Promise<Record<string, number>> {
    try {
      // Chrome-specific performance metrics
      if (this.browserType === BrowserType.CHROME) {
        // Execute JavaScript to get performance metrics
        const metrics = await this.driver.executeScript(`
          const perfData = window.performance.timing;
          const navigationStart = perfData.navigationStart;
          
          return {
            navigationStart: navigationStart,
            loadEventEnd: perfData.loadEventEnd,
            domContentLoaded: perfData.domContentLoadedEventEnd,
            firstPaint: window.performance.getEntriesByType ? 
              (window.performance.getEntriesByType('paint').find(e => e.name === 'first-paint')?.startTime || 0) : 0,
            firstContentfulPaint: window.performance.getEntriesByType ? 
              (window.performance.getEntriesByType('paint').find(e => e.name === 'first-contentful-paint')?.startTime || 0) : 0,
            timeToInteractive: performanceObserver ? window.__timeToInteractive || 0 : 0,
            totalRequests: window.performance.getEntriesByType ? 
              window.performance.getEntriesByType('resource').length : 0,
            serverTiming: (() => {
              if (!window.performance.getEntriesByType) return {};
              const navEntry = window.performance.getEntriesByType('navigation')[0];
              if (!navEntry || !navEntry.serverTiming) return {};
              
              const result = {};
              navEntry.serverTiming.forEach(timing => {
                result[timing.name] = timing.duration;
              });
              return result;
            })()
          };
        `);
        
        // Calculate derived metrics
        const navigationStart = metrics.navigationStart || this.lastNavigationStartTime;
        const loadTime = metrics.loadEventEnd ? metrics.loadEventEnd - navigationStart : 0;
        const domContentLoadedTime = metrics.domContentLoaded ? metrics.domContentLoaded - navigationStart : 0;
        const firstPaintTime = metrics.firstPaint || 0;
        const firstContentfulPaintTime = metrics.firstContentfulPaint || 0;
        
        // Return the metrics
        return {
          loadTime,
          domContentLoadedTime,
          firstPaintTime,
          firstContentfulPaintTime,
          timeToInteractive: metrics.timeToInteractive || 0,
          totalRequests: metrics.totalRequests || 0,
          ...metrics.serverTiming
        };
      } else {
        // Basic metrics for other browsers
        const loadTime = await this.driver.executeScript(`
          return window.performance && window.performance.timing ? 
            window.performance.timing.loadEventEnd - window.performance.timing.navigationStart : 0;
        `);
        
        return { loadTime };
      }
    } catch (error) {
      this.logger.error(`Error getting performance metrics: ${error}`);
      return { error: 1 };
    }
  }

  /**
   * Takes a screenshot
   * @param options Screenshot options
   * @returns The path to the saved screenshot
   */
  public async takeScreenshot(options?: ScreenshotOptions): Promise<string> {
    try {
      const mergedOptions: ScreenshotOptions = {
        path: options?.path || './screenshots',
        fileName: options?.fileName || `screenshot-${new Date().toISOString().replace(/:/g, '-')}.png`,
        fullPage: options?.fullPage || false,
        format: options?.format || 'png',
        quality: options?.quality || 100,
        timeout: options?.timeout || 30000,
        hideScrollbars: options?.hideScrollbars || true,
        element: options?.element
      };
      
      // Ensure directory exists
      CSFileUtils.ensureDirectoryExists(mergedOptions.path!);
      
      // Construct full file path
      const filePath = path.join(mergedOptions.path!, mergedOptions.fileName!);
      
      // Hide scrollbars if requested
      if (mergedOptions.hideScrollbars) {
        await this.driver.executeScript(`
          document.documentElement.style.overflow = 'hidden';
          document.body.style.overflow = 'hidden';
        `);
      }
      
      // Take element screenshot or full page screenshot
      if (mergedOptions.element) {
        // Element screenshot
        const screenshotData = await mergedOptions.element.takeScreenshot();
        fs.writeFileSync(filePath, screenshotData, 'base64');
      } else if (mergedOptions.fullPage && this.browserType === BrowserType.CHROME) {
        // Full page screenshot for Chrome
        await this.takeFullPageScreenshot(filePath, mergedOptions);
      } else {
        // Regular viewport screenshot
        const screenshotData = await this.driver.takeScreenshot();
        fs.writeFileSync(filePath, screenshotData, 'base64');
      }
      
      // Restore scrollbars if hidden
      if (mergedOptions.hideScrollbars) {
        await this.driver.executeScript(`
          document.documentElement.style.overflow = '';
          document.body.style.overflow = '';
        `);
      }
      
      this.logger.debug(`Screenshot saved to ${filePath}`);
      return filePath;
    } catch (error) {
      this.logger.error(`Error taking screenshot: ${error}`);
      throw new Error(`Failed to take screenshot: ${error}`);
    }
  }

  /**
   * Takes a full page screenshot using JavaScript scrolling
   * @param filePath The path to save the screenshot
   * @param options Screenshot options
   */
  private async takeFullPageScreenshot(filePath: string, options: ScreenshotOptions): Promise<void> {
    try {
      // Get page dimensions
      const dimensions = await this.driver.executeScript<{ width: number, height: number }>(`
        return {
          width: Math.max(
            document.documentElement.scrollWidth,
            document.body.scrollWidth,
            document.documentElement.clientWidth
          ),
          height: Math.max(
            document.documentElement.scrollHeight,
            document.body.scrollHeight,
            document.documentElement.clientHeight
          )
        };
      `);
      
      // Get current window size
      const windowSize = await this.driver.manage().window().getRect();
      
      // Set window size to capture full width
      await this.driver.manage().window().setRect({
        x: windowSize.x,
        y: windowSize.y,
        width: dimensions.width,
        height: windowSize.height
      });
      
      // Create canvas for full page
      await this.driver.executeScript(`
        // Remove any existing canvas
        const existingCanvas = document.getElementById('__fullPageScreenshotCanvas');
        if (existingCanvas) {
          existingCanvas.remove();
        }
        
        // Create new canvas
        const canvas = document.createElement('canvas');
        canvas.id = '__fullPageScreenshotCanvas';
        canvas.width = ${dimensions.width};
        canvas.height = ${dimensions.height};
        canvas.style.display = 'none';
        document.body.appendChild(canvas);
        
        // Initialize context
        window.__fullPageScreenshot = {
          canvas: canvas,
          context: canvas.getContext('2d')
        };
      `);
      
      // Calculate chunks to capture
      const chunkHeight = windowSize.height;
      const chunks = Math.ceil(dimensions.height / chunkHeight);
      
      // Capture chunks
      for (let i = 0; i < chunks; i++) {
        const scrollTop = i * chunkHeight;
        
        // Scroll to position
        await this.driver.executeScript(`window.scrollTo(0, ${scrollTop});`);
        
        // Wait for any animations to complete
        await this.driver.sleep(100);
        
        // Capture screenshot
        const screenshotData = await this.driver.takeScreenshot();
        
        // Add to canvas
        await this.driver.executeScript(`
          return new Promise(resolve => {
            const context = window.__fullPageScreenshot.context;
            const img = new Image();
            
            img.onload = () => {
              context.drawImage(img, 0, ${i * chunkHeight});
              resolve();
            };
            
            img.src = 'data:image/png;base64,${screenshotData}';
          });
        `);
      }
      
      // Export from canvas
      const fullScreenshotData = await this.driver.executeScript<string>(`
        const format = '${options.format === 'jpeg' ? 'image/jpeg' : 'image/png'}';
        const quality = ${options.quality / 100};
        
        // Get data URL from canvas
        const dataUrl = window.__fullPageScreenshot.canvas.toDataURL(format, quality);
        
        // Clean up
        document.getElementById('__fullPageScreenshotCanvas').remove();
        delete window.__fullPageScreenshot;
        
        // Return base64 data
        return dataUrl.split(',')[1];
      `);
      
      // Save to file
      fs.writeFileSync(filePath, fullScreenshotData, 'base64');
      
      // Restore window size and scroll position
      await this.driver.manage().window().setRect(windowSize);
      await this.driver.executeScript('window.scrollTo(0, 0);');
    } catch (error) {
      this.logger.error(`Error taking full page screenshot: ${error}`);
      throw new Error(`Failed to take full page screenshot: ${error}`);
    }
  }

  /**
   * Executes JavaScript in the browser
   * @param script The JavaScript to execute
   * @param args The arguments to pass to the script
   * @returns The result of the script execution
   */
  public async executeScript<T>(script: string | Function, ...args: any[]): Promise<T> {
    try {
      // Convert function to string if needed
      if (typeof script === 'function') {
        script = `return (${script.toString()}).apply(null, arguments);`;
      }
      
      return await this.driver.executeScript<T>(script as string, ...args);
    } catch (error) {
      this.logger.error(`Error executing script: ${error}`);
      throw new Error(`Failed to execute script: ${error}`);
    }
  }

  /**
   * Executes asynchronous JavaScript in the browser
   * @param script The JavaScript to execute
   * @param args The arguments to pass to the script
   * @returns The result of the script execution
   */
  public async executeAsyncScript<T>(script: string | Function, ...args: any[]): Promise<T> {
    try {
      // Convert function to string if needed
      if (typeof script === 'function') {
        script = `var callback = arguments[arguments.length - 1];
          (${script.toString()}).apply(null, Array.prototype.slice.call(arguments, 0, -1))
            .then(callback)
            .catch(function(err) { callback({ error: err.toString() }); });`;
      }
      
      return await this.driver.executeAsyncScript<T>(script as string, ...args);
    } catch (error) {
      this.logger.error(`Error executing async script: ${error}`);
      throw new Error(`Failed to execute async script: ${error}`);
    }
  }

  /**
   * Sets headers for all subsequent requests
   * @param headers The headers to set
   */
  public async setHeaders(headers: Record<string, string>): Promise<void> {
    try {
      // Only supported in Chrome
      if (this.browserType !== BrowserType.CHROME) {
        this.logger.warn('Setting headers is only supported in Chrome, skipping');
        return;
      }
      
      // Inject header interceptor script
      await this.driver.executeScript(`
        // Skip if already injected
        if (window.__headerInterceptorInjected) {
          // Update headers
          window.__customHeaders = ${JSON.stringify(headers)};
          return;
        }
        
        window.__headerInterceptorInjected = true;
        window.__customHeaders = ${JSON.stringify(headers)};
        
        // Store original methods
        const originalFetch = window.fetch;
        const originalOpen = XMLHttpRequest.prototype.open;
        
        // Intercept fetch
        window.fetch = function(input, init) {
          // Initialize headers if needed
          init = init || {};
          init.headers = init.headers || {};
          
          // Add custom headers
          for (const [key, value] of Object.entries(window.__customHeaders)) {
            if (init.headers instanceof Headers) {
              if (!init.headers.has(key)) {
                init.headers.append(key, value);
              }
            } else if (Array.isArray(init.headers)) {
              const hasHeader = init.headers.some(h => h[0].toLowerCase() === key.toLowerCase());
              if (!hasHeader) {
                init.headers.push([key, value]);
              }
            } else {
              if (!(key.toLowerCase() in init.headers)) {
                init.headers[key] = value;
              }
            }
          }
          
          return originalFetch.call(this, input, init);
        };
        
        // Intercept XMLHttpRequest
        XMLHttpRequest.prototype.open = function(method, url, ...args) {
          const xhr = this;
          
          // Call original method
          const result = originalOpen.apply(xhr, [method, url, ...args]);
          
          // Add event listener to set headers before sending
          const originalSend = xhr.send;
          xhr.send = function(...sendArgs) {
            // Add custom headers
            for (const [key, value] of Object.entries(window.__customHeaders)) {
              if (!xhr.getResponseHeader(key)) {
                xhr.setRequestHeader(key, value);
              }
            }
            
            return originalSend.apply(xhr, sendArgs);
          };
          
          return result;
        };
      `);
      
      this.logger.debug('Headers set successfully');
    } catch (error) {
      this.logger.error(`Error setting headers: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Clears the browser cache
   */
  public async clearCache(): Promise<void> {
    try {
      if (this.browserType === BrowserType.CHROME) {
        // Chrome-specific cache clearing
        await this.driver.executeScript(`
          // Clear memory cache
          if (window.caches) {
            window.caches.keys().then(keys => {
              keys.forEach(key => window.caches.delete(key));
            });
          }
        `);
        
        // Use Chrome DevTools Protocol to clear cache
        await this.executeAsyncScript(`
          const callback = arguments[arguments.length - 1];
          // This requires CDP connection
          try {
            // Alternative approach using window.navigator
            if (navigator.serviceWorker) {
              navigator.serviceWorker.getRegistrations().then(registrations => {
                Promise.all(registrations.map(r => r.unregister())).then(() => callback(true));
              });
            } else {
              callback(true);
            }
          } catch (e) {
            callback(false);
          }
        `);
      } else {
        // Generic approach
        await this.driver.executeScript(`
          // Clear localStorage and sessionStorage
          if (window.localStorage) window.localStorage.clear();
          if (window.sessionStorage) window.sessionStorage.clear();
          
          // Clear cookies
          document.cookie.split(';').forEach(cookie => {
            const eqPos = cookie.indexOf('=');
            const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();
            document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/';
          });
          
          // Clear service workers
          if (navigator.serviceWorker) {
            navigator.serviceWorker.getRegistrations().then(registrations => {
              registrations.forEach(r => r.unregister());
            });
          }
        `);
      }
      
      this.logger.debug('Cache cleared successfully');
    } catch (error) {
      this.logger.error(`Error clearing cache: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Clears browser cookies
   */
  public async clearCookies(): Promise<void> {
    try {
      await this.driver.manage().deleteAllCookies();
      this.logger.debug('Cookies cleared successfully');
    } catch (error) {
      this.logger.error(`Error clearing cookies: ${error}`);
      throw new Error(`Failed to clear cookies: ${error}`);
    }
  }

  /**
   * Gets all browser cookies
   * @returns The cookies
   */
  public async getCookies(): Promise<any[]> {
    try {
      return await this.driver.manage().getCookies();
    } catch (error) {
      this.logger.error(`Error getting cookies: ${error}`);
      throw new Error(`Failed to get cookies: ${error}`);
    }
  }

  /**
   * Gets a specific cookie by name
   * @param name The cookie name
   * @returns The cookie, or null if not found
   */
  public async getCookie(name: string): Promise<any | null> {
    try {
      return await this.driver.manage().getCookie(name);
    } catch (error) {
      this.logger.error(`Error getting cookie "${name}": ${error}`);
      throw new Error(`Failed to get cookie "${name}": ${error}`);
    }
  }

  /**
   * Adds a cookie
   * @param cookie The cookie to add
   */
  public async addCookie(cookie: CookieOptions): Promise<void> {
    try {
      await this.driver.manage().addCookie(cookie);
      this.logger.debug(`Cookie "${cookie.name}" added successfully`);
    } catch (error) {
      this.logger.error(`Error adding cookie "${cookie.name}": ${error}`);
      throw new Error(`Failed to add cookie "${cookie.name}": ${error}`);
    }
  }

  /**
   * Deletes a cookie
   * @param name The name of the cookie to delete
   */
  public async deleteCookie(name: string): Promise<void> {
    try {
      await this.driver.manage().deleteCookie(name);
      this.logger.debug(`Cookie "${name}" deleted successfully`);
    } catch (error) {
      this.logger.error(`Error deleting cookie "${name}": ${error}`);
      throw new Error(`Failed to delete cookie "${name}": ${error}`);
    }
  }

  /**
   * Gets the window handle of the current window
   * @returns The window handle
   */
  public async getWindowHandle(): Promise<string> {
    try {
      return await this.driver.getWindowHandle();
    } catch (error) {
      this.logger.error(`Error getting window handle: ${error}`);
      throw new Error(`Failed to get window handle: ${error}`);
    }
  }

  /**
   * Gets all window handles
   * @returns The window handles
   */
  public async getWindowHandles(): Promise<string[]> {
    try {
      return await this.driver.getAllWindowHandles();
    } catch (error) {
      this.logger.error(`Error getting window handles: ${error}`);
      throw new Error(`Failed to get window handles: ${error}`);
    }
  }

  /**
   * Gets information about all open windows
   * @returns Information about all open windows
   */
  public async getWindowsInfo(): Promise<WindowInfo[]> {
    try {
      const currentHandle = await this.driver.getWindowHandle();
      const handles = await this.driver.getAllWindowHandles();
      const result: WindowInfo[] = [];
      
      // Get info for each window
      for (const handle of handles) {
        try {
          // Switch to the window
          await this.driver.switchTo().window(handle);
          
          // Get window info
          const title = await this.driver.getTitle();
          const url = await this.driver.getCurrentUrl();
          
          result.push({
            handle,
            title,
            url
          });
        } catch (error) {
          this.logger.warn(`Error getting info for window ${handle}: ${error}`);
          result.push({
            handle,
            title: 'Error',
            url: 'Error'
          });
        }
      }
      
      // Switch back to the original window
      await this.driver.switchTo().window(currentHandle);
      
      return result;
    } catch (error) {
      this.logger.error(`Error getting windows info: ${error}`);
      throw new Error(`Failed to get windows info: ${error}`);
    }
  }

  /**
   * Switches to a window
   * @param handle The window handle
   */
  public async switchToWindow(handle: string): Promise<void> {
    try {
      await this.driver.switchTo().window(handle);
      
      // Update window handle stack
      this.windowHandleStack.push(handle);
      
      this.logger.debug(`Switched to window with handle ${handle}`);
    } catch (error) {
      this.logger.error(`Error switching to window ${handle}: ${error}`);
      throw new Error(`Failed to switch to window ${handle}: ${error}`);
    }
  }

  /**
   * Switches to the previous window
   * If no previous window exists, this is a no-op
   */
  public async switchToPreviousWindow(): Promise<void> {
    try {
      // If we have at least 2 windows in the stack, switch to the previous one
      if (this.windowHandleStack.length > 1) {
        // Remove current window from stack
        this.windowHandleStack.pop();
        
        // Get previous window
        const previousHandle = this.windowHandleStack[this.windowHandleStack.length - 1];
        
        // Switch to previous window
        await this.driver.switchTo().window(previousHandle);
        
        this.logger.debug(`Switched to previous window with handle ${previousHandle}`);
      } else {
        this.logger.warn('No previous window to switch to');
      }
    } catch (error) {
      this.logger.error(`Error switching to previous window: ${error}`);
      
      // Attempt to recover by checking available window handles
      try {
        const handles = await this.driver.getAllWindowHandles();
        if (handles.length > 0) {
          await this.driver.switchTo().window(handles[0]);
          this.windowHandleStack = [handles[0]];
          this.logger.debug(`Recovered by switching to window with handle ${handles[0]}`);
        }
      } catch (recoveryError) {
        this.logger.error(`Error recovering from failed window switch: ${recoveryError}`);
      }
      
      throw new Error(`Failed to switch to previous window: ${error}`);
    }
  }

  /**
   * Switches to the main window
   */
  public async switchToMainWindow(): Promise<void> {
    try {
      await this.driver.switchTo().window(this.mainWindowHandle);
      
      // Reset window handle stack
      this.windowHandleStack = [this.mainWindowHandle];
      
      this.logger.debug('Switched to main window');
    } catch (error) {
      this.logger.error(`Error switching to main window: ${error}`);
      throw new Error(`Failed to switch to main window: ${error}`);
    }
  }

  /**
   * Opens a new tab
   * @param url The URL to open in the new tab (optional)
   * @returns The handle of the new window
   */
  public async openNewTab(url?: string): Promise<string> {
    try {
      // Open a new tab
      await this.driver.executeScript('window.open()');
      
      // Get all window handles
      const handles = await this.driver.getAllWindowHandles();
      
      // Switch to the newly opened tab (last in the list)
      const newHandle = handles[handles.length - 1];
      await this.driver.switchTo().window(newHandle);
      
      // Update window handle stack
      this.windowHandleStack.push(newHandle);
      
      // Navigate to URL if provided
      if (url) {
        await this.navigateTo(url);
      }
      
      this.logger.debug(`Opened new tab with handle ${newHandle}`);
      return newHandle;
    } catch (error) {
      this.logger.error(`Error opening new tab: ${error}`);
      throw new Error(`Failed to open new tab: ${error}`);
    }
  }

  /**
   * Closes the current window/tab
   */
  public async closeCurrentWindow(): Promise<void> {
    try {
      // Store the current handle before closing
      const currentHandle = await this.driver.getWindowHandle();
      
      // Close the window
      await this.driver.close();
      
      // Remove from window handle stack
      this.windowHandleStack = this.windowHandleStack.filter(handle => handle !== currentHandle);
      
      // If there are still windows open, switch to the last one in the stack
      const handles = await this.driver.getAllWindowHandles();
      if (handles.length > 0) {
        const lastHandle = this.windowHandleStack.length > 0 ? 
          this.windowHandleStack[this.windowHandleStack.length - 1] : handles[0];
        
        // Make sure the handle is valid
        if (handles.includes(lastHandle)) {
          await this.driver.switchTo().window(lastHandle);
          
          // If window handle stack is empty, add this handle
          if (this.windowHandleStack.length === 0) {
            this.windowHandleStack.push(lastHandle);
          }
        } else {
          // Fall back to the first available handle
          await this.driver.switchTo().window(handles[0]);
          this.windowHandleStack = [handles[0]];
        }
      }
      
      this.logger.debug(`Closed window with handle ${currentHandle}`);
    } catch (error) {
      this.logger.error(`Error closing current window: ${error}`);
      throw new Error(`Failed to close current window: ${error}`);
    }
  }

  /**
   * Switches to a frame
   * @param frameElement The frame element or index
   */
  public async switchToFrame(frameElement: WebElement | number): Promise<void> {
    try {
      await this.driver.switchTo().frame(frameElement);
      this.logger.debug(`Switched to frame: ${typeof frameElement === 'number' ? `index ${frameElement}` : 'element'}`);
    } catch (error) {
      this.logger.error(`Error switching to frame: ${error}`);
      throw new Error(`Failed to switch to frame: ${error}`);
    }
  }

  /**
   * Switches to a frame by selector
   * @param selector The selector for the frame
   */
  public async switchToFrameBySelector(selector: By): Promise<void> {
    try {
      const frameElement = await this.driver.findElement(selector);
      await this.driver.switchTo().frame(frameElement);
      this.logger.debug(`Switched to frame by selector: ${selector}`);
    } catch (error) {
      this.logger.error(`Error switching to frame by selector: ${error}`);
      throw new Error(`Failed to switch to frame by selector: ${error}`);
    }
  }

  /**
   * Switches to the parent frame
   */
  public async switchToParentFrame(): Promise<void> {
    try {
      await this.driver.switchTo().parentFrame();
      this.logger.debug('Switched to parent frame');
    } catch (error) {
      this.logger.error(`Error switching to parent frame: ${error}`);
      throw new Error(`Failed to switch to parent frame: ${error}`);
    }
  }

  /**
   * Switches to the default content (top-level frame)
   */
  public async switchToDefaultContent(): Promise<void> {
    try {
      await this.driver.switchTo().defaultContent();
      this.logger.debug('Switched to default content');
    } catch (error) {
      this.logger.error(`Error switching to default content: ${error}`);
      throw new Error(`Failed to switch to default content: ${error}`);
    }
  }

  /**
   * Sets the window size
   * @param width The window width
   * @param height The window height
   */
  public async setWindowSize(width: number, height: number): Promise<void> {
    try {
      await this.driver.manage().window().setRect({ width, height });
      this.logger.debug(`Set window size to ${width}x${height}`);
    } catch (error) {
      this.logger.error(`Error setting window size: ${error}`);
      throw new Error(`Failed to set window size: ${error}`);
    }
  }

  /**
   * Sets the window state
   * @param state The window state
   */
  public async setWindowState(state: WindowState): Promise<void> {
    try {
      const window = this.driver.manage().window();
      
      switch (state) {
        case WindowState.MAXIMIZED:
          await window.maximize();
          break;
        case WindowState.MINIMIZED:
          await window.minimize();
          break;
        case WindowState.FULLSCREEN:
          await window.fullscreen();
          break;
        case WindowState.NORMAL:
          // Get current position and size
          const rect = await window.getRect();
          
          // Set a normal size if maximized
          if (rect.width >= 1000) {
            await window.setRect({ width: 1000, height: 800 });
          }
          break;
      }
      
      this.logger.debug(`Set window state to ${state}`);
    } catch (error) {
      this.logger.error(`Error setting window state: ${error}`);
      throw new Error(`Failed to set window state: ${error}`);
    }
  }

  /**
   * Gets the window size
   * @returns The window size
   */
  public async getWindowSize(): Promise<{ width: number; height: number }> {
    try {
      const rect = await this.driver.manage().window().getRect();
      return { width: rect.width, height: rect.height };
    } catch (error) {
      this.logger.error(`Error getting window size: ${error}`);
      throw new Error(`Failed to get window size: ${error}`);
    }
  }

  /**
   * Scrolls to a specific position
   * @param x The x coordinate
   * @param y The y coordinate
   */
  public async scrollTo(x: number, y: number): Promise<void> {
    try {
      await this.driver.executeScript(`window.scrollTo(${x}, ${y});`);
      this.logger.debug(`Scrolled to position (${x}, ${y})`);
    } catch (error) {
      this.logger.error(`Error scrolling to position: ${error}`);
      throw new Error(`Failed to scroll to position: ${error}`);
    }
  }

  /**
   * Scrolls to an element
   * @param element The element to scroll to
   * @param options Options for scrolling
   */
  public async scrollToElement(element: WebElement, options?: { offset?: number; behavior?: 'auto' | 'smooth' }): Promise<void> {
    try {
      const offset = options?.offset || 0;
      const behavior = options?.behavior || 'auto';
      
      await this.driver.executeScript(`
        arguments[0].scrollIntoView({
          behavior: '${behavior}',
          block: 'center'
        });
        window.scrollBy(0, ${offset});
      `, element);
      
      this.logger.debug(`Scrolled to element with offset ${offset}`);
    } catch (error) {
      this.logger.error(`Error scrolling to element: ${error}`);
      throw new Error(`Failed to scroll to element: ${error}`);
    }
  }

  /**
   * Moves the mouse to a specific position
   * @param x The x coordinate
   * @param y The y coordinate
   */
  public async mouseMove(x: number, y: number): Promise<void> {
    try {
      const actions = new Actions(this.driver);
      await actions.move({ x, y }).perform();
      this.logger.debug(`Moved mouse to position (${x}, ${y})`);
    } catch (error) {
      this.logger.error(`Error moving mouse: ${error}`);
      throw new Error(`Failed to move mouse: ${error}`);
    }
  }

  /**
   * Moves the mouse to an element
   * @param element The element to move to
   * @param offset The offset from the element's center
   */
  public async mouseMoveToElement(element: WebElement, offset?: Coordinates): Promise<void> {
    try {
      const actions = new Actions(this.driver);
      
      if (offset) {
        await actions.move({ origin: element, x: offset.x, y: offset.y }).perform();
        this.logger.debug(`Moved mouse to element with offset (${offset.x}, ${offset.y})`);
      } else {
        await actions.move({ origin: element }).perform();
        this.logger.debug('Moved mouse to element');
      }
    } catch (error) {
      this.logger.error(`Error moving mouse to element: ${error}`);
      throw new Error(`Failed to move mouse to element: ${error}`);
    }
  }

  /**
   * Performs a mouse click at the current position
   */
  public async mouseClick(): Promise<void> {
    try {
      const actions = new Actions(this.driver);
      await actions.click().perform();
      this.logger.debug('Performed mouse click');
    } catch (error) {
      this.logger.error(`Error performing mouse click: ${error}`);
      throw new Error(`Failed to perform mouse click: ${error}`);
    }
  }

  /**
   * Performs a context click (right-click) at the current position
   */
  public async mouseRightClick(): Promise<void> {
    try {
      const actions = new Actions(this.driver);
      await actions.contextClick().perform();
      this.logger.debug('Performed mouse right-click');
    } catch (error) {
      this.logger.error(`Error performing mouse right-click: ${error}`);
      throw new Error(`Failed to perform mouse right-click: ${error}`);
    }
  }

  /**
   * Performs a double-click at the current position
   */
  public async mouseDoubleClick(): Promise<void> {
    try {
      const actions = new Actions(this.driver);
      await actions.doubleClick().perform();
      this.logger.debug('Performed mouse double-click');
    } catch (error) {
      this.logger.error(`Error performing mouse double-click: ${error}`);
      throw new Error(`Failed to perform mouse double-click: ${error}`);
    }
  }

  /**
   * Performs a drag and drop operation
   * @param source The source element
   * @param target The target element
   */
  public async dragAndDrop(source: WebElement, target: WebElement): Promise<void> {
    try {
      const actions = new Actions(this.driver);
      await actions.dragAndDrop(source, target).perform();
      this.logger.debug('Performed drag and drop');
    } catch (error) {
      this.logger.error(`Error performing drag and drop: ${error}`);
      throw new Error(`Failed to perform drag and drop: ${error}`);
    }
  }

  /**
   * Performs a drag and drop operation by offset
   * @param source The source element
   * @param xOffset The x offset
   * @param yOffset The y offset
   */
  public async dragAndDropByOffset(source: WebElement, xOffset: number, yOffset: number): Promise<void> {
    try {
      const actions = new Actions(this.driver);
      await actions.dragAndDrop(source, { x: xOffset, y: yOffset }).perform();
      this.logger.debug(`Performed drag and drop by offset (${xOffset}, ${yOffset})`);
    } catch (error) {
      this.logger.error(`Error performing drag and drop by offset: ${error}`);
      throw new Error(`Failed to perform drag and drop by offset: ${error}`);
    }
  }

  /**
   * Uploads a file
   * @param options File upload options
   */
  public async uploadFile(options: FileUploadOptions): Promise<void> {
    try {
      // Resolve the element if it's a locator
      let inputElement: WebElement;
      if (options.element instanceof WebElement) {
        inputElement = options.element;
      } else {
        inputElement = await this.driver.findElement(options.element);
      }
      
      // Validate that the element is an input of type file
      const tagName = await inputElement.getTagName();
      const type = await inputElement.getAttribute('type');
      
      if (tagName.toLowerCase() !== 'input' || type.toLowerCase() !== 'file') {
        throw new Error('Element must be an input of type file');
      }
      
      // Ensure all file paths exist
      for (const filePath of options.filePaths) {
        if (!fs.existsSync(filePath)) {
          throw new Error(`File not found: ${filePath}`);
        }
      }
      
      // Join file paths if multiple files
      const filePathsValue = options.filePaths.join('\n');
      
      // Send keys to input element
      await inputElement.sendKeys(filePathsValue);
      
      // Verify upload if requested
      if (options.verify) {
        await this.driver.wait(async () => {
          try {
            // Check if file name appears in the input's value
            const value = await inputElement.getAttribute('value');
            
            // For security reasons, the value might only include file names, not paths
            const fileNames = options.filePaths.map(path => {
              const parts = path.split(/[/\\]/);
              return parts[parts.length - 1];
            });
            
            // Check if at least one file name is in the value
            return fileNames.some(name => value.includes(name));
          } catch (error) {
            return false;
          }
        }, options.timeout || 10000, 'File upload verification failed');
      }
      
      this.logger.debug(`Uploaded ${options.filePaths.length} file(s) successfully`);
    } catch (error) {
      this.logger.error(`Error uploading file: ${error}`);
      throw new Error(`Failed to upload file: ${error}`);
    }
  }

  /**
   * Sets the browser network conditions (Chrome only)
   * @param conditions The network conditions
   */
  public async setNetworkConditions(conditions: NetworkConditions): Promise<void> {
    try {
      if (this.browserType !== BrowserType.CHROME) {
        this.logger.warn('Network conditions can only be set in Chrome, skipping');
        return;
      }
      
      // Inject script to override browser network API
      await this.driver.executeScript(`
        // Original connections
        if (!window.__originalWebsocketConstructor) {
          window.__originalWebsocketConstructor = window.WebSocket;
          window.__originalFetch = window.fetch;
          window.__originalXhrOpen = XMLHttpRequest.prototype.open;
          window.__originalXhrSend = XMLHttpRequest.prototype.send;
        }
        
        // Network condition settings
        window.__networkConditions = {
          download: ${conditions.download},
          upload: ${conditions.upload},
          latency: ${conditions.latency}
        };
        
        // Helper to apply latency
        const applyLatency = (callback) => {
          const latency = window.__networkConditions.latency;
          if (latency <= 0) {
            callback();
          } else {
            setTimeout(callback, latency);
          }
        };
        
        // Helper to apply throttling
        const applyThrottling = (data, callback, isUpload) => {
          const rate = isUpload ? 
            window.__networkConditions.upload : window.__networkConditions.download;
            
          if (rate <= 0) {
            callback(data);
            return;
          }
          
          // Calculate delay based on data size and rate
          const size = typeof data === 'string' ? data.length : 
            (data instanceof ArrayBuffer ? data.byteLength : 
              (data instanceof Blob ? data.size : String(data).length));
          
          const delayMs = Math.floor(size * 8 / rate * 1000);
          
          setTimeout(() => callback(data), delayMs);
        };
        
        // Override WebSocket
        window.WebSocket = function(...args) {
          const ws = new window.__originalWebsocketConstructor(...args);
          
          // Add latency to events
          const addEventListener = ws.addEventListener;
          ws.addEventListener = function(type, listener, ...rest) {
            if (type === 'message' || type === 'open') {
              return addEventListener.call(this, type, function(event) {
                applyLatency(() => listener(event));
              }, ...rest);
            }
            return addEventListener.call(this, type, listener, ...rest);
          };
          
          // Override send to apply upload throttling
          const send = ws.send;
          ws.send = function(data) {
            applyThrottling(data, (throttledData) => {
              applyLatency(() => send.call(this, throttledData));
            }, true);
          };
          
          return ws;
        };
        
        // Override fetch
        window.fetch = function(...args) {
          return new Promise((resolve, reject) => {
            applyLatency(() => {
              window.__originalFetch.apply(this, args)
                .then(response => {
                  // Create a new response with throttled body
                  const originalJson = response.json;
                  const originalText = response.text;
                  const originalBlob = response.blob;
                  const originalArrayBuffer = response.arrayBuffer;
                  
                  response.json = function() {
                    return originalJson.call(this).then(data => {
                      return new Promise(resolve => {
                        applyThrottling(JSON.stringify(data), () => resolve(data), false);
                      });
                    });
                  };
                  
                  response.text = function() {
                    return originalText.call(this).then(text => {
                      return new Promise(resolve => {
                        applyThrottling(text, () => resolve(text), false);
                      });
                    });
                  };
                  
                  response.blob = function() {
                    return originalBlob.call(this).then(blob => {
                      return new Promise(resolve => {
                        applyThrottling(blob, () => resolve(blob), false);
                      });
                    });
                  };
                  
                  response.arrayBuffer = function() {
                    return originalArrayBuffer.call(this).then(buffer => {
                      return new Promise(resolve => {
                        applyThrottling(buffer, () => resolve(buffer), false);
                      });
                    });
                  };
                  
                  resolve(response);
                })
                .catch(reject);
            });
          });
        };
        
        // Override XMLHttpRequest
        XMLHttpRequest.prototype.open = function(...args) {
          this.__networkThrottlingArgs = args;
          return window.__originalXhrOpen.apply(this, args);
        };
        
        XMLHttpRequest.prototype.send = function(data) {
          const xhr = this;
          
          // Apply upload throttling and latency
          applyThrottling(data, (throttledData) => {
            applyLatency(() => {
              // Store original event handlers
              const originalOnload = xhr.onload;
              const originalOnreadystatechange = xhr.onreadystatechange;
              
              // Override onreadystatechange to apply download throttling
              xhr.onreadystatechange = function(event) {
                if (this.readyState === 4) {
                  // Apply download throttling
                  applyThrottling(this.responseText, () => {
                    if (originalOnreadystatechange) {
                      originalOnreadystatechange.call(this, event);
                    }
                  }, false);
                } else if (originalOnreadystatechange) {
                  originalOnreadystatechange.call(this, event);
                }
              };
              
              // Override onload to apply download throttling
              xhr.onload = function(event) {
                applyThrottling(this.responseText, () => {
                  if (originalOnload) {
                    originalOnload.call(this, event);
                  }
                }, false);
              };
              
              window.__originalXhrSend.call(xhr, throttledData);
            });
          }, true);
        };
      `);
      
      this.logger.debug('Network conditions set successfully');
    } catch (error) {
      this.logger.error(`Error setting network conditions: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Resets the browser network conditions (Chrome only)
   */
  public async resetNetworkConditions(): Promise<void> {
    try {
      if (this.browserType !== BrowserType.CHROME) {
        return;
      }
      
      // Restore original browser network APIs
      await this.driver.executeScript(`
        if (window.__originalWebsocketConstructor) {
          window.WebSocket = window.__originalWebsocketConstructor;
          window.fetch = window.__originalFetch;
          XMLHttpRequest.prototype.open = window.__originalXhrOpen;
          XMLHttpRequest.prototype.send = window.__originalXhrSend;
          
          delete window.__originalWebsocketConstructor;
          delete window.__originalFetch;
          delete window.__originalXhrOpen;
          delete window.__originalXhrSend;
          delete window.__networkConditions;
        }
      `);
      
      this.logger.debug('Network conditions reset successfully');
    } catch (error) {
      this.logger.error(`Error resetting network conditions: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Adds an event listener for browser events
   * @param eventType The event type
   * @param selector The selector for target elements (optional)
   * @param callback The callback code to execute when the event occurs
   */
  public async addEventListener(eventType: string, selector: string | Function, callback?: Function): Promise<void> {
    try {
      // Handle case where selector is actually the callback
      let callbackCode: string;
      let selectorStr: string = '';
      
      if (typeof selector === 'function') {
        callbackCode = selector.toString();
      } else {
        selectorStr = selector;
        callbackCode = callback?.toString() || 'function(event) { console.log("Event captured:", event); }';
      }
      
      // Add the event listener
      await this.driver.executeScript(`
        // Initialize event listeners object if not exists
        if (!window.__customEventListeners) {
          window.__customEventListeners = {};
        }
        
        // Generate unique ID for this listener
        const listenerId = '_' + Math.random().toString(36).substr(2, 9);
        
        // Store the event configuration
        window.__customEventListeners[listenerId] = {
          type: "${eventType}",
          selector: ${selectorStr ? `"${selectorStr}"` : 'null'},
          callback: ${callbackCode}
        };
        
        // Add the actual event listener
        if (${!!selectorStr}) {
          // Delegate event for specific selector
          document.addEventListener("${eventType}", function(event) {
            const targets = document.querySelectorAll("${selectorStr}");
            let target = event.target;
            
            // Check if the event target matches our selector
            while (target && target !== document) {
              for (let i = 0; i < targets.length; i++) {
                if (target === targets[i]) {
                  // Call the callback with the event and matched element
                  window.__customEventListeners[listenerId].callback.call(target, event, target);
                  return;
                }
              }
              target = target.parentNode;
            }
          }, true);
        } else {
          // Global event listener
          document.addEventListener("${eventType}", function(event) {
            window.__customEventListeners[listenerId].callback.call(this, event, event.target);
          }, true);
        }
        
        return listenerId;
      `);
      
      this.logger.debug(`Added event listener for ${eventType}${selectorStr ? ` on ${selectorStr}` : ''}`);
    } catch (error) {
      this.logger.error(`Error adding event listener: ${error}`);
      throw new Error(`Failed to add event listener: ${error}`);
    }
  }

  /**
   * Sets up a console log interceptor to capture browser console logs
   */
  public async setupConsoleInterceptor(): Promise<void> {
    try {
      await this.driver.executeScript(`
        // Skip if already injected
        if (window.__consoleInterceptorInjected) return;
        
        window.__consoleInterceptorInjected = true;
        window.__consoleLogs = [];
        
        // Store original console methods
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        const originalConsoleError = console.error;
        const originalConsoleInfo = console.info;
        const originalConsoleDebug = console.debug;
        
        // Helper to capture logs
        const captureLog = (type, args) => {
          const logEntry = {
            type: type,
            message: Array.from(args).map(arg => {
              try {
                return typeof arg === 'object' ? JSON.stringify(arg) : String(arg);
              } catch (e) {
                return String(arg);
              }
            }).join(' '),
            timestamp: new Date().toISOString()
          };
          
          window.__consoleLogs.push(logEntry);
          
          // Keep log buffer size reasonable
          if (window.__consoleLogs.length > 1000) {
            window.__consoleLogs.shift();
          }
        };
        
        // Override console methods
        console.log = function() {
          captureLog('log', arguments);
          return originalConsoleLog.apply(console, arguments);
        };
        
        console.warn = function() {
          captureLog('warn', arguments);
          return originalConsoleWarn.apply(console, arguments);
        };
        
        console.error = function() {
          captureLog('error', arguments);
          return originalConsoleError.apply(console, arguments);
        };
        
        console.info = function() {
          captureLog('info', arguments);
          return originalConsoleInfo.apply(console, arguments);
        };
        
        console.debug = function() {
          captureLog('debug', arguments);
          return originalConsoleDebug.apply(console, arguments);
        };
      `);
      
      this.logger.debug('Console interceptor set up successfully');
    } catch (error) {
      this.logger.error(`Error setting up console interceptor: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Gets captured console logs
   * @returns The captured console logs
   */
  public async getConsoleLogs(): Promise<any[]> {
    try {
      return await this.driver.executeScript(`
        return window.__consoleLogs || [];
      `);
    } catch (error) {
      this.logger.error(`Error getting console logs: ${error}`);
      return [];
    }
  }

  /**
   * Clears captured console logs
   */
  public async clearConsoleLogs(): Promise<void> {
    try {
      await this.driver.executeScript(`
        window.__consoleLogs = [];
      `);
      
      this.logger.debug('Console logs cleared');
    } catch (error) {
      this.logger.error(`Error clearing console logs: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Creates a PDF of the current page (Chrome only)
   * @param options PDF options
   * @returns The path to the saved PDF
   */
  public async createPdf(options?: {
    path?: string;
    fileName?: string;
    format?: 'A4' | 'A3' | 'Letter' | 'Legal';
    landscape?: boolean;
    scale?: number;
    pageRanges?: string;
    margins?: { top?: number; right?: number; bottom?: number; left?: number };
    printBackground?: boolean;
  }): Promise<string> {
    try {
      // Check if browser is Chrome
      if (this.browserType !== BrowserType.CHROME) {
        throw new Error('PDF creation is only supported in Chrome');
      }
      
      const mergedOptions = {
        path: options?.path || './pdf',
        fileName: options?.fileName || `page-${new Date().toISOString().replace(/:/g, '-')}.pdf`,
        format: options?.format || 'A4',
        landscape: options?.landscape || false,
        scale: options?.scale || 1,
        pageRanges: options?.pageRanges || '',
        margins: {
          top: options?.margins?.top || 10,
          right: options?.margins?.right || 10,
          bottom: options?.margins?.bottom || 10,
          left: options?.margins?.left || 10
        },
        printBackground: options?.printBackground !== undefined ? options.printBackground : true
      };
      
      // Ensure directory exists
      CSFileUtils.ensureDirectoryExists(mergedOptions.path);
      
      // Construct full file path
      const filePath = path.join(mergedOptions.path, mergedOptions.fileName);
      
      // Execute Chrome DevTools Protocol command to generate PDF
      const pdfOptions = {
        landscape: mergedOptions.landscape,
        printBackground: mergedOptions.printBackground,
        scale: mergedOptions.scale,
        paperWidth: mergedOptions.format === 'A3' ? 11.7 : mergedOptions.format === 'Legal' ? 8.5 : mergedOptions.format === 'Letter' ? 8.5 : 8.27,
        paperHeight: mergedOptions.format === 'A3' ? 16.5 : mergedOptions.format === 'Legal' ? 14 : mergedOptions.format === 'Letter' ? 11 : 11.7,
        marginTop: mergedOptions.margins.top * 0.02834,
        marginRight: mergedOptions.margins.right * 0.02834,
        marginBottom: mergedOptions.margins.bottom * 0.02834,
        marginLeft: mergedOptions.margins.left * 0.02834,
        pageRanges: mergedOptions.pageRanges
      };
      
      // Create PDF using Chrome DevTools Protocol via JavaScript
      const pdfData = await this.driver.executeScript(`
        return new Promise(async (resolve, reject) => {
          try {
            const settings = ${JSON.stringify(pdfOptions)};
            
            // Create a print function
            const printToPDF = () => {
              const callback = arguments[arguments.length - 1];
              
              // Use browser's print functionality
              const printWindow = window.open('', '_blank');
              if (!printWindow) {
                callback({ error: 'Failed to open print window' });
                return;
              }
              
              printWindow.document.write('<html><head><title>Print</title></head><body>');
              printWindow.document.write(document.documentElement.outerHTML);
              printWindow.document.write('</body></html>');
              printWindow.document.close();
              
              // Add print styles
              const style = printWindow.document.createElement('style');
              style.textContent = \`
                @page {
                  size: \${settings.landscape ? 'landscape' : 'portrait'};
                  margin: \${settings.marginTop}in \${settings.marginRight}in \${settings.marginBottom}in \${settings.marginLeft}in;
                }
                body { transform: scale(\${settings.scale}); transform-origin: top left; }
              \`;
              printWindow.document.head.appendChild(style);
              
              // Create a canvas and render page
              const canvas = document.createElement('canvas');
              const context = canvas.getContext('2d');
              
              const renderPage = () => {
                return new Promise(resolve => {
                  const image = new Image();
                  image.onload = () => {
                    canvas.width = image.width;
                    canvas.height = image.height;
                    context.drawImage(image, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                  };
                  
                  // Create an SVG with the HTML content
                  const svg = '<svg xmlns="http://www.w3.org/2000/svg" width="' + window.innerWidth + '" height="' + window.innerHeight + '"><foreignObject width="100%" height="100%"><div xmlns="http://www.w3.org/1999/xhtml">' + document.documentElement.outerHTML + '</div></foreignObject></svg>';
                  
                  // Convert SVG to data URL
                  image.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
                });
              };
              
              renderPage().then(dataUrl => {
                printWindow.close();
                callback({ dataUrl: dataUrl });
              }).catch(error => {
                printWindow.close();
                callback({ error: error.toString() });
              });
            };
            
            // Execute print function
            const result = await new Promise(resolve => {
              printToPDF(resolve);
            });
            
            if (result.error) {
              reject(result.error);
            } else {
              resolve(result.dataUrl.split(',')[1]);
            }
          } catch (error) {
            reject(error.toString());
          }
        });
      `);
      
      // Save PDF data to file
      fs.writeFileSync(filePath, pdfData, 'base64');
      
      this.logger.debug(`PDF saved to ${filePath}`);
      return filePath;
    } catch (error) {
      this.logger.error(`Error creating PDF: ${error}`);
      throw new Error(`Failed to create PDF: ${error}`);
    }
  }

  /**
   * Gets all accessibility issues on the page
   * @returns A list of accessibility issues
   */
  public async getAccessibilityIssues(): Promise<any[]> {
    try {
      // Inject and run accessibility audit script
      return await this.driver.executeScript(`
        // Skip if already injected
        if (!window.__a11yAuditInjected) {
          window.__a11yAuditInjected = true;
          
          // Simple a11y audit function
          window.__runA11yAudit = function() {
            const issues = [];
            
            // Check for image alt text
            const images = document.querySelectorAll('img');
            for (const img of images) {
              if (!img.hasAttribute('alt')) {
                issues.push({
                  type: 'error',
                  rule: 'image-alt',
                  element: {
                    nodeName: img.nodeName,
                    selector: getCssSelector(img),
                    outerHTML: img.outerHTML.substring(0, 100) + (img.outerHTML.length > 100 ? '...' : '')
                  },
                  message: 'Image does not have alt text'
                });
              }
            }
            
            // Check for form labels
            const formControls = document.querySelectorAll('input, select, textarea');
            for (const control of formControls) {
              // Skip hidden and non-interactive input types
              if (control.type === 'hidden' || control.type === 'submit' || control.type === 'button' || control.type === 'reset') {
                continue;
              }
              
              // Check if control has a label
              if (!control.id || !document.querySelector(`label[for="\${control.id}"]`)) {
                issues.push({
                  type: 'error',
                  rule: 'label',
                  element: {
                    nodeName: control.nodeName,
                    type: control.type,
                    selector: getCssSelector(control),
                    outerHTML: control.outerHTML.substring(0, 100) + (control.outerHTML.length > 100 ? '...' : '')
                  },
                  message: 'Form control does not have an associated label'
                });
              }
            }
            
            // Check for heading hierarchy
            const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
            const headingLevels = Array.from(headings).map(h => parseInt(h.nodeName.substring(1)));
            
            for (let i = 1; i < headingLevels.length; i++) {
              if (headingLevels[i] > headingLevels[i-1] + 1) {
                const heading = headings[i];
                issues.push({
                  type: 'warning',
                  rule: 'heading-order',
                  element: {
                    nodeName: heading.nodeName,
                    selector: getCssSelector(heading),
                    outerHTML: heading.outerHTML.substring(0, 100) + (heading.outerHTML.length > 100 ? '...' : ''),
                    text: heading.textContent
                  },
                  message: \`Heading level skipped from h\${headingLevels[i-1]} to h\${headingLevels[i]}\`
                });
              }
            }
            
            // Check for color contrast
            // This is a simplified version - not as accurate as a full color contrast analyzer
            const textElements = document.querySelectorAll('p, span, h1, h2, h3, h4, h5, h6, a, button, label');
            for (const element of textElements) {
              // Skip elements without text or invisible elements
              if (!element.textContent.trim() || getComputedStyle(element).display === 'none' || getComputedStyle(element).visibility === 'hidden') {
                continue;
              }
              
              const style = getComputedStyle(element);
              const fontSize = parseInt(style.fontSize);
              const fontWeight = style.fontWeight;
              
              // Only flag very low contrast issues that we can detect reliably
              const foregroundColor = style.color;
              const backgroundColor = getBackgroundColor(element);
              
              if (foregroundColor && backgroundColor && hasVeryLowContrast(foregroundColor, backgroundColor)) {
                issues.push({
                  type: 'warning',
                  rule: 'color-contrast',
                  element: {
                    nodeName: element.nodeName,
                    selector: getCssSelector(element),
                    outerHTML: element.outerHTML.substring(0, 100) + (element.outerHTML.length > 100 ? '...' : ''),
                    text: element.textContent.substring(0, 50) + (element.textContent.length > 50 ? '...' : '')
                  },
                  message: 'Element may have insufficient color contrast',
                  foregroundColor,
                  backgroundColor
                });
              }
            }
            
            // Check for meaningful link text
            const links = document.querySelectorAll('a');
            for (const link of links) {
              const linkText = link.textContent.trim();
              if (linkText.toLowerCase() === 'click here' || linkText.toLowerCase() === 'more' || linkText === '') {
                issues.push({
                  type: 'warning',
                  rule: 'link-name',
                  element: {
                    nodeName: link.nodeName,
                    selector: getCssSelector(link),
                    outerHTML: link.outerHTML.substring(0, 100) + (link.outerHTML.length > 100 ? '...' : ''),
                    text: linkText
                  },
                  message: 'Link does not have meaningful text'
                });
              }
            }
            
            // Check for ARIA attributes
            const ariaElements = document.querySelectorAll('[aria-*]');
            for (const element of ariaElements) {
              const attributes = element.attributes;
              for (let i = 0; i < attributes.length; i++) {
                const attr = attributes[i];
                if (attr.name.startsWith('aria-')) {
                  // Check for invalid ARIA roles
                  if (attr.name === 'aria-role' && !isValidAriaRole(attr.value)) {
                    issues.push({
                      type: 'error',
                      rule: 'aria-roles',
                      element: {
                        nodeName: element.nodeName,
                        selector: getCssSelector(element),
                        outerHTML: element.outerHTML.substring(0, 100) + (element.outerHTML.length > 100 ? '...' : '')
                      },
                      message: \`Invalid ARIA role: \${attr.value}\`
                    });
                  }
                }
              }
            }
            
            return issues;
            
            // Helper function to get a CSS selector for an element
            function getCssSelector(element) {
              if (element.id) {
                return '#' + element.id;
              }
              
              if (element.className) {
                const classes = Array.from(element.classList).join('.');
                if (classes) {
                  return element.nodeName.toLowerCase() + '.' + classes;
                }
              }
              
              // Fallback to a position-based selector
              let selector = element.nodeName.toLowerCase();
              const siblings = Array.from(element.parentNode.children);
              if (siblings.length > 1) {
                const index = siblings.indexOf(element) + 1;
                selector += ':nth-child(' + index + ')';
              }
              
              // Add parent for better specificity
              if (element.parentNode && element.parentNode !== document && element.parentNode.nodeName !== 'BODY') {
                return getCssSelector(element.parentNode) + ' > ' + selector;
              }
              
              return selector;
            }
            
            // Helper function to get background color considering parent elements
            function getBackgroundColor(element) {
              const style = getComputedStyle(element);
              let backgroundColor = style.backgroundColor;
              
              // If transparent, traverse up the DOM tree
              if (backgroundColor === 'transparent' || backgroundColor === 'rgba(0, 0, 0, 0)') {
                let parent = element.parentElement;
                while (parent) {
                  const parentStyle = getComputedStyle(parent);
                  backgroundColor = parentStyle.backgroundColor;
                  
                  if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {
                    break;
                  }
                  
                  parent = parent.parentElement;
                }
              }
              
              // If still transparent, assume white
              if (backgroundColor === 'transparent' || backgroundColor === 'rgba(0, 0, 0, 0)') {
                backgroundColor = 'rgb(255, 255, 255)';
              }
              
              return backgroundColor;
            }
            
            // Extremely simplified contrast check - only catches very bad cases
            function hasVeryLowContrast(foreground, background) {
              // Extract RGB values
              let fgRgb = parseColor(foreground);
              let bgRgb = parseColor(background);
              
              if (!fgRgb || !bgRgb) {
                return false;
              }
              
              // Calculate relative luminance
              const fgLuminance = calculateLuminance(fgRgb);
              const bgLuminance = calculateLuminance(bgRgb);
              
              // Calculate contrast ratio
              const contrast = (Math.max(fgLuminance, bgLuminance) + 0.05) / (Math.min(fgLuminance, bgLuminance) + 0.05);
              
              // Flag only very low contrast
              return contrast < 2.5;
            }
            
            function parseColor(color) {
              const rgbRegex = /^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;
              const rgbaRegex = /^rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d\\.]+)\\s*\\)$/;
              
              let match = color.match(rgbRegex);
              if (match) {
                return {
                  r: parseInt(match[1]),
                  g: parseInt(match[2]),
                  b: parseInt(match[3])
                };
              }
              
              match = color.match(rgbaRegex);
              if (match) {
                return {
                  r: parseInt(match[1]),
                  g: parseInt(match[2]),
                  b: parseInt(match[3]),
                  a: parseFloat(match[4])
                };
              }
              
              return null;
            }
            
            function calculateLuminance(rgb) {
              // Convert RGB to sRGB
              const r = rgb.r / 255;
              const g = rgb.g / 255;
              const b = rgb.b / 255;
              
              // Calculate luminance
              const rsrgb = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
              const gsrgb = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
              const bsrgb = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
              
              return 0.2126 * rsrgb + 0.7152 * gsrgb + 0.0722 * bsrgb;
            }
            
            // Helper function to check if an ARIA role is valid
            function isValidAriaRole(role) {
              const validRoles = [
                'alert', 'alertdialog', 'application', 'article', 'banner', 'button', 'cell',
                'checkbox', 'columnheader', 'combobox', 'complementary', 'contentinfo',
                'definition', 'dialog', 'directory', 'document', 'feed', 'figure', 'form',
                'grid', 'gridcell', 'group', 'heading', 'img', 'link', 'list', 'listbox',
                'listitem', 'log', 'main', 'marquee', 'math', 'menu', 'menubar', 'menuitem',
                'menuitemcheckbox', 'menuitemradio', 'navigation', 'none', 'note', 'option',
                'presentation', 'progressbar', 'radio', 'radiogroup', 'region', 'row', 'rowgroup',
                'rowheader', 'scrollbar', 'search', 'searchbox', 'separator', 'slider', 'spinbutton',
                'status', 'switch', 'tab', 'table', 'tablist', 'tabpanel', 'term', 'textbox',
                'timer', 'toolbar', 'tooltip', 'tree', 'treegrid', 'treeitem'
              ];
              
              return validRoles.includes(role.toLowerCase());
            }
          };
        }
        
        // Run the audit
        return window.__runA11yAudit();
      `);
    } catch (error) {
      this.logger.error(`Error getting accessibility issues: ${error}`);
      return [];
    }
  }

  /**
   * Disables JavaScript on the page
   * @param disable Whether to disable JavaScript
   */
  public async disableJavaScript(disable: boolean): Promise<void> {
    try {
      if (this.browserType !== BrowserType.CHROME) {
        this.logger.warn('Disabling JavaScript is only supported in Chrome, skipping');
        return;
      }
      
      if (disable) {
        // Inject script to intercept and block script execution
        await this.driver.executeScript(`
          // Store original createElement function
          if (!window.__originalCreateElement) {
            window.__originalCreateElement = document.createElement;
            window.__jsDisabled = true;
            
            // Override createElement to prevent script creation
            document.createElement = function(tagName, ...args) {
              if (tagName.toLowerCase() === 'script') {
                console.warn('Script creation blocked due to disabled JavaScript');
                const dummyScript = window.__originalCreateElement.call(document, 'div');
                
                // Simulate script interface but block execution
                dummyScript.src = '';
                dummyScript.type = 'text/plain';
                dummyScript.appendChild = function() { return dummyScript; };
                dummyScript.setAttribute = function() { return dummyScript; };
                return dummyScript;
              }
              
              return window.__originalCreateElement.call(document, tagName, ...args);
            };
            
            // Block eval and related functions
            const noop = function() { return undefined; };
            window.eval = noop;
            
            // Block setTimeout and setInterval for scripts
            window.__originalSetTimeout = window.setTimeout;
            window.__originalSetInterval = window.setInterval;
            
            window.setTimeout = function(callback, ...args) {
              if (typeof callback === 'string') {
                console.warn('String-based setTimeout blocked due to disabled JavaScript');
                return -1;
              }
              return window.__originalSetTimeout.call(window, callback, ...args);
            };
            
            window.setInterval = function(callback, ...args) {
              if (typeof callback === 'string') {
                console.warn('String-based setInterval blocked due to disabled JavaScript');
                return -1;
              }
              return window.__originalSetInterval.call(window, callback, ...args);
            };
            
            // Block inline event handlers
            const originalGetAttribute = Element.prototype.getAttribute;
            const originalSetAttribute = Element.prototype.setAttribute;
            
            Element.prototype.getAttribute = function(name) {
              const attributeName = name.toLowerCase();
              if (attributeName.startsWith('on')) {
                return null;
              }
              return originalGetAttribute.call(this, name);
            };
            
            Element.prototype.setAttribute = function(name, value) {
              const attributeName = name.toLowerCase();
              if (attributeName.startsWith('on')) {
                console.warn(\`Setting \${name} attribute blocked due to disabled JavaScript\`);
                return;
              }
              return originalSetAttribute.call(this, name, value);
            };
          } else {
            window.__jsDisabled = true;
          }
        `);
        
        this.logger.debug('JavaScript disabled');
      } else {
        // Restore original functions
        await this.driver.executeScript(`
          if (window.__originalCreateElement) {
            document.createElement = window.__originalCreateElement;
            window.setTimeout = window.__originalSetTimeout;
            window.setInterval = window.__originalSetInterval;
            delete window.__originalCreateElement;
            delete window.__originalSetTimeout;
            delete window.__originalSetInterval;
            window.__jsDisabled = false;
          }
        `);
        
        this.logger.debug('JavaScript enabled');
      }
    } catch (error) {
      this.logger.error(`Error ${disable ? 'disabling' : 'enabling'} JavaScript: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Disables CSS on the page
   * @param disable Whether to disable CSS
   */
  public async disableCSS(disable: boolean): Promise<void> {
    try {
      if (disable) {
        // Add stylesheet to override all styles
        await this.driver.executeScript(`
          // Create a stylesheet to override all styles
          if (!document.getElementById('__cssDisableStylesheet')) {
            const stylesheet = document.createElement('style');
            stylesheet.id = '__cssDisableStylesheet';
            stylesheet.innerHTML = \`
              * {
                all: initial !important;
                color: black !important;
                background: white !important;
                font-family: serif !important;
                font-size: 16px !important;
                line-height: 1.5 !important;
                margin: 0 !important;
                padding: 0 !important;
                border: none !important;
                position: static !important;
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
              }
              
              a { color: blue !important; text-decoration: underline !important; }
              strong, b { font-weight: bold !important; }
              em, i { font-style: italic !important; }
              h1, h2, h3, h4, h5, h6 { font-weight: bold !important; }
              h1 { font-size: 24px !important; }
              h2 { font-size: 22px !important; }
              h3 { font-size: 20px !important; }
              h4 { font-size: 18px !important; }
              h5 { font-size: 16px !important; }
              h6 { font-size: 16px !important; }
              ul, ol { padding-left: 20px !important; display: block !important; }
              li { display: list-item !important; }
              ul li { list-style-type: disc !important; }
              ol li { list-style-type: decimal !important; }
              img { display: inline-block !important; max-width: 100% !important; }
              table { border-collapse: collapse !important; width: 100% !important; }
              td, th { border: 1px solid black !important; padding: 5px !important; display: table-cell !important; }
              tr { display: table-row !important; }
              thead, tbody, tfoot { display: table-row-group !important; }
              input, textarea, select, button { display: inline-block !important; }
              button { cursor: pointer !important; }
            \`;
            document.head.appendChild(stylesheet);
          }
          
          // Disable all existing stylesheets
          for (const styleSheet of document.styleSheets) {
            try {
              if (styleSheet.ownerNode && styleSheet.ownerNode.id !== '__cssDisableStylesheet') {
                styleSheet.disabled = true;
              }
            } catch (e) {
              // Some cross-origin stylesheets can't be accessed
            }
          }
          
          // Remove inline styles
          const elements = document.querySelectorAll('*[style]');
          for (const element of elements) {
            element.removeAttribute('style');
          }
          
          // Mark as CSS disabled
          window.__cssDisabled = true;
        `);
        
        this.logger.debug('CSS disabled');
      } else {
        // Remove the override stylesheet and re-enable all stylesheets
        await this.driver.executeScript(`
          // Remove override stylesheet
          const stylesheet = document.getElementById('__cssDisableStylesheet');
          if (stylesheet) {
            stylesheet.remove();
          }
          
          // Re-enable all stylesheets
          for (const styleSheet of document.styleSheets) {
            try {
              styleSheet.disabled = false;
            } catch (e) {
              // Some cross-origin stylesheets can't be accessed
            }
          }
          
          // Mark as CSS enabled
          window.__cssDisabled = false;
          
          // Force browser to repaint
          document.body.style.zoom = '99%';
          setTimeout(() => {
            document.body.style.zoom = '100%';
          }, 10);
        `);
        
        this.logger.debug('CSS enabled');
      }
    } catch (error) {
      this.logger.error(`Error ${disable ? 'disabling' : 'enabling'} CSS: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Disables images on the page
   * @param disable Whether to disable images
   */
  public async disableImages(disable: boolean): Promise<void> {
    try {
      if (disable) {
        // Inject script to hide images
        await this.driver.executeScript(`
          // Hide existing images
          const images = document.querySelectorAll('img, [style*="background-image"]');
          for (const img of images) {
            if (img.tagName === 'IMG') {
              // Store original attributes
              img.__originalSrc = img.src;
              img.__originalAlt = img.alt;
              img.__originalWidth = img.width;
              img.__originalHeight = img.height;
              
              // Replace with placeholder
              img.src = '';
              img.alt = img.__originalAlt || 'Image disabled';
              img.style.border = '1px solid #ccc';
              img.style.background = '#f0f0f0';
              img.style.display = 'inline-block';
              img.style.width = img.__originalWidth ? img.__originalWidth + 'px' : '100px';
              img.style.height = img.__originalHeight ? img.__originalHeight + 'px' : '100px';
              img.style.position = 'relative';
              img.style.textAlign = 'center';
              img.style.lineHeight = img.__originalHeight ? img.__originalHeight + 'px' : '100px';
              img.style.color = '#666';
              img.style.fontStyle = 'italic';
            } else {
              // Element with background image
              img.__originalBackgroundImage = getComputedStyle(img).backgroundImage;
              img.style.backgroundImage = 'none';
            }
          }
          
          // Intercept new images
          if (!window.__originalImageConstructor) {
            window.__originalImageConstructor = window.Image;
            
            window.Image = function(...args) {
              const img = new window.__originalImageConstructor(...args);
              
              // Override setter for src
              const originalSrcDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
              Object.defineProperty(img, 'src', {
                set: function(value) {
                  this.__originalSrc = value;
                  return originalSrcDescriptor.set.call(this, '');
                },
                get: function() {
                  return '';
                }
              });
              
              return img;
            };
          }
          
          // Mark as images disabled
          window.__imagesDisabled = true;
        `);
        
        // Also add CSS to hide background images
        await this.driver.executeScript(`
          if (!document.getElementById('__imageDisableStylesheet')) {
            const stylesheet = document.createElement('style');
            stylesheet.id = '__imageDisableStylesheet';
            stylesheet.innerHTML = \`
              *[style*="background-image"] {
                background-image: none !important;
              }
              
              img {
                background-image: none !important;
              }
            \`;
            document.head.appendChild(stylesheet);
          }
        `);
        
        this.logger.debug('Images disabled');
      } else {
        // Restore original images
        await this.driver.executeScript(`
          // Restore existing images
          const images = document.querySelectorAll('img, [style*="background-image"]');
          for (const img of images) {
            if (img.tagName === 'IMG') {
              if (img.__originalSrc) {
                img.src = img.__originalSrc;
                img.style.border = '';
                img.style.background = '';
                img.style.display = '';
                img.style.position = '';
                img.style.textAlign = '';
                img.style.lineHeight = '';
                img.style.color = '';
                img.style.fontStyle = '';
              }
            } else {
              // Element with background image
              if (img.__originalBackgroundImage) {
                img.style.backgroundImage = img.__originalBackgroundImage;
              }
            }
          }
          
          // Restore Image constructor
          if (window.__originalImageConstructor) {
            window.Image = window.__originalImageConstructor;
            delete window.__originalImageConstructor;
          }
          
          // Remove stylesheet
          const stylesheet = document.getElementById('__imageDisableStylesheet');
          if (stylesheet) {
            stylesheet.remove();
          }
          
          // Mark as images enabled
          window.__imagesDisabled = false;
        `);
        
        this.logger.debug('Images enabled');
      }
    } catch (error) {
      this.logger.error(`Error ${disable ? 'disabling' : 'enabling'} images: ${error}`);
      // Continue without failing - this is a best-effort feature
    }
  }

  /**
   * Highlights elements on the page
   * @param selector The CSS selector for elements to highlight
   * @param options Highlight options
   * @returns The number of elements highlighted
   */
  public async highlightElements(selector: string, options?: {
    color?: string;
    backgroundColor?: string;
    border?: string;
    duration?: number;
    padding?: string;
  }): Promise<number> {
    try {
      const opts = {
        color: options?.color || '#ffffff',
        backgroundColor: options?.backgroundColor || 'rgba(255, 0, 0, 0.7)',
        border: options?.border || '2px solid red',
        duration: options?.duration || 3000,
        padding: options?.padding || '2px'
      };
      
      const count = await this.driver.executeScript(`
        const selector = arguments[0];
        const options = arguments[1];
        
        // Find matching elements
        const elements = document.querySelectorAll(selector);
        if (elements.length === 0) {
          return 0;
        }
        
        // Create a style for the highlight
        const style = document.createElement('style');
        const className = '__highlight_' + Math.random().toString(36).substr(2, 9);
        style.innerHTML = \`
          .\${className} {
            outline: \${options.border} !important;
            background-color: \${options.backgroundColor} !important;
            color: \${options.color} !important;
            padding: \${options.padding} !important;
            transition: all 0.3s ease-in-out !important;
            z-index: 9999 !important;
            position: relative !important;
            pointer-events: none !important;
          }
        \`;
        document.head.appendChild(style);
        
        // Add class to matching elements
        elements.forEach(el => {
          el.__originalZIndex = el.style.zIndex;
          el.__originalPosition = el.style.position;
          el.classList.add(className);
        });
        
        // Remove highlights after duration
        setTimeout(() => {
          elements.forEach(el => {
            el.classList.remove(className);
            if (el.__originalZIndex !== undefined) {
              el.style.zIndex = el.__originalZIndex;
              delete el.__originalZIndex;
            }
            if (el.__originalPosition !== undefined) {
              el.style.position = el.__originalPosition;
              delete el.__originalPosition;
            }
          });
          style.remove();
        }, options.duration);
        
        return elements.length;
      `, selector, opts);
      
      this.logger.debug(`Highlighted ${count} elements matching selector: ${selector}`);
      return count;
    } catch (error) {
      this.logger.error(`Error highlighting elements: ${error}`);
      return 0;
    }
  }

  /**
   * Quits the browser
   */
  public async quit(): Promise<void> {
    try {
      // Get the driver ID
      const sessionId = await this.webDriverManager.getSessionId(this.driver);
      const driverId = `${this.browserType}-${CSEncryptionUtils.hash(sessionId)}`;
      
      // Quit the driver
      await this.webDriverManager.quitDriver(driverId);
      
      this.logger.info('Browser quit successfully');
    } catch (error) {
      this.logger.error(`Error quitting browser: ${error}`);
      throw new Error(`Failed to quit browser: ${error}`);
    }
  }
}



CapabilityManager.ts
----------------------------------

import { Capabilities, logging } from 'selenium-webdriver';
import { BrowserType } from '../types/WebDriverTypes';
import { CSLogger } from '../../core/utils/CSLogger';
import { ConfigurationManager } from '../../core/config/ConfigurationManager';

/**
 * CapabilityManager is responsible for creating and managing WebDriver capabilities.
 * It provides methods for creating default capabilities for different browsers,
 * as well as methods for customizing capabilities based on configuration settings.
 */
export class CapabilityManager {
  private static instance: CapabilityManager;
  private logger: CSLogger;
  private configurationManager: ConfigurationManager;
  private defaultCapabilities: Map<BrowserType, Capabilities>;
  
  /**
   * Private constructor to enforce singleton pattern
   */
  private constructor() {
    this.logger = new CSLogger('CapabilityManager');
    this.configurationManager = ConfigurationManager.getInstance();
    this.defaultCapabilities = new Map<BrowserType, Capabilities>();
    this.initializeDefaultCapabilities();
  }
  
  /**
   * Gets the singleton instance of CapabilityManager
   * @returns The CapabilityManager instance
   */
  public static getInstance(): CapabilityManager {
    if (!CapabilityManager.instance) {
      CapabilityManager.instance = new CapabilityManager();
    }
    return CapabilityManager.instance;
  }
  
  /**
   * Initializes the default capabilities for each supported browser
   */
  private initializeDefaultCapabilities(): void {
    // Initialize Chrome capabilities
    this.defaultCapabilities.set(BrowserType.CHROME, this.createChromeCapabilities());
    
    // Initialize Firefox capabilities
    this.defaultCapabilities.set(BrowserType.FIREFOX, this.createFirefoxCapabilities());
    
    // Initialize Edge capabilities
    this.defaultCapabilities.set(BrowserType.EDGE, this.createEdgeCapabilities());
    
    // Initialize Safari capabilities
    this.defaultCapabilities.set(BrowserType.SAFARI, this.createSafariCapabilities());
    
    // Initialize Internet Explorer capabilities
    this.defaultCapabilities.set(BrowserType.IE, this.createIECapabilities());
    
    this.logger.debug('Default capabilities initialized for all supported browsers');
  }
  
  /**
   * Creates default capabilities for Chrome
   * @returns Chrome capabilities
   */
  private createChromeCapabilities(): Capabilities {
    const capabilities = Capabilities.chrome();
    
    // Add Chrome-specific capabilities
    capabilities.set('goog:chromeOptions', {
      args: [
        '--no-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--window-size=1920,1080'
      ],
      excludeSwitches: ['enable-automation', 'enable-logging'],
      prefs: {
        'download.prompt_for_download': false,
        'download.directory_upgrade': true,
        'safebrowsing.enabled': false,
        'credentials_enable_service': false,
        'profile.password_manager_enabled': false
      }
    });
    
    // Add W3C compliance
    capabilities.set('goog:w3c', true);
    
    // Add desired browser name and version
    capabilities.setBrowserName('chrome');
    
    return capabilities;
  }
  
  /**
   * Creates default capabilities for Firefox
   * @returns Firefox capabilities
   */
  private createFirefoxCapabilities(): Capabilities {
    const capabilities = Capabilities.firefox();
    
    // Add Firefox-specific capabilities
    capabilities.set('moz:firefoxOptions', {
      args: ['-width', '1920', '-height', '1080'],
      prefs: {
        'browser.download.folderList': 2,
        'browser.download.manager.showWhenStarting': false,
        'browser.helperApps.neverAsk.saveToDisk': 'application/octet-stream, application/pdf, application/x-pdf, application/zip, text/csv',
        'browser.download.manager.alertOnEXEOpen': false,
        'browser.download.manager.focusWhenStarting': false,
        'browser.download.useDownloadDir': true,
        'browser.helperApps.alwaysAsk.force': false,
        'pdfjs.disabled': true
      },
      log: { level: 'error' }
    });
    
    // Add W3C compliance
    capabilities.set('moz:webdriverClick', true);
    
    // Add desired browser name and version
    capabilities.setBrowserName('firefox');
    
    return capabilities;
  }
  
  /**
   * Creates default capabilities for Edge
   * @returns Edge capabilities
   */
  private createEdgeCapabilities(): Capabilities {
    const capabilities = Capabilities.edge();
    
    // Add Edge-specific capabilities
    capabilities.set('ms:edgeOptions', {
      args: [
        '--no-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--window-size=1920,1080',
        '--inprivate'
      ],
      excludeSwitches: ['enable-automation'],
      prefs: {
        'download.prompt_for_download': false,
        'download.directory_upgrade': true,
        'safebrowsing.enabled': false,
        'credentials_enable_service': false,
        'profile.password_manager_enabled': false
      }
    });
    
    // Add W3C compliance
    capabilities.set('ms:edgeChromium', true);
    
    // Add desired browser name and version
    capabilities.setBrowserName('MicrosoftEdge');
    
    return capabilities;
  }
  
  /**
   * Creates default capabilities for Safari
   * @returns Safari capabilities
   */
  private createSafariCapabilities(): Capabilities {
    const capabilities = Capabilities.safari();
    
    // Add Safari-specific capabilities
    capabilities.set('safari.options', {
      automaticInspection: false,
      automaticProfiling: false
    });
    
    // Set Technology Preview mode to false by default
    capabilities.set('safari:technologyPreview', false);
    
    // Add desired browser name and version
    capabilities.setBrowserName('safari');
    
    return capabilities;
  }
  
  /**
   * Creates default capabilities for Internet Explorer
   * @returns Internet Explorer capabilities
   */
  private createIECapabilities(): Capabilities {
    const capabilities = Capabilities.ie();
    
    // Add IE-specific capabilities
    capabilities.set('se:ieOptions', {
      ignoreProtectedModeSettings: true,
      ignoreZoomSetting: true,
      ensureCleanSession: true,
      initialBrowserUrl: 'about:blank',
      enablePersistentHover: true,
      requireWindowFocus: false,
      nativeEvents: false
    });
    
    // Add desired browser name and version
    capabilities.setBrowserName('internet explorer');
    
    return capabilities;
  }
  
  /**
   * Gets the default capabilities for a specific browser
   * @param browser The browser type
   * @returns The default capabilities for the specified browser
   */
  public getCapabilities(browser: BrowserType): Capabilities {
    const capabilities = this.defaultCapabilities.get(browser);
    
    if (!capabilities) {
      this.logger.warn(`No default capabilities found for browser: ${browser}, using Chrome capabilities`);
      return this.defaultCapabilities.get(BrowserType.CHROME) || Capabilities.chrome();
    }
    
    return capabilities.merge(this.getCustomCapabilities(browser));
  }
  
  /**
   * Gets custom capabilities for a specific browser from the configuration
   * @param browser The browser type
   * @returns The custom capabilities for the specified browser
   */
  private getCustomCapabilities(browser: BrowserType): Capabilities {
    const capabilities = new Capabilities();
    const frameworkConfig = this.configurationManager.getFrameworkConfig();
    
    // If no custom capabilities are defined in the configuration, return empty capabilities
    if (!frameworkConfig.webdriver?.capabilities?.[browser]) {
      return capabilities;
    }
    
    // Add custom capabilities from configuration
    const customCapabilities = frameworkConfig.webdriver.capabilities[browser];
    for (const [key, value] of Object.entries(customCapabilities)) {
      capabilities.set(key, value);
    }
    
    return capabilities;
  }
  
  /**
   * Updates the default capabilities for a specific browser
   * @param browser The browser type
   * @param capabilities The capabilities to set
   */
  public updateCapabilities(browser: BrowserType, capabilities: Capabilities): void {
    this.defaultCapabilities.set(browser, capabilities);
    this.logger.debug(`Updated default capabilities for ${browser}`);
  }
  
  /**
   * Merges custom capabilities with default capabilities
   * @param browser The browser type
   * @param customCapabilities The custom capabilities to merge
   * @returns The merged capabilities
   */
  public mergeCapabilities(browser: BrowserType, customCapabilities: Record<string, any>): Capabilities {
    const baseCapabilities = this.getCapabilities(browser);
    
    // Create a new capabilities object with the base capabilities
    const mergedCapabilities = baseCapabilities.merge(new Capabilities(customCapabilities));
    
    return mergedCapabilities;
  }
  
  /**
   * Creates capabilities for mobile emulation (Chrome only)
   * @param deviceName The device name to emulate (e.g., "iPhone X")
   * @returns The capabilities for mobile emulation
   */
  public createMobileEmulationCapabilities(deviceName: string): Capabilities {
    const capabilities = this.getCapabilities(BrowserType.CHROME);
    
    // Get existing Chrome options
    const chromeOptions = capabilities.get('goog:chromeOptions') || {};
    
    // Add mobile emulation settings
    chromeOptions.mobileEmulation = {
      deviceName: deviceName
    };
    
    // Update Chrome options
    capabilities.set('goog:chromeOptions', chromeOptions);
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for custom mobile emulation (Chrome only)
   * @param width The device width
   * @param height The device height
   * @param pixelRatio The device pixel ratio
   * @param userAgent The user agent string
   * @returns The capabilities for custom mobile emulation
   */
  public createCustomMobileEmulationCapabilities(
    width: number,
    height: number,
    pixelRatio: number,
    userAgent: string
  ): Capabilities {
    const capabilities = this.getCapabilities(BrowserType.CHROME);
    
    // Get existing Chrome options
    const chromeOptions = capabilities.get('goog:chromeOptions') || {};
    
    // Add custom mobile emulation settings
    chromeOptions.mobileEmulation = {
      deviceMetrics: {
        width: width,
        height: height,
        pixelRatio: pixelRatio
      },
      userAgent: userAgent
    };
    
    // Update Chrome options
    capabilities.set('goog:chromeOptions', chromeOptions);
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for headless mode
   * @param browser The browser type
   * @returns The capabilities for headless mode
   */
  public createHeadlessCapabilities(browser: BrowserType): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    switch (browser) {
      case BrowserType.CHROME:
        // Get existing Chrome options
        const chromeOptions = capabilities.get('goog:chromeOptions') || {};
        
        // Add headless arguments
        chromeOptions.args = chromeOptions.args || [];
        if (!chromeOptions.args.includes('--headless')) {
          chromeOptions.args.push('--headless');
        }
        
        // Update Chrome options
        capabilities.set('goog:chromeOptions', chromeOptions);
        break;
        
      case BrowserType.FIREFOX:
        // Get existing Firefox options
        const firefoxOptions = capabilities.get('moz:firefoxOptions') || {};
        
        // Add headless arguments
        firefoxOptions.args = firefoxOptions.args || [];
        if (!firefoxOptions.args.includes('-headless')) {
          firefoxOptions.args.push('-headless');
        }
        
        // Update Firefox options
        capabilities.set('moz:firefoxOptions', firefoxOptions);
        break;
        
      case BrowserType.EDGE:
        // Get existing Edge options
        const edgeOptions = capabilities.get('ms:edgeOptions') || {};
        
        // Add headless arguments
        edgeOptions.args = edgeOptions.args || [];
        if (!edgeOptions.args.includes('--headless')) {
          edgeOptions.args.push('--headless');
        }
        
        // Update Edge options
        capabilities.set('ms:edgeOptions', edgeOptions);
        break;
        
      case BrowserType.SAFARI:
        this.logger.warn('Safari does not support headless mode');
        break;
        
      case BrowserType.IE:
        this.logger.warn('Internet Explorer does not support headless mode');
        break;
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for remote WebDriver
   * @param browser The browser type
   * @param platformName The platform name (e.g., "Windows 10", "macOS 10.15")
   * @param browserVersion The browser version
   * @returns The capabilities for remote WebDriver
   */
  public createRemoteCapabilities(
    browser: BrowserType,
    platformName?: string,
    browserVersion?: string
  ): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    // Add platform name if provided
    if (platformName) {
      capabilities.set('platformName', platformName);
    }
    
    // Add browser version if provided
    if (browserVersion) {
      capabilities.setBrowserVersion(browserVersion);
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for Selenium Grid
   * @param browser The browser type
   * @param platformName The platform name
   * @param browserVersion The browser version
   * @param name The test name
   * @param build The build name
   * @returns The capabilities for Selenium Grid
   */
  public createGridCapabilities(
    browser: BrowserType,
    platformName?: string,
    browserVersion?: string,
    name?: string,
    build?: string
  ): Capabilities {
    const capabilities = this.createRemoteCapabilities(browser, platformName, browserVersion);
    
    // Add test name and build if provided
    if (name) {
      capabilities.set('name', name);
    }
    
    if (build) {
      capabilities.set('build', build);
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for Sauce Labs
   * @param browser The browser type
   * @param platformName The platform name
   * @param browserVersion The browser version
   * @param name The test name
   * @param build The build name
   * @param tunnelIdentifier The tunnel identifier
   * @returns The capabilities for Sauce Labs
   */
  public createSauceLabsCapabilities(
    browser: BrowserType,
    platformName?: string,
    browserVersion?: string,
    name?: string,
    build?: string,
    tunnelIdentifier?: string
  ): Capabilities {
    const capabilities = this.createGridCapabilities(browser, platformName, browserVersion, name, build);
    
    // Add sauce-specific capabilities
    capabilities.set('sauce:options', {
      tunnelIdentifier: tunnelIdentifier,
      screenResolution: '1920x1080'
    });
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for BrowserStack
   * @param browser The browser type
   * @param platformName The platform name
   * @param browserVersion The browser version
   * @param name The test name
   * @param build The build name
   * @param projectName The project name
   * @returns The capabilities for BrowserStack
   */
  public createBrowserStackCapabilities(
    browser: BrowserType,
    platformName?: string,
    browserVersion?: string,
    name?: string,
    build?: string,
    projectName?: string
  ): Capabilities {
    const capabilities = this.createGridCapabilities(browser, platformName, browserVersion, name, build);
    
    // Add BrowserStack-specific capabilities
    capabilities.set('bstack:options', {
      projectName: projectName,
      debug: true,
      networkLogs: true,
      video: true,
      seleniumVersion: '4.0.0',
      resolution: '1920x1080'
    });
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for TestingBot
   * @param browser The browser type
   * @param platformName The platform name
   * @param browserVersion The browser version
   * @param name The test name
   * @param build The build name
   * @returns The capabilities for TestingBot
   */
  public createTestingBotCapabilities(
    browser: BrowserType,
    platformName?: string,
    browserVersion?: string,
    name?: string,
    build?: string
  ): Capabilities {
    const capabilities = this.createGridCapabilities(browser, platformName, browserVersion, name, build);
    
    // Add TestingBot-specific capabilities
    capabilities.set('tb:options', {
      screenResolution: '1920x1080',
      timeZone: 'UTC'
    });
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for LambdaTest
   * @param browser The browser type
   * @param platformName The platform name
   * @param browserVersion The browser version
   * @param name The test name
   * @param build The build name
   * @param projectName The project name
   * @returns The capabilities for LambdaTest
   */
  public createLambdaTestCapabilities(
    browser: BrowserType,
    platformName?: string,
    browserVersion?: string,
    name?: string,
    build?: string,
    projectName?: string
  ): Capabilities {
    const capabilities = this.createGridCapabilities(browser, platformName, browserVersion, name, build);
    
    // Add LambdaTest-specific capabilities
    capabilities.set('LT:Options', {
      resolution: '1920x1080',
      network: true,
      visual: true,
      video: true,
      console: true,
      tunnel: false,
      project: projectName
    });
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for performance logging
   * @param browser The browser type
   * @returns The capabilities with performance logging enabled
   */
  public createPerformanceLoggingCapabilities(browser: BrowserType): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    // Only Chrome supports performance logging
    if (browser === BrowserType.CHROME) {
      // Create logging preferences
      const loggingPrefs = new logging.Preferences();
      loggingPrefs.setLevel(logging.Type.BROWSER, logging.Level.ALL);
      loggingPrefs.setLevel(logging.Type.DRIVER, logging.Level.ALL);
      loggingPrefs.setLevel(logging.Type.PERFORMANCE, logging.Level.ALL);
      
      // Set logging preferences capability
      capabilities.set('goog:loggingPrefs', loggingPrefs);
      
      // Get existing Chrome options
      const chromeOptions = capabilities.get('goog:chromeOptions') || {};
      
      // Enable performance tracing
      chromeOptions.perfLoggingPrefs = {
        enableNetwork: true,
        enablePage: true,
        enableTimeline: true,
        traceCategories: 'browser,devtools.timeline,devtools'
      };
      
      // Update Chrome options
      capabilities.set('goog:chromeOptions', chromeOptions);
    } else {
      this.logger.warn(`Performance logging is only supported in Chrome, not in ${browser}`);
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for video recording (Chrome only)
   * @param browser The browser type
   * @param videoDirectory The directory to save videos
   * @returns The capabilities with video recording enabled
   */
  public createVideoRecordingCapabilities(browser: BrowserType, videoDirectory: string): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    // Only Chrome supports video recording via chromedriver
    if (browser === BrowserType.CHROME) {
      // Get existing Chrome options
      const chromeOptions = capabilities.get('goog:chromeOptions') || {};
      
      // Add video recording capabilities
      chromeOptions.args = chromeOptions.args || [];
      chromeOptions.args.push(`--use-file-for-fake-video-capture=${videoDirectory}/screencast.y4m`);
      
      // Update Chrome options
      capabilities.set('goog:chromeOptions', chromeOptions);
    } else {
      this.logger.warn(`Video recording via capabilities is only supported in Chrome, not in ${browser}`);
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for proxy configuration
   * @param browser The browser type
   * @param proxyUrl The proxy URL (e.g., "http://proxy.example.com:8080")
   * @param proxyBypass The proxy bypass list (e.g., "localhost,127.0.0.1")
   * @returns The capabilities with proxy configuration
   */
  public createProxyCapabilities(browser: BrowserType, proxyUrl: string, proxyBypass?: string): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    // Create proxy configuration
    const proxy: {
      proxyType: string;
      httpProxy?: string;
      sslProxy?: string;
      ftpProxy?: string;
      noProxy?: string;
      socksProxy?: string;
      socksVersion?: number;
    } = {
      proxyType: 'manual'
    };
    
    // Set proxy URL for different protocols
    if (proxyUrl.startsWith('http://')) {
      proxy.httpProxy = proxyUrl;
    } else if (proxyUrl.startsWith('https://')) {
      proxy.sslProxy = proxyUrl;
    } else if (proxyUrl.startsWith('ftp://')) {
      proxy.ftpProxy = proxyUrl;
    } else if (proxyUrl.startsWith('socks://') || proxyUrl.startsWith('socks4://')) {
      proxy.socksProxy = proxyUrl.replace(/^socks4?:\/\//, '');
      proxy.socksVersion = 4;
    } else if (proxyUrl.startsWith('socks5://')) {
      proxy.socksProxy = proxyUrl.replace(/^socks5:\/\//, '');
      proxy.socksVersion = 5;
    } else {
      // If no protocol is specified, use for all protocols
      proxy.httpProxy = proxyUrl;
      proxy.sslProxy = proxyUrl;
      proxy.ftpProxy = proxyUrl;
    }
    
    // Set proxy bypass list if provided
    if (proxyBypass) {
      proxy.noProxy = proxyBypass;
    }
    
    // Set proxy capability
    capabilities.set('proxy', proxy);
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for network conditions emulation (Chrome only)
   * @param browser The browser type
   * @param downloadThroughput The download throughput in kbps
   * @param uploadThroughput The upload throughput in kbps
   * @param latency The latency in ms
   * @returns The capabilities with network conditions emulation
   */
  public createNetworkConditionsCapabilities(
    browser: BrowserType,
    downloadThroughput: number,
    uploadThroughput: number,
    latency: number
  ): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    // Only Chrome supports network conditions emulation
    if (browser === BrowserType.CHROME) {
      // Calculate throughput in bytes per second
      const downloadBytesPerSecond = downloadThroughput * 1024 / 8;
      const uploadBytesPerSecond = uploadThroughput * 1024 / 8;
      
      // Set network conditions capability
      capabilities.set('goog:networkConditions', {
        offline: false,
        latency: latency,
        download_throughput: downloadBytesPerSecond,
        upload_throughput: uploadBytesPerSecond
      });
    } else {
      this.logger.warn(`Network conditions emulation is only supported in Chrome, not in ${browser}`);
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for browser extensions
   * @param browser The browser type
   * @param extensionPaths Array of paths to extension files or directories
   * @returns The capabilities with extensions
   */
  public createExtensionCapabilities(browser: BrowserType, extensionPaths: string[]): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    switch (browser) {
      case BrowserType.CHROME:
        // Get existing Chrome options
        const chromeOptions = capabilities.get('goog:chromeOptions') || {};
        
        // Add extensions
        chromeOptions.extensions = extensionPaths;
        
        // Update Chrome options
        capabilities.set('goog:chromeOptions', chromeOptions);
        break;
        
      case BrowserType.FIREFOX:
        // Get existing Firefox options
        const firefoxOptions = capabilities.get('moz:firefoxOptions') || {};
        
        // Add extensions
        firefoxOptions.extensions = extensionPaths;
        
        // Update Firefox options
        capabilities.set('moz:firefoxOptions', firefoxOptions);
        break;
        
      case BrowserType.EDGE:
        // Get existing Edge options
        const edgeOptions = capabilities.get('ms:edgeOptions') || {};
        
        // Add extensions
        edgeOptions.extensions = extensionPaths;
        
        // Update Edge options
        capabilities.set('ms:edgeOptions', edgeOptions);
        break;
        
      case BrowserType.SAFARI:
        this.logger.warn('Safari does not support adding extensions via capabilities');
        break;
        
      case BrowserType.IE:
        this.logger.warn('Internet Explorer does not support adding extensions via capabilities');
        break;
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for user profile
   * @param browser The browser type
   * @param profilePath Path to the user profile directory
   * @returns The capabilities with user profile
   */
  public createProfileCapabilities(browser: BrowserType, profilePath: string): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    switch (browser) {
      case BrowserType.CHROME:
        // Get existing Chrome options
        const chromeOptions = capabilities.get('goog:chromeOptions') || {};
        
        // Add user profile
        chromeOptions.args = chromeOptions.args || [];
        chromeOptions.args.push(`--user-data-dir=${profilePath}`);
        
        // Update Chrome options
        capabilities.set('goog:chromeOptions', chromeOptions);
        break;
        
      case BrowserType.FIREFOX:
        // Get existing Firefox options
        const firefoxOptions = capabilities.get('moz:firefoxOptions') || {};
        
        // Add user profile
        firefoxOptions.profile = profilePath;
        
        // Update Firefox options
        capabilities.set('moz:firefoxOptions', firefoxOptions);
        break;
        
      case BrowserType.EDGE:
        // Get existing Edge options
        const edgeOptions = capabilities.get('ms:edgeOptions') || {};
        
        // Add user profile
        edgeOptions.args = edgeOptions.args || [];
        edgeOptions.args.push(`--user-data-dir=${profilePath}`);
        
        // Update Edge options
        capabilities.set('ms:edgeOptions', edgeOptions);
        break;
        
      case BrowserType.SAFARI:
        this.logger.warn('Safari does not support user profiles via capabilities');
        break;
        
      case BrowserType.IE:
        // IE supports profiles in a different way
        capabilities.set('ie.ensureCleanSession', false);
        break;
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for incognito/private browsing mode
   * @param browser The browser type
   * @returns The capabilities with incognito/private browsing enabled
   */
  public createIncognitoCapabilities(browser: BrowserType): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    switch (browser) {
      case BrowserType.CHROME:
        // Get existing Chrome options
        const chromeOptions = capabilities.get('goog:chromeOptions') || {};
        
        // Add incognito argument
        chromeOptions.args = chromeOptions.args || [];
        if (!chromeOptions.args.includes('--incognito')) {
          chromeOptions.args.push('--incognito');
        }
        
        // Update Chrome options
        capabilities.set('goog:chromeOptions', chromeOptions);
        break;
        
      case BrowserType.FIREFOX:
        // Get existing Firefox options
        const firefoxOptions = capabilities.get('moz:firefoxOptions') || {};
        
        // Add private browsing preference
        firefoxOptions.prefs = firefoxOptions.prefs || {};
        firefoxOptions.prefs['browser.privatebrowsing.autostart'] = true;
        
        // Update Firefox options
        capabilities.set('moz:firefoxOptions', firefoxOptions);
        break;
        
      case BrowserType.EDGE:
        // Get existing Edge options
        const edgeOptions = capabilities.get('ms:edgeOptions') || {};
        
        // Add InPrivate argument
        edgeOptions.args = edgeOptions.args || [];
        if (!edgeOptions.args.includes('--inprivate')) {
          edgeOptions.args.push('--inprivate');
        }
        
        // Update Edge options
        capabilities.set('ms:edgeOptions', edgeOptions);
        break;
        
      case BrowserType.SAFARI:
        this.logger.warn('Safari does not support private browsing mode via capabilities');
        break;
        
      case BrowserType.IE:
        this.logger.warn('Internet Explorer does not support private browsing mode via capabilities');
        break;
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for window size
   * @param browser The browser type
   * @param width The window width
   * @param height The window height
   * @returns The capabilities with window size
   */
  public createWindowSizeCapabilities(browser: BrowserType, width: number, height: number): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    switch (browser) {
      case BrowserType.CHROME:
        // Get existing Chrome options
        const chromeOptions = capabilities.get('goog:chromeOptions') || {};
        
        // Add window size argument
        chromeOptions.args = chromeOptions.args || [];
        
        // Remove any existing window size arguments
        chromeOptions.args = chromeOptions.args.filter(arg => !arg.startsWith('--window-size='));
        
        // Add new window size argument
        chromeOptions.args.push(`--window-size=${width},${height}`);
        
        // Update Chrome options
        capabilities.set('goog:chromeOptions', chromeOptions);
        break;
        
      case BrowserType.FIREFOX:
        // Get existing Firefox options
        const firefoxOptions = capabilities.get('moz:firefoxOptions') || {};
        
        // Add window size arguments
        firefoxOptions.args = firefoxOptions.args || [];
        
        // Remove any existing window size arguments
        const widthIndex = firefoxOptions.args.indexOf('-width');
        if (widthIndex !== -1) {
          firefoxOptions.args.splice(widthIndex, 2);
        }
        
        const heightIndex = firefoxOptions.args.indexOf('-height');
        if (heightIndex !== -1) {
          firefoxOptions.args.splice(heightIndex, 2);
        }
        
        // Add new window size arguments
        firefoxOptions.args.push('-width', width.toString(), '-height', height.toString());
        
        // Update Firefox options
        capabilities.set('moz:firefoxOptions', firefoxOptions);
        break;
        
      case BrowserType.EDGE:
        // Get existing Edge options
        const edgeOptions = capabilities.get('ms:edgeOptions') || {};
        
        // Add window size argument
        edgeOptions.args = edgeOptions.args || [];
        
        // Remove any existing window size arguments
        edgeOptions.args = edgeOptions.args.filter(arg => !arg.startsWith('--window-size='));
        
        // Add new window size argument
        edgeOptions.args.push(`--window-size=${width},${height}`);
        
        // Update Edge options
        capabilities.set('ms:edgeOptions', edgeOptions);
        break;
        
      case BrowserType.SAFARI:
        // Safari doesn't support window size via capabilities
        this.logger.warn('Safari does not support window size via capabilities, set it after driver initialization');
        break;
        
      case BrowserType.IE:
        // IE doesn't support window size via capabilities
        this.logger.warn('Internet Explorer does not support window size via capabilities, set it after driver initialization');
        break;
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for download directory
   * @param browser The browser type
   * @param downloadDirectory The download directory path
   * @returns The capabilities with download directory
   */
  public createDownloadDirectoryCapabilities(browser: BrowserType, downloadDirectory: string): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    switch (browser) {
      case BrowserType.CHROME:
        // Get existing Chrome options
        const chromeOptions = capabilities.get('goog:chromeOptions') || {};
        
        // Add download directory preferences
        chromeOptions.prefs = chromeOptions.prefs || {};
        chromeOptions.prefs['download.default_directory'] = downloadDirectory;
        chromeOptions.prefs['download.prompt_for_download'] = false;
        chromeOptions.prefs['download.directory_upgrade'] = true;
        
        // Update Chrome options
        capabilities.set('goog:chromeOptions', chromeOptions);
        break;
        
      case BrowserType.FIREFOX:
        // Get existing Firefox options
        const firefoxOptions = capabilities.get('moz:firefoxOptions') || {};
        
        // Add download directory preferences
        firefoxOptions.prefs = firefoxOptions.prefs || {};
        firefoxOptions.prefs['browser.download.dir'] = downloadDirectory;
        firefoxOptions.prefs['browser.download.folderList'] = 2;
        firefoxOptions.prefs['browser.download.manager.showWhenStarting'] = false;
        
        // Update Firefox options
        capabilities.set('moz:firefoxOptions', firefoxOptions);
        break;
        
      case BrowserType.EDGE:
        // Get existing Edge options
        const edgeOptions = capabilities.get('ms:edgeOptions') || {};
        
        // Add download directory preferences
        edgeOptions.prefs = edgeOptions.prefs || {};
        edgeOptions.prefs['download.default_directory'] = downloadDirectory;
        edgeOptions.prefs['download.prompt_for_download'] = false;
        edgeOptions.prefs['download.directory_upgrade'] = true;
        
        // Update Edge options
        capabilities.set('ms:edgeOptions', edgeOptions);
        break;
        
      case BrowserType.SAFARI:
        this.logger.warn('Safari does not support download directory via capabilities');
        break;
        
      case BrowserType.IE:
        this.logger.warn('Internet Explorer does not support download directory via capabilities');
        break;
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for command-line arguments
   * @param browser The browser type
   * @param args Array of command-line arguments
   * @returns The capabilities with command-line arguments
   */
  public createCommandLineArgsCapabilities(browser: BrowserType, args: string[]): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    switch (browser) {
      case BrowserType.CHROME:
        // Get existing Chrome options
        const chromeOptions = capabilities.get('goog:chromeOptions') || {};
        
        // Add command-line arguments
        chromeOptions.args = chromeOptions.args || [];
        chromeOptions.args.push(...args);
        
        // Update Chrome options
        capabilities.set('goog:chromeOptions', chromeOptions);
        break;
        
      case BrowserType.FIREFOX:
        // Get existing Firefox options
        const firefoxOptions = capabilities.get('moz:firefoxOptions') || {};
        
        // Add command-line arguments
        firefoxOptions.args = firefoxOptions.args || [];
        firefoxOptions.args.push(...args);
        
        // Update Firefox options
        capabilities.set('moz:firefoxOptions', firefoxOptions);
        break;
        
      case BrowserType.EDGE:
        // Get existing Edge options
        const edgeOptions = capabilities.get('ms:edgeOptions') || {};
        
        // Add command-line arguments
        edgeOptions.args = edgeOptions.args || [];
        edgeOptions.args.push(...args);
        
        // Update Edge options
        capabilities.set('ms:edgeOptions', edgeOptions);
        break;
        
      case BrowserType.SAFARI:
        this.logger.warn('Safari does not support command-line arguments via capabilities');
        break;
        
      case BrowserType.IE:
        this.logger.warn('Internet Explorer does not support command-line arguments via capabilities');
        break;
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for experimental options
   * @param browser The browser type
   * @param options Record of experimental options
   * @returns The capabilities with experimental options
   */
  public createExperimentalOptionsCapabilities(browser: BrowserType, options: Record<string, any>): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    switch (browser) {
      case BrowserType.CHROME:
        // Get existing Chrome options
        const chromeOptions = capabilities.get('goog:chromeOptions') || {};
        
        // Add experimental options
        for (const [key, value] of Object.entries(options)) {
          chromeOptions[key] = value;
        }
        
        // Update Chrome options
        capabilities.set('goog:chromeOptions', chromeOptions);
        break;
        
      case BrowserType.FIREFOX:
        // Get existing Firefox options
        const firefoxOptions = capabilities.get('moz:firefoxOptions') || {};
        
        // Add experimental options
        for (const [key, value] of Object.entries(options)) {
          firefoxOptions[key] = value;
        }
        
        // Update Firefox options
        capabilities.set('moz:firefoxOptions', firefoxOptions);
        break;
        
      case BrowserType.EDGE:
        // Get existing Edge options
        const edgeOptions = capabilities.get('ms:edgeOptions') || {};
        
        // Add experimental options
        for (const [key, value] of Object.entries(options)) {
          edgeOptions[key] = value;
        }
        
        // Update Edge options
        capabilities.set('ms:edgeOptions', edgeOptions);
        break;
        
      case BrowserType.SAFARI:
        // Get existing Safari options
        const safariOptions = capabilities.get('safari:options') || {};
        
        // Add experimental options
        for (const [key, value] of Object.entries(options)) {
          safariOptions[key] = value;
        }
        
        // Update Safari options
        capabilities.set('safari:options', safariOptions);
        break;
        
      case BrowserType.IE:
        // Get existing IE options
        const ieOptions = capabilities.get('se:ieOptions') || {};
        
        // Add experimental options
        for (const [key, value] of Object.entries(options)) {
          ieOptions[key] = value;
        }
        
        // Update IE options
        capabilities.set('se:ieOptions', ieOptions);
        break;
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for debugging WebDriver
   * @param browser The browser type
   * @param debugPort The debug port
   * @returns The capabilities with debugging enabled
   */
  public createDebugCapabilities(browser: BrowserType, debugPort: number): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    // Set general WebDriver debug capability
    capabilities.set('webdriver.debug', true);
    
    switch (browser) {
      case BrowserType.CHROME:
        // Get existing Chrome options
        const chromeOptions = capabilities.get('goog:chromeOptions') || {};
        
        // Add debug port argument
        chromeOptions.args = chromeOptions.args || [];
        
        // Remove any existing debug port arguments
        chromeOptions.args = chromeOptions.args.filter(arg => !arg.startsWith('--remote-debugging-port='));
        
        // Add new debug port argument
        chromeOptions.args.push(`--remote-debugging-port=${debugPort}`);
        
        // Add verbose logging
        chromeOptions.args.push('--enable-logging', '--v=1');
        
        // Update Chrome options
        capabilities.set('goog:chromeOptions', chromeOptions);
        break;
        
      case BrowserType.FIREFOX:
        // Get existing Firefox options
        const firefoxOptions = capabilities.get('moz:firefoxOptions') || {};
        
        // Add debug port preference
        firefoxOptions.prefs = firefoxOptions.prefs || {};
        firefoxOptions.prefs['devtools.debugger.remote-port'] = debugPort;
        firefoxOptions.prefs['devtools.debugger.remote-enabled'] = true;
        
        // Set higher log level
        firefoxOptions.log = { level: 'trace' };
        
        // Update Firefox options
        capabilities.set('moz:firefoxOptions', firefoxOptions);
        break;
        
      case BrowserType.EDGE:
        // Get existing Edge options
        const edgeOptions = capabilities.get('ms:edgeOptions') || {};
        
        // Add debug port argument
        edgeOptions.args = edgeOptions.args || [];
        
        // Remove any existing debug port arguments
        edgeOptions.args = edgeOptions.args.filter(arg => !arg.startsWith('--remote-debugging-port='));
        
        // Add new debug port argument
        edgeOptions.args.push(`--remote-debugging-port=${debugPort}`);
        
        // Add verbose logging
        edgeOptions.args.push('--enable-logging', '--v=1');
        
        // Update Edge options
        capabilities.set('ms:edgeOptions', edgeOptions);
        break;
        
      case BrowserType.SAFARI:
        // Safari debugging is done differently
        capabilities.set('safari:diagnose', true);
        this.logger.warn('Safari WebDriver debugging is limited and not fully supported via capabilities');
        break;
        
      case BrowserType.IE:
        // IE debugging is done differently
        capabilities.set('ie.enablePersistentHover', true);
        capabilities.set('ie.ensureCleanSession', false);
        capabilities.set('ie.setWindowPosition', true);
        capabilities.set('requireWindowFocus', true);
        this.logger.warn('IE WebDriver debugging is limited and not fully supported via capabilities');
        break;
    }
    
    return capabilities;
  }
  
  /**
   * Creates capabilities for handling SSL certificate errors
   * @param browser The browser type
   * @returns The capabilities with SSL certificate error handling
   */
  public createIgnoreCertificateErrorsCapabilities(browser: BrowserType): Capabilities {
    const capabilities = this.getCapabilities(browser);
    
    // Set accept insecure certs capability
    capabilities.setAcceptInsecureCerts(true);
    
    switch (browser) {
      case BrowserType.CHROME:
        // Get existing Chrome options
        const chromeOptions = capabilities.get('goog:chromeOptions') || {};
        
        // Add ignore-certificate-errors argument
        chromeOptions.args = chromeOptions.args || [];
        if (!chromeOptions.args.includes('--ignore-certificate-errors')) {
          chromeOptions.args.push('--ignore-certificate-errors');
        }
        
        // Update Chrome options
        capabilities.set('goog:chromeOptions', chromeOptions);
        break;
        
      case BrowserType.FIREFOX:
        // Get existing Firefox options
        const firefoxOptions = capabilities.get('moz:firefoxOptions') || {};
        
        // Add certificate preferences
        firefoxOptions.prefs = firefoxOptions.prefs || {};
        firefoxOptions.prefs['security.cert_pinning.enforcement_level'] = 0;
        firefoxOptions.prefs['security.ssl.enable_ocsp_stapling'] = false;
        
        // Update Firefox options
        capabilities.set('moz:firefoxOptions', firefoxOptions);
        break;
        
      case BrowserType.EDGE:
        // Get existing Edge options
        const edgeOptions = capabilities.get('ms:edgeOptions') || {};
        
        // Add ignore-certificate-errors argument
        edgeOptions.args = edgeOptions.args || [];
        if (!edgeOptions.args.includes('--ignore-certificate-errors')) {
          edgeOptions.args.push('--ignore-certificate-errors');
        }
        
        // Update Edge options
        capabilities.set('ms:edgeOptions', edgeOptions);
        break;
        
      case BrowserType.SAFARI:
        // Safari doesn't have a direct capability for this
        this.logger.warn('Safari does not support ignoring certificate errors via capabilities');
        break;
        
      case BrowserType.IE:
        // Set IE capability for ignoring protected mode settings
        capabilities.set('ignoreProtectedModeSettings', true);
        capabilities.set('trustAllSSLCertificates', true);
        break;
    }
    
    return capabilities;
  }
}


CSElement.ts
-----------------------------

import {
  WebDriver,
  WebElement,
  By,
  until,
  Condition,
  Actions,
  Key,
  error as SeleniumError
} from 'selenium-webdriver';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSWaitStrategy } from './CSWaitStrategy';
import { CSVisibilityWait } from './CSVisibilityWait';
import { CSClickableWait } from './CSClickableWait';
import { CSPresenceWait } from './CSPresenceWait';
import { CSWaitFactory } from './CSWaitFactory';
import { CSScreenshotManager } from '../../core/utils/CSScreenshotManager';
import { ElementAttributes, ElementPosition, Coordinates, ActionOptions, ScrollOptions } from '../types/ElementTypes';

/**
 * CSElement is a wrapper for WebElement that provides enhanced functionality
 * and additional methods for interacting with elements.
 */
export class CSElement {
  private driver: WebDriver;
  private locator: By;
  private element: WebElement | null;
  private logger: CSLogger;
  private waitFactory: CSWaitFactory;
  private screenshotManager: CSScreenshotManager;
  private elementFingerprint: Map<string, string>;
  private parent: CSElement | null;
  private frameContext: boolean;
  private defaultTimeout: number = 30000;
  private pollingInterval: number = 500;
  private highlightDuration: number = 100;
  private highlightColor: string = 'red';
  private lastAction: string = '';
  private actionHistory: string[] = [];
  private static MAX_HISTORY_SIZE: number = 10;
  
  /**
   * Creates a new CSElement instance
   * @param driver The WebDriver instance
   * @param locatorOrElement The locator or WebElement to wrap
   * @param parent The parent CSElement (optional)
   * @param frameContext Whether this element is in a frame context (optional)
   */
  constructor(
    driver: WebDriver,
    locatorOrElement: By | WebElement,
    parent: CSElement | null = null,
    frameContext: boolean = false
  ) {
    this.driver = driver;
    this.element = locatorOrElement instanceof WebElement ? locatorOrElement : null;
    this.locator = locatorOrElement instanceof By ? locatorOrElement : By.xpath('.');
    this.logger = new CSLogger('CSElement');
    this.waitFactory = new CSWaitFactory();
    this.screenshotManager = new CSScreenshotManager();
    this.elementFingerprint = new Map<string, string>();
    this.parent = parent;
    this.frameContext = frameContext;
  }
  
  /**
   * Gets the WebElement instance
   * @param timeout The timeout in milliseconds (optional)
   * @returns The WebElement instance
   */
  public async getWebElement(timeout: number = this.defaultTimeout): Promise<WebElement> {
    // If we already have the element, return it
    if (this.element) {
      return this.element;
    }
    
    // If we have a parent element, find the element within the parent
    if (this.parent) {
      const parentElement = await this.parent.getWebElement(timeout);
      
      try {
        this.element = await parentElement.findElement(this.locator);
        return this.element;
      } catch (error) {
        this.logger.error(`Error finding element ${this.locator} within parent: ${error}`);
        throw error;
      }
    }
    
    // Otherwise, find the element within the document
    try {
      // Use explicit wait to find the element
      const wait = this.waitFactory.createPresenceWait(this.locator, timeout);
      this.element = await this.driver.wait(wait, timeout);
      
      // Store the element fingerprint for potential self-healing
      await this.storeElementFingerprint();
      
      return this.element;
    } catch (error) {
      this.logger.error(`Error finding element ${this.locator}: ${error}`);
      
      // Take a screenshot on failure for debugging
      try {
        const screenshotPath = await this.screenshotManager.takeScreenshot(this.driver, 'element_not_found');
        this.logger.debug(`Screenshot saved to ${screenshotPath}`);
      } catch (screenshotError) {
        this.logger.warn(`Failed to take screenshot: ${screenshotError}`);
      }
      
      throw error;
    }
  }
  
  /**
   * Stores the element fingerprint for potential self-healing
   */
  private async storeElementFingerprint(): Promise<void> {
    if (!this.element) {
      return;
    }
    
    try {
      // Get basic element attributes
      const tagName = await this.element.getTagName();
      const id = await this.element.getAttribute('id');
      const className = await this.element.getAttribute('class');
      const name = await this.element.getAttribute('name');
      const type = await this.element.getAttribute('type');
      const value = await this.element.getAttribute('value');
      const href = await this.element.getAttribute('href');
      const src = await this.element.getAttribute('src');
      const text = await this.element.getText();
      const isDisplayed = await this.element.isDisplayed();
      const isEnabled = await this.element.isEnabled();
      
      // Store basic fingerprint data
      this.elementFingerprint.set('tagName', tagName);
      if (id) this.elementFingerprint.set('id', id);
      if (className) this.elementFingerprint.set('className', className);
      if (name) this.elementFingerprint.set('name', name);
      if (type) this.elementFingerprint.set('type', type);
      if (value) this.elementFingerprint.set('value', value);
      if (href) this.elementFingerprint.set('href', href);
      if (src) this.elementFingerprint.set('src', src);
      if (text) this.elementFingerprint.set('text', text);
      this.elementFingerprint.set('isDisplayed', isDisplayed.toString());
      this.elementFingerprint.set('isEnabled', isEnabled.toString());
      
      // Get element position
      const rect = await this.element.getRect();
      this.elementFingerprint.set('x', rect.x.toString());
      this.elementFingerprint.set('y', rect.y.toString());
      this.elementFingerprint.set('width', rect.width.toString());
      this.elementFingerprint.set('height', rect.height.toString());
      
      // Get CSS computed styles
      const computedStyles = await this.driver.executeScript(`
        const styles = window.getComputedStyle(arguments[0]);
        const result = {};
        for (const prop of ['color', 'backgroundColor', 'fontSize', 'fontWeight', 'display', 'position']) {
          result[prop] = styles.getPropertyValue(prop);
        }
        return result;
      `, this.element);
      
      for (const [key, value] of Object.entries(computedStyles)) {
        this.elementFingerprint.set(`css_${key}`, value as string);
      }
      
      // Get DOM structure info
      const domInfo = await this.driver.executeScript(`
        function getPathTo(element) {
          if (element.id) return '//*[@id="' + element.id + '"]';
          
          let path = '';
          while (element && element.nodeType === Node.ELEMENT_NODE) {
            let siblings = Array.from(element.parentNode.childNodes).filter(node => 
              node.nodeType === Node.ELEMENT_NODE && node.tagName === element.tagName
            );
            
            if (siblings.length > 1) {
              let index = siblings.indexOf(element) + 1;
              path = '/' + element.tagName.toLowerCase() + '[' + index + ']' + path;
            } else {
              path = '/' + element.tagName.toLowerCase() + path;
            }
            
            element = element.parentNode;
          }
          
          return path.toLowerCase();
        }
        
        const element = arguments[0];
        const parent = element.parentElement;
        const siblings = parent ? Array.from(parent.children) : [];
        
        return {
          xpath: getPathTo(element),
          siblingCount: siblings.length,
          siblingIndex: siblings.indexOf(element),
          parentTagName: parent ? parent.tagName.toLowerCase() : '',
          ancestorPath: parent ? getPathTo(parent) : ''
        };
      `, this.element);
      
      for (const [key, value] of Object.entries(domInfo)) {
        this.elementFingerprint.set(`dom_${key}`, value as string);
      }
    } catch (error) {
      this.logger.warn(`Error storing element fingerprint: ${error}`);
      // Continue without failing - fingerprinting is a best-effort feature
    }
  }
  
  /**
   * Gets the element fingerprint
   * @returns The element fingerprint
   */
  public getElementFingerprint(): Map<string, string> {
    return new Map(this.elementFingerprint);
  }
  
  /**
   * Sets the default timeout for all operations
   * @param timeout The timeout in milliseconds
   * @returns This CSElement instance for chaining
   */
  public withTimeout(timeout: number): CSElement {
    this.defaultTimeout = timeout;
    return this;
  }
  
  /**
   * Sets the polling interval for waits
   * @param interval The polling interval in milliseconds
   * @returns This CSElement instance for chaining
   */
  public withPollingInterval(interval: number): CSElement {
    this.pollingInterval = interval;
    return this;
  }
  
  /**
   * Sets the highlight settings for element interactions
   * @param color The highlight color
   * @param duration The highlight duration in milliseconds
   * @returns This CSElement instance for chaining
   */
  public withHighlight(color: string, duration: number): CSElement {
    this.highlightColor = color;
    this.highlightDuration = duration;
    return this;
  }
  
  /**
   * Waits for the element to be visible
   * @param timeout The timeout in milliseconds (optional)
   * @returns This CSElement instance for chaining
   */
  public async waitForVisible(timeout: number = this.defaultTimeout): Promise<CSElement> {
    try {
      const element = await this.getWebElement(timeout);
      const wait = this.waitFactory.createVisibilityWait(element, timeout);
      await this.driver.wait(wait, timeout, `Element ${this.locator} not visible after ${timeout}ms`);
      
      this.logAction('waitForVisible');
      return this;
    } catch (error) {
      this.logger.error(`Error waiting for element ${this.locator} to be visible: ${error}`);
      throw error;
    }
  }
  
  /**
   * Waits for the element to be clickable
   * @param timeout The timeout in milliseconds (optional)
   * @returns This CSElement instance for chaining
   */
  public async waitForClickable(timeout: number = this.defaultTimeout): Promise<CSElement> {
    try {
      const element = await this.getWebElement(timeout);
      const wait = this.waitFactory.createClickableWait(element, timeout);
      await this.driver.wait(wait, timeout, `Element ${this.locator} not clickable after ${timeout}ms`);
      
      this.logAction('waitForClickable');
      return this;
    } catch (error) {
      this.logger.error(`Error waiting for element ${this.locator} to be clickable: ${error}`);
      throw error;
    }
  }
  
  /**
   * Waits for the element to have specific text
   * @param text The text to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns This CSElement instance for chaining
   */
  public async waitForText(text: string, timeout: number = this.defaultTimeout): Promise<CSElement> {
    try {
      const element = await this.getWebElement(timeout);
      const wait = this.waitFactory.createTextWait(element, text, timeout);
      await this.driver.wait(wait, timeout, `Element ${this.locator} text did not become "${text}" after ${timeout}ms`);
      
      this.logAction(`waitForText(${text})`);
      return this;
    } catch (error) {
      this.logger.error(`Error waiting for element ${this.locator} to have text "${text}": ${error}`);
      throw error;
    }
  }
  
  /**
   * Waits for the element to have a specific attribute value
   * @param attribute The attribute name
   * @param value The attribute value to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns This CSElement instance for chaining
   */
  public async waitForAttribute(attribute: string, value: string, timeout: number = this.defaultTimeout): Promise<CSElement> {
    try {
      const element = await this.getWebElement(timeout);
      const wait = this.waitFactory.createAttributeWait(element, attribute, value, timeout);
      await this.driver.wait(wait, timeout, `Element ${this.locator} attribute "${attribute}" did not become "${value}" after ${timeout}ms`);
      
      this.logAction(`waitForAttribute(${attribute}, ${value})`);
      return this;
    } catch (error) {
      this.logger.error(`Error waiting for element ${this.locator} to have attribute "${attribute}" with value "${value}": ${error}`);
      throw error;
    }
  }
  
  /**
   * Waits for a custom condition to be met
   * @param condition The condition to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @param message The error message (optional)
   * @returns This CSElement instance for chaining
   */
  public async waitFor(condition: Function | Condition<boolean>, timeout: number = this.defaultTimeout, message?: string): Promise<CSElement> {
    try {
      const element = await this.getWebElement(timeout);
      
      // If condition is a function, create a Condition from it
      if (typeof condition === 'function') {
        const conditionFn = condition;
        condition = new Condition<boolean>(message || 'Custom condition', async () => {
          return await conditionFn(element);
        });
      }
      
      await this.driver.wait(condition as Condition<boolean>, timeout, message);
      
      this.logAction('waitForCustomCondition');
      return this;
    } catch (error) {
      this.logger.error(`Error waiting for custom condition on element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Clicks the element
   * @param options Click options (optional)
   * @returns This CSElement instance for chaining
   */
  public async click(options?: {
    waitForVisible?: boolean;
    waitForClickable?: boolean;
    timeout?: number;
    highlight?: boolean;
    js?: boolean;
    doubleClick?: boolean;
    rightClick?: boolean;
    forceClick?: boolean;
  }): Promise<CSElement> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      waitForClickable: options?.waitForClickable !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false,
      js: options?.js || false,
      doubleClick: options?.doubleClick || false,
      rightClick: options?.rightClick || false,
      forceClick: options?.forceClick || false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Wait for the element to be clickable if requested
      if (opts.waitForClickable) {
        await this.waitForClickable(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Perform the appropriate click action
      if (opts.js) {
        // Click using JavaScript
        await this.driver.executeScript('arguments[0].click();', element);
        this.logAction('click(js)');
      } else if (opts.doubleClick) {
        // Double click
        const actions = new Actions(this.driver);
        await actions.doubleClick(element).perform();
        this.logAction('doubleClick');
      } else if (opts.rightClick) {
        // Right click
        const actions = new Actions(this.driver);
        await actions.contextClick(element).perform();
        this.logAction('rightClick');
      } else if (opts.forceClick) {
        // Force click using ActionSequence
        const actions = new Actions(this.driver);
        // Move to the element, pause briefly, then click
        await actions.move({ origin: element }).pause(50).click().perform();
        this.logAction('forceClick');
      } else {
        // Regular click
        await element.click();
        this.logAction('click');
      }
      
      return this;
    } catch (error) {
      this.logger.error(`Error clicking element ${this.locator}: ${error}`);
      
      // If the element is not clickable, try JavaScript click as a fallback
      if (!opts.js && error instanceof SeleniumError.ElementClickInterceptedError) {
        this.logger.debug('Click was intercepted, trying JavaScript click as fallback');
        return this.click({ ...options, js: true });
      }
      
      // Take a screenshot on failure for debugging
      try {
        const screenshotPath = await this.screenshotManager.takeScreenshot(this.driver, 'click_failed');
        this.logger.debug(`Screenshot saved to ${screenshotPath}`);
      } catch (screenshotError) {
        this.logger.warn(`Failed to take screenshot: ${screenshotError}`);
      }
      
      throw error;
    }
  }
  
  /**
   * Types text into the element
   * @param text The text to type
   * @param options Type options (optional)
   * @returns This CSElement instance for chaining
   */
  public async type(text: string, options?: {
    waitForVisible?: boolean;
    clear?: boolean;
    append?: boolean;
    timeout?: number;
    highlight?: boolean;
    js?: boolean;
    sendKeys?: boolean;
    pressEnter?: boolean;
    pressTab?: boolean;
    delay?: number;
  }): Promise<CSElement> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      clear: options?.clear !== false && !options?.append,
      append: options?.append || false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false,
      js: options?.js || false,
      sendKeys: options?.sendKeys || false,
      pressEnter: options?.pressEnter || false,
      pressTab: options?.pressTab || false,
      delay: options?.delay || 0
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Clear the element if requested
      if (opts.clear) {
        if (opts.js) {
          await this.driver.executeScript('arguments[0].value = "";', element);
        } else {
          await element.clear();
        }
      }
      
      // Type text into the element
      if (opts.js) {
        // Type using JavaScript
        if (opts.append) {
          await this.driver.executeScript('arguments[0].value = arguments[0].value + arguments[1];', element, text);
        } else {
          await this.driver.executeScript('arguments[0].value = arguments[1];', element, text);
        }
      } else if (opts.sendKeys) {
        // Type using sendKeys with delay if specified
        if (opts.delay > 0) {
          // Type each character separately with a delay
          for (let i = 0; i < text.length; i++) {
            await element.sendKeys(text.charAt(i));
            await this.driver.sleep(opts.delay);
          }
        } else {
          // Type the entire text at once
          await element.sendKeys(text);
        }
      } else {
        // Type using default method
        await element.sendKeys(text);
      }
      
      // Press Enter if requested
      if (opts.pressEnter) {
        await element.sendKeys(Key.ENTER);
      }
      
      // Press Tab if requested
      if (opts.pressTab) {
        await element.sendKeys(Key.TAB);
      }
      
      this.logAction(`type(${text.length > 10 ? text.substring(0, 10) + '...' : text})`);
      return this;
    } catch (error) {
      this.logger.error(`Error typing text into element ${this.locator}: ${error}`);
      
      // If the element is not interactable, try JavaScript as a fallback
      if (!opts.js && error instanceof SeleniumError.ElementNotInteractableError) {
        this.logger.debug('Element not interactable, trying JavaScript as fallback');
        return this.type(text, { ...options, js: true });
      }
      
      // Take a screenshot on failure for debugging
      try {
        const screenshotPath = await this.screenshotManager.takeScreenshot(this.driver, 'type_failed');
        this.logger.debug(`Screenshot saved to ${screenshotPath}`);
      } catch (screenshotError) {
        this.logger.warn(`Failed to take screenshot: ${screenshotError}`);
      }
      
      throw error;
    }
  }
  
  /**
   * Clears the element
   * @param options Clear options (optional)
   * @returns This CSElement instance for chaining
   */
  public async clear(options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
    js?: boolean;
  }): Promise<CSElement> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false,
      js: options?.js || false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Clear the element
      if (opts.js) {
        // Clear using JavaScript
        await this.driver.executeScript('arguments[0].value = "";', element);
      } else {
        // Clear using WebDriver
        await element.clear();
      }
      
      this.logAction('clear');
      return this;
    } catch (error) {
      this.logger.error(`Error clearing element ${this.locator}: ${error}`);
      
      // If the element is not interactable, try JavaScript as a fallback
      if (!opts.js && error instanceof SeleniumError.ElementNotInteractableError) {
        this.logger.debug('Element not interactable, trying JavaScript as fallback');
        return this.clear({ ...options, js: true });
      }
      
      throw error;
    }
  }
  
  /**
   * Gets the text of the element
   * @param options Text retrieval options (optional)
   * @returns The element text
   */
  public async getText(options?: {
    waitForVisible?: boolean;
    trim?: boolean;
    timeout?: number;
    highlight?: boolean;
    js?: boolean;
    getInnerText?: boolean;
    getTextContent?: boolean;
  }): Promise<string> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      trim: options?.trim !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false,
      js: options?.js || false,
      getInnerText: options?.getInnerText || false,
      getTextContent: options?.getTextContent || false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      let text: string;
      
      if (opts.js) {
        // Get text using JavaScript
        if (opts.getInnerText) {
          text = await this.driver.executeScript('return arguments[0].innerText;', element) as string;
        } else if (opts.getTextContent) {
          text = await this.driver.executeScript('return arguments[0].textContent;', element) as string;
        } else {
          text = await this.driver.executeScript('return arguments[0].innerText || arguments[0].textContent || arguments[0].value || "";', element) as string;
        }
      } else {
        // Get text using WebDriver
        text = await element.getText();
      }
      
      // Trim the text if requested
      if (opts.trim && text) {
        text = text.trim();
      }
      
      this.logAction('getText');
      return text;
    } catch (error) {
      this.logger.error(`Error getting text from element ${this.locator}: ${error}`);
      
      // If the element is not visible or has no text, try JavaScript as a fallback
      if (!opts.js && (error instanceof SeleniumError.ElementNotVisibleError || error instanceof SeleniumError.StaleElementReferenceError)) {
        this.logger.debug('Element not visible or stale, trying JavaScript as fallback');
        return this.getText({ ...options, js: true });
      }
      
      throw error;
    }
  }
  
  /**
   * Gets the value of the element
   * @param options Value retrieval options (optional)
   * @returns The element value
   */
  public async getValue(options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
  }): Promise<string> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Get the value
      const value = await element.getAttribute('value') || '';
      
      this.logAction('getValue');
      return value;
    } catch (error) {
      this.logger.error(`Error getting value from element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Gets an attribute of the element
   * @param attributeName The attribute name
   * @param options Attribute retrieval options (optional)
   * @returns The attribute value
   */
  public async getAttribute(attributeName: string, options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
  }): Promise<string | null> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Get the attribute
      const attributeValue = await element.getAttribute(attributeName);
      
      this.logAction(`getAttribute(${attributeName})`);
      return attributeValue;
    } catch (error) {
      this.logger.error(`Error getting attribute "${attributeName}" from element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Gets a CSS property of the element
   * @param propertyName The CSS property name
   * @param options CSS property retrieval options (optional)
   * @returns The CSS property value
   */
  public async getCssValue(propertyName: string, options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
    computed?: boolean;
  }): Promise<string> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false,
      computed: options?.computed || false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      let cssValue: string;
      
      if (opts.computed) {
        // Get computed style using JavaScript
        cssValue = await this.driver.executeScript(
          'return window.getComputedStyle(arguments[0]).getPropertyValue(arguments[1]);',
          element,
          propertyName
        ) as string;
      } else {
        // Get CSS value using WebDriver
        cssValue = await element.getCssValue(propertyName);
      }
      
      this.logAction(`getCssValue(${propertyName})`);
      return cssValue;
    } catch (error) {
      this.logger.error(`Error getting CSS property "${propertyName}" from element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Gets the position and size of the element
   * @param options Rect retrieval options (optional)
   * @returns The element position and size
   */
  public async getRect(options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
  }): Promise<ElementPosition> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Get the element rect
      const rect = await element.getRect();
      
      this.logAction('getRect');
      return {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        top: rect.y,
        left: rect.x,
        bottom: rect.y + rect.height,
        right: rect.x + rect.width,
        centerX: rect.x + rect.width / 2,
        centerY: rect.y + rect.height / 2
      };
    } catch (error) {
      this.logger.error(`Error getting rect from element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Checks if the element is displayed
   * @param options Display check options (optional)
   * @returns Whether the element is displayed
   */
  public async isDisplayed(options?: {
    timeout?: number;
    highlight?: boolean;
    checkVisibility?: boolean;
  }): Promise<boolean> {
    const opts = {
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight || false,
      checkVisibility: options?.checkVisibility || false
    };
    
    try {
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Check if the element is displayed
      let isDisplayed = await element.isDisplayed();
      
      // Also check visibility using CSS if requested
      if (opts.checkVisibility && isDisplayed) {
        // Get computed style
        const visibility = await this.getCssValue('visibility', { waitForVisible: false, computed: true });
        const display = await this.getCssValue('display', { waitForVisible: false, computed: true });
        const opacity = await this.getCssValue('opacity', { waitForVisible: false, computed: true });
        
        // Check if the element is actually visible
        isDisplayed = visibility !== 'hidden' && display !== 'none' && parseFloat(opacity) > 0;
      }
      
      this.logAction('isDisplayed');
      return isDisplayed;
    } catch (error) {
      // If the element is not found, it's not displayed
      if (error instanceof SeleniumError.NoSuchElementError || error instanceof SeleniumError.StaleElementReferenceError) {
        return false;
      }
      
      this.logger.error(`Error checking if element ${this.locator} is displayed: ${error}`);
      throw error;
    }
  }
  
  /**
   * Checks if the element is enabled
   * @param options Enabled check options (optional)
   * @returns Whether the element is enabled
   */
  public async isEnabled(options?: {
    timeout?: number;
    highlight?: boolean;
  }): Promise<boolean> {
    const opts = {
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight || false
    };
    
    try {
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Check if the element is enabled
      const isEnabled = await element.isEnabled();
      
      this.logAction('isEnabled');
      return isEnabled;
    } catch (error) {
      this.logger.error(`Error checking if element ${this.locator} is enabled: ${error}`);
      throw error;
    }
  }
  
  /**
   * Checks if the element is selected
   * @param options Selected check options (optional)
   * @returns Whether the element is selected
   */
  public async isSelected(options?: {
    timeout?: number;
    highlight?: boolean;
  }): Promise<boolean> {
    const opts = {
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight || false
    };
    
    try {
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Check if the element is selected
      const isSelected = await element.isSelected();
      
      this.logAction('isSelected');
      return isSelected;
    } catch (error) {
      this.logger.error(`Error checking if element ${this.locator} is selected: ${error}`);
      throw error;
    }
  }
  
  /**
   * Scrolls to the element
   * @param options Scroll options (optional)
   * @returns This CSElement instance for chaining
   */
  public async scrollIntoView(options?: ScrollOptions): Promise<CSElement> {
    const opts: ScrollOptions = {
      block: options?.block || 'center',
      inline: options?.inline || 'nearest',
      behavior: options?.behavior || 'auto',
      offset: options?.offset || 0,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false
    };
    
    try {
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Scroll to the element using JavaScript
      await this.driver.executeScript(
        `arguments[0].scrollIntoView({block: '${opts.block}', inline: '${opts.inline}', behavior: '${opts.behavior}'});
         window.scrollBy(0, ${opts.offset});`,
        element
      );
      
      // Wait a moment for the scroll to complete
      await this.driver.sleep(100);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      this.logAction('scrollIntoView');
      return this;
    } catch (error) {
      this.logger.error(`Error scrolling element ${this.locator} into view: ${error}`);
      throw error;
    }
  }
  
  /**
   * Hovers over the element
   * @param options Hover options (optional)
   * @returns This CSElement instance for chaining
   */
  public async hover(options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
    moveByOffset?: Coordinates;
  }): Promise<CSElement> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false,
      moveByOffset: options?.moveByOffset || { x: 0, y: 0 }
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Hover over the element using Actions
      const actions = new Actions(this.driver);
      
      if (opts.moveByOffset.x !== 0 || opts.moveByOffset.y !== 0) {
        // Move to the element with offset
        await actions
          .move({ origin: element, x: opts.moveByOffset.x, y: opts.moveByOffset.y })
          .perform();
      } else {
        // Move to the center of the element
        await actions.move({ origin: element }).perform();
      }
      
      this.logAction('hover');
      return this;
    } catch (error) {
      this.logger.error(`Error hovering over element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Drags the element to a target element or offset
   * @param target The target element or offset coordinates
   * @param options Drag and drop options (optional)
   * @returns This CSElement instance for chaining
   */
  public async dragAndDrop(
    target: CSElement | WebElement | Coordinates,
    options?: {
      waitForVisible?: boolean;
      timeout?: number;
      highlight?: boolean;
      js?: boolean;
    }
  ): Promise<CSElement> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false,
      js: options?.js || false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Determine target type and perform drag and drop
      if (target instanceof CSElement) {
        // Get target WebElement
        const targetElement = await target.getWebElement(opts.timeout);
        
        // Highlight target element if requested
        if (opts.highlight) {
          await target.highlight();
        }
        
        if (opts.js) {
          // Drag and drop using JavaScript
          await this.driver.executeScript(`
            function simulateDragDrop(sourceNode, destinationNode) {
              var EVENT_TYPES = {
                DRAG_START: 'dragstart',
                DRAG_END: 'dragend',
                DRAG: 'drag',
                DRAG_ENTER: 'dragenter',
                DRAG_OVER: 'dragover',
                DRAG_LEAVE: 'dragleave',
                DROP: 'drop'
              };
              
              function createCustomEvent(type) {
                var event = new CustomEvent(type, {
                  bubbles: true,
                  cancelable: true,
                  view: window
                });
                event.dataTransfer = {
                  data: {},
                  setData: function(type, val) {
                    this.data[type] = val;
                  },
                  getData: function(type) {
                    return this.data[type];
                  },
                  setDragImage: function() {}
                };
                return event;
              }
              
              function dispatchEvent(node, type, event) {
                if (node.dispatchEvent) {
                  return node.dispatchEvent(event);
                }
                if (node.fireEvent) {
                  return node.fireEvent("on" + type, event);
                }
              }
              
              var dragStartEvent = createCustomEvent(EVENT_TYPES.DRAG_START);
              dispatchEvent(sourceNode, EVENT_TYPES.DRAG_START, dragStartEvent);
              
              var dragEvent = createCustomEvent(EVENT_TYPES.DRAG);
              dispatchEvent(sourceNode, EVENT_TYPES.DRAG, dragEvent);
              
              var dragEnterEvent = createCustomEvent(EVENT_TYPES.DRAG_ENTER);
              dispatchEvent(destinationNode, EVENT_TYPES.DRAG_ENTER, dragEnterEvent);
              
              var dragOverEvent = createCustomEvent(EVENT_TYPES.DRAG_OVER);
              dispatchEvent(destinationNode, EVENT_TYPES.DRAG_OVER, dragOverEvent);
              
              var dropEvent = createCustomEvent(EVENT_TYPES.DROP);
              dispatchEvent(destinationNode, EVENT_TYPES.DROP, dropEvent);
              
              var dragEndEvent = createCustomEvent(EVENT_TYPES.DRAG_END);
              dispatchEvent(sourceNode, EVENT_TYPES.DRAG_END, dragEndEvent);
            }
            
            simulateDragDrop(arguments[0], arguments[1]);
          `, element, targetElement);
        } else {
          // Drag and drop using Actions
          const actions = new Actions(this.driver);
          await actions.dragAndDrop(element, targetElement).perform();
        }
        
        this.logAction('dragAndDrop(element)');
      } else if (target instanceof WebElement) {
        // Drag and drop to WebElement
        if (opts.js) {
          // Drag and drop using JavaScript
          await this.driver.executeScript(`
            // Same JavaScript function as above
            function simulateDragDrop(sourceNode, destinationNode) {
              var EVENT_TYPES = {
                DRAG_START: 'dragstart',
                DRAG_END: 'dragend',
                DRAG: 'drag',
                DRAG_ENTER: 'dragenter',
                DRAG_OVER: 'dragover',
                DRAG_LEAVE: 'dragleave',
                DROP: 'drop'
              };
              
              function createCustomEvent(type) {
                var event = new CustomEvent(type, {
                  bubbles: true,
                  cancelable: true,
                  view: window
                });
                event.dataTransfer = {
                  data: {},
                  setData: function(type, val) {
                    this.data[type] = val;
                  },
                  getData: function(type) {
                    return this.data[type];
                  },
                  setDragImage: function() {}
                };
                return event;
              }
              
              function dispatchEvent(node, type, event) {
                if (node.dispatchEvent) {
                  return node.dispatchEvent(event);
                }
                if (node.fireEvent) {
                  return node.fireEvent("on" + type, event);
                }
              }
              
              var dragStartEvent = createCustomEvent(EVENT_TYPES.DRAG_START);
              dispatchEvent(sourceNode, EVENT_TYPES.DRAG_START, dragStartEvent);
              
              var dragEvent = createCustomEvent(EVENT_TYPES.DRAG);
              dispatchEvent(sourceNode, EVENT_TYPES.DRAG, dragEvent);
              
              var dragEnterEvent = createCustomEvent(EVENT_TYPES.DRAG_ENTER);
              dispatchEvent(destinationNode, EVENT_TYPES.DRAG_ENTER, dragEnterEvent);
              
              var dragOverEvent = createCustomEvent(EVENT_TYPES.DRAG_OVER);
              dispatchEvent(destinationNode, EVENT_TYPES.DRAG_OVER, dragOverEvent);
              
              var dropEvent = createCustomEvent(EVENT_TYPES.DROP);
              dispatchEvent(destinationNode, EVENT_TYPES.DROP, dropEvent);
              
              var dragEndEvent = createCustomEvent(EVENT_TYPES.DRAG_END);
              dispatchEvent(sourceNode, EVENT_TYPES.DRAG_END, dragEndEvent);
            }
            
            simulateDragDrop(arguments[0], arguments[1]);
          `, element, target);
        } else {
          // Drag and drop using Actions
          const actions = new Actions(this.driver);
          await actions.dragAndDrop(element, target).perform();
        }
        
        this.logAction('dragAndDrop(webElement)');
      } else {
        // Drag and drop to coordinates
        const actions = new Actions(this.driver);
        await actions
          .clickAndHold(element)
          .moveByOffset(target.x, target.y)
          .release()
          .perform();
        
        this.logAction(`dragAndDrop(${target.x},${target.y})`);
      }
      
      return this;
    } catch (error) {
      this.logger.error(`Error performing drag and drop from element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Submits a form element
   * @param options Submit options (optional)
   * @returns This CSElement instance for chaining
   */
  public async submit(options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
    js?: boolean;
  }): Promise<CSElement> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false,
      js: options?.js || false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Submit the form
      if (opts.js) {
        // Submit using JavaScript
        await this.driver.executeScript('arguments[0].closest("form").submit();', element);
      } else {
        // Submit using WebDriver
        await element.submit();
      }
      
      this.logAction('submit');
      return this;
    } catch (error) {
      this.logger.error(`Error submitting form from element ${this.locator}: ${error}`);
      
      // If the element is not a form or is not in a form, try JavaScript as a fallback
      if (!opts.js && error instanceof SeleniumError.InvalidElementStateError) {
        this.logger.debug('Element is not in a form, trying JavaScript as fallback');
        return this.submit({ ...options, js: true });
      }
      
      throw error;
    }
  }
  
  /**
   * Sends keyboard keys to the element
   * @param keys The keys to send
   * @param options SendKeys options (optional)
   * @returns This CSElement instance for chaining
   */
  public async sendKeys(
    keys: string | number | Promise<string | number> | Array<string | number | Promise<string | number>>,
    options?: {
      waitForVisible?: boolean;
      clear?: boolean;
      timeout?: number;
      highlight?: boolean;
    }
  ): Promise<CSElement> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      clear: options?.clear || false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Clear the element if requested
      if (opts.clear) {
        await element.clear();
      }
      
      // Send keys to the element
      await element.sendKeys(keys);
      
      this.logAction('sendKeys');
      return this;
    } catch (error) {
      this.logger.error(`Error sending keys to element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Takes a screenshot of the element
   * @param options Screenshot options (optional)
   * @returns The screenshot as a base64 encoded string
   */
  public async takeScreenshot(options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
    fileName?: string;
    saveToFile?: boolean;
  }): Promise<string> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight || false,
      fileName: options?.fileName || `element-${Date.now()}.png`,
      saveToFile: options?.saveToFile || false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Take a screenshot of the element
      const screenshot = await element.takeScreenshot();
      
      // Save the screenshot to a file if requested
      if (opts.saveToFile) {
        await this.screenshotManager.saveScreenshot(screenshot, opts.fileName);
      }
      
      this.logAction('takeScreenshot');
      return screenshot;
    } catch (error) {
      this.logger.error(`Error taking screenshot of element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Executes JavaScript on the element
   * @param script The JavaScript to execute
   * @param args Additional arguments to pass to the script
   * @returns The result of the script execution
   */
  public async executeScript<T>(script: string | Function, ...args: any[]): Promise<T> {
    try {
      // Get the WebElement instance
      const element = await this.getWebElement();
      
      // Convert function to string if needed
      if (typeof script === 'function') {
        script = `return (${script.toString()}).apply(null, [arguments[0], ...Array.prototype.slice.call(arguments, 1)]);`;
      }
      
      // Execute the script with the element as the first argument
      return await this.driver.executeScript<T>(script as string, element, ...args);
    } catch (error) {
      this.logger.error(`Error executing script on element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Executes asynchronous JavaScript on the element
   * @param script The JavaScript to execute
   * @param args Additional arguments to pass to the script
   * @returns The result of the script execution
   */
  public async executeAsyncScript<T>(script: string | Function, ...args: any[]): Promise<T> {
    try {
      // Get the WebElement instance
      const element = await this.getWebElement();
      
      // Convert function to string if needed
      if (typeof script === 'function') {
        script = `var callback = arguments[arguments.length - 1];
          (${script.toString()}).apply(null, [arguments[0], ...Array.prototype.slice.call(arguments, 1, -1)])
            .then(callback)
            .catch(function(err) { callback({ error: err.toString() }); });`;
      }
      
      // Execute the script with the element as the first argument
      return await this.driver.executeAsyncScript<T>(script as string, element, ...args);
    } catch (error) {
      this.logger.error(`Error executing async script on element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Highlights the element
   * @param color The highlight color (optional)
   * @param duration The highlight duration in milliseconds (optional)
   * @returns This CSElement instance for chaining
   */
  public async highlight(color?: string, duration?: number): Promise<CSElement> {
    const highlightColor = color || this.highlightColor;
    const highlightDuration = duration || this.highlightDuration;
    
    try {
      // Get the WebElement instance
      const element = await this.getWebElement();
      
      // Store original style
      const originalStyle = await this.driver.executeScript(
        'return arguments[0].getAttribute("style");',
        element
      ) as string;
      
      // Apply highlight style
      await this.driver.executeScript(
        'arguments[0].setAttribute("style", arguments[1]);',
        element,
        `border: 2px solid ${highlightColor} !important; background-color: rgba(255, 255, 0, 0.1) !important;`
      );
      
      // Wait for the specified duration
      await this.driver.sleep(highlightDuration);
      
      // Restore original style
      await this.driver.executeScript(
        'arguments[0].setAttribute("style", arguments[1]);',
        element,
        originalStyle || ''
      );
      
      return this;
    } catch (error) {
      this.logger.warn(`Error highlighting element ${this.locator}: ${error}`);
      // Continue without failing - highlighting is a visual aid only
      return this;
    }
  }
  
  /**
   * Finds a child element using a locator
   * @param childLocator The locator for the child element
   * @returns A new CSElement instance for the child element
   */
  public findElement(childLocator: By): CSElement {
    return new CSElement(this.driver, childLocator, this, this.frameContext);
  }
  
  /**
   * Finds all child elements using a locator
   * @param childLocator The locator for the child elements
   * @returns An array of CSElement instances for the child elements
   */
  public async findElements(childLocator: By): Promise<CSElement[]> {
    try {
      // Get the WebElement instance
      const element = await this.getWebElement();
      
      // Find all child elements
      const childElements = await element.findElements(childLocator);
      
      // Convert WebElements to CSElements
      return childElements.map(childElement => 
        new CSElement(this.driver, childElement, this, this.frameContext)
      );
    } catch (error) {
      this.logger.error(`Error finding child elements using locator ${childLocator}: ${error}`);
      return [];
    }
  }
  
  /**
   * Switches to the element if it's a frame
   * @returns This CSElement instance for chaining
   */
  public async switchToFrame(): Promise<CSElement> {
    try {
      // Get the WebElement instance
      const element = await this.getWebElement();
      
      // Switch to the frame
      await this.driver.switchTo().frame(element);
      
      this.logAction('switchToFrame');
      return new CSElement(this.driver, By.xpath('//html'), null, true);
    } catch (error) {
      this.logger.error(`Error switching to frame ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Switches back to the parent frame
   * @returns A new CSElement instance for the parent frame
   */
  public async switchToParentFrame(): Promise<CSElement> {
    try {
      // Switch to the parent frame
      await this.driver.switchTo().parentFrame();
      
      this.logAction('switchToParentFrame');
      return new CSElement(this.driver, By.xpath('//html'), null, true);
    } catch (error) {
      this.logger.error(`Error switching to parent frame: ${error}`);
      throw error;
    }
  }
  
  /**
   * Gets all attributes of the element
   * @param options Attributes retrieval options (optional)
   * @returns The element attributes as a key-value map
   */
  public async getAttributes(options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
  }): Promise<ElementAttributes> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Get all attributes using JavaScript
      const attributes = await this.driver.executeScript<ElementAttributes>(`
        const element = arguments[0];
        const attributes = {};
        
        // Get standard attributes
        for (let i = 0; i < element.attributes.length; i++) {
          const attr = element.attributes[i];
          attributes[attr.name] = attr.value;
        }
        
        // Get computed properties
        attributes['tagName'] = element.tagName.toLowerCase();
        attributes['text'] = element.textContent || '';
        attributes['innerText'] = element.innerText || '';
        attributes['innerHTML'] = element.innerHTML || '';
        
        // Get dimensions and position
        const rect = element.getBoundingClientRect();
        attributes['x'] = rect.x;
        attributes['y'] = rect.y;
        attributes['width'] = rect.width;
        attributes['height'] = rect.height;
        
        return attributes;
      `, element);
      
      this.logAction('getAttributes');
      return attributes;
    } catch (error) {
      this.logger.error(`Error getting attributes from element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Gets computed style properties of the element
   * @param options Style properties retrieval options (optional)
   * @returns The element computed style properties as a key-value map
   */
  public async getComputedStyles(options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
    properties?: string[];
  }): Promise<Record<string, string>> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false,
      properties: options?.properties || [
        'color', 'backgroundColor', 'fontSize', 'fontWeight',
        'textAlign', 'display', 'position', 'visibility',
        'height', 'width', 'padding', 'margin', 'border',
        'opacity', 'zIndex'
      ]
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Get specified computed styles using JavaScript
      const styles = await this.driver.executeScript<Record<string, string>>(`
        const element = arguments[0];
        const properties = arguments[1];
        const styles = window.getComputedStyle(element);
        const result = {};
        
        for (const prop of properties) {
          result[prop] = styles.getPropertyValue(prop);
        }
        
        return result;
      `, element, opts.properties);
      
      this.logAction('getComputedStyles');
      return styles;
    } catch (error) {
      this.logger.error(`Error getting computed styles from element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Performs a custom action on the element
   * @param action The action function to perform
   * @param options Action options (optional)
   * @returns The result of the action
   */
  public async performAction<T>(
    action: (element: WebElement, driver: WebDriver) => Promise<T>,
    options?: {
      waitForVisible?: boolean;
      timeout?: number;
      highlight?: boolean;
    }
  ): Promise<T> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Perform the custom action
      const result = await action(element, this.driver);
      
      this.logAction('performAction');
      return result;
    } catch (error) {
      this.logger.error(`Error performing custom action on element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Gets the accessibility properties of the element
   * @param options Accessibility properties retrieval options (optional)
   * @returns The element accessibility properties
   */
  public async getA11yProperties(options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
  }): Promise<Record<string, any>> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false
    };
    
    try {
      // Wait for the element to be visible if requested
      if (opts.waitForVisible) {
        await this.waitForVisible(opts.timeout);
      }
      
      // Get the WebElement instance
      const element = await this.getWebElement(opts.timeout);
      
      // Highlight the element if requested
      if (opts.highlight) {
        await this.highlight();
      }
      
      // Get accessibility properties using JavaScript
      const a11yProps = await this.driver.executeScript<Record<string, any>>(`
        const element = arguments[0];
        const result = {};
        
        // Get standard accessibility attributes
        const a11yAttrs = [
          'role', 'aria-label', 'aria-labelledby', 'aria-describedby',
          'aria-controls', 'aria-expanded', 'aria-haspopup', 'aria-hidden',
          'aria-checked', 'aria-selected', 'aria-disabled', 'aria-required',
          'aria-invalid', 'tabindex', 'title'
        ];
        
        for (const attr of a11yAttrs) {
          if (element.hasAttribute(attr)) {
            result[attr] = element.getAttribute(attr);
          }
        }
        
        // Compute some accessibility properties
        result.isKeyboardFocusable = (
          element.tabIndex >= 0 &&
          !element.disabled &&
          element.type !== 'hidden' &&
          window.getComputedStyle(element).display !== 'none' &&
          window.getComputedStyle(element).visibility !== 'hidden'
        );
        
        // Check if the element has a valid accessible name
        let accessibleName = '';
        
        if (element.hasAttribute('aria-labelledby')) {
          const ids = element.getAttribute('aria-labelledby').split(/\\s+/);
          for (const id of ids) {
            const labelElem = document.getElementById(id);
            if (labelElem) {
              accessibleName += (accessibleName ? ' ' : '') + labelElem.textContent.trim();
            }
          }
        }
        
        if (!accessibleName && element.hasAttribute('aria-label')) {
          accessibleName = element.getAttribute('aria-label').trim();
        }
        
        if (!accessibleName && element.hasAttribute('title')) {
          accessibleName = element.getAttribute('title').trim();
        }
        
        if (!accessibleName && element.nodeName === 'INPUT' && element.type !== 'button' && element.type !== 'submit') {
          const labels = document.querySelectorAll('label[for="' + element.id + '"]');
          if (labels.length > 0) {
            accessibleName = labels[0].textContent.trim();
          } else {
            const parent = element.closest('label');
            if (parent) {
              accessibleName = parent.textContent.trim();
            }
          }
        }
        
        result.accessibleName = accessibleName;
        result.hasValidAccessibleName = !!accessibleName;
        
        return result;
      `, element);
      
      this.logAction('getA11yProperties');
      return a11yProps;
    } catch (error) {
      this.logger.error(`Error getting accessibility properties from element ${this.locator}: ${error}`);
      throw error;
    }
  }
  
  /**
   * Gets the locator used to find this element
   * @returns The locator
   */
  public getLocator(): By {
    return this.locator;
  }
  
  /**
   * Gets the parent element
   * @returns The parent element, or null if there is no parent
   */
  public getParent(): CSElement | null {
    return this.parent;
  }
  
  /**
   * Gets the last action performed on this element
   * @returns The last action
   */
  public getLastAction(): string {
    return this.lastAction;
  }
  
  /**
   * Gets the action history for this element
   * @returns The action history
   */
  public getActionHistory(): string[] {
    return [...this.actionHistory];
  }
  
  /**
   * Gets the WebDriver instance
   * @returns The WebDriver instance
   */
  public getDriver(): WebDriver {
    return this.driver;
  }
  
  /**
   * Performs cleanup operations for this element
   */
  public async cleanup(): Promise<void> {
    this.element = null;
    this.elementFingerprint.clear();
    this.actionHistory = [];
    this.lastAction = '';
  }
  
  /**
   * Logs an action performed on this element
   * @param action The action to log
   */
  private logAction(action: string): void {
    this.lastAction = action;
    this.actionHistory.unshift(action);
    
    // Trim history to max size
    if (this.actionHistory.length > CSElement.MAX_HISTORY_SIZE) {
      this.actionHistory = this.actionHistory.slice(0, CSElement.MAX_HISTORY_SIZE);
    }
  }
  
  /**
   * Handles an error with the appropriate logging and screenshots
   * @param methodName The name of the method where the error occurred
   * @param error The error that occurred
   */
  private handleError(methodName: string, error: any): void {
    this.logger.error(`Error in ${methodName} for element ${this.locator}: ${error}`);
    
    // Take a screenshot for debugging
    try {
      this.screenshotManager.takeScreenshot(this.driver, `${methodName}_error`);
    } catch (screenshotError) {
      this.logger.warn(`Failed to take error screenshot: ${screenshotError}`);
    }
  }
}



ElementTypes.ts
------------------------------

/**
 * Represents the position and size of an element in the DOM
 */
export interface ElementPosition {
  /**
   * X coordinate of the element's top-left corner
   */
  x: number;
  
  /**
   * Y coordinate of the element's top-left corner
   */
  y: number;
  
  /**
   * Width of the element
   */
  width: number;
  
  /**
   * Height of the element
   */
  height: number;
  
  /**
   * Y coordinate of the element's top edge (same as y)
   */
  top: number;
  
  /**
   * X coordinate of the element's left edge (same as x)
   */
  left: number;
  
  /**
   * Y coordinate of the element's bottom edge
   */
  bottom: number;
  
  /**
   * X coordinate of the element's right edge
   */
  right: number;
  
  /**
   * X coordinate of the element's center
   */
  centerX: number;
  
  /**
   * Y coordinate of the element's center
   */
  centerY: number;
}

/**
 * Represents coordinates for mouse actions
 */
export interface Coordinates {
  /**
   * X coordinate
   */
  x: number;
  
  /**
   * Y coordinate
   */
  y: number;
}

/**
 * Represents a map of element attributes
 */
export interface ElementAttributes {
  /**
   * Element tag name
   */
  tagName: string;
  
  /**
   * Element inner text
   */
  innerText?: string;
  
  /**
   * Element text content
   */
  text?: string;
  
  /**
   * Element inner HTML
   */
  innerHTML?: string;
  
  /**
   * Element identifier
   */
  id?: string;
  
  /**
   * Element class name
   */
  class?: string;
  
  /**
   * Element name attribute
   */
  name?: string;
  
  /**
   * Element type attribute
   */
  type?: string;
  
  /**
   * Element value attribute
   */
  value?: string;
  
  /**
   * Element href attribute
   */
  href?: string;
  
  /**
   * Element source attribute
   */
  src?: string;
  
  /**
   * Element title attribute
   */
  title?: string;
  
  /**
   * Element alt attribute
   */
  alt?: string;
  
  /**
   * Element placeholder attribute
   */
  placeholder?: string;
  
  /**
   * Element disabled attribute
   */
  disabled?: boolean | string;
  
  /**
   * Element readonly attribute
   */
  readonly?: boolean | string;
  
  /**
   * Element selected attribute
   */
  selected?: boolean | string;
  
  /**
   * Element checked attribute
   */
  checked?: boolean | string;
  
  /**
   * Element required attribute
   */
  required?: boolean | string;
  
  /**
   * Element aria-label attribute
   */
  'aria-label'?: string;
  
  /**
   * Element role attribute
   */
  role?: string;
  
  /**
   * Element tabindex attribute
   */
  tabindex?: string;
  
  /**
   * Element width
   */
  width?: number;
  
  /**
   * Element height
   */
  height?: number;
  
  /**
   * Element x position
   */
  x?: number;
  
  /**
   * Element y position
   */
  y?: number;
  
  /**
   * Any other attributes
   */
  [key: string]: any;
}

/**
 * Represents options for mouse and keyboard actions
 */
export interface ActionOptions {
  /**
   * Whether to wait for the element to be visible before performing the action
   */
  waitForVisible?: boolean;
  
  /**
   * The timeout in milliseconds
   */
  timeout?: number;
  
  /**
   * Whether to highlight the element before performing the action
   */
  highlight?: boolean;
  
  /**
   * Whether to use JavaScript to perform the action
   */
  js?: boolean;
  
  /**
   * Whether to clear the element before typing
   */
  clear?: boolean;
  
  /**
   * Whether to append to the existing content when typing
   */
  append?: boolean;
  
  /**
   * Whether to press Enter after typing
   */
  pressEnter?: boolean;
  
  /**
   * Whether to press Tab after typing
   */
  pressTab?: boolean;
  
  /**
   * The delay between keystrokes in milliseconds
   */
  delay?: number;
  
  /**
   * Whether to force the action (bypass normal WebDriver checks)
   */
  forceAction?: boolean;
  
  /**
   * Whether to double-click
   */
  doubleClick?: boolean;
  
  /**
   * Whether to right-click
   */
  rightClick?: boolean;
  
  /**
   * The offset to move to relative to the element
   */
  moveByOffset?: Coordinates;
}

/**
 * Represents options for scrolling
 */
export interface ScrollOptions {
  /**
   * The vertical scroll alignment (start, center, end, or nearest)
   */
  block?: 'start' | 'center' | 'end' | 'nearest';
  
  /**
   * The horizontal scroll alignment (start, center, end, or nearest)
   */
  inline?: 'start' | 'center' | 'end' | 'nearest';
  
  /**
   * The scroll behavior (auto, smooth)
   */
  behavior?: 'auto' | 'smooth';
  
  /**
   * Additional vertical offset after scrolling (in pixels)
   */
  offset?: number;
  
  /**
   * The timeout in milliseconds
   */
  timeout?: number;
  
  /**
   * Whether to highlight the element after scrolling
   */
  highlight?: boolean;
}

/**
 * Represents shadow DOM traversal options
 */
export interface ShadowDOMOptions {
  /**
   * Whether to search within shadow DOMs
   */
  searchShadowRoots?: boolean;
  
  /**
   * The maximum depth to search within shadow DOMs
   */
  maxShadowDepth?: number;
  
  /**
   * The timeout in milliseconds
   */
  timeout?: number;
}

/**
 * Represents options for finding elements within iframes
 */
export interface IFrameSearchOptions {
  /**
   * Whether to search within iframes
   */
  searchIFrames?: boolean;
  
  /**
   * The maximum depth to search within iframes
   */
  maxIFrameDepth?: number;
  
  /**
   * The timeout in milliseconds
   */
  timeout?: number;
  
  /**
   * Whether to return to the original frame after searching
   */
  returnToOriginalFrame?: boolean;
}

/**
 * Represents a potential match for self-healing
 */
export interface PotentialMatch {
  /**
   * The matching element
   */
  element: any;
  
  /**
   * The similarity score (0.0 to 1.0)
   */
  score: number;
  
  /**
   * The matching strategy used
   */
  strategy: string;
  
  /**
   * The matching attributes
   */
  matchedAttributes: { [key: string]: any };
}

/**
 * Represents a screenshot configuration
 */
export interface ScreenshotConfig {
  /**
   * Whether to take screenshots on error
   */
  screenshotsOnError: boolean;
  
  /**
   * Whether to take screenshots for each action
   */
  screenshotsOnAction: boolean;
  
  /**
   * Whether to take screenshots for each assertion
   */
  screenshotsOnAssertion: boolean;
  
  /**
   * The directory to save screenshots to
   */
  screenshotDir: string;
  
  /**
   * The base screenshot filename
   */
  screenshotBaseFilename: string;
  
  /**
   * The screenshot format (png or jpeg)
   */
  screenshotFormat: 'png' | 'jpeg';
  
  /**
   * The screenshot quality (0-100, jpeg only)
   */
  screenshotQuality: number;
  
  /**
   * Whether to highlight the element in screenshots
   */
  highlightElementInScreenshot: boolean;
}

/**
 * Represents the state of an element for restoring later
 */
export interface ElementState {
  /**
   * The element value
   */
  value?: string;
  
  /**
   * Whether the element is checked
   */
  checked?: boolean;
  
  /**
   * Whether the element is selected
   */
  selected?: boolean;
  
  /**
   * Whether the element is enabled
   */
  enabled?: boolean;
  
  /**
   * Whether the element is displayed
   */
  displayed?: boolean;
  
  /**
   * The element text
   */
  text?: string;
  
  /**
   * The element attributes
   */
  attributes?: { [key: string]: string };
  
  /**
   * The element CSS properties
   */
  cssProperties?: { [key: string]: string };
  
  /**
   * The element position and size
   */
  rect?: ElementPosition;
}

/**
 * Represents a validation rule for an element
 */
export interface ElementValidationRule {
  /**
   * The attribute or property to validate
   */
  property: string;
  
  /**
   * The expected value
   */
  expectedValue: any;
  
  /**
   * The validation operator (equals, contains, etc.)
   */
  operator: 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'matches' | 'present' | 'notPresent' | 'greaterThan' | 'lessThan';
  
  /**
   * Custom error message for validation failure
   */
  errorMessage?: string;
  
  /**
   * Whether to continue validation if this rule fails
   */
  continueOnFailure?: boolean;
}

/**
 * Represents a window handle with additional information
 */
export interface WindowInfo {
  /**
   * The window handle
   */
  handle: string;
  
  /**
   * The window title
   */
  title: string;
  
  /**
   * The window URL
   */
  url: string;
}

/**
 * Represents options for asserting element states
 */
export interface AssertOptions {
  /**
   * The timeout in milliseconds
   */
  timeout?: number;
  
  /**
   * Whether to highlight the element
   */
  highlight?: boolean;
  
  /**
   * Whether to take a screenshot
   */
  screenshot?: boolean;
  
  /**
   * Custom error message
   */
  message?: string;
  
  /**
   * Whether to fail the test immediately
   */
  failFast?: boolean;
  
  /**
   * Whether to use soft assertions (record failure but continue)
   */
  soft?: boolean;
}

/**
 * Represents a network request intercepted by the browser
 */
export interface NetworkRequest {
  /**
   * The request URL
   */
  url: string;
  
  /**
   * The request method
   */
  method: string;
  
  /**
   * The request headers
   */
  headers: { [key: string]: string };
  
  /**
   * The request body
   */
  body?: string;
  
  /**
   * The response status code
   */
  status?: number;
  
  /**
   * The response status text
   */
  statusText?: string;
  
  /**
   * The response headers
   */
  responseHeaders?: { [key: string]: string };
  
  /**
   * The response body
   */
  responseBody?: string;
  
  /**
   * The time when the request started
   */
  startTime?: number;
  
  /**
   * The time when the response ended
   */
  endTime?: number;
  
  /**
   * The request type (document, script, stylesheet, image, etc.)
   */
  type?: string;
  
  /**
   * Any error that occurred during the request
   */
  error?: string;
}



CSElementList.ts
--------------------------------

import { WebDriver, WebElement, By, until } from 'selenium-webdriver';
import { CSElement } from './CSElement';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSScreenshotManager } from '../../core/utils/CSScreenshotManager';
import { ElementAttributes } from '../types/ElementTypes';

/**
 * CSElementList is a wrapper for a collection of CSElement instances
 * that provides additional methods for working with element collections.
 */
export class CSElementList implements Iterable<CSElement> {
  private driver: WebDriver;
  private locator: By;
  private elements: CSElement[] = [];
  private logger: CSLogger;
  private screenshotManager: CSScreenshotManager;
  private parent: CSElement | null;
  private frameContext: boolean;
  private defaultTimeout: number = 30000;
  private pollingInterval: number = 500;
  private highlightColor: string = 'red';
  private highlightDuration: number = 100;
  private initialized: boolean = false;
  private lastFilteredList: CSElementList | null = null;
  private lastMappedList: any[] = [];
  
  /**
   * Creates a new CSElementList instance
   * @param driver The WebDriver instance
   * @param locatorOrElements The locator or array of elements to wrap
   * @param parent The parent CSElement (optional)
   * @param frameContext Whether this element list is in a frame context (optional)
   */
  constructor(
    driver: WebDriver,
    locatorOrElements: By | WebElement[] | CSElement[],
    parent: CSElement | null = null,
    frameContext: boolean = false
  ) {
    this.driver = driver;
    this.logger = new CSLogger('CSElementList');
    this.screenshotManager = new CSScreenshotManager();
    this.parent = parent;
    this.frameContext = frameContext;
    
    if (locatorOrElements instanceof By) {
      this.locator = locatorOrElements;
    } else {
      this.locator = By.css(''); // Placeholder locator
      this.setElements(locatorOrElements);
      this.initialized = true;
    }
  }
  
  /**
   * Sets the elements in the list
   * @param elements The elements to set
   */
  private setElements(elements: WebElement[] | CSElement[]): void {
    this.elements = [];
    
    if (elements.length === 0) {
      return;
    }
    
    if (elements[0] instanceof WebElement) {
      // Convert WebElements to CSElements
      const webElements = elements as WebElement[];
      this.elements = webElements.map(element => new CSElement(this.driver, element));
    } else {
      // Use CSElements as-is
      this.elements = elements as CSElement[];
    }
  }
  
  /**
   * Initializes the element list by finding all matching elements
   * @param timeout The timeout in milliseconds (optional)
   * @returns This CSElementList instance
   */
  public async initialize(timeout: number = this.defaultTimeout): Promise<CSElementList> {
    if (this.initialized) {
      return this;
    }
    
    try {
      // If we have a parent element, find elements within the parent
      if (this.parent) {
        const parentElement = await this.parent.getWebElement(timeout);
        const elements = await parentElement.findElements(this.locator);
        this.setElements(elements);
      } else {
        // Find elements in the document
        const elements = await this.driver.findElements(this.locator);
        this.setElements(elements);
      }
      
      this.initialized = true;
      return this;
    } catch (error) {
      this.logger.error(`Error initializing element list with locator ${this.locator}: ${error}`);
      
      // Take a screenshot on failure for debugging
      try {
        const screenshotPath = await this.screenshotManager.takeScreenshot(this.driver, 'element_list_init_failed');
        this.logger.debug(`Screenshot saved to ${screenshotPath}`);
      } catch (screenshotError) {
        this.logger.warn(`Failed to take screenshot: ${screenshotError}`);
      }
      
      throw error;
    }
  }
  
  /**
   * Refreshes the element list by finding all matching elements again
   * @param timeout The timeout in milliseconds (optional)
   * @returns This CSElementList instance
   */
  public async refresh(timeout: number = this.defaultTimeout): Promise<CSElementList> {
    this.initialized = false;
    this.lastFilteredList = null;
    this.lastMappedList = [];
    return this.initialize(timeout);
  }
  
  /**
   * Gets the number of elements in the list
   * @returns The number of elements
   */
  public async count(): Promise<number> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    return this.elements.length;
  }
  
  /**
   * Checks if the list is empty
   * @returns Whether the list is empty
   */
  public async isEmpty(): Promise<boolean> {
    return (await this.count()) === 0;
  }
  
  /**
   * Gets the element at the specified index
   * @param index The index of the element to get
   * @returns The CSElement at the specified index
   * @throws Error if the index is out of bounds
   */
  public async get(index: number): Promise<CSElement> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    if (index < 0 || index >= this.elements.length) {
      throw new Error(`Index out of bounds: ${index}, list size: ${this.elements.length}`);
    }
    
    return this.elements[index];
  }
  
  /**
   * Gets the first element in the list
   * @returns The first CSElement, or null if the list is empty
   */
  public async first(): Promise<CSElement | null> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    if (this.elements.length === 0) {
      return null;
    }
    
    return this.elements[0];
  }
  
  /**
   * Gets the last element in the list
   * @returns The last CSElement, or null if the list is empty
   */
  public async last(): Promise<CSElement | null> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    if (this.elements.length === 0) {
      return null;
    }
    
    return this.elements[this.elements.length - 1];
  }
  
  /**
   * Gets a random element from the list
   * @returns A random CSElement, or null if the list is empty
   */
  public async random(): Promise<CSElement | null> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    if (this.elements.length === 0) {
      return null;
    }
    
    const randomIndex = Math.floor(Math.random() * this.elements.length);
    return this.elements[randomIndex];
  }
  
  /**
   * Gets an array of all CSElements in the list
   * @returns An array of CSElements
   */
  public async asArray(): Promise<CSElement[]> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    return [...this.elements];
  }
  
  /**
   * Gets a slice of the list
   * @param start The start index
   * @param end The end index (optional)
   * @returns A new CSElementList containing the sliced elements
   */
  public async slice(start: number, end?: number): Promise<CSElementList> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    const slicedElements = this.elements.slice(start, end);
    return new CSElementList(this.driver, slicedElements);
  }
  
  /**
   * Filters the list based on a predicate
   * @param predicate The predicate function
   * @returns A new CSElementList containing elements that satisfy the predicate
   */
  public async filter(predicate: (element: CSElement, index: number) => Promise<boolean>): Promise<CSElementList> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    const filteredElements: CSElement[] = [];
    
    for (let i = 0; i < this.elements.length; i++) {
      const element = this.elements[i];
      if (await predicate(element, i)) {
        filteredElements.push(element);
      }
    }
    
    const result = new CSElementList(this.driver, filteredElements);
    this.lastFilteredList = result;
    return result;
  }
  
  /**
   * Maps the list to an array of values
   * @param mapper The mapper function
   * @returns An array of mapped values
   */
  public async map<T>(mapper: (element: CSElement, index: number) => Promise<T>): Promise<T[]> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    const mappedValues: T[] = [];
    
    for (let i = 0; i < this.elements.length; i++) {
      const element = this.elements[i];
      const value = await mapper(element, i);
      mappedValues.push(value);
    }
    
    this.lastMappedList = mappedValues;
    return mappedValues;
  }
  
  /**
   * Finds elements by text content
   * @param text The text to search for
   * @param options Filter options (optional)
   * @returns A new CSElementList with elements matching the text
   */
  public async findByText(text: string, options?: {
    exact?: boolean;
    caseSensitive?: boolean;
    trim?: boolean;
    subString?: boolean;
    regex?: boolean;
  }): Promise<CSElementList> {
    const opts = {
      exact: options?.exact !== false,
      caseSensitive: options?.caseSensitive || false,
      trim: options?.trim !== false,
      subString: options?.subString || false,
      regex: options?.regex || false
    };
    
    return this.filter(async (element) => {
      let elementText = await element.getText({ waitForVisible: false });
      
      if (opts.trim) {
        elementText = elementText.trim();
      }
      
      if (opts.regex) {
        // Use regex matching
        const regex = new RegExp(text, opts.caseSensitive ? '' : 'i');
        return regex.test(elementText);
      } else if (opts.exact) {
        // Exact matching
        if (opts.caseSensitive) {
          return elementText === text;
        } else {
          return elementText.toLowerCase() === text.toLowerCase();
        }
      } else if (opts.subString) {
        // Substring matching
        if (opts.caseSensitive) {
          return elementText.includes(text);
        } else {
          return elementText.toLowerCase().includes(text.toLowerCase());
        }
      } else {
        // Default to exact case-insensitive
        return elementText.toLowerCase() === text.toLowerCase();
      }
    });
  }
  
  /**
   * Finds elements by attribute value
   * @param attribute The attribute name
   * @param value The attribute value
   * @param options Filter options (optional)
   * @returns A new CSElementList with elements matching the attribute
   */
  public async findByAttribute(attribute: string, value: string, options?: {
    exact?: boolean;
    caseSensitive?: boolean;
    subString?: boolean;
    regex?: boolean;
  }): Promise<CSElementList> {
    const opts = {
      exact: options?.exact !== false,
      caseSensitive: options?.caseSensitive || false,
      subString: options?.subString || false,
      regex: options?.regex || false
    };
    
    return this.filter(async (element) => {
      const attributeValue = await element.getAttribute(attribute, { waitForVisible: false });
      
      if (attributeValue === null) {
        return false;
      }
      
      if (opts.regex) {
        // Use regex matching
        const regex = new RegExp(value, opts.caseSensitive ? '' : 'i');
        return regex.test(attributeValue);
      } else if (opts.exact) {
        // Exact matching
        if (opts.caseSensitive) {
          return attributeValue === value;
        } else {
          return attributeValue.toLowerCase() === value.toLowerCase();
        }
      } else if (opts.subString) {
        // Substring matching
        if (opts.caseSensitive) {
          return attributeValue.includes(value);
        } else {
          return attributeValue.toLowerCase().includes(value.toLowerCase());
        }
      } else {
        // Default to exact case-insensitive
        return attributeValue.toLowerCase() === value.toLowerCase();
      }
    });
  }
  
  /**
   * Finds elements by CSS class
   * @param className The CSS class name
   * @returns A new CSElementList with elements having the specified class
   */
  public async findByClass(className: string): Promise<CSElementList> {
    return this.filter(async (element) => {
      const classes = await element.getAttribute('class', { waitForVisible: false });
      
      if (!classes) {
        return false;
      }
      
      const classArray = classes.split(/\s+/);
      return classArray.includes(className);
    });
  }
  
  /**
   * Finds visible elements
   * @returns A new CSElementList with visible elements
   */
  public async findVisible(): Promise<CSElementList> {
    return this.filter(async (element) => {
      return await element.isDisplayed({ checkVisibility: true });
    });
  }
  
  /**
   * Finds enabled elements
   * @returns A new CSElementList with enabled elements
   */
  public async findEnabled(): Promise<CSElementList> {
    return this.filter(async (element) => {
      return await element.isEnabled();
    });
  }
  
  /**
   * Finds elements by tag name
   * @param tagName The tag name
   * @returns A new CSElementList with elements having the specified tag
   */
  public async findByTag(tagName: string): Promise<CSElementList> {
    return this.filter(async (element) => {
      const elemTagName = await element.getWebElement().then(e => e.getTagName());
      return elemTagName.toLowerCase() === tagName.toLowerCase();
    });
  }
  
  /**
   * Checks if all elements satisfy a predicate
   * @param predicate The predicate function
   * @returns Whether all elements satisfy the predicate
   */
  public async every(predicate: (element: CSElement, index: number) => Promise<boolean>): Promise<boolean> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    for (let i = 0; i < this.elements.length; i++) {
      if (!await predicate(this.elements[i], i)) {
        return false;
      }
    }
    
    return true;
  }
  
  /**
   * Checks if any element satisfies a predicate
   * @param predicate The predicate function
   * @returns Whether any element satisfies the predicate
   */
  public async some(predicate: (element: CSElement, index: number) => Promise<boolean>): Promise<boolean> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    for (let i = 0; i < this.elements.length; i++) {
      if (await predicate(this.elements[i], i)) {
        return true;
      }
    }
    
    return false;
  }
  
  /**
   * Finds the index of the first element that satisfies a predicate
   * @param predicate The predicate function
   * @returns The index of the first matching element, or -1 if not found
   */
  public async findIndex(predicate: (element: CSElement, index: number) => Promise<boolean>): Promise<number> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    for (let i = 0; i < this.elements.length; i++) {
      if (await predicate(this.elements[i], i)) {
        return i;
      }
    }
    
    return -1;
  }
  
  /**
   * Finds the first element that satisfies a predicate
   * @param predicate The predicate function
   * @returns The first matching element, or null if not found
   */
  public async find(predicate: (element: CSElement, index: number) => Promise<boolean>): Promise<CSElement | null> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    for (let i = 0; i < this.elements.length; i++) {
      if (await predicate(this.elements[i], i)) {
        return this.elements[i];
      }
    }
    
    return null;
  }
  
  /**
   * Performs an action on each element
   * @param action The action function
   * @returns This CSElementList instance
   */
  public async forEach(action: (element: CSElement, index: number) => Promise<void>): Promise<CSElementList> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    for (let i = 0; i < this.elements.length; i++) {
      await action(this.elements[i], i);
    }
    
    return this;
  }
  
  /**
   * Performs an action on each element in parallel
   * @param action The action function
   * @param concurrency The maximum number of concurrent actions (default: 5)
   * @returns This CSElementList instance
   */
  public async forEachParallel(
    action: (element: CSElement, index: number) => Promise<void>,
    concurrency: number = 5
  ): Promise<CSElementList> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    // Process elements in batches of size 'concurrency'
    for (let i = 0; i < this.elements.length; i += concurrency) {
      const batch = this.elements.slice(i, i + concurrency);
      const promises = batch.map((element, batchIndex) => 
        action(element, i + batchIndex)
      );
      
      await Promise.all(promises);
    }
    
    return this;
  }
  
  /**
   * Reduces the elements to a single value
   * @param reducer The reducer function
   * @param initialValue The initial value
   * @returns The reduced value
   */
  public async reduce<T>(
    reducer: (accumulator: T, element: CSElement, index: number) => Promise<T>,
    initialValue: T
  ): Promise<T> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    let accumulator = initialValue;
    
    for (let i = 0; i < this.elements.length; i++) {
      accumulator = await reducer(accumulator, this.elements[i], i);
    }
    
    return accumulator;
  }
  
  /**
   * Sorts the elements based on a comparison function
   * @param compareFn The comparison function
   * @returns A new CSElementList with sorted elements
   */
  public async sort(
    compareFn: (a: CSElement, b: CSElement) => Promise<number>
  ): Promise<CSElementList> {
    if (!this.initialized) {
      await this.initialize();
    }
    
    // Create a copy of the elements
    const elementsCopy = [...this.elements];
    
    // Sort the elements using the async comparison function
    const sortedElements = await this.asyncSort(elementsCopy, compareFn);
    
    return new CSElementList(this.driver, sortedElements);
  }
  
  /**
   * Helper method for async sorting
   * @param elements The elements to sort
   * @param compareFn The comparison function
   * @returns The sorted elements
   */
  private async asyncSort(
    elements: CSElement[],
    compareFn: (a: CSElement, b: CSElement) => Promise<number>
  ): Promise<CSElement[]> {
    // For small arrays, use insertion sort
    if (elements.length <= 10) {
      return this.asyncInsertionSort(elements, compareFn);
    }
    
    // For larger arrays, use quicksort
    return this.asyncQuickSort(elements, compareFn);
  }
  
  /**
   * Async insertion sort implementation
   * @param elements The elements to sort
   * @param compareFn The comparison function
   * @returns The sorted elements
   */
  private async asyncInsertionSort(
    elements: CSElement[],
    compareFn: (a: CSElement, b: CSElement) => Promise<number>
  ): Promise<CSElement[]> {
    const result = [...elements];
    
    for (let i = 1; i < result.length; i++) {
      const current = result[i];
      let j = i - 1;
      
      while (j >= 0 && await compareFn(result[j], current) > 0) {
        result[j + 1] = result[j];
        j--;
      }
      
      result[j + 1] = current;
    }
    
    return result;
  }
  
  /**
   * Async quicksort implementation
   * @param elements The elements to sort
   * @param compareFn The comparison function
   * @returns The sorted elements
   */
  private async asyncQuickSort(
    elements: CSElement[],
    compareFn: (a: CSElement, b: CSElement) => Promise<number>
  ): Promise<CSElement[]> {
    if (elements.length <= 1) {
      return elements;
    }
    
    const pivot = elements[Math.floor(elements.length / 2)];
    const less: CSElement[] = [];
    const equal: CSElement[] = [];
    const greater: CSElement[] = [];
    
    for (const element of elements) {
      const cmp = await compareFn(element, pivot);
      if (cmp < 0) {
        less.push(element);
      } else if (cmp > 0) {
        greater.push(element);
      } else {
        equal.push(element);
      }
    }
    
    const sortedLess = await this.asyncQuickSort(less, compareFn);
    const sortedGreater = await this.asyncQuickSort(greater, compareFn);
    
    return [...sortedLess, ...equal, ...sortedGreater];
  }
  
  /**
   * Sorts the elements by text content
   * @param ascending Whether to sort in ascending order (default: true)
   * @returns A new CSElementList with sorted elements
   */
  public async sortByText(ascending: boolean = true): Promise<CSElementList> {
    return this.sort(async (a, b) => {
      const textA = await a.getText({ waitForVisible: false });
      const textB = await b.getText({ waitForVisible: false });
      
      return ascending ? 
        textA.localeCompare(textB) : 
        textB.localeCompare(textA);
    });
  }
  
  /**
   * Sorts the elements by attribute value
   * @param attribute The attribute to sort by
   * @param ascending Whether to sort in ascending order (default: true)
   * @returns A new CSElementList with sorted elements
   */
  public async sortByAttribute(attribute: string, ascending: boolean = true): Promise<CSElementList> {
    return this.sort(async (a, b) => {
      const valueA = await a.getAttribute(attribute, { waitForVisible: false }) || '';
      const valueB = await b.getAttribute(attribute, { waitForVisible: false }) || '';
      
      return ascending ? 
        valueA.localeCompare(valueB) : 
        valueB.localeCompare(valueA);
    });
  }
  
  /**
   * Gets all text content from the elements
   * @returns An array of text content
   */
  public async getAllText(): Promise<string[]> {
    return this.map(async (element) => {
      return element.getText({ waitForVisible: false });
    });
  }
  
  /**
   * Gets all attribute values from the elements
   * @param attribute The attribute name
   * @returns An array of attribute values
   */
  public async getAllAttributes(attribute: string): Promise<(string | null)[]> {
    return this.map(async (element) => {
      return element.getAttribute(attribute, { waitForVisible: false });
    });
  }
  
  /**
   * Gets all element attributes as objects
   * @returns An array of attribute objects
   */
  public async getAllElementAttributes(): Promise<ElementAttributes[]> {
    return this.map(async (element) => {
      return element.getAttributes({ waitForVisible: false });
    });
  }
  
  /**
   * Clicks all elements in the list
   * @param options Click options (optional)
   * @returns This CSElementList instance
   */
  public async clickAll(options?: {
    waitForVisible?: boolean;
    waitForClickable?: boolean;
    timeout?: number;
    highlight?: boolean;
    parallel?: boolean;
    concurrency?: number;
  }): Promise<CSElementList> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      waitForClickable: options?.waitForClickable !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight !== false,
      parallel: options?.parallel || false,
      concurrency: options?.concurrency || 5
    };
    
    if (opts.parallel) {
      // Click elements in parallel
      return this.forEachParallel(async (element) => {
        await element.click({
          waitForVisible: opts.waitForVisible,
          waitForClickable: opts.waitForClickable,
          timeout: opts.timeout,
          highlight: opts.highlight
        });
      }, opts.concurrency);
    } else {
      // Click elements sequentially
      return this.forEach(async (element) => {
        await element.click({
          waitForVisible: opts.waitForVisible,
          waitForClickable: opts.waitForClickable,
          timeout: opts.timeout,
          highlight: opts.highlight
        });
      });
    }
  }
  
  /**
   * Highlights all elements in the list
   * @param color The highlight color (optional)
   * @param duration The highlight duration in milliseconds (optional)
   * @returns This CSElementList instance
   */
  public async highlightAll(color?: string, duration?: number): Promise<CSElementList> {
    const highlightColor = color || this.highlightColor;
    const highlightDuration = duration || this.highlightDuration;
    
    if (!this.initialized) {
      await this.initialize();
    }
    
    // Highlight all elements with JavaScript for better performance
    if (this.elements.length > 0) {
      // Get the WebElement instances
      const webElements = await Promise.all(
        this.elements.map(element => element.getWebElement())
      );
      
      // Highlight all elements at once using JavaScript
      await this.driver.executeScript(`
        const elements = arguments;
        const color = "${highlightColor}";
        const originalStyles = [];
        
        // Save original styles and apply highlights
        for (let i = 0; i < elements.length; i++) {
          const element = elements[i];
          originalStyles[i] = element.getAttribute("style");
          element.setAttribute("style", "border: 2px solid " + color + " !important; background-color: rgba(255, 255, 0, 0.1) !important;");
        }
        
        // Return original styles for later restoration
        return originalStyles;
      `, ...webElements);
      
      // Wait for the specified duration
      await this.driver.sleep(highlightDuration);
      
      // Restore original styles
      await this.driver.executeScript(`
        const elements = arguments;
        const originalStyles = arguments[elements.length - 1];
        
        // Restore original styles
        for (let i = 0; i < elements.length - 1; i++) {
          const element = elements[i];
          element.setAttribute("style", originalStyles[i] || "");
        }
      `, ...webElements, []);
    }
    
    return this;
  }
  
  /**
   * Takes screenshots of all elements in the list
   * @param options Screenshot options (optional)
   * @returns An array of base64-encoded screenshots
   */
  public async takeScreenshotsOfAll(options?: {
    waitForVisible?: boolean;
    timeout?: number;
    highlight?: boolean;
    fileNamePrefix?: string;
    saveToFile?: boolean;
  }): Promise<string[]> {
    const opts = {
      waitForVisible: options?.waitForVisible !== false,
      timeout: options?.timeout || this.defaultTimeout,
      highlight: options?.highlight || false,
      fileNamePrefix: options?.fileNamePrefix || 'element-list-',
      saveToFile: options?.saveToFile || false
    };
    
    if (!this.initialized) {
      await this.initialize();
    }
    
    const screenshots: string[] = [];
    
    for (let i = 0; i < this.elements.length; i++) {
      const fileName = `${opts.fileNamePrefix}${i}-${Date.now()}.png`;
      const screenshot = await this.elements[i].takeScreenshot({
        waitForVisible: opts.waitForVisible,
        timeout: opts.timeout,
        highlight: opts.highlight,
        fileName: fileName,
        saveToFile: opts.saveToFile
      });
      
      screenshots.push(screenshot);
    }
    
    return screenshots;
  }
  
  /**
   * Sets the default timeout for all operations
   * @param timeout The timeout in milliseconds
   * @returns This CSElementList instance
   */
  public withTimeout(timeout: number): CSElementList {
    this.defaultTimeout = timeout;
    return this;
  }
  
  /**
   * Sets the polling interval for waits
   * @param interval The polling interval in milliseconds
   * @returns This CSElementList instance
   */
  public withPollingInterval(interval: number): CSElementList {
    this.pollingInterval = interval;
    return this;
  }
  
  /**
   * Sets the highlight settings for element interactions
   * @param color The highlight color
   * @param duration The highlight duration in milliseconds
   * @returns This CSElementList instance
   */
  public withHighlight(color: string, duration: number): CSElementList {
    this.highlightColor = color;
    this.highlightDuration = duration;
    return this;
  }
  
  /**
   * Gets the WebDriver instance
   * @returns The WebDriver instance
   */
  public getDriver(): WebDriver {
    return this.driver;
  }
  
  /**
   * Gets the locator used to find the elements
   * @returns The locator
   */
  public getLocator(): By {
    return this.locator;
  }
  
  /**
   * Gets the parent element
   * @returns The parent element, or null if there is no parent
   */
  public getParent(): CSElement | null {
    return this.parent;
  }
  
  /**
   * Gets the last filtered list
   * @returns The last filtered list, or null if no filtering has been performed
   */
  public getLastFilteredList(): CSElementList | null {
    return this.lastFilteredList;
  }
  
  /**
   * Gets the last mapped list
   * @returns The last mapped list
   */
  public getLastMappedList(): any[] {
    return [...this.lastMappedList];
  }
  
  /**
   * Creates a new CSElementList with the given elements
   * @param elements The elements to include
   * @returns A new CSElementList
   */
  public static fromElements(driver: WebDriver, elements: CSElement[]): CSElementList {
    return new CSElementList(driver, elements);
  }
  
  /**
   * Creates a new CSElementList with empty elements
   * @returns A new empty CSElementList
   */
  public static empty(driver: WebDriver): CSElementList {
    return new CSElementList(driver, []);
  }
  
  /**
   * Combines multiple CSElementLists into a single list
   * @param lists The lists to combine
   * @returns A new CSElementList with all elements
   */
  public static combine(driver: WebDriver, ...lists: CSElementList[]): CSElementList {
    const allElements: CSElement[] = [];
    
    for (const list of lists) {
      // Skip uninitialized lists
      if (!list.initialized) {
        continue;
      }
      
      allElements.push(...list.elements);
    }
    
    return new CSElementList(driver, allElements);
  }
  
  /**
   * Implementation of the iterator protocol
   */
  [Symbol.iterator](): Iterator<CSElement> {
    let index = 0;
    const elements = this.elements;
    
    return {
      next(): IteratorResult<CSElement> {
        if (index < elements.length) {
          return { value: elements[index++], done: false };
        } else {
          return { value: undefined as any, done: true };
        }
      }
    };
  }
}



CSWaitStrategy.ts
-------------------------------

import { WebDriver, WebElement, Condition, error as SeleniumError } from 'selenium-webdriver';
import { CSLogger } from '../../core/utils/CSLogger';

/**
 * CSWaitStrategy defines the interface for all wait strategies that are used
 * to wait for specific conditions on elements or the browser.
 */
export interface CSWaitStrategy<T> {
  /**
   * Gets the strategy name.
   * @returns The strategy name
   */
  getName(): string;
  
  /**
   * Gets the timeout for this wait.
   * @returns The timeout in milliseconds
   */
  getTimeout(): number;
  
  /**
   * Gets the polling interval for this wait.
   * @returns The polling interval in milliseconds
   */
  getPollingInterval(): number;
  
  /**
   * Gets the message to display if the wait times out.
   * @returns The timeout message
   */
  getTimeoutMessage(): string;
  
  /**
   * Gets the Selenium Condition object that represents this wait.
   * @returns The Condition object
   */
  getCondition(): Condition<T>;
  
  /**
   * Sets the timeout for this wait.
   * @param timeout The timeout in milliseconds
   * @returns This CSWaitStrategy instance
   */
  withTimeout(timeout: number): CSWaitStrategy<T>;
  
  /**
   * Sets the polling interval for this wait.
   * @param interval The polling interval in milliseconds
   * @returns This CSWaitStrategy instance
   */
  withPollingInterval(interval: number): CSWaitStrategy<T>;
  
  /**
   * Sets the timeout message for this wait.
   * @param message The timeout message
   * @returns This CSWaitStrategy instance
   */
  withTimeoutMessage(message: string): CSWaitStrategy<T>;
  
  /**
   * Performs the wait operation using the provided WebDriver.
   * @param driver The WebDriver instance
   * @returns A Promise that resolves to the wait result
   */
  wait(driver: WebDriver): Promise<T>;
  
  /**
   * Ignores specific exceptions during the wait.
   * @param exceptions The exceptions to ignore
   * @returns This CSWaitStrategy instance
   */
  ignoring(...exceptions: Array<typeof Error>): CSWaitStrategy<T>;
  
  /**
   * Creates a new wait strategy that is the logical NOT of this strategy.
   * @returns A new CSWaitStrategy instance
   */
  not(): CSWaitStrategy<boolean>;
  
  /**
   * Creates a new wait strategy that is the logical AND of this strategy and another.
   * @param other The other wait strategy
   * @returns A new CSWaitStrategy instance
   */
  and<U>(other: CSWaitStrategy<U>): CSWaitStrategy<boolean>;
  
  /**
   * Creates a new wait strategy that is the logical OR of this strategy and another.
   * @param other The other wait strategy
   * @returns A new CSWaitStrategy instance
   */
  or<U>(other: CSWaitStrategy<U>): CSWaitStrategy<boolean>;
  
  /**
   * Creates a new wait strategy that transforms the result of this strategy.
   * @param transform The transformation function
   * @returns A new CSWaitStrategy instance
   */
  map<U>(transform: (value: T) => U): CSWaitStrategy<U>;
  
  /**
   * Checks if the condition is currently met without waiting.
   * @param driver The WebDriver instance
   * @returns A Promise that resolves to true if the condition is met, false otherwise
   */
  isConditionMet(driver: WebDriver): Promise<boolean>;
}

/**
 * Type for retry options, allowing specification of interval and count.
 */
export interface RetryOptions {
  /**
   * The interval between retries in milliseconds.
   */
  interval: number;
  
  /**
   * The maximum number of retries.
   */
  count: number;
  
  /**
   * Whether to use exponential backoff for retry intervals.
   */
  exponentialBackoff?: boolean;
  
  /**
   * The factor by which to increase the interval on each retry when using exponential backoff.
   */
  backoffFactor?: number;
  
  /**
   * A callback function to call before each retry.
   */
  beforeRetry?: (retryCount: number, error: Error) => Promise<void>;
  
  /**
   * A callback function to call after each failed retry.
   */
  afterRetryFailed?: (retryCount: number, error: Error) => Promise<void>;
}

/**
 * Type for wait configuration options.
 */
export interface WaitConfig {
  /**
   * The timeout in milliseconds.
   */
  timeout: number;
  
  /**
   * The polling interval in milliseconds.
   */
  pollingInterval: number;
  
  /**
   * The timeout message.
   */
  message?: string;
  
  /**
   * The exceptions to ignore during the wait.
   */
  ignoredExceptions?: Array<typeof Error>;
  
  /**
   * The retry options for the wait.
   */
  retryOptions?: RetryOptions;
  
  /**
   * Whether to fail immediately on any error.
   */
  failFast?: boolean;
  
  /**
   * Whether to take a screenshot when the wait times out.
   */
  screenshotOnFailure?: boolean;
  
  /**
   * The logger to use for logging.
   */
  logger?: CSLogger;
}

/**
 * Type for element finder function, which finds an element from the WebDriver.
 */
export type ElementFinder = (driver: WebDriver) => Promise<WebElement>;


CSAbstractWaitStrategy.ts
----------------------------------

import { WebDriver, Condition, error as SeleniumError } from 'selenium-webdriver';
import { CSWaitStrategy, WaitConfig, RetryOptions } from './CSWaitStrategy';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSScreenshotManager } from '../../core/utils/CSScreenshotManager';

/**
 * Abstract base class for all wait strategies that implements common functionality.
 */
export abstract class CSAbstractWaitStrategy<T> implements CSWaitStrategy<T> {
  /**
   * The default timeout in milliseconds.
   */
  protected static readonly DEFAULT_TIMEOUT: number = 30000;
  
  /**
   * The default polling interval in milliseconds.
   */
  protected static readonly DEFAULT_POLLING_INTERVAL: number = 500;
  
  /**
   * The default timeout message.
   */
  protected static readonly DEFAULT_TIMEOUT_MESSAGE: string = 'Timed out waiting for condition';
  
  /**
   * The name of the strategy.
   */
  protected name: string;
  
  /**
   * The timeout in milliseconds.
   */
  protected timeout: number;
  
  /**
   * The polling interval in milliseconds.
   */
  protected pollingInterval: number;
  
  /**
   * The timeout message.
   */
  protected timeoutMessage: string;
  
  /**
   * The exceptions to ignore during the wait.
   */
  protected ignoredExceptions: Array<typeof Error> = [];
  
  /**
   * The retry options for the wait.
   */
  protected retryOptions?: RetryOptions;
  
  /**
   * Whether to fail immediately on any error.
   */
  protected failFast: boolean = false;
  
  /**
   * Whether to take a screenshot when the wait times out.
   */
  protected screenshotOnFailure: boolean = true;
  
  /**
   * The logger instance.
   */
  protected logger: CSLogger;
  
  /**
   * The screenshot manager instance.
   */
  protected screenshotManager: CSScreenshotManager;
  
  /**
   * Creates a new CSAbstractWaitStrategy instance.
   * @param name The name of the strategy
   * @param config The wait configuration
   */
  constructor(name: string, config?: Partial<WaitConfig>) {
    this.name = name;
    this.timeout = config?.timeout || CSAbstractWaitStrategy.DEFAULT_TIMEOUT;
    this.pollingInterval = config?.pollingInterval || CSAbstractWaitStrategy.DEFAULT_POLLING_INTERVAL;
    this.timeoutMessage = config?.message || CSAbstractWaitStrategy.DEFAULT_TIMEOUT_MESSAGE;
    this.ignoredExceptions = config?.ignoredExceptions || [];
    this.retryOptions = config?.retryOptions;
    this.failFast = config?.failFast || false;
    this.screenshotOnFailure = config?.screenshotOnFailure !== false;
    this.logger = config?.logger || new CSLogger(name);
    this.screenshotManager = new CSScreenshotManager();
  }
  
  /**
   * Gets the strategy name.
   * @returns The strategy name
   */
  public getName(): string {
    return this.name;
  }
  
  /**
   * Gets the timeout for this wait.
   * @returns The timeout in milliseconds
   */
  public getTimeout(): number {
    return this.timeout;
  }
  
  /**
   * Gets the polling interval for this wait.
   * @returns The polling interval in milliseconds
   */
  public getPollingInterval(): number {
    return this.pollingInterval;
  }
  
  /**
   * Gets the message to display if the wait times out.
   * @returns The timeout message
   */
  public getTimeoutMessage(): string {
    return this.timeoutMessage;
  }
  
  /**
   * Gets the Selenium Condition object that represents this wait.
   * This method must be implemented by concrete subclasses.
   * @returns The Condition object
   */
  public abstract getCondition(): Condition<T>;
  
  /**
   * Sets the timeout for this wait.
   * @param timeout The timeout in milliseconds
   * @returns This CSWaitStrategy instance
   */
  public withTimeout(timeout: number): CSWaitStrategy<T> {
    this.timeout = timeout;
    return this;
  }
  
  /**
   * Sets the polling interval for this wait.
   * @param interval The polling interval in milliseconds
   * @returns This CSWaitStrategy instance
   */
  public withPollingInterval(interval: number): CSWaitStrategy<T> {
    this.pollingInterval = interval;
    return this;
  }
  
  /**
   * Sets the timeout message for this wait.
   * @param message The timeout message
   * @returns This CSWaitStrategy instance
   */
  public withTimeoutMessage(message: string): CSWaitStrategy<T> {
    this.timeoutMessage = message;
    return this;
  }
  
  /**
   * Sets the retry options for this wait.
   * @param options The retry options
   * @returns This CSWaitStrategy instance
   */
  public withRetryOptions(options: RetryOptions): CSWaitStrategy<T> {
    this.retryOptions = options;
    return this;
  }
  
  /**
   * Sets whether to fail immediately on any error.
   * @param failFast Whether to fail immediately
   * @returns This CSWaitStrategy instance
   */
  public withFailFast(failFast: boolean): CSWaitStrategy<T> {
    this.failFast = failFast;
    return this;
  }
  
  /**
   * Sets whether to take a screenshot when the wait times out.
   * @param screenshotOnFailure Whether to take a screenshot
   * @returns This CSWaitStrategy instance
   */
  public withScreenshotOnFailure(screenshotOnFailure: boolean): CSWaitStrategy<T> {
    this.screenshotOnFailure = screenshotOnFailure;
    return this;
  }
  
  /**
   * Ignores specific exceptions during the wait.
   * @param exceptions The exceptions to ignore
   * @returns This CSWaitStrategy instance
   */
  public ignoring(...exceptions: Array<typeof Error>): CSWaitStrategy<T> {
    this.ignoredExceptions = this.ignoredExceptions.concat(exceptions);
    return this;
  }
  
  /**
   * Creates a new wait strategy that is the logical NOT of this strategy.
   * @returns A new CSWaitStrategy instance
   */
  public not(): CSWaitStrategy<boolean> {
    const condition = this.getCondition();
    const notCondition = new Condition<boolean>(
      `not(${this.name})`,
      async (driver: WebDriver): Promise<boolean> => {
        try {
          // If the original condition is met, return false, otherwise true
          await condition.fn(driver);
          return false;
        } catch (error) {
          // If the original condition throws, it's not met, so return true
          return true;
        }
      }
    );
    
    return new NotWaitStrategy(this, {
      timeout: this.timeout,
      pollingInterval: this.pollingInterval,
      message: `Not: ${this.timeoutMessage}`,
      ignoredExceptions: this.ignoredExceptions,
      retryOptions: this.retryOptions,
      failFast: this.failFast,
      screenshotOnFailure: this.screenshotOnFailure,
      logger: this.logger
    });
  }
  
  /**
   * Creates a new wait strategy that is the logical AND of this strategy and another.
   * @param other The other wait strategy
   * @returns A new CSWaitStrategy instance
   */
  public and<U>(other: CSWaitStrategy<U>): CSWaitStrategy<boolean> {
    return new AndWaitStrategy(this, other, {
      timeout: Math.min(this.timeout, other.getTimeout()),
      pollingInterval: Math.min(this.pollingInterval, other.getPollingInterval()),
      message: `${this.timeoutMessage} AND ${other.getTimeoutMessage()}`,
      ignoredExceptions: this.ignoredExceptions,
      retryOptions: this.retryOptions,
      failFast: this.failFast,
      screenshotOnFailure: this.screenshotOnFailure,
      logger: this.logger
    });
  }
  
  /**
   * Creates a new wait strategy that is the logical OR of this strategy and another.
   * @param other The other wait strategy
   * @returns A new CSWaitStrategy instance
   */
  public or<U>(other: CSWaitStrategy<U>): CSWaitStrategy<boolean> {
    return new OrWaitStrategy(this, other, {
      timeout: Math.max(this.timeout, other.getTimeout()),
      pollingInterval: Math.min(this.pollingInterval, other.getPollingInterval()),
      message: `${this.timeoutMessage} OR ${other.getTimeoutMessage()}`,
      ignoredExceptions: [...this.ignoredExceptions],
      retryOptions: this.retryOptions,
      failFast: this.failFast,
      screenshotOnFailure: this.screenshotOnFailure,
      logger: this.logger
    });
  }
  
  /**
   * Creates a new wait strategy that transforms the result of this strategy.
   * @param transform The transformation function
   * @returns A new CSWaitStrategy instance
   */
  public map<U>(transform: (value: T) => U): CSWaitStrategy<U> {
    return new MapWaitStrategy(this, transform, {
      timeout: this.timeout,
      pollingInterval: this.pollingInterval,
      message: this.timeoutMessage,
      ignoredExceptions: this.ignoredExceptions,
      retryOptions: this.retryOptions,
      failFast: this.failFast,
      screenshotOnFailure: this.screenshotOnFailure,
      logger: this.logger
    });
  }
  
  /**
   * Checks if the condition is currently met without waiting.
   * @param driver The WebDriver instance
   * @returns A Promise that resolves to true if the condition is met, false otherwise
   */
  public async isConditionMet(driver: WebDriver): Promise<boolean> {
    try {
      await this.getCondition().fn(driver);
      return true;
    } catch (error) {
      return false;
    }
  }
  
  /**
   * Performs the wait operation using the provided WebDriver.
   * @param driver The WebDriver instance
   * @returns A Promise that resolves to the wait result
   */
  public async wait(driver: WebDriver): Promise<T> {
    try {
      const condition = this.getCondition();
      
      // Configure the wait
      let wait = driver.wait(condition, this.timeout, this.timeoutMessage)
        .catch((error) => this.handleWaitError(driver, error));
      
      // Apply ignoring if specified
      if (this.ignoredExceptions.length > 0) {
        for (const exception of this.ignoredExceptions) {
          wait = wait.ignoring(exception);
        }
      }
      
      // Perform the wait
      return await wait;
    } catch (error) {
      // Handle any errors that weren't caught by the wait catch handler
      return this.handleWaitError(driver, error as Error);
    }
  }
  
  /**
   * Handles errors that occur during the wait operation.
   * @param driver The WebDriver instance
   * @param error The error that occurred
   * @returns A Promise that resolves to the wait result or rejects with the error
   */
  protected async handleWaitError(driver: WebDriver, error: Error): Promise<T> {
    // Take a screenshot if configured to do so
    if (this.screenshotOnFailure) {
      try {
        const screenshotPath = await this.screenshotManager.takeScreenshot(
          driver, 
          `wait_${this.name.replace(/\s+/g, '_').toLowerCase()}_failed`
        );
        this.logger.debug(`Screenshot saved to ${screenshotPath}`);
      } catch (screenshotError) {
        this.logger.warn(`Failed to take screenshot: ${screenshotError}`);
      }
    }
    
    // Check if we should retry
    if (this.retryOptions && this.shouldRetry(error)) {
      return this.retryWait(driver, error);
    }
    
    // Log the error
    if (error instanceof SeleniumError.TimeoutError) {
      this.logger.error(`Wait timeout: ${this.timeoutMessage}`);
    } else {
      this.logger.error(`Wait error: ${error.message}`);
    }
    
    // Rethrow the error
    throw error;
  }
  
  /**
   * Determines if a wait operation should be retried based on the error.
   * @param error The error that occurred
   * @returns True if the wait should be retried, false otherwise
   */
  protected shouldRetry(error: Error): boolean {
    // Don't retry if fail fast is enabled
    if (this.failFast) {
      return false;
    }
    
    // Only retry on timeout errors by default
    return error instanceof SeleniumError.TimeoutError;
  }
  
  /**
   * Retries the wait operation using the configured retry options.
   * @param driver The WebDriver instance
   * @param error The error that caused the retry
   * @returns A Promise that resolves to the wait result
   */
  protected async retryWait(driver: WebDriver, error: Error): Promise<T> {
    if (!this.retryOptions) {
      throw error;
    }
    
    let retryCount = 0;
    let lastError = error;
    let interval = this.retryOptions.interval;
    
    while (retryCount < this.retryOptions.count) {
      // Call before retry callback if specified
      if (this.retryOptions.beforeRetry) {
        await this.retryOptions.beforeRetry(retryCount, lastError);
      }
      
      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, interval));
      
      // Increase interval if using exponential backoff
      if (this.retryOptions.exponentialBackoff && this.retryOptions.backoffFactor) {
        interval *= this.retryOptions.backoffFactor;
      }
      
      try {
        // Try the wait again
        const condition = this.getCondition();
        return await driver.wait(condition, this.timeout, this.timeoutMessage);
      } catch (e) {
        // Store the error
        lastError = e as Error;
        
        // Call after retry failed callback if specified
        if (this.retryOptions.afterRetryFailed) {
          await this.retryOptions.afterRetryFailed(retryCount, lastError);
        }
        
        // Log the retry attempt
        this.logger.debug(`Retry ${retryCount + 1}/${this.retryOptions.count} failed: ${lastError.message}`);
        
        // Increment retry count
        retryCount++;
      }
    }
    
    // All retries failed, throw the last error
    this.logger.error(`All ${this.retryOptions.count} retries failed for ${this.name}`);
    throw lastError;
  }
}

/**
 * Strategy that inverts the result of another strategy (logical NOT).
 */
class NotWaitStrategy extends CSAbstractWaitStrategy<boolean> {
  /**
   * The original strategy.
   */
  private originalStrategy: CSWaitStrategy<any>;
  
  /**
   * Creates a new NotWaitStrategy instance.
   * @param originalStrategy The original strategy to invert
   * @param config The wait configuration
   */
  constructor(originalStrategy: CSWaitStrategy<any>, config?: Partial<WaitConfig>) {
    super(`not(${originalStrategy.getName()})`, config);
    this.originalStrategy = originalStrategy;
  }
  
  /**
   * Gets the Selenium Condition object that represents this strategy.
   * @returns The Condition object
   */
  public getCondition(): Condition<boolean> {
    const originalCondition = this.originalStrategy.getCondition();
    
    return new Condition<boolean>(
      this.name,
      async (driver: WebDriver): Promise<boolean> => {
        try {
          // If the original condition is met, return false, otherwise true
          await originalCondition.fn(driver);
          return false;
        } catch (error) {
          // If the original condition throws, it's not met, so return true
          return true;
        }
      }
    );
  }
}

/**
 * Strategy that combines two strategies with logical AND.
 */
class AndWaitStrategy extends CSAbstractWaitStrategy<boolean> {
  /**
   * The first strategy.
   */
  private strategy1: CSWaitStrategy<any>;
  
  /**
   * The second strategy.
   */
  private strategy2: CSWaitStrategy<any>;
  
  /**
   * Creates a new AndWaitStrategy instance.
   * @param strategy1 The first strategy
   * @param strategy2 The second strategy
   * @param config The wait configuration
   */
  constructor(
    strategy1: CSWaitStrategy<any>,
    strategy2: CSWaitStrategy<any>,
    config?: Partial<WaitConfig>
  ) {
    super(`${strategy1.getName()} AND ${strategy2.getName()}`, config);
    this.strategy1 = strategy1;
    this.strategy2 = strategy2;
  }
  
  /**
   * Gets the Selenium Condition object that represents this strategy.
   * @returns The Condition object
   */
  public getCondition(): Condition<boolean> {
    const condition1 = this.strategy1.getCondition();
    const condition2 = this.strategy2.getCondition();
    
    return new Condition<boolean>(
      this.name,
      async (driver: WebDriver): Promise<boolean> => {
        // Check the first condition
        try {
          await condition1.fn(driver);
        } catch (error) {
          // First condition is not met, return false
          return false;
        }
        
        // Check the second condition
        try {
          await condition2.fn(driver);
          // Both conditions are met, return true
          return true;
        } catch (error) {
          // Second condition is not met, return false
          return false;
        }
      }
    );
  }
}

/**
 * Strategy that combines two strategies with logical OR.
 */
class OrWaitStrategy extends CSAbstractWaitStrategy<boolean> {
  /**
   * The first strategy.
   */
  private strategy1: CSWaitStrategy<any>;
  
  /**
   * The second strategy.
   */
  private strategy2: CSWaitStrategy<any>;
  
  /**
   * Creates a new OrWaitStrategy instance.
   * @param strategy1 The first strategy
   * @param strategy2 The second strategy
   * @param config The wait configuration
   */
  constructor(
    strategy1: CSWaitStrategy<any>,
    strategy2: CSWaitStrategy<any>,
    config?: Partial<WaitConfig>
  ) {
    super(`${strategy1.getName()} OR ${strategy2.getName()}`, config);
    this.strategy1 = strategy1;
    this.strategy2 = strategy2;
  }
  
  /**
   * Gets the Selenium Condition object that represents this strategy.
   * @returns The Condition object
   */
  public getCondition(): Condition<boolean> {
    const condition1 = this.strategy1.getCondition();
    const condition2 = this.strategy2.getCondition();
    
    return new Condition<boolean>(
      this.name,
      async (driver: WebDriver): Promise<boolean> => {
        // Check the first condition
        try {
          await condition1.fn(driver);
          // First condition is met, return true
          return true;
        } catch (error1) {
          // First condition is not met, check the second condition
          try {
            await condition2.fn(driver);
            // Second condition is met, return true
            return true;
          } catch (error2) {
            // Both conditions are not met, return false
            return false;
          }
        }
      }
    );
  }
}

/**
 * Strategy that transforms the result of another strategy.
 */
class MapWaitStrategy<T, U> extends CSAbstractWaitStrategy<U> {
  /**
   * The original strategy.
   */
  private originalStrategy: CSWaitStrategy<T>;
  
  /**
   * The transformation function.
   */
  private transform: (value: T) => U;
  
  /**
   * Creates a new MapWaitStrategy instance.
   * @param originalStrategy The original strategy to transform
   * @param transform The transformation function
   * @param config The wait configuration
   */
  constructor(
    originalStrategy: CSWaitStrategy<T>,
    transform: (value: T) => U,
    config?: Partial<WaitConfig>
  ) {
    super(`map(${originalStrategy.getName()})`, config);
    this.originalStrategy = originalStrategy;
    this.transform = transform;
  }
  
  /**
   * Gets the Selenium Condition object that represents this strategy.
   * @returns The Condition object
   */
  public getCondition(): Condition<U> {
    const originalCondition = this.originalStrategy.getCondition();
    
    return new Condition<U>(
      this.name,
      async (driver: WebDriver): Promise<U> => {
        // Get the result from the original condition
        const originalResult = await originalCondition.fn(driver);
        
        // Transform the result
        return this.transform(originalResult);
      }
    );
  }
}

/**
 * Factory function to create a wait strategy that waits for a condition to be true.
 * @param name The name of the strategy
 * @param conditionFn The condition function
 * @param config The wait configuration
 * @returns A new CSWaitStrategy instance
 */
export function waitFor<T>(
  name: string,
  conditionFn: (driver: WebDriver) => Promise<T>,
  config?: Partial<WaitConfig>
): CSWaitStrategy<T> {
  return new GenericWaitStrategy<T>(name, conditionFn, config);
}

/**
 * Factory function to create a wait strategy that waits for an element.
 * @param elementFinder The element finder function
 * @param config The wait configuration
 * @returns A new CSWaitStrategy instance
 */
export function waitForElement(
  elementFinder: (driver: WebDriver) => Promise<WebElement>,
  config?: Partial<WaitConfig>
): CSWaitStrategy<WebElement> {
  return new ElementWaitStrategy(elementFinder, config);
}

/**
 * Generic wait strategy implementation.
 */
class GenericWaitStrategy<T> extends CSAbstractWaitStrategy<T> {
  /**
   * The condition function.
   */
  private conditionFn: (driver: WebDriver) => Promise<T>;
  
  /**
   * Creates a new GenericWaitStrategy instance.
   * @param name The name of the strategy
   * @param conditionFn The condition function
   * @param config The wait configuration
   */
  constructor(
    name: string,
    conditionFn: (driver: WebDriver) => Promise<T>,
    config?: Partial<WaitConfig>
  ) {
    super(name, config);
    this.conditionFn = conditionFn;
  }
  
  /**
   * Gets the Selenium Condition object that represents this strategy.
   * @returns The Condition object
   */
  public getCondition(): Condition<T> {
    return new Condition<T>(this.name, this.conditionFn);
  }
}

/**
 * Strategy that waits for an element.
 */
class ElementWaitStrategy extends CSAbstractWaitStrategy<WebElement> {
  /**
   * The element finder function.
   */
  private elementFinder: (driver: WebDriver) => Promise<WebElement>;
  
  /**
   * Creates a new ElementWaitStrategy instance.
   * @param elementFinder The element finder function
   * @param config The wait configuration
   */
  constructor(
    elementFinder: (driver: WebDriver) => Promise<WebElement>,
    config?: Partial<WaitConfig>
  ) {
    super('element', config);
    this.elementFinder = elementFinder;
  }
  
  /**
   * Gets the Selenium Condition object that represents this strategy.
   * @returns The Condition object
   */
  public getCondition(): Condition<WebElement> {
    return new Condition<WebElement>(
      this.name,
      async (driver: WebDriver): Promise<WebElement> => {
        return this.elementFinder(driver);
      }
    );
  }
}


CSVisibilityWait.ts
------------------------

import { WebDriver, WebElement, By, Condition, until, error as SeleniumError } from 'selenium-webdriver';
import { CSAbstractWaitStrategy } from './CSAbstractWaitStrategy';
import { WaitConfig, ElementFinder } from './CSWaitStrategy';
import { CSLogger } from '../../core/utils/CSLogger';

/**
 * Wait strategy that waits for an element to be visible in the DOM.
 * An element is considered visible if it is displayed and has
 * a width and height greater than 0.
 */
export class CSVisibilityWait extends CSAbstractWaitStrategy<WebElement> {
  /**
   * The element or locator to wait for.
   */
  private elementOrLocator: WebElement | By | ElementFinder;
  
  /**
   * Whether to check for computed visibility (opacity, display, visibility).
   */
  private checkComputedVisibility: boolean;
  
  /**
   * Whether to check for element dimensions.
   */
  private checkDimensions: boolean;
  
  /**
   * Whether to check for element viewport visibility.
   */
  private checkViewportVisibility: boolean;
  
  /**
   * The viewport visibility threshold (0.0 to 1.0).
   */
  private viewportVisibilityThreshold: number;
  
  /**
   * Creates a new CSVisibilityWait instance.
   * @param elementOrLocator The element or locator to wait for
   * @param config The wait configuration
   */
  constructor(
    elementOrLocator: WebElement | By | ElementFinder,
    config?: Partial<WaitConfig> & {
      checkComputedVisibility?: boolean;
      checkDimensions?: boolean;
      checkViewportVisibility?: boolean;
      viewportVisibilityThreshold?: number;
    }
  ) {
    super('element visibility', config);
    this.elementOrLocator = elementOrLocator;
    this.checkComputedVisibility = config?.checkComputedVisibility !== false;
    this.checkDimensions = config?.checkDimensions !== false;
    this.checkViewportVisibility = config?.checkViewportVisibility || false;
    this.viewportVisibilityThreshold = config?.viewportVisibilityThreshold || 0.1; // 10% by default
    
    // Set appropriate timeout message based on the element or locator
    if (elementOrLocator instanceof WebElement) {
      this.timeoutMessage = `Timed out waiting for element to be visible after ${this.timeout}ms`;
    } else if (elementOrLocator instanceof By) {
      this.timeoutMessage = `Timed out waiting for element located by ${elementOrLocator.toString()} to be visible after ${this.timeout}ms`;
    } else {
      this.timeoutMessage = `Timed out waiting for element to be visible after ${this.timeout}ms`;
    }
    
    // Add appropriate ignored exceptions
    this.ignoredExceptions.push(SeleniumError.NoSuchElementError);
    this.ignoredExceptions.push(SeleniumError.StaleElementReferenceError);
  }
  
  /**
   * Gets the Selenium Condition object that represents this strategy.
   * @returns The Condition object
   */
  public getCondition(): Condition<WebElement> {
    return new Condition<WebElement>(
      this.name,
      async (driver: WebDriver): Promise<WebElement> => {
        try {
          // Get the element
          const element = await this.findElement(driver);
          
          // Check if the element is displayed
          const isDisplayed = await element.isDisplayed();
          if (!isDisplayed) {
            throw new Error('Element is not displayed');
          }
          
          // Perform additional checks if required
          if (this.checkComputedVisibility || this.checkDimensions || this.checkViewportVisibility) {
            await this.performAdditionalChecks(driver, element);
          }
          
          return element;
        } catch (error) {
          if (error instanceof SeleniumError.NoSuchElementError) {
            throw new Error(`Element not found: ${error.message}`);
          } else if (error instanceof SeleniumError.StaleElementReferenceError) {
            throw new Error(`Element is stale: ${error.message}`);
          } else {
            throw error;
          }
        }
      }
    );
  }
  
  /**
   * Finds the element based on the elementOrLocator.
   * @param driver The WebDriver instance
   * @returns The WebElement
   */
  private async findElement(driver: WebDriver): Promise<WebElement> {
    if (this.elementOrLocator instanceof WebElement) {
      return this.elementOrLocator;
    } else if (this.elementOrLocator instanceof By) {
      return driver.findElement(this.elementOrLocator);
    } else {
      return this.elementOrLocator(driver);
    }
  }
  
  /**
   * Performs additional visibility checks beyond the basic isDisplayed() check.
   * @param driver The WebDriver instance
   * @param element The WebElement to check
   */
  private async performAdditionalChecks(driver: WebDriver, element: WebElement): Promise<void> {
    // Check computed visibility (CSS properties)
    if (this.checkComputedVisibility) {
      await this.checkComputedVisibilityProperties(driver, element);
    }
    
    // Check dimensions
    if (this.checkDimensions) {
      await this.checkElementDimensions(element);
    }
    
    // Check viewport visibility
    if (this.checkViewportVisibility) {
      await this.checkElementViewportVisibility(driver, element);
    }
  }
  
  /**
   * Checks if the element has appropriate CSS visibility properties.
   * @param driver The WebDriver instance
   * @param element The WebElement to check
   */
  private async checkComputedVisibilityProperties(driver: WebDriver, element: WebElement): Promise<void> {
    // Execute JavaScript to check computed styles
    const visibilityResult = await driver.executeScript<{visible: boolean, reason?: string}>(
      `
      function isVisibleByComputedStyle(element) {
        const styles = window.getComputedStyle(element);
        
        // Check visibility property
        if (styles.visibility === 'hidden' || styles.visibility === 'collapse') {
          return { visible: false, reason: 'CSS visibility: ' + styles.visibility };
        }
        
        // Check display property
        if (styles.display === 'none') {
          return { visible: false, reason: 'CSS display: none' };
        }
        
        // Check opacity property
        if (parseFloat(styles.opacity) < 0.1) {
          return { visible: false, reason: 'CSS opacity: ' + styles.opacity };
        }
        
        // Check if element or any ancestor has overflow: hidden and the element is outside the overflow
        let currentElement = element;
        let parent = element.parentElement;
        
        while (parent) {
          const parentStyles = window.getComputedStyle(parent);
          if (parentStyles.overflow === 'hidden' || parentStyles.overflowY === 'hidden' || parentStyles.overflowX === 'hidden') {
            const parentRect = parent.getBoundingClientRect();
            const elementRect = currentElement.getBoundingClientRect();
            
            // Check if the element is completely outside the parent bounds
            if (elementRect.bottom < parentRect.top || 
                elementRect.top > parentRect.bottom ||
                elementRect.right < parentRect.left ||
                elementRect.left > parentRect.right) {
              return { visible: false, reason: 'Outside overflow: hidden container' };
            }
          }
          
          currentElement = parent;
          parent = parent.parentElement;
        }
        
        return { visible: true };
      }
      
      return isVisibleByComputedStyle(arguments[0]);
      `,
      element
    );
    
    if (!visibilityResult.visible) {
      throw new Error(`Element has invisible CSS properties: ${visibilityResult.reason}`);
    }
  }
  
  /**
   * Checks if the element has non-zero dimensions.
   * @param element The WebElement to check
   */
  private async checkElementDimensions(element: WebElement): Promise<void> {
    const rect = await element.getRect();
    
    if (rect.width <= 0 || rect.height <= 0) {
      throw new Error(`Element has zero dimensions: width=${rect.width}, height=${rect.height}`);
    }
  }
  
  /**
   * Checks if the element is visible in the viewport.
   * @param driver The WebDriver instance
   * @param element The WebElement to check
   */
  private async checkElementViewportVisibility(driver: WebDriver, element: WebElement): Promise<void> {
    // Execute JavaScript to check viewport visibility
    const viewportResult = await driver.executeScript<{visible: boolean, visibleRatio: number, reason?: string}>(
      `
      function isVisibleInViewport(element, threshold) {
        // Get element and viewport dimensions
        const rect = element.getBoundingClientRect();
        const windowHeight = window.innerHeight || document.documentElement.clientHeight;
        const windowWidth = window.innerWidth || document.documentElement.clientWidth;
        
        // Element dimensions
        const elementWidth = rect.width;
        const elementHeight = rect.height;
        const elementArea = elementWidth * elementHeight;
        
        if (elementArea === 0) {
          return { visible: false, visibleRatio: 0, reason: 'Element has zero area' };
        }
        
        // Calculate the visible part of the element
        const visibleLeft = Math.max(0, Math.min(rect.right, windowWidth) - Math.max(rect.left, 0));
        const visibleTop = Math.max(0, Math.min(rect.bottom, windowHeight) - Math.max(rect.top, 0));
        const visibleArea = visibleLeft * visibleTop;
        
        // Calculate the ratio of visible area to total area
        const visibleRatio = visibleArea / elementArea;
        
        // Check if the visible ratio exceeds the threshold
        if (visibleRatio < threshold) {
          return { 
            visible: false, 
            visibleRatio: visibleRatio, 
            reason: 'Element is not sufficiently visible in viewport: ' + (visibleRatio * 100).toFixed(1) + '% visible' 
          };
        }
        
        return { visible: true, visibleRatio: visibleRatio };
      }
      
      return isVisibleInViewport(arguments[0], arguments[1]);
      `,
      element,
      this.viewportVisibilityThreshold
    );
    
    if (!viewportResult.visible) {
      throw new Error(`Element is not sufficiently visible in viewport: ${viewportResult.reason}`);
    }
  }
  
  /**
   * Sets whether to check for computed visibility.
   * @param check Whether to check computed visibility
   * @returns This CSVisibilityWait instance
   */
  public withComputedVisibilityCheck(check: boolean): CSVisibilityWait {
    this.checkComputedVisibility = check;
    return this;
  }
  
  /**
   * Sets whether to check for element dimensions.
   * @param check Whether to check element dimensions
   * @returns This CSVisibilityWait instance
   */
  public withDimensionsCheck(check: boolean): CSVisibilityWait {
    this.checkDimensions = check;
    return this;
  }
  
  /**
   * Sets whether to check for element viewport visibility.
   * @param check Whether to check viewport visibility
   * @returns This CSVisibilityWait instance
   */
  public withViewportVisibilityCheck(check: boolean): CSVisibilityWait {
    this.checkViewportVisibility = check;
    return this;
  }
  
  /**
   * Sets the viewport visibility threshold.
   * @param threshold The visibility threshold (0.0 to 1.0)
   * @returns This CSVisibilityWait instance
   */
  public withViewportVisibilityThreshold(threshold: number): CSVisibilityWait {
    if (threshold < 0 || threshold > 1) {
      throw new Error('Viewport visibility threshold must be between 0.0 and 1.0');
    }
    
    this.viewportVisibilityThreshold = threshold;
    return this;
  }
  
  /**
   * Factory method to create a new CSVisibilityWait instance for a WebElement.
   * @param element The WebElement to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSVisibilityWait instance
   */
  public static forElement(element: WebElement, timeout?: number): CSVisibilityWait {
    return new CSVisibilityWait(element, { timeout });
  }
  
  /**
   * Factory method to create a new CSVisibilityWait instance for a locator.
   * @param locator The locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSVisibilityWait instance
   */
  public static forLocator(locator: By, timeout?: number): CSVisibilityWait {
    return new CSVisibilityWait(locator, { timeout });
  }
  
  /**
   * Factory method to create a new CSVisibilityWait instance for an element finder.
   * @param finder The element finder function
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSVisibilityWait instance
   */
  public static forFinder(finder: ElementFinder, timeout?: number): CSVisibilityWait {
    return new CSVisibilityWait(finder, { timeout });
  }
  
  /**
   * Factory method to create a new CSVisibilityWait instance with enhanced visibility checks.
   * @param elementOrLocator The element or locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSVisibilityWait instance
   */
  public static enhanced(
    elementOrLocator: WebElement | By | ElementFinder,
    timeout?: number
  ): CSVisibilityWait {
    return new CSVisibilityWait(elementOrLocator, {
      timeout,
      checkComputedVisibility: true,
      checkDimensions: true,
      checkViewportVisibility: true,
      viewportVisibilityThreshold: 0.1
    });
  }
  
  /**
   * Factory method to create a new CSVisibilityWait instance with full visibility checks.
   * @param elementOrLocator The element or locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSVisibilityWait instance
   */
  public static full(
    elementOrLocator: WebElement | By | ElementFinder,
    timeout?: number
  ): CSVisibilityWait {
    return new CSVisibilityWait(elementOrLocator, {
      timeout,
      checkComputedVisibility: true,
      checkDimensions: true,
      checkViewportVisibility: true,
      viewportVisibilityThreshold: 0.5 // 50% visibility
    });
  }
}


CSClickableWait.ts
-------------------------------

import { WebDriver, WebElement, By, Condition, error as SeleniumError } from 'selenium-webdriver';
import { CSAbstractWaitStrategy } from './CSAbstractWaitStrategy';
import { WaitConfig, ElementFinder } from './CSWaitStrategy';
import { CSVisibilityWait } from './CSVisibilityWait';
import { CSLogger } from '../../core/utils/CSLogger';

/**
 * Wait strategy that waits for an element to be clickable.
 * An element is considered clickable if it is visible, enabled,
 * and not obscured by other elements.
 */
export class CSClickableWait extends CSAbstractWaitStrategy<WebElement> {
  /**
   * The element or locator to wait for.
   */
  private elementOrLocator: WebElement | By | ElementFinder;
  
  /**
   * Whether to check if the element is enabled.
   */
  private checkEnabled: boolean;
  
  /**
   * Whether to check if the element is visible.
   */
  private checkVisible: boolean;
  
  /**
   * Whether to check if the element is not obscured by other elements.
   */
  private checkNotObscured: boolean;
  
  /**
   * Whether to check if the element has appropriate pointer events.
   */
  private checkPointerEvents: boolean;
  
  /**
   * Whether to check if the element is within the viewport.
   */
  private checkWithinViewport: boolean;
  
  /**
   * Whether to check if the element has sufficient size for clicking.
   */
  private checkSufficientSize: boolean;
  
  /**
   * The minimum size (width or height) in pixels for an element to be considered clickable.
   */
  private minimumElementSize: number;
  
  /**
   * Whether to check if the element has an appropriate tag for clicking.
   */
  private checkAppropriateTag: boolean;
  
  /**
   * Tags that are considered appropriate for clicking.
   */
  private static readonly CLICKABLE_TAGS: string[] = [
    'a', 'button', 'input', 'select', 'textarea', 'label', 'div', 'span', 'img', 'li', 'option'
  ];
  
  /**
   * Creates a new CSClickableWait instance.
   * @param elementOrLocator The element or locator to wait for
   * @param config The wait configuration
   */
  constructor(
    elementOrLocator: WebElement | By | ElementFinder,
    config?: Partial<WaitConfig> & {
      checkEnabled?: boolean;
      checkVisible?: boolean;
      checkNotObscured?: boolean;
      checkPointerEvents?: boolean;
      checkWithinViewport?: boolean;
      checkSufficientSize?: boolean;
      minimumElementSize?: number;
      checkAppropriateTag?: boolean;
    }
  ) {
    super('element clickable', config);
    this.elementOrLocator = elementOrLocator;
    this.checkEnabled = config?.checkEnabled !== false;
    this.checkVisible = config?.checkVisible !== false;
    this.checkNotObscured = config?.checkNotObscured !== false;
    this.checkPointerEvents = config?.checkPointerEvents || false;
    this.checkWithinViewport = config?.checkWithinViewport || false;
    this.checkSufficientSize = config?.checkSufficientSize || false;
    this.minimumElementSize = config?.minimumElementSize || 5; // 5px minimum size
    this.checkAppropriateTag = config?.checkAppropriateTag || false;
    
    // Set appropriate timeout message based on the element or locator
    if (elementOrLocator instanceof WebElement) {
      this.timeoutMessage = `Timed out waiting for element to be clickable after ${this.timeout}ms`;
    } else if (elementOrLocator instanceof By) {
      this.timeoutMessage = `Timed out waiting for element located by ${elementOrLocator.toString()} to be clickable after ${this.timeout}ms`;
    } else {
      this.timeoutMessage = `Timed out waiting for element to be clickable after ${this.timeout}ms`;
    }
    
    // Add appropriate ignored exceptions
    this.ignoredExceptions.push(SeleniumError.NoSuchElementError);
    this.ignoredExceptions.push(SeleniumError.StaleElementReferenceError);
    this.ignoredExceptions.push(SeleniumError.ElementNotInteractableError);
  }
  
  /**
   * Gets the Selenium Condition object that represents this strategy.
   * @returns The Condition object
   */
  public getCondition(): Condition<WebElement> {
    return new Condition<WebElement>(
      this.name,
      async (driver: WebDriver): Promise<WebElement> => {
        try {
          // Get the element
          const element = await this.findElement(driver);
          
          // Check if the element is visible if required
          if (this.checkVisible) {
            await this.checkElementVisible(driver, element);
          }
          
          // Check if the element is enabled if required
          if (this.checkEnabled) {
            await this.checkElementEnabled(element);
          }
          
          // Check if the element is not obscured if required
          if (this.checkNotObscured) {
            await this.checkElementNotObscured(driver, element);
          }
          
          // Check if the element has appropriate pointer events if required
          if (this.checkPointerEvents) {
            await this.checkElementPointerEvents(driver, element);
          }
          
          // Check if the element is within the viewport if required
          if (this.checkWithinViewport) {
            await this.checkElementWithinViewport(driver, element);
          }
          
          // Check if the element has sufficient size if required
          if (this.checkSufficientSize) {
            await this.checkElementSufficientSize(element);
          }
          
          // Check if the element has an appropriate tag if required
          if (this.checkAppropriateTag) {
            await this.checkElementAppropriateTag(element);
          }
          
          return element;
        } catch (error) {
          if (error instanceof SeleniumError.NoSuchElementError) {
            throw new Error(`Element not found: ${error.message}`);
          } else if (error instanceof SeleniumError.StaleElementReferenceError) {
            throw new Error(`Element is stale: ${error.message}`);
          } else if (error instanceof SeleniumError.ElementNotInteractableError) {
            throw new Error(`Element is not interactable: ${error.message}`);
          } else {
            throw error;
          }
        }
      }
    );
  }
  
  /**
   * Finds the element based on the elementOrLocator.
   * @param driver The WebDriver instance
   * @returns The WebElement
   */
  private async findElement(driver: WebDriver): Promise<WebElement> {
    if (this.elementOrLocator instanceof WebElement) {
      return this.elementOrLocator;
    } else if (this.elementOrLocator instanceof By) {
      return driver.findElement(this.elementOrLocator);
    } else {
      return this.elementOrLocator(driver);
    }
  }
  
  /**
   * Checks if the element is visible.
   * @param driver The WebDriver instance
   * @param element The WebElement to check
   */
  private async checkElementVisible(driver: WebDriver, element: WebElement): Promise<void> {
    // Use CSVisibilityWait to check element visibility
    const visibilityWait = new CSVisibilityWait(element, {
      timeout: this.pollingInterval, // Use a short timeout since we're already in a wait
      logger: this.logger,
      checkComputedVisibility: true
    });
    
    try {
      await visibilityWait.wait(driver);
    } catch (error) {
      throw new Error(`Element is not visible: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Checks if the element is enabled.
   * @param element The WebElement to check
   */
  private async checkElementEnabled(element: WebElement): Promise<void> {
    const isEnabled = await element.isEnabled();
    
    if (!isEnabled) {
      throw new Error('Element is disabled');
    }
  }
  
  /**
   * Checks if the element is not obscured by other elements.
   * @param driver The WebDriver instance
   * @param element The WebElement to check
   */
  private async checkElementNotObscured(driver: WebDriver, element: WebElement): Promise<void> {
    // Execute JavaScript to check if the element is obscured
    const obscuredResult = await driver.executeScript<{
      obscured: boolean;
      obscuringElement?: string;
      obscuredRatio?: number;
      reason?: string;
    }>(
      `
      function isElementObscured(element) {
        // Get the element's center point
        const rect = element.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        // Get the element at the center point
        const topElement = document.elementFromPoint(centerX, centerY);
        
        // Check if the element is obscured at its center
        if (!topElement || !element.contains(topElement)) {
          // Element is fully obscured at center
          return { 
            obscured: true, 
            obscuringElement: topElement ? topElement.tagName.toLowerCase() : 'unknown',
            reason: 'Element is obscured at its center' 
          };
        }
        
        // Check multiple points for larger elements
        if (rect.width > 10 && rect.height > 10) {
          const points = [
            { x: rect.left + 5, y: rect.top + 5 },                      // Top-left
            { x: rect.right - 5, y: rect.top + 5 },                     // Top-right
            { x: rect.left + 5, y: rect.bottom - 5 },                   // Bottom-left
            { x: rect.right - 5, y: rect.bottom - 5 },                  // Bottom-right
            { x: rect.left + rect.width / 2, y: rect.top + 5 },         // Top-middle
            { x: rect.left + rect.width / 2, y: rect.bottom - 5 },      // Bottom-middle
            { x: rect.left + 5, y: rect.top + rect.height / 2 },        // Left-middle
            { x: rect.right - 5, y: rect.top + rect.height / 2 }        // Right-middle
          ];
          
          let obscuredPoints = 0;
          let obscuringElements = [];
          
          for (const point of points) {
            const elementAtPoint = document.elementFromPoint(point.x, point.y);
            if (!elementAtPoint || !element.contains(elementAtPoint)) {
              obscuredPoints++;
              obscuringElements.push(elementAtPoint ? elementAtPoint.tagName.toLowerCase() : 'unknown');
            }
          }
          
          const obscuredRatio = obscuredPoints / points.length;
          
          // If more than 50% of test points are obscured, consider the element obscured
          if (obscuredRatio > 0.5) {
            return {
              obscured: true,
              obscuringElement: obscuringElements.join(', '),
              obscuredRatio: obscuredRatio,
              reason: 'Element is obscured at multiple points'
            };
          }
        }
        
        // Check pointer-events CSS property
        const style = window.getComputedStyle(element);
        if (style.pointerEvents === 'none') {
          return {
            obscured: true,
            reason: 'Element has pointer-events: none'
          };
        }
        
        // Element is not obscured
        return { obscured: false };
      }
      
      return isElementObscured(arguments[0]);
      `,
      element
    );
    
    if (obscuredResult.obscured) {
      throw new Error(`Element is obscured: ${obscuredResult.reason}${
        obscuredResult.obscuringElement 
          ? ` by ${obscuredResult.obscuringElement}` 
          : ''
      }${
        obscuredResult.obscuredRatio 
          ? ` (${Math.round(obscuredResult.obscuredRatio * 100)}% obscured)` 
          : ''
      }`);
    }
  }
  
  /**
   * Checks if the element has appropriate pointer events.
   * @param driver The WebDriver instance
   * @param element The WebElement to check
   */
  private async checkElementPointerEvents(driver: WebDriver, element: WebElement): Promise<void> {
    // Execute JavaScript to check pointer events
    const pointerResult = await driver.executeScript<{
      clickable: boolean;
      reason?: string;
    }>(
      `
      function hasAppropriatePointerEvents(element) {
        const style = window.getComputedStyle(element);
        
        // Check if pointer-events is 'none'
        if (style.pointerEvents === 'none') {
          return { clickable: false, reason: 'Element has pointer-events: none' };
        }
        
        // Check if cursor is appropriate for clicking
        const cursor = style.cursor;
        const clickableCursors = ['pointer', 'hand', 'default'];
        
        if (!clickableCursors.includes(cursor) && cursor !== '') {
          return { clickable: true, reason: 'Warning: Element has non-standard cursor: ' + cursor };
        }
        
        // Check parent elements for pointer-events
        let parent = element.parentElement;
        while (parent) {
          const parentStyle = window.getComputedStyle(parent);
          if (parentStyle.pointerEvents === 'none') {
            return { clickable: false, reason: 'Parent element has pointer-events: none' };
          }
          parent = parent.parentElement;
        }
        
        // Check for click event handlers
        const hasClickHandler = element.onclick || 
                               element.getAttribute('onclick') || 
                               element.hasAttribute('ng-click') ||
                               element.hasAttribute('@click') ||
                               element.hasAttribute('v-on:click');
        
        // Special case for links with href
        const isLink = element.tagName.toLowerCase() === 'a' && element.hasAttribute('href');
        
        // Special case for form controls
        const isFormControl = ['button', 'input', 'select', 'textarea', 'option'].includes(element.tagName.toLowerCase());
        
        // Special case for elements with role="button"
        const hasButtonRole = element.getAttribute('role') === 'button';
        
        if (!hasClickHandler && !isLink && !isFormControl && !hasButtonRole) {
          return { clickable: true, reason: 'Warning: Element may not have click handlers' };
        }
        
        return { clickable: true };
      }
      
      return hasAppropriatePointerEvents(arguments[0]);
      `,
      element
    );
    
    if (!pointerResult.clickable) {
      throw new Error(`Element has inappropriate pointer events: ${pointerResult.reason}`);
    } else if (pointerResult.reason) {
      // Just log warning but don't fail
      this.logger.warn(pointerResult.reason);
    }
  }
  
  /**
   * Checks if the element is within the viewport.
   * @param driver The WebDriver instance
   * @param element The WebElement to check
   */
  private async checkElementWithinViewport(driver: WebDriver, element: WebElement): Promise<void> {
    // Execute JavaScript to check if the element is within the viewport
    const viewportResult = await driver.executeScript<{
      inViewport: boolean;
      reason?: string;
    }>(
      `
      function isElementInViewport(element) {
        // Get the element's bounding rectangle
        const rect = element.getBoundingClientRect();
        
        // Get the viewport dimensions
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
        
        // Element is partially outside viewport if any of these are true
        if (rect.left < 0) {
          return { inViewport: false, reason: 'Element extends beyond left edge of viewport' };
        }
        
        if (rect.top < 0) {
          return { inViewport: false, reason: 'Element extends beyond top edge of viewport' };
        }
        
        if (rect.right > viewportWidth) {
          return { inViewport: false, reason: 'Element extends beyond right edge of viewport' };
        }
        
        if (rect.bottom > viewportHeight) {
          return { inViewport: false, reason: 'Element extends beyond bottom edge of viewport' };
        }
        
        // Element is fully within viewport
        return { inViewport: true };
      }
      
      return isElementInViewport(arguments[0]);
      `,
      element
    );
    
    if (!viewportResult.inViewport) {
      throw new Error(`Element is not within viewport: ${viewportResult.reason}`);
    }
  }
  
  /**
   * Checks if the element has sufficient size for clicking.
   * @param element The WebElement to check
   */
  private async checkElementSufficientSize(element: WebElement): Promise<void> {
    const rect = await element.getRect();
    
    if (rect.width < this.minimumElementSize || rect.height < this.minimumElementSize) {
      throw new Error(`Element is too small to click reliably: width=${rect.width}px, height=${rect.height}px`);
    }
  }
  
  /**
   * Checks if the element has an appropriate tag for clicking.
   * @param element The WebElement to check
   */
  private async checkElementAppropriateTag(element: WebElement): Promise<void> {
    const tagName = await element.getTagName();
    
    if (!CSClickableWait.CLICKABLE_TAGS.includes(tagName.toLowerCase())) {
      // This is just a warning, not an error, since many elements can be clicked even if they're not typical clickable elements
      this.logger.warn(`Element has unconventional tag for clicking: ${tagName}`);
    }
    
    // Additional check for specific element types
    if (tagName.toLowerCase() === 'input') {
      const type = await element.getAttribute('type');
      
      if (type === 'hidden') {
        throw new Error('Element is a hidden input field and cannot be clicked');
      }
    }
  }
  
  /**
   * Sets whether to check if the element is enabled.
   * @param check Whether to check if the element is enabled
   * @returns This CSClickableWait instance
   */
  public withEnabledCheck(check: boolean): CSClickableWait {
    this.checkEnabled = check;
    return this;
  }
  
  /**
   * Sets whether to check if the element is visible.
   * @param check Whether to check if the element is visible
   * @returns This CSClickableWait instance
   */
  public withVisibilityCheck(check: boolean): CSClickableWait {
    this.checkVisible = check;
    return this;
  }
  
  /**
   * Sets whether to check if the element is not obscured.
   * @param check Whether to check if the element is not obscured
   * @returns This CSClickableWait instance
   */
  public withObscuredCheck(check: boolean): CSClickableWait {
    this.checkNotObscured = check;
    return this;
  }
  
  /**
   * Sets whether to check if the element has appropriate pointer events.
   * @param check Whether to check if the element has appropriate pointer events
   * @returns This CSClickableWait instance
   */
  public withPointerEventsCheck(check: boolean): CSClickableWait {
    this.checkPointerEvents = check;
    return this;
  }
  
  /**
   * Sets whether to check if the element is within the viewport.
   * @param check Whether to check if the element is within the viewport
   * @returns This CSClickableWait instance
   */
  public withViewportCheck(check: boolean): CSClickableWait {
    this.checkWithinViewport = check;
    return this;
  }
  
  /**
   * Sets whether to check if the element has sufficient size for clicking.
   * @param check Whether to check if the element has sufficient size
   * @returns This CSClickableWait instance
   */
  public withSizeSufficiencyCheck(check: boolean): CSClickableWait {
    this.checkSufficientSize = check;
    return this;
  }
  
  /**
   * Sets the minimum element size for clicking.
   * @param size The minimum size in pixels
   * @returns This CSClickableWait instance
   */
  public withMinimumElementSize(size: number): CSClickableWait {
    this.minimumElementSize = size;
    return this;
  }
  
  /**
   * Sets whether to check if the element has an appropriate tag for clicking.
   * @param check Whether to check if the element has an appropriate tag
   * @returns This CSClickableWait instance
   */
  public withAppropriateTagCheck(check: boolean): CSClickableWait {
    this.checkAppropriateTag = check;
    return this;
  }
  
  /**
   * Factory method to create a new CSClickableWait instance for a WebElement.
   * @param element The WebElement to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSClickableWait instance
   */
  public static forElement(element: WebElement, timeout?: number): CSClickableWait {
    return new CSClickableWait(element, { timeout });
  }
  
  /**
   * Factory method to create a new CSClickableWait instance for a locator.
   * @param locator The locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSClickableWait instance
   */
  public static forLocator(locator: By, timeout?: number): CSClickableWait {
    return new CSClickableWait(locator, { timeout });
  }
  
  /**
   * Factory method to create a new CSClickableWait instance for an element finder.
   * @param finder The element finder function
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSClickableWait instance
   */
  public static forFinder(finder: ElementFinder, timeout?: number): CSClickableWait {
    return new CSClickableWait(finder, { timeout });
  }
  
  /**
   * Factory method to create a new CSClickableWait instance with enhanced clickability checks.
   * @param elementOrLocator The element or locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSClickableWait instance
   */
  public static enhanced(
    elementOrLocator: WebElement | By | ElementFinder,
    timeout?: number
  ): CSClickableWait {
    return new CSClickableWait(elementOrLocator, {
      timeout,
      checkEnabled: true,
      checkVisible: true,
      checkNotObscured: true,
      checkPointerEvents: true,
      checkWithinViewport: false, // Not requiring viewport visibility for enhanced mode
      checkSufficientSize: true,
      minimumElementSize: 5,
      checkAppropriateTag: true
    });
  }
  
  /**
   * Factory method to create a new CSClickableWait instance with strict clickability checks.
   * @param elementOrLocator The element or locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSClickableWait instance
   */
  public static strict(
    elementOrLocator: WebElement | By | ElementFinder,
    timeout?: number
  ): CSClickableWait {
    return new CSClickableWait(elementOrLocator, {
      timeout,
      checkEnabled: true,
      checkVisible: true,
      checkNotObscured: true,
      checkPointerEvents: true,
      checkWithinViewport: true, // Requiring viewport visibility for strict mode
      checkSufficientSize: true,
      minimumElementSize: 10, // Larger minimum size for strict mode
      checkAppropriateTag: true
    });
  }
}



CSWaitFactory.ts
---------------------------

import { WebDriver, WebElement, By, Condition, until } from 'selenium-webdriver';
import { CSWaitStrategy, WaitConfig, ElementFinder } from './CSWaitStrategy';
import { CSVisibilityWait } from './CSVisibilityWait';
import { CSClickableWait } from './CSClickableWait';
import { CSPresenceWait } from './CSPresenceWait';
import { CSInvisibilityWait } from './CSInvisibilityWait';
import { CSTextWait } from './CSTextWait';
import { CSAttributeWait } from './CSAttributeWait';
import { CSLogger } from '../../core/utils/CSLogger';
import { ConfigurationManager } from '../../core/config/ConfigurationManager';

/**
 * Factory class for creating wait strategy instances.
 * Provides convenient methods for creating various wait strategies with 
 * configuration from the framework configuration.
 */
export class CSWaitFactory {
  /**
   * The logger instance.
   */
  private logger: CSLogger;
  
  /**
   * The configuration manager instance.
   */
  private configManager: ConfigurationManager;
  
  /**
   * The default timeout for wait strategies.
   */
  private defaultTimeout: number;
  
  /**
   * The default polling interval for wait strategies.
   */
  private defaultPollingInterval: number;
  
  /**
   * The default retry options for wait strategies.
   */
  private defaultRetryOptions: { enabled: boolean; count: number; interval: number; };
  
  /**
   * Creates a new CSWaitFactory instance.
   */
  constructor() {
    this.logger = new CSLogger('CSWaitFactory');
    this.configManager = ConfigurationManager.getInstance();
    
    // Get wait configuration from framework configuration
    const frameworkConfig = this.configManager.getFrameworkConfig();
    const waitConfig = frameworkConfig.wait || {};
    
    // Set default values
    this.defaultTimeout = waitConfig.timeout || 30000;
    this.defaultPollingInterval = waitConfig.pollingInterval || 500;
    
    // Set default retry options
    this.defaultRetryOptions = {
      enabled: waitConfig.retry?.enabled || false,
      count: waitConfig.retry?.count || 3,
      interval: waitConfig.retry?.interval || 1000
    };
    
    this.logger.debug('CSWaitFactory initialized with timeout=' + this.defaultTimeout + 
                     'ms, pollingInterval=' + this.defaultPollingInterval + 'ms');
  }
  
  /**
   * Creates a base wait configuration.
   * @param timeout The timeout in milliseconds (optional)
   * @returns The wait configuration
   */
  private createBaseConfig(timeout?: number): Partial<WaitConfig> {
    return {
      timeout: timeout || this.defaultTimeout,
      pollingInterval: this.defaultPollingInterval,
      logger: this.logger,
      retryOptions: this.defaultRetryOptions.enabled ? {
        count: this.defaultRetryOptions.count,
        interval: this.defaultRetryOptions.interval,
        exponentialBackoff: true,
        backoffFactor: 1.5
      } : undefined,
      screenshotOnFailure: true
    };
  }
  
  /**
   * Creates a visibility wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSVisibilityWait instance
   */
  public createVisibilityWait(
    elementOrLocator: WebElement | By | ElementFinder,
    timeout?: number
  ): CSVisibilityWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for visibility wait
    const visibilityConfig = {
      ...config,
      checkComputedVisibility: true,
      checkDimensions: true,
      checkViewportVisibility: false
    };
    
    return new CSVisibilityWait(elementOrLocator, visibilityConfig);
  }
  
  /**
   * Creates an enhanced visibility wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSVisibilityWait instance with enhanced checks
   */
  public createEnhancedVisibilityWait(
    elementOrLocator: WebElement | By | ElementFinder,
    timeout?: number
  ): CSVisibilityWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for enhanced visibility wait
    const enhancedConfig = {
      ...config,
      checkComputedVisibility: true,
      checkDimensions: true,
      checkViewportVisibility: true,
      viewportVisibilityThreshold: 0.1
    };
    
    return new CSVisibilityWait(elementOrLocator, enhancedConfig);
  }
  
  /**
   * Creates a clickable wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSClickableWait instance
   */
  public createClickableWait(
    elementOrLocator: WebElement | By | ElementFinder,
    timeout?: number
  ): CSClickableWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for clickable wait
    const clickableConfig = {
      ...config,
      checkEnabled: true,
      checkVisible: true,
      checkNotObscured: true,
      checkPointerEvents: false,
      checkWithinViewport: false,
      checkSufficientSize: false,
      checkAppropriateTag: false
    };
    
    return new CSClickableWait(elementOrLocator, clickableConfig);
  }
  
  /**
   * Creates an enhanced clickable wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSClickableWait instance with enhanced checks
   */
  public createEnhancedClickableWait(
    elementOrLocator: WebElement | By | ElementFinder,
    timeout?: number
  ): CSClickableWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for enhanced clickable wait
    const enhancedConfig = {
      ...config,
      checkEnabled: true,
      checkVisible: true,
      checkNotObscured: true,
      checkPointerEvents: true,
      checkWithinViewport: true,
      checkSufficientSize: true,
      minimumElementSize: 5,
      checkAppropriateTag: true
    };
    
    return new CSClickableWait(elementOrLocator, enhancedConfig);
  }
  
  /**
   * Creates a presence wait strategy for an element.
   * @param locator The locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSPresenceWait instance
   */
  public createPresenceWait(
    locator: By,
    timeout?: number
  ): CSPresenceWait {
    const config = this.createBaseConfig(timeout);
    
    return new CSPresenceWait(locator, config);
  }
  
  /**
   * Creates an invisibility wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSInvisibilityWait instance
   */
  public createInvisibilityWait(
    elementOrLocator: WebElement | By | ElementFinder,
    timeout?: number
  ): CSInvisibilityWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for invisibility wait
    const invisibilityConfig = {
      ...config,
      checkComputedVisibility: true,
      checkDimensions: false,
      checkViewportVisibility: false
    };
    
    return new CSInvisibilityWait(elementOrLocator, invisibilityConfig);
  }
  
  /**
   * Creates a text wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param text The text to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance
   */
  public createTextWait(
    elementOrLocator: WebElement | By | ElementFinder,
    text: string,
    timeout?: number
  ): CSTextWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for text wait
    const textConfig = {
      ...config,
      exact: false,
      caseSensitive: false,
      trim: true,
      normalizeWhitespace: true
    };
    
    return new CSTextWait(elementOrLocator, text, textConfig);
  }
  
  /**
   * Creates an exact text wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param text The exact text to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance with exact matching
   */
  public createExactTextWait(
    elementOrLocator: WebElement | By | ElementFinder,
    text: string,
    timeout?: number
  ): CSTextWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for exact text wait
    const exactTextConfig = {
      ...config,
      exact: true,
      caseSensitive: true,
      trim: true,
      normalizeWhitespace: true
    };
    
    return new CSTextWait(elementOrLocator, text, exactTextConfig);
  }
  
  /**
   * Creates a text contains wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param text The text to be contained
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance with contains matching
   */
  public createTextContainsWait(
    elementOrLocator: WebElement | By | ElementFinder,
    text: string,
    timeout?: number
  ): CSTextWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for text contains wait
    const textContainsConfig = {
      ...config,
      exact: false,
      caseSensitive: false,
      trim: true,
      normalizeWhitespace: true
    };
    
    return new CSTextWait(elementOrLocator, text, textContainsConfig);
  }
  
  /**
   * Creates a text matches wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param pattern The regular expression pattern to match
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance with regex matching
   */
  public createTextMatchesWait(
    elementOrLocator: WebElement | By | ElementFinder,
    pattern: RegExp,
    timeout?: number
  ): CSTextWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for text matches wait
    const textMatchesConfig = {
      ...config,
      regex: true,
      trim: true,
      normalizeWhitespace: true
    };
    
    return new CSTextWait(elementOrLocator, pattern.source, textMatchesConfig);
  }
  
  /**
   * Creates an attribute wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param attribute The attribute name
   * @param value The attribute value
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSAttributeWait instance
   */
  public createAttributeWait(
    elementOrLocator: WebElement | By | ElementFinder,
    attribute: string,
    value: string,
    timeout?: number
  ): CSAttributeWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for attribute wait
    const attributeConfig = {
      ...config,
      exact: true,
      caseSensitive: true
    };
    
    return new CSAttributeWait(elementOrLocator, attribute, value, attributeConfig);
  }
  
  /**
   * Creates an attribute contains wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param attribute The attribute name
   * @param value The attribute value to be contained
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSAttributeWait instance with contains matching
   */
  public createAttributeContainsWait(
    elementOrLocator: WebElement | By | ElementFinder,
    attribute: string,
    value: string,
    timeout?: number
  ): CSAttributeWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for attribute contains wait
    const attributeContainsConfig = {
      ...config,
      exact: false,
      caseSensitive: true
    };
    
    return new CSAttributeWait(elementOrLocator, attribute, value, attributeContainsConfig);
  }
  
  /**
   * Creates an attribute matches wait strategy for an element.
   * @param elementOrLocator The element or locator to wait for
   * @param attribute The attribute name
   * @param pattern The regular expression pattern to match
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSAttributeWait instance with regex matching
   */
  public createAttributeMatchesWait(
    elementOrLocator: WebElement | By | ElementFinder,
    attribute: string,
    pattern: RegExp,
    timeout?: number
  ): CSAttributeWait {
    const config = this.createBaseConfig(timeout);
    
    // Create configuration for attribute matches wait
    const attributeMatchesConfig = {
      ...config,
      regex: true
    };
    
    return new CSAttributeWait(elementOrLocator, attribute, pattern.source, attributeMatchesConfig);
  }
  
  /**
   * Creates a custom wait strategy using a condition function.
   * @param name The name of the wait strategy
   * @param conditionFn The condition function
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new custom wait strategy
   */
  public createCustomWait<T>(
    name: string,
    conditionFn: (driver: WebDriver) => Promise<T>,
    timeout?: number
  ): CSWaitStrategy<T> {
    const config = this.createBaseConfig(timeout);
    
    return {
      getName: () => name,
      getTimeout: () => config.timeout || this.defaultTimeout,
      getPollingInterval: () => config.pollingInterval || this.defaultPollingInterval,
      getTimeoutMessage: () => `Timed out waiting for '${name}' condition after ${config.timeout || this.defaultTimeout}ms`,
      getCondition: () => new Condition<T>(name, conditionFn),
      withTimeout: (timeout: number) => this.createCustomWait(name, conditionFn, timeout),
      withPollingInterval: (interval: number) => {
        const newConfig = { ...config, pollingInterval: interval };
        return this.createCustomWait(name, conditionFn, newConfig.timeout);
      },
      withTimeoutMessage: (message: string) => {
        const newConditionFn = conditionFn;
        return this.createCustomWait(name, newConditionFn, config.timeout);
      },
      wait: async (driver: WebDriver) => {
        return driver.wait(
          new Condition<T>(name, conditionFn),
          config.timeout || this.defaultTimeout,
          `Timed out waiting for '${name}' condition after ${config.timeout || this.defaultTimeout}ms`
        );
      },
      ignoring: (...exceptions: Array<typeof Error>) => {
        return this.createCustomWait(name, conditionFn, config.timeout);
      },
      not: () => {
        const notConditionFn = async (driver: WebDriver): Promise<boolean> => {
          try {
            await conditionFn(driver);
            return false;
          } catch (error) {
            return true;
          }
        };
        return this.createCustomWait<boolean>(`not(${name})`, notConditionFn, config.timeout);
      },
      and: <U>(other: CSWaitStrategy<U>) => {
        const andConditionFn = async (driver: WebDriver): Promise<boolean> => {
          try {
            await conditionFn(driver);
            await other.getCondition().fn(driver);
            return true;
          } catch (error) {
            return false;
          }
        };
        return this.createCustomWait<boolean>(
          `${name} AND ${other.getName()}`,
          andConditionFn,
          Math.min(config.timeout || this.defaultTimeout, other.getTimeout())
        );
      },
      or: <U>(other: CSWaitStrategy<U>) => {
        const orConditionFn = async (driver: WebDriver): Promise<boolean> => {
          try {
            await conditionFn(driver);
            return true;
          } catch (error1) {
            try {
              await other.getCondition().fn(driver);
              return true;
            } catch (error2) {
              return false;
            }
          }
        };
        return this.createCustomWait<boolean>(
          `${name} OR ${other.getName()}`,
          orConditionFn,
          Math.max(config.timeout || this.defaultTimeout, other.getTimeout())
        );
      },
      map: <U>(transform: (value: T) => U) => {
        const mapConditionFn = async (driver: WebDriver): Promise<U> => {
          const value = await conditionFn(driver);
          return transform(value);
        };
        return this.createCustomWait<U>(
          `map(${name})`,
          mapConditionFn,
          config.timeout
        );
      },
      isConditionMet: async (driver: WebDriver) => {
        try {
          await conditionFn(driver);
          return true;
        } catch (error) {
          return false;
        }
      }
    };
  }
  
  /**
   * Creates a wait strategy for an alert to be present.
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSWaitStrategy instance
   */
  public createAlertPresentWait(timeout?: number): CSWaitStrategy<boolean> {
    const config = this.createBaseConfig(timeout);
    
    const alertPresentFn = async (driver: WebDriver): Promise<boolean> => {
      try {
        await driver.switchTo().alert();
        return true;
      } catch (error) {
        throw new Error('No alert present');
      }
    };
    
    return this.createCustomWait<boolean>('alert-present', alertPresentFn, config.timeout);
  }
  
  /**
   * Creates a wait strategy for a page title.
   * @param title The title to wait for
   * @param options Options for title matching (optional)
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSWaitStrategy instance
   */
  public createTitleWait(
    title: string,
    options?: {
      exact?: boolean;
      caseSensitive?: boolean;
      regex?: boolean;
    },
    timeout?: number
  ): CSWaitStrategy<boolean> {
    const config = this.createBaseConfig(timeout);
    
    const opts = {
      exact: options?.exact !== false,
      caseSensitive: options?.caseSensitive || false,
      regex: options?.regex || false
    };
    
    const titleWaitFn = async (driver: WebDriver): Promise<boolean> => {
      const currentTitle = await driver.getTitle();
      
      if (opts.regex) {
        const pattern = new RegExp(title, opts.caseSensitive ? '' : 'i');
        if (!pattern.test(currentTitle)) {
          throw new Error(`Page title "${currentTitle}" does not match pattern "${title}"`);
        }
      } else if (opts.exact) {
        const expectedTitle = opts.caseSensitive ? title : title.toLowerCase();
        const actualTitle = opts.caseSensitive ? currentTitle : currentTitle.toLowerCase();
        
        if (expectedTitle !== actualTitle) {
          throw new Error(`Page title "${currentTitle}" does not match "${title}"`);
        }
      } else {
        const expectedTitle = opts.caseSensitive ? title : title.toLowerCase();
        const actualTitle = opts.caseSensitive ? currentTitle : currentTitle.toLowerCase();
        
        if (!actualTitle.includes(expectedTitle)) {
          throw new Error(`Page title "${currentTitle}" does not contain "${title}"`);
        }
      }
      
      return true;
    };
    
    return this.createCustomWait<boolean>(
      opts.regex ? `title-matches(${title})` : 
      opts.exact ? `title-is(${title})` : 
      `title-contains(${title})`,
      titleWaitFn,
      config.timeout
    );
  }
  
  /**
   * Creates a wait strategy for a URL.
   * @param url The URL to wait for
   * @param options Options for URL matching (optional)
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSWaitStrategy instance
   */
  public createUrlWait(
    url: string,
    options?: {
      exact?: boolean;
      caseSensitive?: boolean;
      regex?: boolean;
    },
    timeout?: number
  ): CSWaitStrategy<boolean> {
    const config = this.createBaseConfig(timeout);
    
    const opts = {
      exact: options?.exact !== false,
      caseSensitive: options?.caseSensitive || false,
      regex: options?.regex || false
    };
    
    const urlWaitFn = async (driver: WebDriver): Promise<boolean> => {
      const currentUrl = await driver.getCurrentUrl();
      
      if (opts.regex) {
        const pattern = new RegExp(url, opts.caseSensitive ? '' : 'i');
        if (!pattern.test(currentUrl)) {
          throw new Error(`URL "${currentUrl}" does not match pattern "${url}"`);
        }
      } else if (opts.exact) {
        const expectedUrl = opts.caseSensitive ? url : url.toLowerCase();
        const actualUrl = opts.caseSensitive ? currentUrl : currentUrl.toLowerCase();
        
        if (expectedUrl !== actualUrl) {
          throw new Error(`URL "${currentUrl}" does not match "${url}"`);
        }
      } else {
        const expectedUrl = opts.caseSensitive ? url : url.toLowerCase();
        const actualUrl = opts.caseSensitive ? currentUrl : currentUrl.toLowerCase();
        
        if (!actualUrl.includes(expectedUrl)) {
          throw new Error(`URL "${currentUrl}" does not contain "${url}"`);
        }
      }
      
      return true;
    };
    
    return this.createCustomWait<boolean>(
      opts.regex ? `url-matches(${url})` : 
      opts.exact ? `url-is(${url})` : 
      `url-contains(${url})`,
      urlWaitFn,
      config.timeout
    );
  }
  
  /**
   * Creates a wait strategy for a page to load completely.
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSWaitStrategy instance
   */
  public createPageLoadWait(timeout?: number): CSWaitStrategy<boolean> {
    const config = this.createBaseConfig(timeout);
    
    const pageLoadFn = async (driver: WebDriver): Promise<boolean> => {
      const readyState = await driver.executeScript('return document.readyState');
      
      if (readyState !== 'complete') {
        throw new Error(`Page is not loaded, current readyState: ${readyState}`);
      }
      
      return true;
    };
    
    return this.createCustomWait<boolean>('page-load', pageLoadFn, config.timeout);
  }
  
  /**
   * Creates a wait strategy for a specific number of elements.
   * @param locator The locator for the elements
   * @param count The expected number of elements
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSWaitStrategy instance
   */
  public createElementCountWait(
    locator: By,
    count: number,
    timeout?: number
  ): CSWaitStrategy<boolean> {
    const config = this.createBaseConfig(timeout);
    
    const elementCountFn = async (driver: WebDriver): Promise<boolean> => {
      const elements = await driver.findElements(locator);
      const actualCount = elements.length;
      
      if (actualCount !== count) {
        throw new Error(`Expected ${count} elements, but found ${actualCount}`);
      }
      
      return true;
    };
    
    return this.createCustomWait<boolean>(
      `element-count(${locator}, ${count})`,
      elementCountFn,
      config.timeout
    );
  }
  
  /**
   * Creates a wait strategy for a frame to be available and switch to it.
   * @param frameLocator The locator for the frame, index, or name/id
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSWaitStrategy instance
   */
  public createFrameToBeAvailableWait(
    frameLocator: By | number | string | WebElement,
    timeout?: number
  ): CSWaitStrategy<WebDriver> {
    const config = this.createBaseConfig(timeout);
    
    const frameAvailableFn = async (driver: WebDriver): Promise<WebDriver> => {
      try {
        return await driver.switchTo().frame(frameLocator);
      } catch (error) {
        throw new Error(`Frame ${frameLocator} is not available: ${error}`);
      }
    };
    
    return this.createCustomWait<WebDriver>(
      `frame-available(${frameLocator})`,
      frameAvailableFn,
      config.timeout
    );
  }
  
  /**
   * Creates a wait strategy for an element to be selected.
   * @param elementOrLocator The element or locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSWaitStrategy instance
   */
  public createElementToBeSelectedWait(
    elementOrLocator: WebElement | By | ElementFinder,
    timeout?: number
  ): CSWaitStrategy<boolean> {
    const config = this.createBaseConfig(timeout);
    
    const elementSelectedFn = async (driver: WebDriver): Promise<boolean> => {
      let element: WebElement;
      
      if (elementOrLocator instanceof WebElement) {
        element = elementOrLocator;
      } else if (elementOrLocator instanceof By) {
        element = await driver.findElement(elementOrLocator);
      } else {
        element = await elementOrLocator(driver);
      }
      
      const selected = await element.isSelected();
      
      if (!selected) {
        throw new Error('Element is not selected');
      }
      
      return true;
    };
    
    return this.createCustomWait<boolean>(
      'element-selected',
      elementSelectedFn,
      config.timeout
    );
  }
  
  /**
   * Creates a wait strategy for an element to be enabled.
   * @param elementOrLocator The element or locator to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSWaitStrategy instance
   */
  public createElementToBeEnabledWait(
    elementOrLocator: WebElement | By | ElementFinder,
    timeout?: number
  ): CSWaitStrategy<boolean> {
    const config = this.createBaseConfig(timeout);
    
    const elementEnabledFn = async (driver: WebDriver): Promise<boolean> => {
      let element: WebElement;
      
      if (elementOrLocator instanceof WebElement) {
        element = elementOrLocator;
      } else if (elementOrLocator instanceof By) {
        element = await driver.findElement(elementOrLocator);
      } else {
        element = await elementOrLocator(driver);
      }
      
      const enabled = await element.isEnabled();
      
      if (!enabled) {
        throw new Error('Element is not enabled');
      }
      
      return true;
    };
    
    return this.createCustomWait<boolean>(
      'element-enabled',
      elementEnabledFn,
      config.timeout
    );
  }
  
  /**
   * Creates a wait strategy for all elements matching a locator.
   * @param locator The locator for the elements
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSWaitStrategy instance
   */
  public createAllElementsLocatedWait(
    locator: By,
    timeout?: number
  ): CSWaitStrategy<WebElement[]> {
    const config = this.createBaseConfig(timeout);
    
    const allElementsLocatedFn = async (driver: WebDriver): Promise<WebElement[]> => {
      const elements = await driver.findElements(locator);
      
      if (elements.length === 0) {
        throw new Error(`No elements found for locator: ${locator}`);
      }
      
      return elements;
    };
    
    return this.createCustomWait<WebElement[]>(
      `all-elements-located(${locator})`,
      allElementsLocatedFn,
      config.timeout
    );
  }
  
  /**
   * Creates a wait strategy for a staleness check on an element.
   * @param element The element to check for staleness
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSWaitStrategy instance
   */
  public createStalenessOfWait(
    element: WebElement,
    timeout?: number
  ): CSWaitStrategy<boolean> {
    const config = this.createBaseConfig(timeout);
    
    const stalenessFn = async (driver: WebDriver): Promise<boolean> => {
      try {
        // If this succeeds, the element is not stale
        await element.isEnabled();
        throw new Error('Element is still attached to the DOM');
      } catch (error) {
        if (error instanceof SeleniumError.StaleElementReferenceError) {
          // Element is stale, which is what we want
          return true;
        }
        // Some other error occurred
        throw error;
      }
    };
    
    return this.createCustomWait<boolean>(
      'staleness-of',
      stalenessFn,
      config.timeout
    );
  }
  
  /**
   * Sets the default timeout for all wait strategies.
   * @param timeout The timeout in milliseconds
   */
  public setDefaultTimeout(timeout: number): void {
    this.defaultTimeout = timeout;
    this.logger.debug(`Default timeout set to ${timeout}ms`);
  }
  
  /**
   * Sets the default polling interval for all wait strategies.
   * @param interval The polling interval in milliseconds
   */
  public setDefaultPollingInterval(interval: number): void {
    this.defaultPollingInterval = interval;
    this.logger.debug(`Default polling interval set to ${interval}ms`);
  }
  
  /**
   * Sets the default retry options for all wait strategies.
   * @param enabled Whether retries are enabled
   * @param count The number of retries
   * @param interval The interval between retries in milliseconds
   */
  public setDefaultRetryOptions(enabled: boolean, count: number, interval: number): void {
    this.defaultRetryOptions = { enabled, count, interval };
    this.logger.debug(`Default retry options set to enabled=${enabled}, count=${count}, interval=${interval}ms`);
  }
}


CSTextWait.ts
----------------------

import { WebDriver, WebElement, By, Condition, error as SeleniumError } from 'selenium-webdriver';
import { CSAbstractWaitStrategy } from './CSAbstractWaitStrategy';
import { WaitConfig, ElementFinder } from './CSWaitStrategy';
import { CSLogger } from '../../core/utils/CSLogger';

/**
 * Wait strategy that waits for an element to have specific text content.
 * Supports exact matching, case-insensitive matching, substring matching,
 * and regular expression matching.
 */
export class CSTextWait extends CSAbstractWaitStrategy<WebElement> {
  /**
   * The element or locator to wait for.
   */
  private elementOrLocator: WebElement | By | ElementFinder;
  
  /**
   * The text to wait for.
   */
  private expectedText: string;
  
  /**
   * Whether to use exact text matching.
   */
  private exact: boolean;
  
  /**
   * Whether to use case-sensitive matching.
   */
  private caseSensitive: boolean;
  
  /**
   * Whether to trim text before comparison.
   */
  private trim: boolean;
  
  /**
   * Whether to normalize whitespace before comparison.
   */
  private normalizeWhitespace: boolean;
  
  /**
   * Whether to use regular expression matching.
   */
  private regex: boolean;
  
  /**
   * Whether to check text content (default) or value property.
   */
  private checkValue: boolean;
  
  /**
   * Whether to also check child element texts.
   */
  private includeChildrenText: boolean;
  
  /**
   * Whether to check inner text or text content.
   */
  private useInnerText: boolean;
  
  /**
   * Creates a new CSTextWait instance.
   * @param elementOrLocator The element or locator to wait for
   * @param expectedText The text to wait for
   * @param config The wait configuration
   */
  constructor(
    elementOrLocator: WebElement | By | ElementFinder,
    expectedText: string,
    config?: Partial<WaitConfig> & {
      exact?: boolean;
      caseSensitive?: boolean;
      trim?: boolean;
      normalizeWhitespace?: boolean;
      regex?: boolean;
      checkValue?: boolean;
      includeChildrenText?: boolean;
      useInnerText?: boolean;
    }
  ) {
    super('element text', config);
    this.elementOrLocator = elementOrLocator;
    this.expectedText = expectedText;
    this.exact = config?.exact !== false;
    this.caseSensitive = config?.caseSensitive || false;
    this.trim = config?.trim !== false;
    this.normalizeWhitespace = config?.normalizeWhitespace !== false;
    this.regex = config?.regex || false;
    this.checkValue = config?.checkValue || false;
    this.includeChildrenText = config?.includeChildrenText !== false;
    this.useInnerText = config?.useInnerText || false;
    
    // Set appropriate timeout message based on the element or locator
    let elementDescription: string;
    if (elementOrLocator instanceof WebElement) {
      elementDescription = 'element';
    } else if (elementOrLocator instanceof By) {
      elementDescription = `element located by ${elementOrLocator.toString()}`;
    } else {
      elementDescription = 'element';
    }
    
    // Set message based on matching type
    if (this.regex) {
      this.timeoutMessage = `Timed out waiting for ${elementDescription} text to match pattern "${expectedText}" after ${this.timeout}ms`;
    } else if (this.exact) {
      this.timeoutMessage = `Timed out waiting for ${elementDescription} text to be "${expectedText}" after ${this.timeout}ms`;
    } else {
      this.timeoutMessage = `Timed out waiting for ${elementDescription} text to contain "${expectedText}" after ${this.timeout}ms`;
    }
    
    // Add appropriate ignored exceptions
    this.ignoredExceptions.push(SeleniumError.NoSuchElementError);
    this.ignoredExceptions.push(SeleniumError.StaleElementReferenceError);
  }
  
  /**
   * Gets the Selenium Condition object that represents this strategy.
   * @returns The Condition object
   */
  public getCondition(): Condition<WebElement> {
    return new Condition<WebElement>(
      this.name,
      async (driver: WebDriver): Promise<WebElement> => {
        try {
          // Get the element
          const element = await this.findElement(driver);
          
          // Get the text to check
          const actualText = await this.getTextToCheck(driver, element);
          
          // Check if the text matches the expected text
          if (!this.textMatches(actualText)) {
            throw new Error(this.formatMismatchError(actualText));
          }
          
          return element;
        } catch (error) {
          if (error instanceof SeleniumError.NoSuchElementError) {
            throw new Error(`Element not found: ${error.message}`);
          } else if (error instanceof SeleniumError.StaleElementReferenceError) {
            throw new Error(`Element is stale: ${error.message}`);
          } else {
            throw error;
          }
        }
      }
    );
  }
  
  /**
   * Finds the element based on the elementOrLocator.
   * @param driver The WebDriver instance
   * @returns The WebElement
   */
  private async findElement(driver: WebDriver): Promise<WebElement> {
    if (this.elementOrLocator instanceof WebElement) {
      return this.elementOrLocator;
    } else if (this.elementOrLocator instanceof By) {
      return driver.findElement(this.elementOrLocator);
    } else {
      return this.elementOrLocator(driver);
    }
  }
  
  /**
   * Gets the text to check based on the configuration.
   * @param driver The WebDriver instance
   * @param element The WebElement to check
   * @returns The text to check
   */
  private async getTextToCheck(driver: WebDriver, element: WebElement): Promise<string> {
    let text: string;
    
    if (this.checkValue) {
      // Check value property
      text = await element.getAttribute('value') || '';
    } else if (this.useInnerText) {
      // Use JavaScript to get innerText
      text = await driver.executeScript('return arguments[0].innerText;', element) as string;
    } else {
      // Use standard getText method
      if (this.includeChildrenText) {
        // Get text including children's text
        text = await element.getText();
      } else {
        // Get text excluding children's text using JavaScript
        text = await driver.executeScript(`
          const element = arguments[0];
          const childTexts = Array.from(element.childNodes)
            .filter(node => node.nodeType === Node.TEXT_NODE)
            .map(node => node.textContent)
            .join('');
          return childTexts;
        `, element) as string;
      }
    }
    
    // Apply text processing based on configuration
    if (this.trim) {
      text = text.trim();
    }
    
    if (this.normalizeWhitespace) {
      text = text.replace(/\s+/g, ' ');
    }
    
    return text;
  }
  
  /**
   * Checks if the text matches the expected text based on the configuration.
   * @param text The text to check
   * @returns Whether the text matches
   */
  private textMatches(text: string): boolean {
    // Copy the expected text to avoid modifying the original
    let expectedTextForComparison = this.expectedText;
    let textForComparison = text;
    
    // Apply case insensitivity if required
    if (!this.caseSensitive) {
      expectedTextForComparison = expectedTextForComparison.toLowerCase();
      textForComparison = textForComparison.toLowerCase();
    }
    
    // Apply matching based on configuration
    if (this.regex) {
      // Use regular expression matching
      let pattern: RegExp;
      try {
        pattern = new RegExp(this.expectedText, this.caseSensitive ? '' : 'i');
      } catch (error) {
        throw new Error(`Invalid regular expression "${this.expectedText}": ${error}`);
      }
      
      return pattern.test(text);
    } else if (this.exact) {
      // Use exact matching
      return textForComparison === expectedTextForComparison;
    } else {
      // Use substring matching
      return textForComparison.includes(expectedTextForComparison);
    }
  }
  
  /**
   * Formats an error message for when the text doesn't match.
   * @param actualText The actual text
   * @returns The error message
   */
  private formatMismatchError(actualText: string): string {
    if (this.regex) {
      return `Expected text to match pattern "${this.expectedText}" but was "${actualText}"`;
    } else if (this.exact) {
      return `Expected text to be "${this.expectedText}" but was "${actualText}"`;
    } else {
      return `Expected text to contain "${this.expectedText}" but was "${actualText}"`;
    }
  }
  
  /**
   * Sets whether to use exact text matching.
   * @param exact Whether to use exact text matching
   * @returns This CSTextWait instance
   */
  public withExactMatching(exact: boolean): CSTextWait {
    this.exact = exact;
    return this;
  }
  
  /**
   * Sets whether to use case-sensitive matching.
   * @param caseSensitive Whether to use case-sensitive matching
   * @returns This CSTextWait instance
   */
  public withCaseSensitivity(caseSensitive: boolean): CSTextWait {
    this.caseSensitive = caseSensitive;
    return this;
  }
  
  /**
   * Sets whether to trim text before comparison.
   * @param trim Whether to trim text
   * @returns This CSTextWait instance
   */
  public withTrim(trim: boolean): CSTextWait {
    this.trim = trim;
    return this;
  }
  
  /**
   * Sets whether to normalize whitespace before comparison.
   * @param normalize Whether to normalize whitespace
   * @returns This CSTextWait instance
   */
  public withWhitespaceNormalization(normalize: boolean): CSTextWait {
    this.normalizeWhitespace = normalize;
    return this;
  }
  
  /**
   * Sets whether to use regular expression matching.
   * @param regex Whether to use regular expression matching
   * @returns This CSTextWait instance
   */
  public withRegex(regex: boolean): CSTextWait {
    this.regex = regex;
    return this;
  }
  
  /**
   * Sets whether to check value property instead of text content.
   * @param checkValue Whether to check value property
   * @returns This CSTextWait instance
   */
  public withValueCheck(checkValue: boolean): CSTextWait {
    this.checkValue = checkValue;
    return this;
  }
  
  /**
   * Sets whether to include child element texts in the check.
   * @param include Whether to include child element texts
   * @returns This CSTextWait instance
   */
  public withChildrenTextIncluded(include: boolean): CSTextWait {
    this.includeChildrenText = include;
    return this;
  }
  
  /**
   * Sets whether to use innerText instead of textContent.
   * @param useInnerText Whether to use innerText
   * @returns This CSTextWait instance
   */
  public withInnerText(useInnerText: boolean): CSTextWait {
    this.useInnerText = useInnerText;
    return this;
  }
  
  /**
   * Factory method to create a new CSTextWait instance for a WebElement.
   * @param element The WebElement to wait for
   * @param text The text to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance
   */
  public static forElement(element: WebElement, text: string, timeout?: number): CSTextWait {
    return new CSTextWait(element, text, { timeout });
  }
  
  /**
   * Factory method to create a new CSTextWait instance for a locator.
   * @param locator The locator to wait for
   * @param text The text to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance
   */
  public static forLocator(locator: By, text: string, timeout?: number): CSTextWait {
    return new CSTextWait(locator, text, { timeout });
  }
  
  /**
   * Factory method to create a new CSTextWait instance for an element finder.
   * @param finder The element finder function
   * @param text The text to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance
   */
  public static forFinder(finder: ElementFinder, text: string, timeout?: number): CSTextWait {
    return new CSTextWait(finder, text, { timeout });
  }
  
  /**
   * Factory method to create a new CSTextWait instance for exact text matching.
   * @param elementOrLocator The element or locator to wait for
   * @param text The exact text to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance with exact matching
   */
  public static exactText(
    elementOrLocator: WebElement | By | ElementFinder,
    text: string,
    timeout?: number
  ): CSTextWait {
    return new CSTextWait(elementOrLocator, text, {
      timeout,
      exact: true,
      caseSensitive: true,
      trim: true,
      normalizeWhitespace: true
    });
  }
  
  /**
   * Factory method to create a new CSTextWait instance for case-insensitive text matching.
   * @param elementOrLocator The element or locator to wait for
   * @param text The text to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance with case-insensitive matching
   */
  public static containsText(
    elementOrLocator: WebElement | By | ElementFinder,
    text: string,
    timeout?: number
  ): CSTextWait {
    return new CSTextWait(elementOrLocator, text, {
      timeout,
      exact: false,
      caseSensitive: false,
      trim: true,
      normalizeWhitespace: true
    });
  }
  
  /**
   * Factory method to create a new CSTextWait instance for regular expression matching.
   * @param elementOrLocator The element or locator to wait for
   * @param pattern The regular expression pattern to match
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance with regex matching
   */
  public static matchesText(
    elementOrLocator: WebElement | By | ElementFinder,
    pattern: string | RegExp,
    timeout?: number
  ): CSTextWait {
    const patternStr = typeof pattern === 'string' ? pattern : pattern.source;
    
    return new CSTextWait(elementOrLocator, patternStr, {
      timeout,
      regex: true,
      trim: true,
      normalizeWhitespace: true
    });
  }
  
  /**
   * Factory method to create a new CSTextWait instance for checking input value.
   * @param elementOrLocator The element or locator to wait for
   * @param value The value to wait for
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance for checking value
   */
  public static hasValue(
    elementOrLocator: WebElement | By | ElementFinder,
    value: string,
    timeout?: number
  ): CSTextWait {
    return new CSTextWait(elementOrLocator, value, {
      timeout,
      checkValue: true,
      exact: true,
      trim: true
    });
  }
  
  /**
   * Factory method to create a new CSTextWait instance for checking input value containing text.
   * @param elementOrLocator The element or locator to wait for
   * @param value The value to be contained
   * @param timeout The timeout in milliseconds (optional)
   * @returns A new CSTextWait instance for checking value contains
   */
  public static valueContains(
    elementOrLocator: WebElement | By | ElementFinder,
    value: string,
    timeout?: number
  ): CSTextWait {
    return new CSTextWait(elementOrLocator, value, {
      timeout,
      checkValue: true,
      exact: false,
      caseSensitive: false,
      trim: true
    });
  }
}


CSAttributeWait.ts
----------------------------

import { WebElement } from 'selenium-webdriver';
import { CSAbstractWaitStrategy } from './CSAbstractWaitStrategy';
import { CSLogger } from '../../core/utils/CSLogger';
import { TimeoutError } from '../../core/exceptions/TimeoutError';
import { CSConstants } from '../../core/utils/CSConstants';
import { CSTextUtils } from '../../core/utils/CSTextUtils';

/**
 * Wait strategy that waits for an element to have a specific attribute with an expected value.
 * Supports exact match, contains, starts with, ends with, and regex pattern matching.
 */
export class CSAttributeWait extends CSAbstractWaitStrategy<boolean> {
    private readonly element: WebElement;
    private readonly attributeName: string;
    private readonly expectedValue: string | RegExp;
    private readonly matchType: AttributeMatchType;
    private readonly caseSensitive: boolean;
    private readonly nullAcceptable: boolean;
    private readonly emptyAcceptable: boolean;
    private readonly logEnabled: boolean;

    /**
     * Creates a new attribute wait strategy instance
     * 
     * @param element The element to check
     * @param attributeName The name of the attribute to check
     * @param expectedValue The expected value of the attribute (string or regex)
     * @param matchType The type of match to perform
     * @param options Additional options for the attribute wait
     */
    constructor(
        element: WebElement, 
        attributeName: string, 
        expectedValue: string | RegExp,
        matchType: AttributeMatchType = AttributeMatchType.EXACT_MATCH,
        options: AttributeWaitOptions = {}
    ) {
        super(
            options.timeout || CSConstants.DEFAULT_TIMEOUT,
            options.pollingInterval || CSConstants.DEFAULT_POLLING_INTERVAL,
            options.message || `Element should have attribute '${attributeName}' with value '${expectedValue}'`
        );
        
        this.element = element;
        this.attributeName = attributeName;
        this.expectedValue = expectedValue;
        this.matchType = matchType;
        this.caseSensitive = options.caseSensitive !== undefined ? options.caseSensitive : true;
        this.nullAcceptable = options.nullAcceptable || false;
        this.emptyAcceptable = options.emptyAcceptable || false;
        this.logEnabled = options.logEnabled !== undefined ? options.logEnabled : true;
    }

    /**
     * Checks if the element's attribute matches the expected value
     * 
     * @returns Promise resolving to boolean indicating whether the condition is met
     */
    protected async evaluate(): Promise<boolean> {
        try {
            const attributeValue = await this.element.getAttribute(this.attributeName);
            
            // Check for null attribute value
            if (attributeValue === null) {
                return this.nullAcceptable;
            }
            
            // Check for empty attribute value
            if (attributeValue === '') {
                return this.emptyAcceptable;
            }
            
            // Handle regex pattern matching
            if (this.expectedValue instanceof RegExp) {
                return this.expectedValue.test(attributeValue);
            }
            
            let actualValue = attributeValue;
            let expectedValue = this.expectedValue as string;
            
            // Apply case insensitivity if needed
            if (!this.caseSensitive) {
                actualValue = actualValue.toLowerCase();
                expectedValue = expectedValue.toLowerCase();
            }
            
            // Perform the specified type of matching
            switch (this.matchType) {
                case AttributeMatchType.EXACT_MATCH:
                    return actualValue === expectedValue;
                
                case AttributeMatchType.CONTAINS:
                    return actualValue.includes(expectedValue);
                
                case AttributeMatchType.STARTS_WITH:
                    return actualValue.startsWith(expectedValue);
                
                case AttributeMatchType.ENDS_WITH:
                    return actualValue.endsWith(expectedValue);
                
                case AttributeMatchType.NOT_EQUAL:
                    return actualValue !== expectedValue;
                
                case AttributeMatchType.NOT_CONTAINS:
                    return !actualValue.includes(expectedValue);
                
                default:
                    // Default to exact match
                    return actualValue === expectedValue;
            }
        } catch (error) {
            if (this.logEnabled) {
                CSLogger.debug(`Error while checking attribute ${this.attributeName}: ${error.message}`);
            }
            return false;
        }
    }

    /**
     * Waits for the element's attribute to match the expected value
     * 
     * @returns Promise resolving when the condition is met or rejecting when the timeout is reached
     */
    public async wait(): Promise<boolean> {
        try {
            return await super.wait();
        } catch (error) {
            const actualValue = await this.safeGetAttributeValue();
            throw new TimeoutError(
                CSTextUtils.format(
                    "Timed out waiting for element attribute '{}' to be '{}'. Actual value: '{}'",
                    this.attributeName,
                    this.expectedValue,
                    actualValue
                ),
                error
            );
        }
    }
    
    /**
     * Safely gets the current attribute value for error reporting
     * 
     * @returns Promise resolving to the current attribute value or a descriptive string
     */
    private async safeGetAttributeValue(): Promise<string> {
        try {
            const value = await this.element.getAttribute(this.attributeName);
            return value === null ? 'null' : `'${value}'`;
        } catch (error) {
            return 'unavailable';
        }
    }
    
    /**
     * Creates a builder for this wait strategy
     * 
     * @param element The element to check
     * @returns A new builder for attribute wait strategies
     */
    public static forElement(element: WebElement): CSAttributeWaitBuilder {
        return new CSAttributeWaitBuilder(element);
    }
}

/**
 * Enum representing different types of attribute matching strategies
 */
export enum AttributeMatchType {
    EXACT_MATCH = 'exactMatch',
    CONTAINS = 'contains',
    STARTS_WITH = 'startsWith',
    ENDS_WITH = 'endsWith',
    NOT_EQUAL = 'notEqual',
    NOT_CONTAINS = 'notContains'
}

/**
 * Interface for attribute wait strategy options
 */
export interface AttributeWaitOptions {
    timeout?: number;
    pollingInterval?: number;
    message?: string;
    caseSensitive?: boolean;
    nullAcceptable?: boolean;
    emptyAcceptable?: boolean;
    logEnabled?: boolean;
}

/**
 * Builder class to create CSAttributeWait instances with a fluent API
 */
export class CSAttributeWaitBuilder {
    private element: WebElement;
    private attributeName: string;
    private expectedValue: string | RegExp;
    private matchType: AttributeMatchType = AttributeMatchType.EXACT_MATCH;
    private options: AttributeWaitOptions = {};
    
    /**
     * Creates a new builder instance
     * 
     * @param element The element to check
     */
    constructor(element: WebElement) {
        this.element = element;
    }
    
    /**
     * Sets the attribute name to check
     * 
     * @param attributeName The name of the attribute
     * @returns This builder instance for chaining
     */
    public withAttribute(attributeName: string): CSAttributeWaitBuilder {
        this.attributeName = attributeName;
        return this;
    }
    
    /**
     * Sets the expected attribute value for exact matching
     * 
     * @param value The expected attribute value
     * @returns This builder instance for chaining
     */
    public hasValue(value: string): CSAttributeWaitBuilder {
        this.expectedValue = value;
        this.matchType = AttributeMatchType.EXACT_MATCH;
        return this;
    }
    
    /**
     * Sets the expected attribute value for contains matching
     * 
     * @param value The substring to check for
     * @returns This builder instance for chaining
     */
    public containsValue(value: string): CSAttributeWaitBuilder {
        this.expectedValue = value;
        this.matchType = AttributeMatchType.CONTAINS;
        return this;
    }
    
    /**
     * Sets the expected attribute value for starts-with matching
     * 
     * @param value The prefix to check for
     * @returns This builder instance for chaining
     */
    public startsWithValue(value: string): CSAttributeWaitBuilder {
        this.expectedValue = value;
        this.matchType = AttributeMatchType.STARTS_WITH;
        return this;
    }
    
    /**
     * Sets the expected attribute value for ends-with matching
     * 
     * @param value The suffix to check for
     * @returns This builder instance for chaining
     */
    public endsWithValue(value: string): CSAttributeWaitBuilder {
        this.expectedValue = value;
        this.matchType = AttributeMatchType.ENDS_WITH;
        return this;
    }
    
    /**
     * Sets the expected attribute value for not-equal matching
     * 
     * @param value The value to check inequality against
     * @returns This builder instance for chaining
     */
    public notEqualToValue(value: string): CSAttributeWaitBuilder {
        this.expectedValue = value;
        this.matchType = AttributeMatchType.NOT_EQUAL;
        return this;
    }
    
    /**
     * Sets the expected attribute value for not-contains matching
     * 
     * @param value The substring to check absence for
     * @returns This builder instance for chaining
     */
    public notContainsValue(value: string): CSAttributeWaitBuilder {
        this.expectedValue = value;
        this.matchType = AttributeMatchType.NOT_CONTAINS;
        return this;
    }
    
    /**
     * Sets a regular expression pattern to match against the attribute value
     * 
     * @param pattern The regex pattern to match
     * @returns This builder instance for chaining
     */
    public matchesPattern(pattern: RegExp): CSAttributeWaitBuilder {
        this.expectedValue = pattern;
        return this;
    }
    
    /**
     * Sets whether the matching should be case-sensitive
     * 
     * @param caseSensitive Whether the matching should be case-sensitive
     * @returns This builder instance for chaining
     */
    public withCaseSensitivity(caseSensitive: boolean): CSAttributeWaitBuilder {
        this.options.caseSensitive = caseSensitive;
        return this;
    }
    
    /**
     * Sets whether null attribute values are acceptable
     * 
     * @param nullAcceptable Whether null values are acceptable
     * @returns This builder instance for chaining
     */
    public withNullAcceptance(nullAcceptable: boolean): CSAttributeWaitBuilder {
        this.options.nullAcceptable = nullAcceptable;
        return this;
    }
    
    /**
     * Sets whether empty attribute values are acceptable
     * 
     * @param emptyAcceptable Whether empty values are acceptable
     * @returns This builder instance for chaining
     */
    public withEmptyAcceptance(emptyAcceptable: boolean): CSAttributeWaitBuilder {
        this.options.emptyAcceptable = emptyAcceptable;
        return this;
    }
    
    /**
     * Sets the timeout for this wait strategy
     * 
     * @param timeout The timeout in milliseconds
     * @returns This builder instance for chaining
     */
    public withTimeout(timeout: number): CSAttributeWaitBuilder {
        this.options.timeout = timeout;
        return this;
    }
    
    /**
     * Sets the polling interval for this wait strategy
     * 
     * @param pollingInterval The polling interval in milliseconds
     * @returns This builder instance for chaining
     */
    public withPollingInterval(pollingInterval: number): CSAttributeWaitBuilder {
        this.options.pollingInterval = pollingInterval;
        return this;
    }
    
    /**
     * Sets a custom message for timeout errors
     * 
     * @param message The custom error message
     * @returns This builder instance for chaining
     */
    public withMessage(message: string): CSAttributeWaitBuilder {
        this.options.message = message;
        return this;
    }
    
    /**
     * Enables or disables logging during attribute checks
     * 
     * @param enabled Whether logging is enabled
     * @returns This builder instance for chaining
     */
    public withLogging(enabled: boolean): CSAttributeWaitBuilder {
        this.options.logEnabled = enabled;
        return this;
    }
    
    /**
     * Builds the CSAttributeWait instance
     * 
     * @returns A new CSAttributeWait instance with the configured settings
     * @throws Error if any required settings are missing
     */
    public build(): CSAttributeWait {
        if (!this.element) {
            throw new Error('Element must be provided');
        }
        
        if (!this.attributeName) {
            throw new Error('Attribute name must be provided');
        }
        
        if (this.expectedValue === undefined) {
            throw new Error('Expected value must be provided');
        }
        
        return new CSAttributeWait(
            this.element,
            this.attributeName,
            this.expectedValue,
            this.matchType,
            this.options
        );
    }
    
    /**
     * Builds and immediately executes the wait strategy
     * 
     * @returns Promise resolving when the condition is met
     */
    public async wait(): Promise<boolean> {
        return this.build().wait();
    }
}


CSPresenceWait.ts
-------------------------

import { By, WebDriver, WebElement } from 'selenium-webdriver';
import { CSAbstractWaitStrategy } from './CSAbstractWaitStrategy';
import { CSLogger } from '../../core/utils/CSLogger';
import { TimeoutError } from '../../core/exceptions/TimeoutError';
import { CSConstants } from '../../core/utils/CSConstants';
import { CSTextUtils } from '../../core/utils/CSTextUtils';
import { CSPathUtils } from '../../core/utils/CSPathUtils';

/**
 * Wait strategy that waits for an element to be present in the DOM,
 * regardless of its visibility or interactability.
 */
export class CSPresenceWait extends CSAbstractWaitStrategy<boolean> {
    private readonly locator: By | null;
    private readonly element: WebElement | null;
    private readonly driver: WebDriver;
    private readonly count: number;
    private readonly comparisonType: ComparisonType;
    private readonly logEnabled: boolean;
    private readonly failFast: boolean;
    private readonly shadowRootQuery: string | null;
    private readonly frameLocator: By | null;
    private readonly waitForFrame: boolean;

    /**
     * Creates a new element presence wait strategy instance
     * 
     * @param driverOrElement The WebDriver instance or a specific WebElement
     * @param locatorOrCount The locator to find elements or the expected count
     * @param options Additional options for the presence wait
     */
    constructor(
        driverOrElement: WebDriver | WebElement,
        locatorOrCount?: By | number,
        options: PresenceWaitOptions = {}
    ) {
        super(
            options.timeout || CSConstants.DEFAULT_TIMEOUT,
            options.pollingInterval || CSConstants.DEFAULT_POLLING_INTERVAL,
            options.message || 'Element should be present in DOM'
        );
        
        if (driverOrElement instanceof WebDriver) {
            this.driver = driverOrElement;
            this.element = null;
            
            if (locatorOrCount instanceof By) {
                this.locator = locatorOrCount;
                this.count = 1;
                this.comparisonType = ComparisonType.AT_LEAST;
            } else if (typeof locatorOrCount === 'number') {
                throw new Error('Cannot specify count without a locator. Use driver.wait() instead.');
            } else {
                throw new Error('Must provide a locator when using WebDriver');
            }
        } else {
            this.driver = null;
            this.element = driverOrElement;
            this.locator = null;
            
            if (typeof locatorOrCount === 'number') {
                this.count = locatorOrCount;
                this.comparisonType = options.comparisonType || ComparisonType.EXACT;
            } else {
                this.count = 1;
                this.comparisonType = ComparisonType.AT_LEAST;
            }
        }
        
        this.logEnabled = options.logEnabled !== undefined ? options.logEnabled : true;
        this.failFast = options.failFast !== undefined ? options.failFast : false;
        this.shadowRootQuery = options.shadowRootQuery || null;
        this.frameLocator = options.frameLocator || null;
        this.waitForFrame = options.waitForFrame !== undefined ? options.waitForFrame : true;
    }

    /**
     * Checks if the element is present in the DOM
     * 
     * @returns Promise resolving to boolean indicating whether the condition is met
     */
    protected async evaluate(): Promise<boolean> {
        try {
            // Handle frame switching if specified
            if (this.frameLocator && this.driver) {
                if (this.waitForFrame) {
                    const framePresent = await this.isFrameAvailable(this.frameLocator);
                    if (!framePresent) {
                        if (this.logEnabled) {
                            CSLogger.debug(`Frame not yet available for locator: ${this.frameLocator}`);
                        }
                        return false;
                    }
                }
                
                await this.driver.switchTo().frame(await this.driver.findElement(this.frameLocator));
                
                // Perform check in the frame
                const result = await this.performPresenceCheck();
                
                // Return to the default content
                await this.driver.switchTo().defaultContent();
                
                return result;
            }
            
            return await this.performPresenceCheck();
        } catch (error) {
            if (this.logEnabled) {
                CSLogger.debug(`Error while checking element presence: ${error.message}`);
            }
            
            if (this.failFast) {
                throw error;
            }
            
            return false;
        }
    }
    
    /**
     * Performs the actual presence check based on the configuration
     * 
     * @returns Promise resolving to boolean indicating whether the condition is met
     */
    private async performPresenceCheck(): Promise<boolean> {
        // Single element check
        if (this.element) {
            try {
                // Check if the element is still attached to the DOM
                await this.element.getTagName();
                
                // Element exists in DOM
                return true;
            } catch (error) {
                if (error.name === 'StaleElementReferenceError') {
                    // Element no longer exists in DOM
                    return false;
                }
                throw error;
            }
        }
        
        // Locator check
        if (this.driver && this.locator) {
            let elements: WebElement[];
            
            if (this.shadowRootQuery) {
                elements = await this.findElementsInShadowDOM(this.driver, this.locator, this.shadowRootQuery);
            } else {
                elements = await this.driver.findElements(this.locator);
            }
            
            return this.checkElementCount(elements.length);
        }
        
        throw new Error('Invalid configuration: No element or locator provided');
    }
    
    /**
     * Finds elements in Shadow DOM
     * 
     * @param driver WebDriver instance
     * @param locator The locator to find elements
     * @param shadowRootQuery The shadow root query path
     * @returns Promise resolving to array of WebElements
     */
    private async findElementsInShadowDOM(
        driver: WebDriver, 
        locator: By, 
        shadowRootQuery: string
    ): Promise<WebElement[]> {
        // Parse shadow root path
        const shadowParts = shadowRootQuery.split('>>').map(part => part.trim());
        
        // Find the base element
        const baseElementSelector = shadowParts[0];
        const baseElements = await driver.findElements(By.css(baseElementSelector));
        
        if (baseElements.length === 0) {
            return [];
        }
        
        let currentElement = baseElements[0];
        
        // Navigate through the shadow DOM path
        for (let i = 1; i < shadowParts.length; i++) {
            // Get the shadow root
            const shadowRoot = await driver.executeScript(
                'return arguments[0].shadowRoot', 
                currentElement
            );
            
            if (!shadowRoot) {
                return [];
            }
            
            // Find the next element in the path
            const nextSelector = shadowParts[i];
            const elements = await driver.executeScript(
                'return arguments[0].querySelectorAll(arguments[1])',
                shadowRoot,
                nextSelector
            );
            
            if (!elements || elements.length === 0) {
                return [];
            }
            
            currentElement = elements[0];
        }
        
        // Get the shadow root of the last element in the path
        const finalShadowRoot = await driver.executeScript(
            'return arguments[0].shadowRoot', 
            currentElement
        );
        
        if (!finalShadowRoot) {
            return [];
        }
        
        // Convert the locator to a CSS selector if possible, or use XPath as fallback
        let selector: string;
        let useXPath = false;
        
        try {
            if (locator.toString().includes('By.css selector')) {
                selector = locator.toString().match(/By.css selector: (.+)\)$/)[1];
            } else if (locator.toString().includes('By.xpath')) {
                selector = locator.toString().match(/By.xpath: (.+)\)$/)[1];
                useXPath = true;
            } else if (locator.toString().includes('By.id')) {
                const id = locator.toString().match(/By.id: (.+)\)$/)[1];
                selector = `#${id}`;
            } else if (locator.toString().includes('By.className')) {
                const className = locator.toString().match(/By.className: (.+)\)$/)[1];
                selector = `.${className}`;
            } else if (locator.toString().includes('By.name')) {
                const name = locator.toString().match(/By.name: (.+)\)$/)[1];
                selector = `[name='${name}']`;
            } else if (locator.toString().includes('By.tagName')) {
                selector = locator.toString().match(/By.tagName: (.+)\)$/)[1];
            } else if (locator.toString().includes('By.linkText')) {
                const text = locator.toString().match(/By.linkText: (.+)\)$/)[1];
                selector = `a:contains('${text}')`;
            } else {
                throw new Error(`Unsupported locator type for shadow DOM: ${locator}`);
            }
        } catch (error) {
            throw new Error(`Failed to parse locator for shadow DOM: ${error.message}`);
        }
        
        // Find elements in the shadow root
        if (useXPath) {
            // XPath doesn't work directly in shadow DOM, use a workaround
            // Use document.evaluate for XPath in shadow DOM
            return await driver.executeScript(
                `
                const shadowRoot = arguments[0];
                const xpath = arguments[1];
                const result = [];
                const xpathResult = document.evaluate(
                    xpath, 
                    shadowRoot, 
                    null, 
                    XPathResult.ORDERED_NODE_ITERATOR_TYPE, 
                    null
                );
                let node;
                while (node = xpathResult.iterateNext()) {
                    result.push(node);
                }
                return result;
                `,
                finalShadowRoot,
                selector
            );
        } else {
            // Use querySelector for CSS selectors
            return await driver.executeScript(
                'return arguments[0].querySelectorAll(arguments[1])',
                finalShadowRoot,
                selector
            );
        }
    }
    
    /**
     * Checks if a frame is available
     * 
     * @param frameLocator The locator to find the frame
     * @returns Promise resolving to boolean indicating whether the frame is available
     */
    private async isFrameAvailable(frameLocator: By): Promise<boolean> {
        try {
            const frames = await this.driver.findElements(frameLocator);
            return frames.length > 0;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Checks if the element count matches the expected count based on the comparison type
     * 
     * @param actualCount The actual number of elements found
     * @returns Boolean indicating whether the condition is met
     */
    private checkElementCount(actualCount: number): boolean {
        switch (this.comparisonType) {
            case ComparisonType.EXACT:
                return actualCount === this.count;
            
            case ComparisonType.AT_LEAST:
                return actualCount >= this.count;
            
            case ComparisonType.AT_MOST:
                return actualCount <= this.count;
            
            case ComparisonType.GREATER_THAN:
                return actualCount > this.count;
            
            case ComparisonType.LESS_THAN:
                return actualCount < this.count;
            
            case ComparisonType.NOT_EQUAL:
                return actualCount !== this.count;
            
            default:
                return actualCount === this.count;
        }
    }

    /**
     * Waits for the element to be present in the DOM
     * 
     * @returns Promise resolving when the condition is met or rejecting when the timeout is reached
     */
    public async wait(): Promise<boolean> {
        try {
            return await super.wait();
        } catch (error) {
            let errorMessage: string;
            
            if (this.element) {
                errorMessage = "Element is no longer attached to the DOM";
            } else if (this.locator) {
                const locatorString = this.locator.toString();
                errorMessage = CSTextUtils.format(
                    "Timed out waiting for {} element(s) matching {} to be present",
                    this.count,
                    locatorString
                );
                
                if (this.shadowRootQuery) {
                    errorMessage += CSTextUtils.format(" in shadow DOM path: {}", this.shadowRootQuery);
                }
                
                if (this.frameLocator) {
                    errorMessage += CSTextUtils.format(" in frame: {}", this.frameLocator.toString());
                }
            } else {
                errorMessage = "Timed out waiting for element presence";
            }
            
            throw new TimeoutError(errorMessage, error);
        }
    }
    
    /**
     * Creates a builder for this wait strategy with a WebDriver
     * 
     * @param driver The WebDriver instance
     * @returns A new builder for presence wait strategies
     */
    public static forDriver(driver: WebDriver): CSPresenceWaitDriverBuilder {
        return new CSPresenceWaitDriverBuilder(driver);
    }
    
    /**
     * Creates a builder for this wait strategy with a WebElement
     * 
     * @param element The WebElement to check
     * @returns A new builder for presence wait strategies
     */
    public static forElement(element: WebElement): CSPresenceWaitElementBuilder {
        return new CSPresenceWaitElementBuilder(element);
    }
}

/**
 * Enum representing different types of count comparison strategies
 */
export enum ComparisonType {
    EXACT = 'exact',
    AT_LEAST = 'atLeast',
    AT_MOST = 'atMost',
    GREATER_THAN = 'greaterThan',
    LESS_THAN = 'lessThan',
    NOT_EQUAL = 'notEqual'
}

/**
 * Interface for presence wait strategy options
 */
export interface PresenceWaitOptions {
    timeout?: number;
    pollingInterval?: number;
    message?: string;
    comparisonType?: ComparisonType;
    logEnabled?: boolean;
    failFast?: boolean;
    shadowRootQuery?: string;
    frameLocator?: By;
    waitForFrame?: boolean;
}

/**
 * Builder class to create CSPresenceWait instances with a fluent API for WebDriver
 */
export class CSPresenceWaitDriverBuilder {
    private driver: WebDriver;
    private locator: By;
    private count: number = 1;
    private options: PresenceWaitOptions = {};
    
    /**
     * Creates a new builder instance
     * 
     * @param driver The WebDriver instance
     */
    constructor(driver: WebDriver) {
        this.driver = driver;
    }
    
    /**
     * Sets the locator to find elements
     * 
     * @param locator The locator to find elements
     * @returns This builder instance for chaining
     */
    public withLocator(locator: By): CSPresenceWaitDriverBuilder {
        this.locator = locator;
        return this;
    }
    
    /**
     * Sets the expected count of elements with exact matching
     * 
     * @param count The expected count
     * @returns This builder instance for chaining
     */
    public withExactCount(count: number): CSPresenceWaitDriverBuilder {
        this.count = count;
        this.options.comparisonType = ComparisonType.EXACT;
        return this;
    }
    
    /**
     * Sets the minimum expected count of elements
     * 
     * @param count The minimum count
     * @returns This builder instance for chaining
     */
    public withMinimumCount(count: number): CSPresenceWaitDriverBuilder {
        this.count = count;
        this.options.comparisonType = ComparisonType.AT_LEAST;
        return this;
    }
    
    /**
     * Sets the maximum expected count of elements
     * 
     * @param count The maximum count
     * @returns This builder instance for chaining
     */
    public withMaximumCount(count: number): CSPresenceWaitDriverBuilder {
        this.count = count;
        this.options.comparisonType = ComparisonType.AT_MOST;
        return this;
    }
    
    /**
     * Sets the shadow root query path
     * 
     * @param query The shadow root query path (e.g., "host-element >> nested-element")
     * @returns This builder instance for chaining
     */
    public inShadowDom(query: string): CSPresenceWaitDriverBuilder {
        this.options.shadowRootQuery = query;
        return this;
    }
    
    /**
     * Sets the frame locator
     * 
     * @param frameLocator The locator to find the frame
     * @returns This builder instance for chaining
     */
    public inFrame(frameLocator: By): CSPresenceWaitDriverBuilder {
        this.options.frameLocator = frameLocator;
        return this;
    }
    
    /**
     * Sets whether to wait for the frame to be available
     * 
     * @param wait Whether to wait for the frame
     * @returns This builder instance for chaining
     */
    public withFrameWaiting(wait: boolean): CSPresenceWaitDriverBuilder {
        this.options.waitForFrame = wait;
        return this;
    }
    
    /**
     * Sets the timeout for this wait strategy
     * 
     * @param timeout The timeout in milliseconds
     * @returns This builder instance for chaining
     */
    public withTimeout(timeout: number): CSPresenceWaitDriverBuilder {
        this.options.timeout = timeout;
        return this;
    }
    
    /**
     * Sets the polling interval for this wait strategy
     * 
     * @param pollingInterval The polling interval in milliseconds
     * @returns This builder instance for chaining
     */
    public withPollingInterval(pollingInterval: number): CSPresenceWaitDriverBuilder {
        this.options.pollingInterval = pollingInterval;
        return this;
    }
    
    /**
     * Sets a custom message for timeout errors
     * 
     * @param message The custom error message
     * @returns This builder instance for chaining
     */
    public withMessage(message: string): CSPresenceWaitDriverBuilder {
        this.options.message = message;
        return this;
    }
    
    /**
     * Enables or disables logging during presence checks
     * 
     * @param enabled Whether logging is enabled
     * @returns This builder instance for chaining
     */
    public withLogging(enabled: boolean): CSPresenceWaitDriverBuilder {
        this.options.logEnabled = enabled;
        return this;
    }
    
    /**
     * Sets whether to fail fast on errors
     * 
     * @param failFast Whether to fail fast
     * @returns This builder instance for chaining
     */
    public withFailFast(failFast: boolean): CSPresenceWaitDriverBuilder {
        this.options.failFast = failFast;
        return this;
    }
    
    /**
     * Builds the CSPresenceWait instance
     * 
     * @returns A new CSPresenceWait instance with the configured settings
     * @throws Error if any required settings are missing
     */
    public build(): CSPresenceWait {
        if (!this.driver) {
            throw new Error('WebDriver instance must be provided');
        }
        
        if (!this.locator) {
            throw new Error('Locator must be provided');
        }
        
        return new CSPresenceWait(
            this.driver,
            this.locator,
            {
                ...this.options,
                comparisonType: this.options.comparisonType || ComparisonType.AT_LEAST
            }
        );
    }
    
    /**
     * Builds and immediately executes the wait strategy
     * 
     * @returns Promise resolving when the condition is met
     */
    public async wait(): Promise<boolean> {
        return this.build().wait();
    }
}

/**
 * Builder class to create CSPresenceWait instances with a fluent API for WebElement
 */
export class CSPresenceWaitElementBuilder {
    private element: WebElement;
    private options: PresenceWaitOptions = {};
    
    /**
     * Creates a new builder instance
     * 
     * @param element The WebElement instance
     */
    constructor(element: WebElement) {
        this.element = element;
    }
    
    /**
     * Sets the timeout for this wait strategy
     * 
     * @param timeout The timeout in milliseconds
     * @returns This builder instance for chaining
     */
    public withTimeout(timeout: number): CSPresenceWaitElementBuilder {
        this.options.timeout = timeout;
        return this;
    }
    
    /**
     * Sets the polling interval for this wait strategy
     * 
     * @param pollingInterval The polling interval in milliseconds
     * @returns This builder instance for chaining
     */
    public withPollingInterval(pollingInterval: number): CSPresenceWaitElementBuilder {
        this.options.pollingInterval = pollingInterval;
        return this;
    }
    
    /**
     * Sets a custom message for timeout errors
     * 
     * @param message The custom error message
     * @returns This builder instance for chaining
     */
    public withMessage(message: string): CSPresenceWaitElementBuilder {
        this.options.message = message;
        return this;
    }
    
    /**
     * Enables or disables logging during presence checks
     * 
     * @param enabled Whether logging is enabled
     * @returns This builder instance for chaining
     */
    public withLogging(enabled: boolean): CSPresenceWaitElementBuilder {
        this.options.logEnabled = enabled;
        return this;
    }
    
    /**
     * Sets whether to fail fast on errors
     * 
     * @param failFast Whether to fail fast
     * @returns This builder instance for chaining
     */
    public withFailFast(failFast: boolean): CSPresenceWaitElementBuilder {
        this.options.failFast = failFast;
        return this;
    }
    
    /**
     * Builds the CSPresenceWait instance
     * 
     * @returns A new CSPresenceWait instance with the configured settings
     * @throws Error if any required settings are missing
     */
    public build(): CSPresenceWait {
        if (!this.element) {
            throw new Error('WebElement must be provided');
        }
        
        return new CSPresenceWait(this.element, null, this.options);
    }
    
    /**
     * Builds and immediately executes the wait strategy
     * 
     * @returns Promise resolving when the condition is met
     */
    public async wait(): Promise<boolean> {
        return this.build().wait();
    }
}



CSInvisibilityWait.ts
---------------------------

import { By, WebDriver, WebElement } from 'selenium-webdriver';
import { CSAbstractWaitStrategy } from './CSAbstractWaitStrategy';
import { CSLogger } from '../../core/utils/CSLogger';
import { TimeoutError } from '../../core/exceptions/TimeoutError';
import { CSConstants } from '../../core/utils/CSConstants';
import { CSTextUtils } from '../../core/utils/CSTextUtils';

/**
 * Wait strategy that waits for an element to be invisible or not present in the DOM.
 * An element is considered invisible if it:
 * 1. Is not present in the DOM, or
 * 2. Is present but not displayed (display: none, visibility: hidden, opacity: 0, etc.), or
 * 3. Has zero width and height, or
 * 4. Is completely outside the viewport and not reachable by scrolling
 */
export class CSInvisibilityWait extends CSAbstractWaitStrategy<boolean> {
    private readonly locator: By | null;
    private readonly element: WebElement | null;
    private readonly driver: WebDriver;
    private readonly strictMode: boolean;
    private readonly checkAllElements: boolean;
    private readonly allowZeroSize: boolean;
    private readonly checkCSSProperties: boolean;
    private readonly checkParentVisibility: boolean;
    private readonly checkOverflowHidden: boolean;
    private readonly logEnabled: boolean;
    private readonly checkComputedStyle: boolean;
    private readonly shadowRootQuery: string | null;

    /**
     * Creates a new element invisibility wait strategy instance
     * 
     * @param driverOrElement The WebDriver instance or a specific WebElement
     * @param locator The locator to find elements (if using WebDriver)
     * @param options Additional options for the invisibility wait
     */
    constructor(
        driverOrElement: WebDriver | WebElement,
        locator?: By,
        options: InvisibilityWaitOptions = {}
    ) {
        super(
            options.timeout || CSConstants.DEFAULT_TIMEOUT,
            options.pollingInterval || CSConstants.DEFAULT_POLLING_INTERVAL,
            options.message || 'Element should be invisible or not present in DOM'
        );
        
        if (driverOrElement instanceof WebDriver) {
            this.driver = driverOrElement;
            this.element = null;
            
            if (!locator) {
                throw new Error('Locator must be provided when using WebDriver');
            }
            
            this.locator = locator;
        } else {
            this.element = driverOrElement;
            this.locator = null;
            
            // Get the driver from the element
            this.driver = null;
        }
        
        this.strictMode = options.strictMode !== undefined ? options.strictMode : false;
        this.checkAllElements = options.checkAllElements !== undefined ? options.checkAllElements : false;
        this.allowZeroSize = options.allowZeroSize !== undefined ? options.allowZeroSize : false;
        this.checkCSSProperties = options.checkCSSProperties !== undefined ? options.checkCSSProperties : true;
        this.checkParentVisibility = options.checkParentVisibility !== undefined ? options.checkParentVisibility : true;
        this.checkOverflowHidden = options.checkOverflowHidden !== undefined ? options.checkOverflowHidden : true;
        this.logEnabled = options.logEnabled !== undefined ? options.logEnabled : true;
        this.checkComputedStyle = options.checkComputedStyle !== undefined ? options.checkComputedStyle : true;
        this.shadowRootQuery = options.shadowRootQuery || null;
    }

    /**
     * Checks if the element is invisible or not present in the DOM
     * 
     * @returns Promise resolving to boolean indicating whether the condition is met
     */
    protected async evaluate(): Promise<boolean> {
        try {
            // Handle single element check
            if (this.element) {
                return await this.isInvisible(this.element);
            }
            
            // Handle locator check
            if (this.driver && this.locator) {
                let elements: WebElement[];
                
                if (this.shadowRootQuery) {
                    elements = await this.findElementsInShadowDOM(this.driver, this.locator, this.shadowRootQuery);
                } else {
                    elements = await this.driver.findElements(this.locator);
                }
                
                // If no elements found, they are not present in the DOM, which means they are invisible
                if (elements.length === 0) {
                    return true;
                }
                
                // In strict mode, all elements must be invisible
                if (this.checkAllElements) {
                    for (const element of elements) {
                        const isElementInvisible = await this.isInvisible(element);
                        if (!isElementInvisible) {
                            // At least one element is visible
                            return false;
                        }
                    }
                    // All elements are invisible
                    return true;
                } else {
                    // In non-strict mode, check only the first element
                    return await this.isInvisible(elements[0]);
                }
            }
            
            throw new Error('Invalid configuration: No element or locator provided');
        } catch (error) {
            if (error.name === 'StaleElementReferenceError') {
                // Element is no longer attached to the DOM, which means it's not visible
                return true;
            }
            
            if (this.logEnabled) {
                CSLogger.debug(`Error while checking element invisibility: ${error.message}`);
            }
            
            // In strict mode, any error is considered a failure
            if (this.strictMode) {
                throw error;
            }
            
            // In non-strict mode, assume the element is not visible if an error occurs
            return true;
        }
    }
    
    /**
     * Finds elements in Shadow DOM
     * 
     * @param driver WebDriver instance
     * @param locator The locator to find elements
     * @param shadowRootQuery The shadow root query path
     * @returns Promise resolving to array of WebElements
     */
    private async findElementsInShadowDOM(
        driver: WebDriver, 
        locator: By, 
        shadowRootQuery: string
    ): Promise<WebElement[]> {
        // Parse shadow root path
        const shadowParts = shadowRootQuery.split('>>').map(part => part.trim());
        
        // Find the base element
        const baseElementSelector = shadowParts[0];
        const baseElements = await driver.findElements(By.css(baseElementSelector));
        
        if (baseElements.length === 0) {
            return [];
        }
        
        let currentElement = baseElements[0];
        
        // Navigate through the shadow DOM path
        for (let i = 1; i < shadowParts.length; i++) {
            // Get the shadow root
            const shadowRoot = await driver.executeScript(
                'return arguments[0].shadowRoot', 
                currentElement
            );
            
            if (!shadowRoot) {
                return [];
            }
            
            // Find the next element in the path
            const nextSelector = shadowParts[i];
            const elements = await driver.executeScript(
                'return arguments[0].querySelectorAll(arguments[1])',
                shadowRoot,
                nextSelector
            );
            
            if (!elements || elements.length === 0) {
                return [];
            }
            
            currentElement = elements[0];
        }
        
        // Get the shadow root of the last element in the path
        const finalShadowRoot = await driver.executeScript(
            'return arguments[0].shadowRoot', 
            currentElement
        );
        
        if (!finalShadowRoot) {
            return [];
        }
        
        // Convert the locator to a CSS selector if possible, or use XPath as fallback
        let selector: string;
        let useXPath = false;
        
        try {
            if (locator.toString().includes('By.css selector')) {
                selector = locator.toString().match(/By.css selector: (.+)\)$/)[1];
            } else if (locator.toString().includes('By.xpath')) {
                selector = locator.toString().match(/By.xpath: (.+)\)$/)[1];
                useXPath = true;
            } else if (locator.toString().includes('By.id')) {
                const id = locator.toString().match(/By.id: (.+)\)$/)[1];
                selector = `#${id}`;
            } else if (locator.toString().includes('By.className')) {
                const className = locator.toString().match(/By.className: (.+)\)$/)[1];
                selector = `.${className}`;
            } else if (locator.toString().includes('By.name')) {
                const name = locator.toString().match(/By.name: (.+)\)$/)[1];
                selector = `[name='${name}']`;
            } else if (locator.toString().includes('By.tagName')) {
                selector = locator.toString().match(/By.tagName: (.+)\)$/)[1];
            } else if (locator.toString().includes('By.linkText')) {
                const text = locator.toString().match(/By.linkText: (.+)\)$/)[1];
                selector = `a:contains('${text}')`;
            } else {
                throw new Error(`Unsupported locator type for shadow DOM: ${locator}`);
            }
        } catch (error) {
            throw new Error(`Failed to parse locator for shadow DOM: ${error.message}`);
        }
        
        // Find elements in the shadow root
        if (useXPath) {
            // XPath doesn't work directly in shadow DOM, use a workaround
            // Use document.evaluate for XPath in shadow DOM
            return await this.driver.executeScript(
                `
                const shadowRoot = arguments[0];
                const xpath = arguments[1];
                const result = [];
                const xpathResult = document.evaluate(
                    xpath, 
                    shadowRoot, 
                    null, 
                    XPathResult.ORDERED_NODE_ITERATOR_TYPE, 
                    null
                );
                let node;
                while (node = xpathResult.iterateNext()) {
                    result.push(node);
                }
                return result;
                `,
                finalShadowRoot,
                selector
            );
        } else {
            // Use querySelector for CSS selectors
            return await this.driver.executeScript(
                'return arguments[0].querySelectorAll(arguments[1])',
                finalShadowRoot,
                selector
            );
        }
    }
    
    /**
     * Checks if an element is invisible
     * 
     * @param element The element to check
     * @returns Promise resolving to boolean indicating whether the element is invisible
     */
    private async isInvisible(element: WebElement): Promise<boolean> {
        try {
            // First, check if the element is displayed (fastest check)
            const isDisplayed = await element.isDisplayed();
            
            // If element is not displayed, it's invisible
            if (!isDisplayed) {
                return true;
            }
            
            // If the element is displayed but we're in strict mode,
            // perform additional checks to ensure the element is truly invisible
            if (this.strictMode) {
                // Check element size
                if (!this.allowZeroSize) {
                    const size = await element.getRect();
                    if (size.width === 0 || size.height === 0) {
                        return true;
                    }
                }
                
                // Check CSS properties if enabled
                if (this.checkCSSProperties) {
                    const isInvisibleByCSS = await this.isInvisibleByCSSProperties(element);
                    if (isInvisibleByCSS) {
                        return true;
                    }
                }
                
                // Check parent visibility if enabled
                if (this.checkParentVisibility) {
                    const isInvisibleByParent = await this.isInvisibleByParentVisibility(element);
                    if (isInvisibleByParent) {
                        return true;
                    }
                }
                
                // Check if element is hidden by overflow if enabled
                if (this.checkOverflowHidden) {
                    const isHiddenByOverflow = await this.isHiddenByOverflow(element);
                    if (isHiddenByOverflow) {
                        return true;
                    }
                }
                
                // If we get here, the element passed all visibility checks and is considered visible
                return false;
            }
            
            // In non-strict mode, if the element is displayed, it's considered visible
            return false;
        } catch (error) {
            if (error.name === 'StaleElementReferenceError') {
                // Element is no longer attached to the DOM, which means it's not visible
                return true;
            }
            
            if (this.logEnabled) {
                CSLogger.debug(`Error while checking element visibility: ${error.message}`);
            }
            
            // In strict mode, any error is considered a failure
            if (this.strictMode) {
                throw error;
            }
            
            // In non-strict mode, assume the element is not visible if an error occurs
            return true;
        }
    }
    
    /**
     * Checks if an element is invisible based on its CSS properties
     * 
     * @param element The element to check
     * @returns Promise resolving to boolean indicating whether the element is invisible by CSS
     */
    private async isInvisibleByCSSProperties(element: WebElement): Promise<boolean> {
        try {
            if (!this.checkComputedStyle) {
                return false;
            }
            
            // Get computed style properties
            const computedStyle = await this.driver.executeScript(
                `
                const element = arguments[0];
                const style = window.getComputedStyle(element);
                return {
                    display: style.display,
                    visibility: style.visibility,
                    opacity: parseFloat(style.opacity),
                    zIndex: parseInt(style.zIndex, 10),
                    position: style.position,
                    clip: style.clip,
                    transform: style.transform
                };
                `,
                element
            ) as ComputedStyleProperties;
            
            // Check display property
            if (computedStyle.display === 'none') {
                return true;
            }
            
            // Check visibility property
            if (computedStyle.visibility === 'hidden' || computedStyle.visibility === 'collapse') {
                return true;
            }
            
            // Check opacity property
            if (computedStyle.opacity === 0) {
                return true;
            }
            
            // Check if element is clipped
            if (computedStyle.clip && computedStyle.clip !== 'auto' && computedStyle.clip !== 'none') {
                // Check if the clip rect effectively hides the element
                // Example clip: rect(0px, 0px, 0px, 0px)
                if (computedStyle.clip.includes('0px') && !computedStyle.clip.includes('auto')) {
                    return true;
                }
            }
            
            // Check if element is moved off-screen with transform
            if (computedStyle.transform && 
                (computedStyle.transform.includes('translate(-9999px') || 
                 computedStyle.transform.includes('translateX(-9999px') || 
                 computedStyle.transform.includes('translateY(-9999px'))) {
                return true;
            }
            
            // If positioned absolutely with negative position values
            if (computedStyle.position === 'absolute' || computedStyle.position === 'fixed') {
                const rect = await element.getRect();
                
                // Check if element is positioned completely outside the viewport and not reachable by scrolling
                if (rect.x < -10000 || rect.y < -10000) {
                    return true;
                }
            }
            
            return false;
        } catch (error) {
            if (this.logEnabled) {
                CSLogger.debug(`Error checking CSS properties: ${error.message}`);
            }
            
            // In strict mode, any error is considered a failure
            if (this.strictMode) {
                throw error;
            }
            
            // In non-strict mode, return false to indicate the element is not invisible by CSS
            return false;
        }
    }
    
    /**
     * Checks if an element is invisible because its parent is invisible
     * 
     * @param element The element to check
     * @returns Promise resolving to boolean indicating whether the element is invisible by parent
     */
    private async isInvisibleByParentVisibility(element: WebElement): Promise<boolean> {
        try {
            // Check if any parent element is hidden
            return await this.driver.executeScript(
                `
                const element = arguments[0];
                let currentElement = element.parentElement;
                
                while (currentElement) {
                    const style = window.getComputedStyle(currentElement);
                    
                    // Check display
                    if (style.display === 'none') {
                        return true;
                    }
                    
                    // Check visibility
                    if (style.visibility === 'hidden' || style.visibility === 'collapse') {
                        return true;
                    }
                    
                    // Check opacity
                    if (parseFloat(style.opacity) === 0) {
                        return true;
                    }
                    
                    // Move up the DOM tree
                    currentElement = currentElement.parentElement;
                }
                
                return false;
                `,
                element
            );
        } catch (error) {
            if (this.logEnabled) {
                CSLogger.debug(`Error checking parent visibility: ${error.message}`);
            }
            
            // In strict mode, any error is considered a failure
            if (this.strictMode) {
                throw error;
            }
            
            // In non-strict mode, return false to indicate the element is not invisible by parent
            return false;
        }
    }
    
    /**
     * Checks if an element is hidden by overflow properties
     * 
     * @param element The element to check
     * @returns Promise resolving to boolean indicating whether the element is hidden by overflow
     */
    private async isHiddenByOverflow(element: WebElement): Promise<boolean> {
        try {
            // Check if element is hidden by overflow
            return await this.driver.executeScript(
                `
                const element = arguments[0];
                const rect = element.getBoundingClientRect();
                
                // Check if element has zero size
                if (rect.width === 0 || rect.height === 0) {
                    return true;
                }
                
                let currentElement = element.parentElement;
                
                while (currentElement) {
                    const style = window.getComputedStyle(currentElement);
                    const parentRect = currentElement.getBoundingClientRect();
                    
                    // Skip if the parent has no dimensions
                    if (parentRect.width === 0 || parentRect.height === 0) {
                        currentElement = currentElement.parentElement;
                        continue;
                    }
                    
                    // Check only if overflow is hidden, scroll, or auto
                    if (
                        style.overflow === 'hidden' || 
                        style.overflow === 'scroll' || 
                        style.overflow === 'auto' ||
                        style.overflowX === 'hidden' || 
                        style.overflowX === 'scroll' || 
                        style.overflowX === 'auto' ||
                        style.overflowY === 'hidden' || 
                        style.overflowY === 'scroll' || 
                        style.overflowY === 'auto'
                    ) {
                        // Calculate intersection
                        const isIntersecting = !(
                            rect.top >= parentRect.bottom ||
                            rect.bottom <= parentRect.top ||
                            rect.left >= parentRect.right ||
                            rect.right <= parentRect.left
                        );
                        
                        // If not intersecting, element is hidden by overflow
                        if (!isIntersecting) {
                            return true;
                        }
                    }
                    
                    // Move up the DOM tree
                    currentElement = currentElement.parentElement;
                }
                
                return false;
                `,
                element
            );
        } catch (error) {
            if (this.logEnabled) {
                CSLogger.debug(`Error checking overflow hiding: ${error.message}`);
            }
            
            // In strict mode, any error is considered a failure
            if (this.strictMode) {
                throw error;
            }
            
            // In non-strict mode, return false to indicate the element is not hidden by overflow
            return false;
        }
    }

    /**
     * Waits for the element to be invisible or not present in the DOM
     * 
     * @returns Promise resolving when the condition is met or rejecting when the timeout is reached
     */
    public async wait(): Promise<boolean> {
        try {
            return await super.wait();
        } catch (error) {
            let errorMessage: string;
            
            if (this.element) {
                errorMessage = "Timed out waiting for element to become invisible";
            } else if (this.locator) {
                const locatorString = this.locator.toString();
                
                errorMessage = CSTextUtils.format(
                    "Timed out waiting for element(s) matching {} to become invisible",
                    locatorString
                );
                
                if (this.shadowRootQuery) {
                    errorMessage += CSTextUtils.format(" in shadow DOM path: {}", this.shadowRootQuery);
                }
                
                if (this.checkAllElements) {
                    errorMessage += " (checking all matching elements)";
                }
            } else {
                errorMessage = "Timed out waiting for element invisibility";
            }
            
            throw new TimeoutError(errorMessage, error);
        }
    }
    
    /**
     * Creates a builder for this wait strategy with a WebDriver
     * 
     * @param driver The WebDriver instance
     * @returns A new builder for invisibility wait strategies
     */
    public static forDriver(driver: WebDriver): CSInvisibilityWaitDriverBuilder {
        return new CSInvisibilityWaitDriverBuilder(driver);
    }
    
    /**
     * Creates a builder for this wait strategy with a WebElement
     * 
     * @param element The WebElement to check
     * @returns A new builder for invisibility wait strategies
     */
    public static forElement(element: WebElement): CSInvisibilityWaitElementBuilder {
        return new CSInvisibilityWaitElementBuilder(element);
    }
}

/**
 * Interface for computed style properties relevant to visibility checks
 */
interface ComputedStyleProperties {
    display: string;
    visibility: string;
    opacity: number;
    zIndex: number;
    position: string;
    clip: string;
    transform: string;
}

/**
 * Interface for invisibility wait strategy options
 */
export interface InvisibilityWaitOptions {
    timeout?: number;
    pollingInterval?: number;
    message?: string;
    strictMode?: boolean;
    checkAllElements?: boolean;
    allowZeroSize?: boolean;
    checkCSSProperties?: boolean;
    checkParentVisibility?: boolean;
    checkOverflowHidden?: boolean;
    logEnabled?: boolean;
    checkComputedStyle?: boolean;
    shadowRootQuery?: string;
}

/**
 * Builder class to create CSInvisibilityWait instances with a fluent API for WebDriver
 */
export class CSInvisibilityWaitDriverBuilder {
    private driver: WebDriver;
    private locator: By;
    private options: InvisibilityWaitOptions = {};
    
    /**
     * Creates a new builder instance
     * 
     * @param driver The WebDriver instance
     */
    constructor(driver: WebDriver) {
        this.driver = driver;
    }
    
    /**
     * Sets the locator to find elements
     * 
     * @param locator The locator to find elements
     * @returns This builder instance for chaining
     */
    public withLocator(locator: By): CSInvisibilityWaitDriverBuilder {
        this.locator = locator;
        return this;
    }
    
    /**
     * Sets strict mode for visibility checks
     * 
     * @param strictMode Whether to use strict mode
     * @returns This builder instance for chaining
     */
    public withStrictMode(strictMode: boolean): CSInvisibilityWaitDriverBuilder {
        this.options.strictMode = strictMode;
        return this;
    }
    
    /**
     * Sets whether to check all matching elements
     * 
     * @param checkAll Whether to check all matching elements
     * @returns This builder instance for chaining
     */
    public checkAllElements(checkAll: boolean): CSInvisibilityWaitDriverBuilder {
        this.options.checkAllElements = checkAll;
        return this;
    }
    
    /**
     * Sets whether zero-sized elements are considered visible
     * 
     * @param allow Whether to allow zero-sized elements to be considered visible
     * @returns This builder instance for chaining
     */
    public allowZeroSize(allow: boolean): CSInvisibilityWaitDriverBuilder {
        this.options.allowZeroSize = allow;
        return this;
    }
    
    /**
     * Sets whether to check CSS properties for visibility
     * 
     * @param check Whether to check CSS properties
     * @returns This builder instance for chaining
     */
    public checkCSSProperties(check: boolean): CSInvisibilityWaitDriverBuilder {
        this.options.checkCSSProperties = check;
        return this;
    }
    
    /**
     * Sets whether to check parent visibility
     * 
     * @param check Whether to check parent visibility
     * @returns This builder instance for chaining
     */
    public checkParentVisibility(check: boolean): CSInvisibilityWaitDriverBuilder {
        this.options.checkParentVisibility = check;
        return this;
    }
    
    /**
     * Sets whether to check overflow hiding
     * 
     * @param check Whether to check overflow hiding
     * @returns This builder instance for chaining
     */
    public checkOverflowHidden(check: boolean): CSInvisibilityWaitDriverBuilder {
        this.options.checkOverflowHidden = check;
        return this;
    }
    
    /**
     * Sets whether to check computed style properties
     * 
     * @param check Whether to check computed style properties
     * @returns This builder instance for chaining
     */
    public checkComputedStyle(check: boolean): CSInvisibilityWaitDriverBuilder {
        this.options.checkComputedStyle = check;
        return this;
    }
    
    /**
     * Sets the shadow root query path
     * 
     * @param query The shadow root query path (e.g., "host-element >> nested-element")
     * @returns This builder instance for chaining
     */
    public inShadowDom(query: string): CSInvisibilityWaitDriverBuilder {
        this.options.shadowRootQuery = query;
        return this;
    }
    
    /**
     * Sets the timeout for this wait strategy
     * 
     * @param timeout The timeout in milliseconds
     * @returns This builder instance for chaining
     */
    public withTimeout(timeout: number): CSInvisibilityWaitDriverBuilder {
        this.options.timeout = timeout;
        return this;
    }
    
    /**
     * Sets the polling interval for this wait strategy
     * 
     * @param pollingInterval The polling interval in milliseconds
     * @returns This builder instance for chaining
     */
    public withPollingInterval(pollingInterval: number): CSInvisibilityWaitDriverBuilder {
        this.options.pollingInterval = pollingInterval;
        return this;
    }
    
    /**
     * Sets a custom message for timeout errors
     * 
     * @param message The custom error message
     * @returns This builder instance for chaining
     */
    public withMessage(message: string): CSInvisibilityWaitDriverBuilder {
        this.options.message = message;
        return this;
    }
    
    /**
     * Enables or disables logging during invisibility checks
     * 
     * @param enabled Whether logging is enabled
     * @returns This builder instance for chaining
     */
    public withLogging(enabled: boolean): CSInvisibilityWaitDriverBuilder {
        this.options.logEnabled = enabled;
        return this;
    }
    
    /**
     * Builds the CSInvisibilityWait instance
     * 
     * @returns A new CSInvisibilityWait instance with the configured settings
     * @throws Error if any required settings are missing
     */
    public build(): CSInvisibilityWait {
        if (!this.driver) {
            throw new Error('WebDriver instance must be provided');
        }
        
        if (!this.locator) {
            throw new Error('Locator must be provided');
        }
        
        return new CSInvisibilityWait(this.driver, this.locator, this.options);
    }
    
    /**
     * Builds and immediately executes the wait strategy
     * 
     * @returns Promise resolving when the condition is met
     */
    public async wait(): Promise<boolean> {
        return this.build().wait();
    }
}

/**
 * Builder class to create CSInvisibilityWait instances with a fluent API for WebElement
 */
export class CSInvisibilityWaitElementBuilder {
    private element: WebElement;
    private options: InvisibilityWaitOptions = {};
    
    /**
     * Creates a new builder instance
     * 
     * @param element The WebElement to check
     */
    constructor(element: WebElement) {
        this.element = element;
    }
    
    /**
     * Sets strict mode for visibility checks
     * 
     * @param strictMode Whether to use strict mode
     * @returns This builder instance for chaining
     */
    public withStrictMode(strictMode: boolean): CSInvisibilityWaitElementBuilder {
        this.options.strictMode = strictMode;
        return this;
    }
    
    /**
     * Sets whether zero-sized elements are considered visible
     * 
     * @param allow Whether to allow zero-sized elements to be considered visible
     * @returns This builder instance for chaining
     */
    public allowZeroSize(allow: boolean): CSInvisibilityWaitElementBuilder {
        this.options.allowZeroSize = allow;
        return this;
    }
    
    /**
     * Sets whether to check CSS properties for visibility
     * 
     * @param check Whether to check CSS properties
     * @returns This builder instance for chaining
     */
    public checkCSSProperties(check: boolean): CSInvisibilityWaitElementBuilder {
        this.options.checkCSSProperties = check;
        return this;
    }
    
    /**
     * Sets whether to check parent visibility
     * 
     * @param check Whether to check parent visibility
     * @returns This builder instance for chaining
     */
    public checkParentVisibility(check: boolean): CSInvisibilityWaitElementBuilder {
        this.options.checkParentVisibility = check;
        return this;
    }
    
    /**
     * Sets whether to check overflow hiding
     * 
     * @param check Whether to check overflow hiding
     * @returns This builder instance for chaining
     */
    public checkOverflowHidden(check: boolean): CSInvisibilityWaitElementBuilder {
        this.options.checkOverflowHidden = check;
        return this;
    }
    
    /**
     * Sets whether to check computed style properties
     * 
     * @param check Whether to check computed style properties
     * @returns This builder instance for chaining
     */
    public checkComputedStyle(check: boolean): CSInvisibilityWaitElementBuilder {
        this.options.checkComputedStyle = check;
        return this;
    }
    
    /**
     * Sets the timeout for this wait strategy
     * 
     * @param timeout The timeout in milliseconds
     * @returns This builder instance for chaining
     */
    public withTimeout(timeout: number): CSInvisibilityWaitElementBuilder {
        this.options.timeout = timeout;
        return this;
    }
    
    /**
     * Sets the polling interval for this wait strategy
     * 
     * @param pollingInterval The polling interval in milliseconds
     * @returns This builder instance for chaining
     */
    public withPollingInterval(pollingInterval: number): CSInvisibilityWaitElementBuilder {
        this.options.pollingInterval = pollingInterval;
        return this;
    }
    
    /**
     * Sets a custom message for timeout errors
     * 
     * @param message The custom error message
     * @returns This builder instance for chaining
     */
    public withMessage(message: string): CSInvisibilityWaitElementBuilder {
        this.options.message = message;
        return this;
    }
    
    /**
     * Enables or disables logging during invisibility checks
     * 
     * @param enabled Whether logging is enabled
     * @returns This builder instance for chaining
     */
    public withLogging(enabled: boolean): CSInvisibilityWaitElementBuilder {
        this.options.logEnabled = enabled;
        return this;
    }
    
    /**
     * Builds the CSInvisibilityWait instance
     * 
     * @returns A new CSInvisibilityWait instance with the configured settings
     * @throws Error if any required settings are missing
     */
    public build(): CSInvisibilityWait {
        if (!this.element) {
            throw new Error('WebElement must be provided');
        }
        
        return new CSInvisibilityWait(this.element, null, this.options);
    }
    
    /**
     * Builds and immediately executes the wait strategy
     * 
     * @returns Promise resolving when the condition is met
     */
    public async wait(): Promise<boolean> {
        return this.build().wait();
    }
}



CSSelect.ts
------------------------

import { By, WebElement, WebDriver } from 'selenium-webdriver';
import { CSElement } from './CSElement';
import { CSElementList } from './CSElementList';
import { CSWaitFactory } from '../wait/CSWaitFactory';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSConstants } from '../../core/utils/CSConstants';
import { CSTextUtils } from '../../core/utils/CSTextUtils';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';
import { ActionFailedException } from '../../core/exceptions/ActionFailedException';
import { InvalidStateException } from '../../core/exceptions/InvalidStateException';

/**
 * Enhanced select element wrapper with advanced interaction capabilities.
 * Provides methods for handling both traditional select elements and custom
 * select implementations (e.g., div-based dropdowns, material design selects).
 */
export class CSSelect extends CSElement {
    private readonly optionsLocator: By;
    private readonly containerLocator: By | null;
    private readonly isCustomSelect: boolean;
    private readonly customSelectConfig: CustomSelectConfig;
    private readonly multiSelect: boolean;
    private cachedOptions: WebElement[] | null = null;
    private cachedOptionsText: string[] | null = null;
    private cachedOptionsValue: string[] | null = null;
    private readonly observeOptionChanges: boolean;
    private readonly expandBeforeSelect: boolean;

    /**
     * Creates a new select element wrapper.
     * 
     * @param element The WebElement representing the select element
     * @param options Configuration options for the select element
     */
    constructor(element: WebElement, options: CSSelectOptions = {}) {
        super(element);
        
        this.optionsLocator = options.optionsLocator || By.css('option');
        this.containerLocator = options.containerLocator || null;
        this.isCustomSelect = options.isCustomSelect || false;
        this.multiSelect = options.multiSelect || false;
        this.observeOptionChanges = options.observeOptionChanges !== undefined ? options.observeOptionChanges : true;
        this.expandBeforeSelect = options.expandBeforeSelect !== undefined ? options.expandBeforeSelect : this.isCustomSelect;
        
        // Default configuration for custom selects
        this.customSelectConfig = {
            expandSelector: options.customSelectConfig?.expandSelector || '.select-dropdown, .select-field, [role="combobox"]',
            optionsContainerSelector: options.customSelectConfig?.optionsContainerSelector || '.select-options, .dropdown-menu, [role="listbox"]',
            optionSelector: options.customSelectConfig?.optionSelector || '.select-option, .dropdown-item, [role="option"]',
            selectedClass: options.customSelectConfig?.selectedClass || 'selected',
            selectedAttribute: options.customSelectConfig?.selectedAttribute || 'aria-selected',
            expandMethod: options.customSelectConfig?.expandMethod || 'click',
            optionSelectMethod: options.customSelectConfig?.optionSelectMethod || 'click',
            closeAfterSelection: options.customSelectConfig?.closeAfterSelection !== undefined ? 
                options.customSelectConfig.closeAfterSelection : true,
            customSelectCloseMethod: options.customSelectConfig?.customSelectCloseMethod || 'clickOutside',
            searchInputSelector: options.customSelectConfig?.searchInputSelector || '.select-search, input[type="search"]',
            selectAllSelector: options.customSelectConfig?.selectAllSelector || '[data-select-all], .select-all',
            clearSelectionSelector: options.customSelectConfig?.clearSelectionSelector || '[data-clear], .clear-selection',
            ...options.customSelectConfig
        };
    }

    /**
     * Selects an option by visible text.
     * 
     * @param text The visible text of the option to select
     * @param exactMatch Whether to match the text exactly or use contains
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws ActionFailedException if the option cannot be selected
     */
    public async selectByVisibleText(
        text: string, 
        exactMatch: boolean = true, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        await this.ensureSelectIsInteractable();
        
        try {
            if (this.isCustomSelect) {
                return await this.selectCustomOptionByText(text, exactMatch, timeout);
            }
            
            // Native select element
            const options = await this.getOptions(timeout);
            let found = false;
            
            for (const option of options) {
                const optionText = await option.getText();
                
                if ((exactMatch && optionText === text) || (!exactMatch && optionText.includes(text))) {
                    // Check if option is already selected in multi-select
                    if (this.multiSelect) {
                        const isSelected = await option.isSelected();
                        if (!isSelected) {
                            await option.click();
                        }
                    } else {
                        await option.click();
                    }
                    found = true;
                    
                    // For single select, we can break once we find the first match
                    if (!this.multiSelect) {
                        break;
                    }
                }
            }
            
            if (!found) {
                throw new ElementNotFoundException(`Option with text "${text}" not found in select element`);
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to select option with text "${text}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Selects an option by its value attribute.
     * 
     * @param value The value attribute of the option to select
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws ActionFailedException if the option cannot be selected
     */
    public async selectByValue(
        value: string, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        await this.ensureSelectIsInteractable();
        
        try {
            if (this.isCustomSelect) {
                return await this.selectCustomOptionByValue(value, timeout);
            }
            
            // Native select element
            const options = await this.getOptions(timeout);
            let found = false;
            
            for (const option of options) {
                const optionValue = await option.getAttribute('value');
                
                if (optionValue === value) {
                    // Check if option is already selected in multi-select
                    if (this.multiSelect) {
                        const isSelected = await option.isSelected();
                        if (!isSelected) {
                            await option.click();
                        }
                    } else {
                        await option.click();
                    }
                    found = true;
                    
                    // For single select, we can break once we find the first match
                    if (!this.multiSelect) {
                        break;
                    }
                }
            }
            
            if (!found) {
                throw new ElementNotFoundException(`Option with value "${value}" not found in select element`);
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to select option with value "${value}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Selects an option by its index.
     * 
     * @param index The zero-based index of the option to select
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws ActionFailedException if the option cannot be selected
     */
    public async selectByIndex(
        index: number, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        await this.ensureSelectIsInteractable();
        
        try {
            if (this.isCustomSelect) {
                return await this.selectCustomOptionByIndex(index, timeout);
            }
            
            // Native select element
            const options = await this.getOptions(timeout);
            
            if (index < 0 || index >= options.length) {
                throw new ElementNotFoundException(`Option with index ${index} is out of bounds (0-${options.length - 1})`);
            }
            
            await options[index].click();
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to select option with index ${index}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Deselects an option by visible text (only for multi-select elements).
     * 
     * @param text The visible text of the option to deselect
     * @param exactMatch Whether to match the text exactly or use contains
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws InvalidStateException if not a multi-select element
     * @throws ActionFailedException if the option cannot be deselected
     */
    public async deselectByVisibleText(
        text: string, 
        exactMatch: boolean = true, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        if (!this.multiSelect) {
            throw new InvalidStateException("Cannot deselect options in a non-multi-select element");
        }
        
        await this.ensureSelectIsInteractable();
        
        try {
            if (this.isCustomSelect) {
                return await this.deselectCustomOptionByText(text, exactMatch, timeout);
            }
            
            // Native select element
            const options = await this.getOptions(timeout);
            let found = false;
            
            for (const option of options) {
                const optionText = await option.getText();
                const isSelected = await option.isSelected();
                
                if (isSelected && ((exactMatch && optionText === text) || (!exactMatch && optionText.includes(text)))) {
                    await option.click();
                    found = true;
                }
            }
            
            if (!found) {
                throw new ElementNotFoundException(`Selected option with text "${text}" not found in select element`);
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to deselect option with text "${text}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Deselects an option by its value attribute (only for multi-select elements).
     * 
     * @param value The value attribute of the option to deselect
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws InvalidStateException if not a multi-select element
     * @throws ActionFailedException if the option cannot be deselected
     */
    public async deselectByValue(
        value: string, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        if (!this.multiSelect) {
            throw new InvalidStateException("Cannot deselect options in a non-multi-select element");
        }
        
        await this.ensureSelectIsInteractable();
        
        try {
            if (this.isCustomSelect) {
                return await this.deselectCustomOptionByValue(value, timeout);
            }
            
            // Native select element
            const options = await this.getOptions(timeout);
            let found = false;
            
            for (const option of options) {
                const optionValue = await option.getAttribute('value');
                const isSelected = await option.isSelected();
                
                if (isSelected && optionValue === value) {
                    await option.click();
                    found = true;
                }
            }
            
            if (!found) {
                throw new ElementNotFoundException(`Selected option with value "${value}" not found in select element`);
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to deselect option with value "${value}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Deselects an option by its index (only for multi-select elements).
     * 
     * @param index The zero-based index of the option to deselect
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws InvalidStateException if not a multi-select element
     * @throws ActionFailedException if the option cannot be deselected
     */
    public async deselectByIndex(
        index: number, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        if (!this.multiSelect) {
            throw new InvalidStateException("Cannot deselect options in a non-multi-select element");
        }
        
        await this.ensureSelectIsInteractable();
        
        try {
            if (this.isCustomSelect) {
                return await this.deselectCustomOptionByIndex(index, timeout);
            }
            
            // Native select element
            const options = await this.getOptions(timeout);
            
            if (index < 0 || index >= options.length) {
                throw new ElementNotFoundException(`Option with index ${index} is out of bounds (0-${options.length - 1})`);
            }
            
            const isSelected = await options[index].isSelected();
            
            if (isSelected) {
                await options[index].click();
            } else {
                throw new ElementNotFoundException(`Option with index ${index} is not selected`);
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to deselect option with index ${index}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Deselects all selected options (only for multi-select elements).
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws InvalidStateException if not a multi-select element
     * @throws ActionFailedException if options cannot be deselected
     */
    public async deselectAll(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<CSSelect> {
        if (!this.multiSelect) {
            throw new InvalidStateException("Cannot deselect options in a non-multi-select element");
        }
        
        await this.ensureSelectIsInteractable();
        
        try {
            if (this.isCustomSelect) {
                return await this.deselectAllCustomOptions(timeout);
            }
            
            // Native select element
            const options = await this.getOptions(timeout);
            
            for (const option of options) {
                const isSelected = await option.isSelected();
                
                if (isSelected) {
                    await option.click();
                }
            }
            
            return this;
        } catch (error) {
            throw new ActionFailedException(
                `Failed to deselect all options: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets all options in the select element.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to an array of WebElements representing the options
     * @throws ElementNotFoundException if options cannot be found
     */
    public async getOptions(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<WebElement[]> {
        if (this.cachedOptions && !this.observeOptionChanges) {
            return this.cachedOptions;
        }
        
        try {
            if (this.isCustomSelect) {
                if (this.expandBeforeSelect) {
                    await this.expandCustomSelect();
                }
                
                const options = await this.getCustomSelectOptions(timeout);
                
                if (this.observeOptionChanges) {
                    this.cachedOptions = options;
                }
                
                return options;
            }
            
            // Native select element
            const options = await this.element.findElements(this.optionsLocator);
            
            if (options.length === 0) {
                throw new ElementNotFoundException("No options found in select element");
            }
            
            if (this.observeOptionChanges) {
                this.cachedOptions = options;
            }
            
            return options;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(
                `Failed to get options: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets all option text values in the select element.
     * 
     * @param refresh Whether to refresh the cache
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to an array of strings representing the option text values
     * @throws ElementNotFoundException if options cannot be found
     */
    public async getOptionsText(
        refresh: boolean = false,
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<string[]> {
        if (this.cachedOptionsText && !refresh && !this.observeOptionChanges) {
            return this.cachedOptionsText;
        }
        
        try {
            const options = await this.getOptions(timeout);
            const textValues: string[] = [];
            
            for (const option of options) {
                textValues.push(await option.getText());
            }
            
            if (this.observeOptionChanges || refresh) {
                this.cachedOptionsText = textValues;
            }
            
            return textValues;
        } catch (error) {
            throw new ElementNotFoundException(
                `Failed to get option text values: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets all option value attributes in the select element.
     * 
     * @param refresh Whether to refresh the cache
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to an array of strings representing the option value attributes
     * @throws ElementNotFoundException if options cannot be found
     */
    public async getOptionsValues(
        refresh: boolean = false,
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<string[]> {
        if (this.cachedOptionsValue && !refresh && !this.observeOptionChanges) {
            return this.cachedOptionsValue;
        }
        
        try {
            const options = await this.getOptions(timeout);
            const values: string[] = [];
            
            for (const option of options) {
                values.push(await option.getAttribute('value'));
            }
            
            if (this.observeOptionChanges || refresh) {
                this.cachedOptionsValue = values;
            }
            
            return values;
        } catch (error) {
            throw new ElementNotFoundException(
                `Failed to get option values: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets the currently selected option.
     * For multi-select elements, returns the first selected option.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to the selected WebElement, or null if no option is selected
     * @throws ElementNotFoundException if options cannot be found
     */
    public async getSelectedOption(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<WebElement | null> {
        try {
            if (this.isCustomSelect) {
                return await this.getSelectedCustomOption(timeout);
            }
            
            // Native select element
            const options = await this.getOptions(timeout);
            
            for (const option of options) {
                const isSelected = await option.isSelected();
                
                if (isSelected) {
                    return option;
                }
            }
            
            return null;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(
                `Failed to get selected option: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets all selected options for multi-select elements.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to an array of selected WebElements
     * @throws ElementNotFoundException if options cannot be found
     */
    public async getAllSelectedOptions(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<WebElement[]> {
        try {
            if (this.isCustomSelect) {
                return await this.getAllSelectedCustomOptions(timeout);
            }
            
            // Native select element
            const options = await this.getOptions(timeout);
            const selectedOptions: WebElement[] = [];
            
            for (const option of options) {
                const isSelected = await option.isSelected();
                
                if (isSelected) {
                    selectedOptions.push(option);
                }
            }
            
            return selectedOptions;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(
                `Failed to get selected options: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets the text of the currently selected option.
     * For multi-select elements, returns the text of the first selected option.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to the selected option text, or null if no option is selected
     * @throws ElementNotFoundException if options cannot be found
     */
    public async getSelectedText(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<string | null> {
        try {
            const selectedOption = await this.getSelectedOption(timeout);
            
            if (selectedOption) {
                return await selectedOption.getText();
            }
            
            return null;
        } catch (error) {
            throw new ElementNotFoundException(
                `Failed to get selected option text: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets the value attribute of the currently selected option.
     * For multi-select elements, returns the value of the first selected option.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to the selected option value, or null if no option is selected
     * @throws ElementNotFoundException if options cannot be found
     */
    public async getSelectedValue(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<string | null> {
        try {
            const selectedOption = await this.getSelectedOption(timeout);
            
            if (selectedOption) {
                return await selectedOption.getAttribute('value');
            }
            
            return null;
        } catch (error) {
            throw new ElementNotFoundException(
                `Failed to get selected option value: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets the index of the currently selected option.
     * For multi-select elements, returns the index of the first selected option.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to the selected option index, or -1 if no option is selected
     * @throws ElementNotFoundException if options cannot be found
     */
    public async getSelectedIndex(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<number> {
        try {
            const options = await this.getOptions(timeout);
            
            for (let i = 0; i < options.length; i++) {
                const isSelected = await options[i].isSelected();
                
                if (isSelected) {
                    return i;
                }
            }
            
            return -1;
        } catch (error) {
            throw new ElementNotFoundException(
                `Failed to get selected option index: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets the text values of all selected options for multi-select elements.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to an array of selected option text values
     * @throws ElementNotFoundException if options cannot be found
     */
    public async getAllSelectedText(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<string[]> {
        try {
            const selectedOptions = await this.getAllSelectedOptions(timeout);
            const textValues: string[] = [];
            
            for (const option of selectedOptions) {
                textValues.push(await option.getText());
            }
            
            return textValues;
        } catch (error) {
            throw new ElementNotFoundException(
                `Failed to get selected option text values: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets the value attributes of all selected options for multi-select elements.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to an array of selected option value attributes
     * @throws ElementNotFoundException if options cannot be found
     */
    public async getAllSelectedValues(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<string[]> {
        try {
            const selectedOptions = await this.getAllSelectedOptions(timeout);
            const values: string[] = [];
            
            for (const option of selectedOptions) {
                values.push(await option.getAttribute('value'));
            }
            
            return values;
        } catch (error) {
            throw new ElementNotFoundException(
                `Failed to get selected option values: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Checks if the select element has a specific option by visible text.
     * 
     * @param text The visible text of the option to check
     * @param exactMatch Whether to match the text exactly or use contains
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to boolean indicating whether the option exists
     */
    public async hasOptionWithText(
        text: string, 
        exactMatch: boolean = true, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<boolean> {
        try {
            const optionsText = await this.getOptionsText(false, timeout);
            
            return optionsText.some(optionText => {
                return exactMatch ? optionText === text : optionText.includes(text);
            });
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Checks if the select element has a specific option by value attribute.
     * 
     * @param value The value attribute of the option to check
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to boolean indicating whether the option exists
     */
    public async hasOptionWithValue(
        value: string, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<boolean> {
        try {
            const optionsValues = await this.getOptionsValues(false, timeout);
            
            return optionsValues.includes(value);
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Checks if the multi-select element has any selected options.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to boolean indicating whether any option is selected
     */
    public async hasSelectedOptions(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<boolean> {
        try {
            const selectedOption = await this.getSelectedOption(timeout);
            
            return selectedOption !== null;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Gets the container element for custom selects.
     * 
     * @returns Promise resolving to the CSElement representing the container element
     * @throws ElementNotFoundException if the container cannot be found
     */
    public async getContainer(): Promise<CSElement> {
        if (!this.isCustomSelect) {
            return this;
        }
        
        try {
            if (this.containerLocator) {
                const container = await this.element.findElement(this.containerLocator);
                return new CSElement(container);
            }
            
            return this;
        } catch (error) {
            throw new ElementNotFoundException(
                `Failed to get container element: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Waits for the options to be available.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving when options are available
     * @throws TimeoutError if options are not available within the timeout
     */
    public async waitForOptions(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<void> {
        if (this.isCustomSelect) {
            await this.expandCustomSelect();
            
            await CSWaitFactory.createWait(this.element)
                .untilLocated(By.css(this.customSelectConfig.optionSelector))
                .withTimeout(timeout)
                .withMessage(`Waiting for custom select options to be available`)
                .wait();
        } else {
            await CSWaitFactory.createWait(this.element)
                .untilLocated(this.optionsLocator)
                .withTimeout(timeout)
                .withMessage(`Waiting for select options to be available`)
                .wait();
        }
    }

    /**
     * PRIVATE METHODS FOR CUSTOM SELECT IMPLEMENTATION
     */

    /**
     * Ensures the select element is interactable.
     * 
     * @returns Promise resolving when the element is interactable
     * @throws ActionFailedException if the element is not interactable
     */
    private async ensureSelectIsInteractable(): Promise<void> {
        try {
            await CSWaitFactory.createWait(this.element)
                .untilInteractable()
                .withMessage(`Waiting for select element to be interactable`)
                .wait();
            
            if (!this.isCustomSelect) {
                const tagName = await this.element.getTagName();
                
                if (tagName.toLowerCase() !== 'select') {
                    throw new Error("Element is not a select element");
                }
                
                if (!this.multiSelect) {
                    // Verify that this is not a multi-select if multiSelect is false
                    const multiple = await this.element.getAttribute('multiple');
                    
                    if (multiple && multiple !== 'false') {
                        CSLogger.warn("Element is a multi-select but multiSelect is false");
                        // Update the multiSelect flag
                        (this as any).multiSelect = true;
                    }
                }
            }
        } catch (error) {
            throw new ActionFailedException(
                `Select element is not interactable: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Expands a custom select element.
     * 
     * @returns Promise resolving when the custom select is expanded
     * @throws ActionFailedException if the custom select cannot be expanded
     */
    private async expandCustomSelect(): Promise<void> {
        if (!this.isCustomSelect) {
            return;
        }
        
        try {
            // Find the dropdown toggle element
            let toggleElement: WebElement;
            
            try {
                toggleElement = await this.element.findElement(By.css(this.customSelectConfig.expandSelector));
            } catch (error) {
                // If no specific toggle element is found, use the select element itself
                toggleElement = this.element;
            }
            
            // Check if the dropdown is already expanded
            const isExpanded = await this.isCustomSelectExpanded();
            
            if (isExpanded) {
                return;
            }
            
            // Expand the dropdown
            switch (this.customSelectConfig.expandMethod) {
                case 'click':
                    await toggleElement.click();
                    break;
                
                case 'focus':
                    await toggleElement.sendKeys('');
                    break;
                
                case 'mouseDown':
                    await this.driver.actions()
                        .move({ origin: toggleElement })
                        .press()
                        .perform();
                    break;
                
                case 'hover':
                    await this.driver.actions()
                        .move({ origin: toggleElement })
                        .perform();
                    break;
                
                default:
                    await toggleElement.click();
                    break;
            }
            
            // Wait for the dropdown to expand
            await this.waitForCustomSelectExpanded();
        } catch (error) {
            throw new ActionFailedException(
                `Failed to expand custom select: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Checks if a custom select element is expanded.
     * 
     * @returns Promise resolving to boolean indicating whether the custom select is expanded
     */
    private async isCustomSelectExpanded(): Promise<boolean> {
        try {
            // Check for expanded attribute
            const ariaExpanded = await this.element.getAttribute('aria-expanded');
            
            if (ariaExpanded === 'true') {
                return true;
            }
            
            // Check for presence of the options container
            const optionsContainer = await this.findCustomOptionsContainer();
            
            if (!optionsContainer) {
                return false;
            }
            
            // Check if the options container is displayed
            return await optionsContainer.isDisplayed();
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Waits for a custom select element to be expanded.
     * 
     * @param timeout Timeout in milliseconds to wait for the custom select to be expanded
     * @returns Promise resolving when the custom select is expanded
     * @throws TimeoutError if the custom select is not expanded within the timeout
     */
    private async waitForCustomSelectExpanded(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<void> {
        const wait = CSWaitFactory.createWait(this.driver);
        
        await wait.until(async () => {
            return await this.isCustomSelectExpanded();
        })
        .withTimeout(timeout)
        .withMessage(`Waiting for custom select to be expanded`)
        .wait();
    }
    
    /**
     * Finds the options container for a custom select element.
     * 
     * @returns Promise resolving to the WebElement representing the options container, or null if not found
     */
    private async findCustomOptionsContainer(): Promise<WebElement | null> {
        try {
            // Try to find the options container relative to the select element
            const container = await this.element.findElement(By.css(this.customSelectConfig.optionsContainerSelector));
            return container;
        } catch (error) {
            try {
                // If not found, try to find it in the document
                const containers = await this.driver.findElements(By.css(this.customSelectConfig.optionsContainerSelector));
                
                // Find the first visible container
                for (const container of containers) {
                    const isDisplayed = await container.isDisplayed();
                    
                    if (isDisplayed) {
                        return container;
                    }
                }
                
                return null;
            } catch (error) {
                return null;
            }
        }
    }
    
    /**
     * Gets the options for a custom select element.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to an array of WebElements representing the options
     * @throws ElementNotFoundException if options cannot be found
     */
    private async getCustomSelectOptions(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<WebElement[]> {
        try {
            // Find the options container
            const container = await this.findCustomOptionsContainer();
            
            if (!container) {
                throw new ElementNotFoundException("Options container not found for custom select");
            }
            
            // Wait for options to be available
            await CSWaitFactory.createWait(container)
                .untilLocated(By.css(this.customSelectConfig.optionSelector))
                .withTimeout(timeout)
                .withMessage(`Waiting for custom select options to be available`)
                .wait();
            
            // Get the options
            const options = await container.findElements(By.css(this.customSelectConfig.optionSelector));
            
            if (options.length === 0) {
                throw new ElementNotFoundException("No options found in custom select");
            }
            
            return options;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(
                `Failed to get custom select options: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Selects a custom select option by visible text.
     * 
     * @param text The visible text of the option to select
     * @param exactMatch Whether to match the text exactly or use contains
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws ElementNotFoundException if the option cannot be found
     * @throws ActionFailedException if the option cannot be selected
     */
    private async selectCustomOptionByText(
        text: string, 
        exactMatch: boolean = true, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        try {
            await this.expandCustomSelect();
            
            const options = await this.getCustomSelectOptions(timeout);
            let found = false;
            
            for (const option of options) {
                const optionText = await option.getText();
                
                if ((exactMatch && optionText === text) || (!exactMatch && optionText.includes(text))) {
                    // Check if option is already selected in multi-select
                    if (this.multiSelect) {
                        const isSelected = await this.isCustomOptionSelected(option);
                        if (!isSelected) {
                            await this.clickCustomOption(option);
                        }
                    } else {
                        await this.clickCustomOption(option);
                        
                        if (this.customSelectConfig.closeAfterSelection) {
                            await this.closeCustomSelect();
                        }
                    }
                    found = true;
                    
                    // For single select, we can break once we find the first match
                    if (!this.multiSelect) {
                        break;
                    }
                }
            }
            
            if (!found) {
                throw new ElementNotFoundException(`Option with text "${text}" not found in custom select`);
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to select custom option with text "${text}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Selects a custom select option by value attribute.
     * 
     * @param value The value attribute of the option to select
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws ElementNotFoundException if the option cannot be found
     * @throws ActionFailedException if the option cannot be selected
     */
    private async selectCustomOptionByValue(
        value: string, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        try {
            await this.expandCustomSelect();
            
            const options = await this.getCustomSelectOptions(timeout);
            let found = false;
            
            for (const option of options) {
                const optionValue = await option.getAttribute('value') || await option.getAttribute('data-value');
                
                if (optionValue === value) {
                    // Check if option is already selected in multi-select
                    if (this.multiSelect) {
                        const isSelected = await this.isCustomOptionSelected(option);
                        if (!isSelected) {
                            await this.clickCustomOption(option);
                        }
                    } else {
                        await this.clickCustomOption(option);
                        
                        if (this.customSelectConfig.closeAfterSelection) {
                            await this.closeCustomSelect();
                        }
                    }
                    found = true;
                    
                    // For single select, we can break once we find the first match
                    if (!this.multiSelect) {
                        break;
                    }
                }
            }
            
            if (!found) {
                throw new ElementNotFoundException(`Option with value "${value}" not found in custom select`);
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to select custom option with value "${value}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Selects a custom select option by its index.
     * 
     * @param index The zero-based index of the option to select
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws ElementNotFoundException if the option cannot be found
     * @throws ActionFailedException if the option cannot be selected
     */
    private async selectCustomOptionByIndex(
        index: number, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        try {
            await this.expandCustomSelect();
            
            const options = await this.getCustomSelectOptions(timeout);
            
            if (index < 0 || index >= options.length) {
                throw new ElementNotFoundException(`Option with index ${index} is out of bounds (0-${options.length - 1})`);
            }
            
            // Check if option is already selected in multi-select
            if (this.multiSelect) {
                const isSelected = await this.isCustomOptionSelected(options[index]);
                if (!isSelected) {
                    await this.clickCustomOption(options[index]);
                }
            } else {
                await this.clickCustomOption(options[index]);
                
                if (this.customSelectConfig.closeAfterSelection) {
                    await this.closeCustomSelect();
                }
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to select custom option with index ${index}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Deselects a custom select option by visible text.
     * 
     * @param text The visible text of the option to deselect
     * @param exactMatch Whether to match the text exactly or use contains
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws ElementNotFoundException if the option cannot be found
     * @throws ActionFailedException if the option cannot be deselected
     */
    private async deselectCustomOptionByText(
        text: string, 
        exactMatch: boolean = true, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        try {
            await this.expandCustomSelect();
            
            const options = await this.getCustomSelectOptions(timeout);
            let found = false;
            
            for (const option of options) {
                const optionText = await option.getText();
                const isSelected = await this.isCustomOptionSelected(option);
                
                if (isSelected && ((exactMatch && optionText === text) || (!exactMatch && optionText.includes(text)))) {
                    await this.clickCustomOption(option);
                    found = true;
                }
            }
            
            if (!found) {
                throw new ElementNotFoundException(`Selected option with text "${text}" not found in custom select`);
            }
            
            if (this.customSelectConfig.closeAfterSelection) {
                await this.closeCustomSelect();
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to deselect custom option with text "${text}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Deselects a custom select option by value attribute.
     * 
     * @param value The value attribute of the option to deselect
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws ElementNotFoundException if the option cannot be found
     * @throws ActionFailedException if the option cannot be deselected
     */
    private async deselectCustomOptionByValue(
        value: string, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        try {
            await this.expandCustomSelect();
            
            const options = await this.getCustomSelectOptions(timeout);
            let found = false;
            
            for (const option of options) {
                const optionValue = await option.getAttribute('value') || await option.getAttribute('data-value');
                const isSelected = await this.isCustomOptionSelected(option);
                
                if (isSelected && optionValue === value) {
                    await this.clickCustomOption(option);
                    found = true;
                }
            }
            
            if (!found) {
                throw new ElementNotFoundException(`Selected option with value "${value}" not found in custom select`);
            }
            
            if (this.customSelectConfig.closeAfterSelection) {
                await this.closeCustomSelect();
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to deselect custom option with value "${value}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Deselects a custom select option by its index.
     * 
     * @param index The zero-based index of the option to deselect
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws ElementNotFoundException if the option cannot be found
     * @throws ActionFailedException if the option cannot be deselected
     */
    private async deselectCustomOptionByIndex(
        index: number, 
        timeout: number = CSConstants.DEFAULT_TIMEOUT
    ): Promise<CSSelect> {
        try {
            await this.expandCustomSelect();
            
            const options = await this.getCustomSelectOptions(timeout);
            
            if (index < 0 || index >= options.length) {
                throw new ElementNotFoundException(`Option with index ${index} is out of bounds (0-${options.length - 1})`);
            }
            
            const isSelected = await this.isCustomOptionSelected(options[index]);
            
            if (isSelected) {
                await this.clickCustomOption(options[index]);
            } else {
                throw new ElementNotFoundException(`Option with index ${index} is not selected`);
            }
            
            if (this.customSelectConfig.closeAfterSelection) {
                await this.closeCustomSelect();
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to deselect custom option with index ${index}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Deselects all selected options in a custom select.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns This element instance for chaining
     * @throws ActionFailedException if options cannot be deselected
     */
    private async deselectAllCustomOptions(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<CSSelect> {
        try {
            await this.expandCustomSelect();
            
            // Check if there's a clear selection button
            try {
                const clearButton = await this.element.findElement(By.css(this.customSelectConfig.clearSelectionSelector));
                await clearButton.click();
                
                if (this.customSelectConfig.closeAfterSelection) {
                    await this.closeCustomSelect();
                }
                
                return this;
            } catch (error) {
                // No clear button, deselect options individually
                const options = await this.getCustomSelectOptions(timeout);
                
                for (const option of options) {
                    const isSelected = await this.isCustomOptionSelected(option);
                    
                    if (isSelected) {
                        await this.clickCustomOption(option);
                    }
                }
                
                if (this.customSelectConfig.closeAfterSelection) {
                    await this.closeCustomSelect();
                }
                
                return this;
            }
        } catch (error) {
            throw new ActionFailedException(
                `Failed to deselect all custom options: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets the selected option in a custom select.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to the selected WebElement, or null if no option is selected
     * @throws ElementNotFoundException if options cannot be found
     */
    private async getSelectedCustomOption(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<WebElement | null> {
        try {
            // Try to find the selected option without expanding the dropdown
            try {
                const selectedOption = await this.element.findElement(By.css(
                    `${this.customSelectConfig.optionSelector}.${this.customSelectConfig.selectedClass}, ` +
                    `${this.customSelectConfig.optionSelector}[${this.customSelectConfig.selectedAttribute}='true']`
                ));
                
                return selectedOption;
            } catch (error) {
                // If not found, expand the dropdown and check all options
                await this.expandCustomSelect();
                
                const options = await this.getCustomSelectOptions(timeout);
                
                for (const option of options) {
                    const isSelected = await this.isCustomOptionSelected(option);
                    
                    if (isSelected) {
                        return option;
                    }
                }
                
                // Close the dropdown since we didn't find anything
                await this.closeCustomSelect();
                
                return null;
            }
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(
                `Failed to get selected custom option: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets all selected options in a custom select.
     * 
     * @param timeout Timeout in milliseconds to wait for options to be available
     * @returns Promise resolving to an array of selected WebElements
     * @throws ElementNotFoundException if options cannot be found
     */
    private async getAllSelectedCustomOptions(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<WebElement[]> {
        try {
            // Try to find all selected options without expanding the dropdown
            try {
                const selectedOptions = await this.element.findElements(By.css(
                    `${this.customSelectConfig.optionSelector}.${this.customSelectConfig.selectedClass}, ` +
                    `${this.customSelectConfig.optionSelector}[${this.customSelectConfig.selectedAttribute}='true']`
                ));
                
                if (selectedOptions.length > 0) {
                    return selectedOptions;
                }
            } catch (error) {
                // Ignore errors and continue
            }
            
            // If not found, expand the dropdown and check all options
            await this.expandCustomSelect();
            
            const options = await this.getCustomSelectOptions(timeout);
            const selectedOptions: WebElement[] = [];
            
            for (const option of options) {
                const isSelected = await this.isCustomOptionSelected(option);
                
                if (isSelected) {
                    selectedOptions.push(option);
                }
            }
            
            // Close the dropdown
            await this.closeCustomSelect();
            
            return selectedOptions;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(
                `Failed to get selected custom options: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Checks if a custom select option is selected.
     * 
     * @param option The WebElement representing the option
     * @returns Promise resolving to boolean indicating whether the option is selected
     */
    private async isCustomOptionSelected(option: WebElement): Promise<boolean> {
        try {
            // Check for selected class
            const classes = await option.getAttribute('class');
            if (classes && classes.includes(this.customSelectConfig.selectedClass)) {
                return true;
            }
            
            // Check for selected attribute
            const selectedAttr = await option.getAttribute(this.customSelectConfig.selectedAttribute);
            if (selectedAttr === 'true') {
                return true;
            }
            
            // Check for ARIA selected attribute
            const ariaSelected = await option.getAttribute('aria-selected');
            if (ariaSelected === 'true') {
                return true;
            }
            
            return false;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Clicks a custom select option.
     * 
     * @param option The WebElement representing the option
     * @returns Promise resolving when the option is clicked
     */
    private async clickCustomOption(option: WebElement): Promise<void> {
        switch (this.customSelectConfig.optionSelectMethod) {
            case 'click':
                await option.click();
                break;
            
            case 'mouseDown':
                await this.driver.actions()
                    .move({ origin: option })
                    .press()
                    .release()
                    .perform();
                break;
            
            default:
                await option.click();
                break;
        }
    }
    
    /**
     * Closes a custom select dropdown.
     * 
     * @returns Promise resolving when the custom select is closed
     */
    private async closeCustomSelect(): Promise<void> {
        // Skip if the dropdown is already closed
        const isExpanded = await this.isCustomSelectExpanded();
        
        if (!isExpanded) {
            return;
        }
        
        try {
            switch (this.customSelectConfig.customSelectCloseMethod) {
                case 'clickOutside':
                    // Click on the body element to close the dropdown
                    await this.driver.findElement(By.css('body')).click();
                    break;
                
                case 'clickToggle':
                    // Click on the dropdown toggle again
                    const toggleElement = await this.element.findElement(By.css(this.customSelectConfig.expandSelector));
                    await toggleElement.click();
                    break;
                
                case 'escape':
                    // Send escape key
                    await this.element.sendKeys(this.driver.Key.ESCAPE);
                    break;
                
                case 'esc':
                    // Send escape key
                    await this.driver.actions().sendKeys(this.driver.Key.ESCAPE).perform();
                    break;
                
                case 'tab':
                    // Send tab key
                    await this.driver.actions().sendKeys(this.driver.Key.TAB).perform();
                    break;
                
                default:
                    // Default to clicking outside
                    await this.driver.findElement(By.css('body')).click();
                    break;
            }
            
            // Wait for the dropdown to close
            await this.waitForCustomSelectClosed();
        } catch (error) {
            // Ignore errors when closing the dropdown
            CSLogger.debug(`Error closing custom select: ${error.message}`);
        }
    }
    
    /**
     * Waits for a custom select element to be closed.
     * 
     * @param timeout Timeout in milliseconds to wait for the custom select to be closed
     * @returns Promise resolving when the custom select is closed
     */
    private async waitForCustomSelectClosed(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<void> {
        const wait = CSWaitFactory.createWait(this.driver);
        
        try {
            await wait.until(async () => {
                return !(await this.isCustomSelectExpanded());
            })
            .withTimeout(timeout)
            .withMessage(`Waiting for custom select to be closed`)
            .wait();
        } catch (error) {
            // Ignore timeout errors when waiting for the dropdown to close
            CSLogger.debug(`Timeout waiting for custom select to close: ${error.message}`);
        }
    }
    
    /**
     * Creates a new CSSelect instance with convenient static factory methods.
     */
    public static create(element: WebElement, options: CSSelectOptions = {}): CSSelect {
        return new CSSelect(element, options);
    }
    
    /**
     * Creates a new CSSelect instance for a standard select element.
     */
    public static createStandard(element: WebElement, isMultiSelect: boolean = false): CSSelect {
        return new CSSelect(element, {
            isCustomSelect: false,
            multiSelect: isMultiSelect
        });
    }
    
    /**
     * Creates a new CSSelect instance for a custom select element.
     */
    public static createCustom(element: WebElement, customConfig: Partial<CustomSelectConfig> = {}, isMultiSelect: boolean = false): CSSelect {
        return new CSSelect(element, {
            isCustomSelect: true,
            multiSelect: isMultiSelect,
            customSelectConfig: customConfig
        });
    }
    
    /**
     * Creates a new CSSelect instance for a Material Design select element.
     */
    public static createMaterialSelect(element: WebElement, isMultiSelect: boolean = false): CSSelect {
        return new CSSelect(element, {
            isCustomSelect: true,
            multiSelect: isMultiSelect,
            customSelectConfig: {
                expandSelector: '.mat-select-trigger',
                optionsContainerSelector: '.mat-select-panel',
                optionSelector: '.mat-option',
                selectedClass: 'mat-selected',
                selectedAttribute: 'aria-selected',
                expandMethod: 'click',
                optionSelectMethod: 'click',
                closeAfterSelection: true,
                customSelectCloseMethod: 'escape'
            }
        });
    }
    
    /**
     * Creates a new CSSelect instance for a Bootstrap select element.
     */
    public static createBootstrapSelect(element: WebElement, isMultiSelect: boolean = false): CSSelect {
        return new CSSelect(element, {
            isCustomSelect: true,
            multiSelect: isMultiSelect,
            customSelectConfig: {
                expandSelector: '.dropdown-toggle',
                optionsContainerSelector: '.dropdown-menu',
                optionSelector: '.dropdown-item',
                selectedClass: 'active',
                selectedAttribute: 'aria-selected',
                expandMethod: 'click',
                optionSelectMethod: 'click',
                closeAfterSelection: true,
                customSelectCloseMethod: 'clickOutside'
            }
        });
    }
    
    /**
     * Creates a new CSSelect instance for a Select2 element.
     */
    public static createSelect2(element: WebElement, isMultiSelect: boolean = false): CSSelect {
        return new CSSelect(element, {
            isCustomSelect: true,
            multiSelect: isMultiSelect,
            customSelectConfig: {
                expandSelector: '.select2-selection',
                optionsContainerSelector: '.select2-dropdown',
                optionSelector: '.select2-results__option',
                selectedClass: 'select2-results__option--highlighted',
                selectedAttribute: 'aria-selected',
                expandMethod: 'click',
                optionSelectMethod: 'click',
                closeAfterSelection: true,
                customSelectCloseMethod: 'escape',
                searchInputSelector: '.select2-search__field'
            }
        });
    }
    
    /**
     * Creates a new CSSelect instance for a Chosen select element.
     */
    public static createChosenSelect(element: WebElement, isMultiSelect: boolean = false): CSSelect {
        return new CSSelect(element, {
            isCustomSelect: true,
            multiSelect: isMultiSelect,
            customSelectConfig: {
                expandSelector: '.chosen-single, .chosen-choices',
                optionsContainerSelector: '.chosen-drop',
                optionSelector: '.chosen-results li',
                selectedClass: 'highlighted',
                selectedAttribute: 'data-selected',
                expandMethod: 'click',
                optionSelectMethod: 'click',
                closeAfterSelection: true,
                customSelectCloseMethod: 'escape',
                searchInputSelector: '.chosen-search input'
            }
        });
    }
    
    /**
     * Creates a new CSSelect instance for a Semantic UI dropdown.
     */
    public static createSemanticUIDropdown(element: WebElement, isMultiSelect: boolean = false): CSSelect {
        return new CSSelect(element, {
            isCustomSelect: true,
            multiSelect: isMultiSelect,
            customSelectConfig: {
                expandSelector: '.dropdown',
                optionsContainerSelector: '.menu',
                optionSelector: '.item',
                selectedClass: 'selected',
                selectedAttribute: 'data-selected',
                expandMethod: 'click',
                optionSelectMethod: 'click',
                closeAfterSelection: true,
                customSelectCloseMethod: 'clickOutside',
                searchInputSelector: '.search'
            }
        });
    }
    
    /**
     * Creates a new CSSelect instance for an AngularJS or Angular Material select.
     */
    public static createAngularSelect(element: WebElement, isMultiSelect: boolean = false): CSSelect {
        return new CSSelect(element, {
            isCustomSelect: true,
            multiSelect: isMultiSelect,
            customSelectConfig: {
                expandSelector: '[ng-model], [formControlName], [aria-haspopup="listbox"]',
                optionsContainerSelector: '.md-select-menu-container, .ng-dropdown-panel, mat-option, .mat-select-panel',
                optionSelector: 'md-option, .ng-option, mat-option, .mat-option',
                selectedClass: 'md-selected, ng-selected, mat-selected',
                selectedAttribute: 'aria-selected',
                expandMethod: 'click',
                optionSelectMethod: 'click',
                closeAfterSelection: true,
                customSelectCloseMethod: 'escape'
            }
        });
    }
    
    /**
     * Creates a new CSSelect instance for a React Select component.
     */
    public static createReactSelect(element: WebElement, isMultiSelect: boolean = false): CSSelect {
        return new CSSelect(element, {
            isCustomSelect: true,
            multiSelect: isMultiSelect,
            customSelectConfig: {
                expandSelector: '.react-select__control, [class*="control"]',
                optionsContainerSelector: '.react-select__menu, [class*="menu"]',
                optionSelector: '.react-select__option, [class*="option"]',
                selectedClass: 'react-select__option--is-selected, [class*="selected"]',
                selectedAttribute: 'aria-selected',
                expandMethod: 'click',
                optionSelectMethod: 'click',
                closeAfterSelection: true,
                customSelectCloseMethod: 'escape',
                searchInputSelector: '.react-select__input, input'
            }
        });
    }
    
    /**
     * Creates a new CSSelect instance for a jQuery UI select.
     */
    public static createJQuerySelect(element: WebElement, isMultiSelect: boolean = false): CSSelect {
        return new CSSelect(element, {
            isCustomSelect: true,
            multiSelect: isMultiSelect,
            customSelectConfig: {
                expandSelector: '.ui-selectmenu-button, .ui-button',
                optionsContainerSelector: '.ui-selectmenu-menu, .ui-menu',
                optionSelector: '.ui-menu-item, .ui-menu-item-wrapper',
                selectedClass: 'ui-state-active',
                selectedAttribute: 'aria-selected',
                expandMethod: 'click',
                optionSelectMethod: 'click',
                closeAfterSelection: true,
                customSelectCloseMethod: 'clickOutside'
            }
        });
    }
    
    /**
     * Creates a new CSSelect instance from a container element that may contain
     * either a standard or custom select.
     * 
     * @param container The container element
     * @param options Additional options for the select element
     * @returns Promise resolving to a new CSSelect instance
     */
    public static async fromContainer(container: WebElement, options: CSSelectOptions = {}): Promise<CSSelect> {
        try {
            // Try to find a standard select element
            const selectElement = await container.findElement(By.css('select'));
            
            // Check if it's a multi-select
            const multiple = await selectElement.getAttribute('multiple');
            const isMultiple = multiple !== null && multiple !== 'false';
            
            return CSSelect.createStandard(selectElement, isMultiple);
        } catch (error) {
            // No standard select found, look for common custom select patterns
            try {
                // Look for common custom select elements
                const customSelectElements = await container.findElements(By.css(
                    '.select, .dropdown, [role="combobox"], [role="listbox"], ' +
                    '.custom-select, .select-wrapper, .chosen-container, ' +
                    '.select2-container, .ui-selectmenu-button'
                ));
                
                if (customSelectElements.length > 0) {
                    // Auto-detect the type of custom select
                    const classes = await customSelectElements[0].getAttribute('class') || '';
                    
                    if (classes.includes('mat-select')) {
                        return CSSelect.createMaterialSelect(customSelectElements[0], options.multiSelect);
                    } else if (classes.includes('select2')) {
                        return CSSelect.createSelect2(customSelectElements[0], options.multiSelect);
                    } else if (classes.includes('chosen')) {
                        return CSSelect.createChosenSelect(customSelectElements[0], options.multiSelect);
                    } else if (classes.includes('ui-selectmenu')) {
                        return CSSelect.createJQuerySelect(customSelectElements[0], options.multiSelect);
                    } else if (classes.includes('dropdown')) {
                        return CSSelect.createBootstrapSelect(customSelectElements[0], options.multiSelect);
                    } else if (classes.includes('react-select')) {
                        return CSSelect.createReactSelect(customSelectElements[0], options.multiSelect);
                    } else if (classes.includes('ng-') || classes.includes('md-')) {
                        return CSSelect.createAngularSelect(customSelectElements[0], options.multiSelect);
                    } else {
                        // Generic custom select
                        return CSSelect.createCustom(customSelectElements[0], {}, options.multiSelect);
                    }
                }
                
                // If no specific custom select found, use the container itself
                return CSSelect.createCustom(container, {}, options.multiSelect);
            } catch (error) {
                // If all else fails, use the container itself
                return CSSelect.createCustom(container, {}, options.multiSelect);
            }
        }
    }
    
    /**
     * Creates a CSSelect wrapper from an existing CSElement.
     * 
     * @param element The CSElement to wrap
     * @param options Additional options for the select element
     * @returns A new CSSelect instance
     */
    public static fromCSElement(element: CSElement, options: CSSelectOptions = {}): CSSelect {
        return new CSSelect(element.getWebElement(), options);
    }
}

/**
 * Configuration options for custom select elements.
 */
export interface CustomSelectConfig {
    /**
     * CSS selector for the element that triggers the dropdown expansion.
     */
    expandSelector: string;
    
    /**
     * CSS selector for the container element that holds the options.
     */
    optionsContainerSelector: string;
    
    /**
     * CSS selector for individual option elements.
     */
    optionSelector: string;
    
    /**
     * CSS class that indicates a selected option.
     */
    selectedClass: string;
    
    /**
     * Attribute that indicates a selected option.
     */
    selectedAttribute: string;
    
    /**
     * Method to use for expanding the dropdown.
     * Options: 'click', 'focus', 'mouseDown', 'hover'
     */
    expandMethod: 'click' | 'focus' | 'mouseDown' | 'hover';
    
    /**
     * Method to use for selecting options.
     * Options: 'click', 'mouseDown'
     */
    optionSelectMethod: 'click' | 'mouseDown';
    
    /**
     * Whether to close the dropdown after selecting an option.
     */
    closeAfterSelection: boolean;
    
    /**
     * Method to use for closing the dropdown.
     * Options: 'clickOutside', 'clickToggle', 'escape', 'esc', 'tab'
     */
    customSelectCloseMethod: 'clickOutside' | 'clickToggle' | 'escape' | 'esc' | 'tab';
    
    /**
     * CSS selector for search input element in searchable dropdowns.
     */
    searchInputSelector?: string;
    
    /**
     * CSS selector for "Select All" button in multi-select dropdowns.
     */
    selectAllSelector?: string;
    
    /**
     * CSS selector for "Clear Selection" button in multi-select dropdowns.
     */
    clearSelectionSelector?: string;
    
    /**
     * CSS selector for the placeholder text element.
     */
    placeholderSelector?: string;
    
    /**
     * CSS selector for dropdown group headers.
     */
    groupHeaderSelector?: string;
    
    /**
     * CSS selector for loading indicator.
     */
    loadingIndicatorSelector?: string;
    
    /**
     * CSS selector for error message element.
     */
    errorMessageSelector?: string;
    
    /**
     * Whether to search for elements by text content.
     */
    searchByText?: boolean;
    
    /**
     * Custom JS attributes to use for option values.
     */
    valueAttributes?: string[];
}

/**
 * Options for creating a CSSelect instance.
 */
export interface CSSelectOptions {
    /**
     * CSS selector to find option elements within a standard select.
     * Default: By.css('option')
     */
    optionsLocator?: By;
    
    /**
     * CSS selector to find the container element for a custom select.
     * Default: null (use the select element itself)
     */
    containerLocator?: By | null;
    
    /**
     * Whether this is a custom select (div-based, etc.) rather than a standard select element.
     * Default: false
     */
    isCustomSelect?: boolean;
    
    /**
     * Configuration options for custom select elements.
     */
    customSelectConfig?: Partial<CustomSelectConfig>;
    
    /**
     * Whether this is a multi-select element.
     * Default: false
     */
    multiSelect?: boolean;
    
    /**
     * Whether to observe option changes and refresh the cache.
     * Default: true
     */
    observeOptionChanges?: boolean;
    
    /**
     * Whether to expand the dropdown before selecting options.
     * Default: true for custom selects, false for standard selects
     */
    expandBeforeSelect?: boolean;
}


CSForm.ts
-----------------------

import { By, WebElement, Key } from 'selenium-webdriver';
import { CSElement } from './CSElement';
import { CSElementList } from './CSElementList';
import { CSSelect } from './CSSelect';
import { CSWaitFactory } from '../wait/CSWaitFactory';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSConstants } from '../../core/utils/CSConstants';
import { CSTextUtils } from '../../core/utils/CSTextUtils';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';
import { ActionFailedException } from '../../core/exceptions/ActionFailedException';
import { InvalidStateException } from '../../core/exceptions/InvalidStateException';

/**
 * Enhanced form element wrapper with advanced form interaction capabilities.
 * Provides methods for filling form fields, validating forms, and submitting them.
 */
export class CSForm extends CSElement {
    private readonly formFieldsMap: Map<string, FormFieldConfig> = new Map();
    private readonly submitButtonSelector: string;
    private readonly resetButtonSelector: string;
    private readonly validationMessageSelector: string;
    private readonly errorMessageSelector: string;
    private readonly formGroupSelector: string;
    private readonly formFieldSelector: string;
    private readonly labelSelector: string;
    private readonly requiredIndicatorSelector: string;
    private readonly invalidFieldClass: string;
    private readonly validFieldClass: string;
    private readonly validationStrategy: FormValidationStrategy;
    private readonly fieldDataAttributeName: string;
    private readonly autoSubmit: boolean;
    private readonly autoReset: boolean;
    private readonly clearBeforeFill: boolean;
    private readonly waitForValidation: boolean;
    private readonly strictMode: boolean;
    
    /**
     * Creates a new form element wrapper.
     * 
     * @param element The WebElement representing the form element
     * @param options Configuration options for the form element
     */
    constructor(element: WebElement, options: CSFormOptions = {}) {
        super(element);
        
        this.submitButtonSelector = options.submitButtonSelector || 'button[type="submit"], input[type="submit"], .submit-button, [data-submit="form"]';
        this.resetButtonSelector = options.resetButtonSelector || 'button[type="reset"], input[type="reset"], .reset-button, [data-reset="form"]';
        this.validationMessageSelector = options.validationMessageSelector || '.validation-message, .help-block, .form-text, .form-message';
        this.errorMessageSelector = options.errorMessageSelector || '.error-message, .alert, .error-text, .form-error';
        this.formGroupSelector = options.formGroupSelector || '.form-group, .input-group, .field-group, .form-field';
        this.formFieldSelector = options.formFieldSelector || 'input, select, textarea, [contenteditable]';
        this.labelSelector = options.labelSelector || 'label, .field-label';
        this.requiredIndicatorSelector = options.requiredIndicatorSelector || '.required, .required-indicator, [aria-required="true"]';
        this.invalidFieldClass = options.invalidFieldClass || 'is-invalid, invalid, error, form-error';
        this.validFieldClass = options.validFieldClass || 'is-valid, valid, success, form-success';
        this.fieldDataAttributeName = options.fieldDataAttributeName || 'name';
        this.validationStrategy = options.validationStrategy || FormValidationStrategy.ATTRIBUTE_AND_CLASS;
        this.autoSubmit = options.autoSubmit !== undefined ? options.autoSubmit : false;
        this.autoReset = options.autoReset !== undefined ? options.autoReset : false;
        this.clearBeforeFill = options.clearBeforeFill !== undefined ? options.clearBeforeFill : true;
        this.waitForValidation = options.waitForValidation !== undefined ? options.waitForValidation : true;
        this.strictMode = options.strictMode !== undefined ? options.strictMode : false;
        
        // Initialize form fields map
        if (options.fields) {
            for (const [key, config] of Object.entries(options.fields)) {
                this.formFieldsMap.set(key, config);
            }
        }
    }

    /**
     * Fills the form with the provided data.
     * 
     * @param data An object containing field names and their values
     * @param submit Whether to submit the form after filling it
     * @returns This form instance for chaining
     * @throws ActionFailedException if the form cannot be filled
     */
    public async fill(data: Record<string, any>, submit: boolean = false): Promise<CSForm> {
        try {
            // Iterate through each data field
            for (const [fieldName, fieldValue] of Object.entries(data)) {
                await this.fillField(fieldName, fieldValue);
            }
            
            // Submit the form if requested or if autoSubmit is enabled
            if (submit || this.autoSubmit) {
                await this.submit();
            }
            
            return this;
        } catch (error) {
            throw new ActionFailedException(
                `Failed to fill form: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Fills a specific field in the form.
     * 
     * @param fieldName The name or identifier of the field
     * @param value The value to set
     * @returns Promise resolving when the field is filled
     * @throws ElementNotFoundException if the field cannot be found
     * @throws ActionFailedException if the field cannot be filled
     */
    public async fillField(fieldName: string, value: any): Promise<void> {
        try {
            // Get field configuration if available
            const fieldConfig = this.formFieldsMap.get(fieldName);
            
            // Find the field element
            const fieldElement = await this.findFormField(fieldName, fieldConfig);
            
            if (!fieldElement) {
                throw new ElementNotFoundException(`Field "${fieldName}" not found in form`);
            }
            
            // Determine field type
            const fieldType = await this.getFieldType(fieldElement, fieldConfig);
            
            // Fill the field based on its type and the value
            await this.fillFieldByType(fieldElement, fieldType, value, fieldConfig);
            
            // Wait for validation to complete if enabled
            if (this.waitForValidation) {
                await this.waitForFieldValidation(fieldElement, fieldConfig);
            }
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                if (this.strictMode) {
                    throw error;
                }
                CSLogger.warn(`Field "${fieldName}" not found in form, continuing with other fields`);
                return;
            }
            
            throw new ActionFailedException(
                `Failed to fill field "${fieldName}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Finds a form field element by its name or identifier.
     * 
     * @param fieldName The name or identifier of the field
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving to the WebElement representing the field, or null if not found
     */
    private async findFormField(fieldName: string, fieldConfig?: FormFieldConfig): Promise<WebElement | null> {
        try {
            // Use custom selector if provided in field config
            if (fieldConfig?.selector) {
                return await this.element.findElement(fieldConfig.selector);
            }
            
            // Try to find the field by name attribute
            try {
                return await this.element.findElement(By.css(`[name="${fieldName}"]`));
            } catch (error) {
                // Not found by name, try other means
            }
            
            // Try to find the field by id attribute
            try {
                return await this.element.findElement(By.css(`#${fieldName}`));
            } catch (error) {
                // Not found by id, try other means
            }
            
            // Try to find the field by data attribute
            if (this.fieldDataAttributeName) {
                try {
                    return await this.element.findElement(By.css(`[data-${this.fieldDataAttributeName}="${fieldName}"]`));
                } catch (error) {
                    // Not found by data attribute, try other means
                }
            }
            
            // Try to find the field by matching label text
            try {
                const labels = await this.element.findElements(By.css(this.labelSelector));
                
                for (const label of labels) {
                    const labelText = await label.getText();
                    
                    if (labelText.trim() === fieldName || labelText.trim().startsWith(fieldName)) {
                        // Get the field associated with this label
                        try {
                            // First, try to get the field by the for attribute
                            const forAttr = await label.getAttribute('for');
                            
                            if (forAttr) {
                                return await this.element.findElement(By.css(`#${forAttr}`));
                            }
                            
                            // If no for attribute, check if the field is a descendant of the label
                            const fields = await label.findElements(By.css(this.formFieldSelector));
                            
                            if (fields.length > 0) {
                                return fields[0];
                            }
                            
                            // If no field found within the label, try to find sibling fields
                            const parentElement = await this.driver.executeScript(
                                'return arguments[0].parentElement', 
                                label
                            );
                            
                            if (parentElement) {
                                const siblingFields = await parentElement.findElements(By.css(this.formFieldSelector));
                                
                                if (siblingFields.length > 0) {
                                    return siblingFields[0];
                                }
                            }
                        } catch (error) {
                            // Skip this label if no field is found
                        }
                    }
                }
            } catch (error) {
                // Skip label-based lookup if an error occurs
            }
            
            // Try to find the field by matching placeholder text
            try {
                const fields = await this.element.findElements(By.css(`[placeholder="${fieldName}"], [placeholder*="${fieldName}"]`));
                
                if (fields.length > 0) {
                    return fields[0];
                }
            } catch (error) {
                // Skip placeholder-based lookup if an error occurs
            }
            
            // Try to find the field near a matching text node
            try {
                // This is a more complex operation requiring JavaScript execution
                const fieldElement = await this.driver.executeScript(
                    `
                    const form = arguments[0];
                    const fieldName = arguments[1];
                    const formFieldSelector = arguments[2];
                    
                    // Helper function to get all text nodes
                    function getTextNodes(element) {
                        const textNodes = [];
                        const walker = document.createTreeWalker(
                            element,
                            NodeFilter.SHOW_TEXT,
                            { acceptNode: node => node.nodeValue.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT },
                            false
                        );
                        
                        let node;
                        while (node = walker.nextNode()) {
                            textNodes.push(node);
                        }
                        
                        return textNodes;
                    }
                    
                    // Get all text nodes in the form
                    const textNodes = getTextNodes(form);
                    
                    // Find text nodes matching the field name
                    for (const textNode of textNodes) {
                        if (textNode.nodeValue.trim() === fieldName || textNode.nodeValue.trim().startsWith(fieldName)) {
                            // Look for nearby form fields
                            let element = textNode.parentElement;
                            
                            // Traverse up a few levels to look for fields
                            for (let i = 0; i < 3; i++) {
                                // Look for fields in the current element
                                const fields = element.querySelectorAll(formFieldSelector);
                                
                                if (fields.length > 0) {
                                    return fields[0];
                                }
                                
                                // Move up one level
                                if (element.parentElement) {
                                    element = element.parentElement;
                                } else {
                                    break;
                                }
                            }
                        }
                    }
                    
                    return null;
                    `,
                    this.element,
                    fieldName,
                    this.formFieldSelector
                );
                
                if (fieldElement) {
                    return fieldElement;
                }
            } catch (error) {
                // Skip text node-based lookup if an error occurs
            }
            
            // Field not found by any means
            return null;
        } catch (error) {
            throw new ElementNotFoundException(`Failed to find field "${fieldName}": ${error.message}`);
        }
    }
    
    /**
     * Gets the type of a form field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving to the field type
     */
    private async getFieldType(fieldElement: WebElement, fieldConfig?: FormFieldConfig): Promise<FormFieldType> {
        // Use type from field config if available
        if (fieldConfig?.type) {
            return fieldConfig.type;
        }
        
        // Determine type based on element attributes
        const tagName = await fieldElement.getTagName();
        
        // Handle different element types
        switch (tagName.toLowerCase()) {
            case 'input':
                const inputType = await fieldElement.getAttribute('type');
                
                switch ((inputType || 'text').toLowerCase()) {
                    case 'text':
                        return FormFieldType.TEXT;
                    
                    case 'number':
                        return FormFieldType.NUMBER;
                    
                    case 'email':
                        return FormFieldType.EMAIL;
                    
                    case 'password':
                        return FormFieldType.PASSWORD;
                    
                    case 'checkbox':
                        return FormFieldType.CHECKBOX;
                    
                    case 'radio':
                        return FormFieldType.RADIO;
                    
                    case 'date':
                        return FormFieldType.DATE;
                    
                    case 'time':
                        return FormFieldType.TIME;
                    
                    case 'datetime-local':
                        return FormFieldType.DATETIME;
                    
                    case 'file':
                        return FormFieldType.FILE;
                    
                    case 'range':
                        return FormFieldType.RANGE;
                    
                    case 'color':
                        return FormFieldType.COLOR;
                    
                    case 'tel':
                        return FormFieldType.TELEPHONE;
                    
                    case 'url':
                        return FormFieldType.URL;
                    
                    case 'search':
                        return FormFieldType.SEARCH;
                    
                    case 'week':
                        return FormFieldType.WEEK;
                    
                    case 'month':
                        return FormFieldType.MONTH;
                    
                    case 'hidden':
                        return FormFieldType.HIDDEN;
                    
                    default:
                        return FormFieldType.TEXT;
                }
            
            case 'textarea':
                return FormFieldType.TEXTAREA;
            
            case 'select':
                const multiple = await fieldElement.getAttribute('multiple');
                return multiple ? FormFieldType.MULTI_SELECT : FormFieldType.SELECT;
            
            case 'div':
            case 'span':
                const contentEditable = await fieldElement.getAttribute('contenteditable');
                
                if (contentEditable === 'true') {
                    return FormFieldType.RICH_TEXT;
                }
                
                const role = await fieldElement.getAttribute('role');
                
                if (role === 'combobox' || role === 'listbox') {
                    return FormFieldType.CUSTOM_SELECT;
                }
                
                if (role === 'checkbox' || role === 'switch') {
                    return FormFieldType.CUSTOM_CHECKBOX;
                }
                
                if (role === 'radio') {
                    return FormFieldType.CUSTOM_RADIO;
                }
                
                // Check for common custom date picker classes/attributes
                const classes = await fieldElement.getAttribute('class') || '';
                
                if (classes.includes('datepicker') || 
                    classes.includes('date-picker') || 
                    await fieldElement.getAttribute('data-role') === 'datepicker') {
                    return FormFieldType.CUSTOM_DATE;
                }
                
                return FormFieldType.CUSTOM;
            
            default:
                // Default to custom type for unknown elements
                return FormFieldType.CUSTOM;
        }
    }
    
    /**
     * Fills a form field based on its type and the provided value.
     * 
     * @param fieldElement The WebElement representing the field
     * @param fieldType The type of the field
     * @param value The value to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     * @throws ActionFailedException if the field cannot be filled
     */
    private async fillFieldByType(
        fieldElement: WebElement, 
        fieldType: FormFieldType, 
        value: any, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        try {
            // Skip disabled or readonly fields unless overridden in config
            if (!fieldConfig?.fillWhenDisabled) {
                const isDisabled = await fieldElement.getAttribute('disabled') !== null;
                const isReadonly = await fieldElement.getAttribute('readonly') !== null;
                
                if (isDisabled || isReadonly) {
                    CSLogger.debug(`Skipping disabled/readonly field of type ${fieldType}`);
                    return;
                }
            }
            
            // Special case for null or undefined values
            if (value === null || value === undefined) {
                // Skip filling the field
                return;
            }
            
            // Handle different field types
            switch (fieldType) {
                case FormFieldType.TEXT:
                case FormFieldType.NUMBER:
                case FormFieldType.EMAIL:
                case FormFieldType.PASSWORD:
                case FormFieldType.TELEPHONE:
                case FormFieldType.URL:
                case FormFieldType.SEARCH:
                    await this.fillTextField(fieldElement, value.toString(), fieldConfig);
                    break;
                
                case FormFieldType.TEXTAREA:
                    await this.fillTextareaField(fieldElement, value.toString(), fieldConfig);
                    break;
                
                case FormFieldType.SELECT:
                    await this.fillSelectField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.MULTI_SELECT:
                    await this.fillMultiSelectField(fieldElement, Array.isArray(value) ? value : [value], fieldConfig);
                    break;
                
                case FormFieldType.CHECKBOX:
                    await this.fillCheckboxField(fieldElement, !!value, fieldConfig);
                    break;
                
                case FormFieldType.RADIO:
                    await this.fillRadioField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.DATE:
                    await this.fillDateField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.TIME:
                    await this.fillTimeField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.DATETIME:
                    await this.fillDateTimeField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.FILE:
                    await this.fillFileField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.RANGE:
                    await this.fillRangeField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.COLOR:
                    await this.fillColorField(fieldElement, value.toString(), fieldConfig);
                    break;
                
                case FormFieldType.WEEK:
                    await this.fillWeekField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.MONTH:
                    await this.fillMonthField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.HIDDEN:
                    await this.fillHiddenField(fieldElement, value.toString(), fieldConfig);
                    break;
                
                case FormFieldType.RICH_TEXT:
                    await this.fillRichTextField(fieldElement, value.toString(), fieldConfig);
                    break;
                
                case FormFieldType.CUSTOM_SELECT:
                    await this.fillCustomSelectField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.CUSTOM_CHECKBOX:
                    await this.fillCustomCheckboxField(fieldElement, !!value, fieldConfig);
                    break;
                
                case FormFieldType.CUSTOM_RADIO:
                    await this.fillCustomRadioField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.CUSTOM_DATE:
                    await this.fillCustomDateField(fieldElement, value, fieldConfig);
                    break;
                
                case FormFieldType.CUSTOM:
                    // Use custom fill function if provided
                    if (fieldConfig?.customFillFunction) {
                        await fieldConfig.customFillFunction(fieldElement, value, this.driver);
                    } else {
                        // Try to fill as text field
                        await this.fillTextField(fieldElement, value.toString(), fieldConfig);
                    }
                    break;
                
                default:
                    throw new Error(`Unsupported field type: ${fieldType}`);
            }
        } catch (error) {
            throw new ActionFailedException(`Failed to fill field of type ${fieldType}: ${error.message}`, error);
        }
    }
    
    /**
     * Fills a text input field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The text value to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillTextField(
        fieldElement: WebElement, 
        value: string, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Optionally clear the field first
        if (this.clearBeforeFill && !fieldConfig?.skipClear) {
            await fieldElement.clear();
        }
        
        // Custom fill logic
        if (fieldConfig?.useBackspace) {
            await this.clearFieldWithBackspace(fieldElement);
        }
        
        // Send character by character if specified
        if (fieldConfig?.sendCharByChar) {
            for (const char of value) {
                await fieldElement.sendKeys(char);
                
                // Optional delay between characters
                if (fieldConfig.charDelay && fieldConfig.charDelay > 0) {
                    await this.sleep(fieldConfig.charDelay);
                }
            }
        } else {
            // Send the entire value at once
            await fieldElement.sendKeys(value);
        }
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
        
        // Press Enter or Tab after filling if specified
        if (fieldConfig?.pressEnter) {
            await fieldElement.sendKeys(Key.ENTER);
        } else if (fieldConfig?.pressTab) {
            await fieldElement.sendKeys(Key.TAB);
        }
    }
    
    /**
     * Fills a textarea field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The text value to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillTextareaField(
        fieldElement: WebElement, 
        value: string, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Use the same logic as text fields
        await this.fillTextField(fieldElement, value, fieldConfig);
    }
    
    /**
     * Fills a select field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The value to select
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillSelectField(
        fieldElement: WebElement, 
        value: string | number, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Create a CSSelect wrapper for enhanced select functionality
        const select = new CSSelect(fieldElement);
        
        // Select by value, visible text, or index based on the value type and configuration
        if (typeof value === 'number') {
            await select.selectByIndex(value);
        } else if (fieldConfig?.selectByValue) {
            await select.selectByValue(value);
        } else if (fieldConfig?.selectByText || fieldConfig?.selectByText === undefined) {
            // Default to selecting by text
            await select.selectByVisibleText(value, fieldConfig?.exactMatch !== false);
        } else {
            // Try to select by value as fallback
            await select.selectByValue(value);
        }
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
    }
    
    /**
     * Fills a multi-select field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param values An array of values to select
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillMultiSelectField(
        fieldElement: WebElement, 
        values: Array<string | number>, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Create a CSSelect wrapper for enhanced select functionality
        const select = new CSSelect(fieldElement, { multiSelect: true });
        
        // Deselect all options first if specified
        if (fieldConfig?.deselectAllFirst) {
            await select.deselectAll();
        }
        
        // Select each value
        for (const value of values) {
            if (typeof value === 'number') {
                await select.selectByIndex(value);
            } else if (fieldConfig?.selectByValue) {
                await select.selectByValue(value);
            } else if (fieldConfig?.selectByText || fieldConfig?.selectByText === undefined) {
                // Default to selecting by text
                await select.selectByVisibleText(value, fieldConfig?.exactMatch !== false);
            } else {
                // Try to select by value as fallback
                await select.selectByValue(value);
            }
        }
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
    }
    
    /**
     * Fills a checkbox field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param checked Whether the checkbox should be checked
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillCheckboxField(
        fieldElement: WebElement, 
        checked: boolean, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Get current checked state
        const isCurrentlyChecked = await fieldElement.isSelected();
        
        // Only click if the current state doesn't match the desired state
        if (isCurrentlyChecked !== checked) {
            await fieldElement.click();
        }
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
    }
    
    /**
     * Fills a radio button field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The value to select
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillRadioField(
        fieldElement: WebElement, 
        value: string | boolean, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Handle boolean values
        if (typeof value === 'boolean') {
            // Only click if the value is true
            if (value) {
                await fieldElement.click();
            }
            
            // Fire custom events if specified
            if (fieldConfig?.fireCustomEvents) {
                await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
            }
            
            return;
        }
        
        // For string values, find the radio button with the matching value
        const name = await fieldElement.getAttribute('name');
        
        if (!name) {
            // Just click the provided radio button if it has no name
            await fieldElement.click();
            
            // Fire custom events if specified
            if (fieldConfig?.fireCustomEvents) {
                await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
            }
            
            return;
        }
        
        // Find all radio buttons with the same name
        const radioGroup = await this.element.findElements(By.css(`input[type="radio"][name="${name}"]`));
        
        // Check for no radio buttons found
        if (radioGroup.length === 0) {
            throw new ElementNotFoundException(`No radio buttons found with name "${name}"`);
        }
        
        // Find the radio button with the matching value
        let found = false;
        for (const radio of radioGroup) {
            const radioValue = await radio.getAttribute('value');
            
            if (radioValue === value) {
                await radio.click();
                found = true;
                
                // Fire custom events if specified
                if (fieldConfig?.fireCustomEvents) {
                    await this.fireInputEvents(radio, fieldConfig.customEvents);
                }
                
                break;
            }
        }
        
        // If no matching radio button found, try to find by label text
        if (!found) {
            const labels = await this.element.findElements(By.css('label'));
            
            for (const label of labels) {
                const labelText = await label.getText();
                
                if (labelText.trim() === value) {
                    // Find the associated radio button
                    try {
                        const forAttr = await label.getAttribute('for');
                        
                        if (forAttr) {
                            const radioByLabel = await this.element.findElement(By.css(`#${forAttr}`));
                            await radioByLabel.click();
                            found = true;
                            
                            // Fire custom events if specified
                            if (fieldConfig?.fireCustomEvents) {
                                await this.fireInputEvents(radioByLabel, fieldConfig.customEvents);
                            }
                            
                            break;
                        }
                    } catch (error) {
                        // Skip this label if no radio button is found
                    }
                }
            }
        }
        
        // If still not found and strict mode is enabled, throw an error
        if (!found && this.strictMode) {
            throw new ElementNotFoundException(`No radio button found with value or label "${value}" in group "${name}"`);
        }
    }
    
    /**
     * Fills a date input field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The date value to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillDateField(
        fieldElement: WebElement, 
        value: string | Date, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Convert Date object to string format (YYYY-MM-DD)
        let dateValue: string;
        
        if (value instanceof Date) {
            const year = value.getFullYear();
            const month = (value.getMonth() + 1).toString().padStart(2, '0');
            const day = value.getDate().toString().padStart(2, '0');
            dateValue = `${year}-${month}-${day}`;
        } else {
            dateValue = value;
        }
        
        // Clear the field first
        if (this.clearBeforeFill && !fieldConfig?.skipClear) {
            await fieldElement.clear();
        }
        
        // Set the date value using JS to avoid issues with browser date fields
        await this.driver.executeScript(
            'arguments[0].value = arguments[1]',
            fieldElement,
            dateValue
        );
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents !== false) {
            // Date fields typically need events to properly update
            await this.fireInputEvents(fieldElement, fieldConfig?.customEvents || ['input', 'change']);
        }
    }
    
    /**
     * Fills a time input field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The time value to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillTimeField(
        fieldElement: WebElement, 
        value: string | Date, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Convert Date object to string format (HH:MM or HH:MM:SS)
        let timeValue: string;
        
        if (value instanceof Date) {
            const hours = value.getHours().toString().padStart(2, '0');
            const minutes = value.getMinutes().toString().padStart(2, '0');
            
            if (fieldConfig?.includeSeconds) {
                const seconds = value.getSeconds().toString().padStart(2, '0');
                timeValue = `${hours}:${minutes}:${seconds}`;
            } else {
                timeValue = `${hours}:${minutes}`;
            }
        } else {
            timeValue = value;
        }
        
        // Clear the field first
        if (this.clearBeforeFill && !fieldConfig?.skipClear) {
            await fieldElement.clear();
        }
        
        // Set the time value using JS to avoid issues with browser time fields
        await this.driver.executeScript(
            'arguments[0].value = arguments[1]',
            fieldElement,
            timeValue
        );
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents !== false) {
            // Time fields typically need events to properly update
            await this.fireInputEvents(fieldElement, fieldConfig?.customEvents || ['input', 'change']);
        }
    }
    
    /**
     * Fills a datetime-local input field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The datetime value to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillDateTimeField(
        fieldElement: WebElement, 
        value: string | Date, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Convert Date object to string format (YYYY-MM-DDTHH:MM or YYYY-MM-DDTHH:MM:SS)
        let dateTimeValue: string;
        
        if (value instanceof Date) {
            const year = value.getFullYear();
            const month = (value.getMonth() + 1).toString().padStart(2, '0');
            const day = value.getDate().toString().padStart(2, '0');
            const hours = value.getHours().toString().padStart(2, '0');
            const minutes = value.getMinutes().toString().padStart(2, '0');
            
            if (fieldConfig?.includeSeconds) {
                const seconds = value.getSeconds().toString().padStart(2, '0');
                dateTimeValue = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
            } else {
                dateTimeValue = `${year}-${month}-${day}T${hours}:${minutes}`;
            }
        } else {
            dateTimeValue = value;
        }
        
        // Clear the field first
        if (this.clearBeforeFill && !fieldConfig?.skipClear) {
            await fieldElement.clear();
        }
        
        // Set the datetime value using JS to avoid issues with browser datetime fields
        await this.driver.executeScript(
            'arguments[0].value = arguments[1]',
            fieldElement,
            dateTimeValue
        );
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents !== false) {
            // Datetime fields typically need events to properly update
            await this.fireInputEvents(fieldElement, fieldConfig?.customEvents || ['input', 'change']);
        }
    }
    
    /**
     * Fills a file input field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The file path or paths to upload
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillFileField(
        fieldElement: WebElement, 
        value: string | string[], 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Handle array of file paths for multiple file upload
        const filePaths = Array.isArray(value) ? value : [value];
        
        // Send file paths to the file input
        await fieldElement.sendKeys(filePaths.join('\n'));
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
    }
    
    /**
     * Fills a range input field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The numeric value to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillRangeField(
        fieldElement: WebElement, 
        value: number | string, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Convert string to number if needed
        const numericValue = typeof value === 'string' ? parseFloat(value) : value;
        
        // Set the range value using JS to ensure accurate positioning
        await this.driver.executeScript(
            'arguments[0].value = arguments[1]',
            fieldElement,
            numericValue
        );
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents !== false) {
            // Range fields typically need events to properly update
            await this.fireInputEvents(fieldElement, fieldConfig?.customEvents || ['input', 'change']);
        }
    }
    
    /**
     * Fills a color input field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The color value to set (hex format)
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillColorField(
        fieldElement: WebElement, 
        value: string, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Ensure the value is in the correct format (#RRGGBB)
        let colorValue = value;
        
        if (!colorValue.startsWith('#')) {
            colorValue = `#${colorValue}`;
        }
        
        // Set the color value using JS
        await this.driver.executeScript(
            'arguments[0].value = arguments[1]',
            fieldElement,
            colorValue
        );
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
    }
    
    /**
     * Fills a week input field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The week value to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillWeekField(
        fieldElement: WebElement, 
        value: string | Date, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Convert Date object to string format (YYYY-Www)
        let weekValue: string;
        
        if (value instanceof Date) {
            const year = value.getFullYear();
            
            // Calculate week number (ISO week number)
            const date = new Date(value.getTime());
            date.setHours(0, 0, 0, 0);
            date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
            const week = Math.floor((date.getTime() - new Date(date.getFullYear(), 0, 4).getTime()) / 86400000 / 7) + 1;
            
            weekValue = `${year}-W${week.toString().padStart(2, '0')}`;
        } else {
            weekValue = value;
        }
        
        // Clear the field first
        if (this.clearBeforeFill && !fieldConfig?.skipClear) {
            await fieldElement.clear();
        }
        
        // Set the week value using JS
        await this.driver.executeScript(
            'arguments[0].value = arguments[1]',
            fieldElement,
            weekValue
        );
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
    }
    
    /**
     * Fills a month input field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The month value to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillMonthField(
        fieldElement: WebElement, 
        value: string | Date, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Convert Date object to string format (YYYY-MM)
        let monthValue: string;
        
        if (value instanceof Date) {
            const year = value.getFullYear();
            const month = (value.getMonth() + 1).toString().padStart(2, '0');
            monthValue = `${year}-${month}`;
        } else {
            monthValue = value;
        }
        
        // Clear the field first
        if (this.clearBeforeFill && !fieldConfig?.skipClear) {
            await fieldElement.clear();
        }
        
        // Set the month value using JS
        await this.driver.executeScript(
            'arguments[0].value = arguments[1]',
            fieldElement,
            monthValue
        );
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
    }
    
    /**
     * Fills a hidden input field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The value to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillHiddenField(
        fieldElement: WebElement, 
        value: string, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Set the hidden field value using JS
        await this.driver.executeScript(
            'arguments[0].value = arguments[1]',
            fieldElement,
            value
        );
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
    }
    
    /**
     * Fills a rich text editor field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The HTML content to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillRichTextField(
        fieldElement: WebElement, 
        value: string, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Clear the existing content if needed
        if (this.clearBeforeFill && !fieldConfig?.skipClear) {
            await this.driver.executeScript(
                'arguments[0].innerHTML = ""',
                fieldElement
            );
        }
        
        // Set the rich text content using JS
        if (fieldConfig?.useInnerHTML) {
            await this.driver.executeScript(
                'arguments[0].innerHTML = arguments[1]',
                fieldElement,
                value
            );
        } else {
            // Focus the element first
            await fieldElement.sendKeys('');
            
            // Set the text content
            await this.driver.executeScript(
                'arguments[0].textContent = arguments[1]',
                fieldElement,
                value
            );
        }
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents || ['input', 'change']);
        }
    }
    
    /**
     * Fills a custom select field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The value to select
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillCustomSelectField(
        fieldElement: WebElement, 
        value: string | string[] | number, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Create a CSSelect wrapper for the custom select
        const select = CSSelect.createCustom(
            fieldElement, 
            fieldConfig?.customSelectConfig, 
            Array.isArray(value)
        );
        
        // Handle different value types
        if (Array.isArray(value)) {
            // For multiple values, select each one
            for (const val of value) {
                if (typeof val === 'number') {
                    await select.selectByIndex(val);
                } else if (fieldConfig?.selectByValue) {
                    await select.selectByValue(val);
                } else {
                    await select.selectByVisibleText(val, fieldConfig?.exactMatch !== false);
                }
            }
        } else if (typeof value === 'number') {
            await select.selectByIndex(value);
        } else if (fieldConfig?.selectByValue) {
            await select.selectByValue(value);
        } else {
            await select.selectByVisibleText(value, fieldConfig?.exactMatch !== false);
        }
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
    }
    
    /**
     * Fills a custom checkbox field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param checked Whether the checkbox should be checked
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillCustomCheckboxField(
        fieldElement: WebElement, 
        checked: boolean, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Determine current state
        let isCurrentlyChecked = false;
        
        // Check for ARIA checked attribute
        const ariaChecked = await fieldElement.getAttribute('aria-checked');
        if (ariaChecked) {
            isCurrentlyChecked = ariaChecked === 'true';
        } else {
            // Check for checked class
            const classes = await fieldElement.getAttribute('class') || '';
            isCurrentlyChecked = classes.includes('checked') || 
                classes.includes('selected') || 
                classes.includes('active');
        }
        
        // Only click if the current state doesn't match the desired state
        if (isCurrentlyChecked !== checked) {
            await fieldElement.click();
        }
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
    }
    
    /**
     * Fills a custom radio button field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The value to select
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillCustomRadioField(
        fieldElement: WebElement, 
        value: string | boolean, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Handle boolean values
        if (typeof value === 'boolean') {
            // Only click if the value is true
            if (value) {
                await fieldElement.click();
            }
            
            // Fire custom events if specified
            if (fieldConfig?.fireCustomEvents) {
                await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
            }
            
            return;
        }
        
        // Try to find a radio button with the matching text or value
        // First, look for a group container
        const groupContainer = await this.driver.executeScript(
            `
            const element = arguments[0];
            
            // Find closest group container
            let container = element;
            
            // Check if the element has a role of radiogroup
            if (element.getAttribute('role') === 'radiogroup') {
                return element;
            }
            
            // Try to find a parent with role="radiogroup"
            while (container.parentElement) {
                container = container.parentElement;
                if (container.getAttribute('role') === 'radiogroup') {
                    return container;
                }
            }
            
            // If no radiogroup role found, return the original element
            return element;
            `,
            fieldElement
        );
        
        // Find all radio buttons in the group
        let radioButtons: WebElement[];
        
        try {
            radioButtons = await groupContainer.findElements(By.css('[role="radio"]'));
            
            if (radioButtons.length === 0) {
                // Try alternative selectors
                radioButtons = await groupContainer.findElements(
                    By.css('.radio, .radio-button, .custom-radio, [type="radio"]')
                );
            }
        } catch (error) {
            // If we can't find the group, just click the original element
            await fieldElement.click();
            
            // Fire custom events if specified
            if (fieldConfig?.fireCustomEvents) {
                await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
            }
            
            return;
        }
        
        // Try to find and click the radio button with the matching value or text
        let found = false;
        
        for (const radio of radioButtons) {
            // Check for value attribute
            const radioValue = await radio.getAttribute('value') || 
                await radio.getAttribute('data-value');
            
            if (radioValue === value) {
                await radio.click();
                found = true;
                
                // Fire custom events if specified
                if (fieldConfig?.fireCustomEvents) {
                    await this.fireInputEvents(radio, fieldConfig.customEvents);
                }
                
                break;
            }
            
            // Check for text content
            const radioText = await radio.getText();
            if (radioText.trim() === value) {
                await radio.click();
                found = true;
                
                // Fire custom events if specified
                if (fieldConfig?.fireCustomEvents) {
                    await this.fireInputEvents(radio, fieldConfig.customEvents);
                }
                
                break;
            }
        }
        
        // If not found, check for labels
        if (!found) {
            for (const radio of radioButtons) {
                // Find associated label
                const labelId = await radio.getAttribute('aria-labelledby') || 
                    await radio.getAttribute('id');
                
                if (labelId) {
                    try {
                        let label: WebElement;
                        
                        if (await radio.getAttribute('aria-labelledby')) {
                            label = await this.element.findElement(By.css(`#${labelId}`));
                        } else {
                            label = await this.element.findElement(By.css(`label[for="${labelId}"]`));
                        }
                        
                        const labelText = await label.getText();
                        
                        if (labelText.trim() === value) {
                            await radio.click();
                            found = true;
                            
                            // Fire custom events if specified
                            if (fieldConfig?.fireCustomEvents) {
                                await this.fireInputEvents(radio, fieldConfig.customEvents);
                            }
                            
                            break;
                        }
                    } catch (error) {
                        // Skip if label not found
                    }
                }
            }
        }
        
        // If still not found and strict mode is enabled, throw an error
        if (!found && this.strictMode) {
            throw new ElementNotFoundException(`No custom radio button found with value or label "${value}"`);
        }
    }
    
    /**
     * Fills a custom date picker field.
     * 
     * @param fieldElement The WebElement representing the field
     * @param value The date value to set
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when the field is filled
     */
    private async fillCustomDateField(
        fieldElement: WebElement, 
        value: string | Date, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Format the date
        let dateValue: string;
        
        if (value instanceof Date) {
            // Format based on configuration or default to ISO format
            if (fieldConfig?.dateFormat) {
                dateValue = this.formatDate(value, fieldConfig.dateFormat);
            } else {
                const year = value.getFullYear();
                const month = (value.getMonth() + 1).toString().padStart(2, '0');
                const day = value.getDate().toString().padStart(2, '0');
                dateValue = `${year}-${month}-${day}`;
            }
        } else {
            dateValue = value;
        }
        
        // Try to find an input field within or associated with the date picker
        let inputField: WebElement | null = null;
        
        try {
            // Check if the element itself is an input
            const tagName = await fieldElement.getTagName();
            
            if (tagName.toLowerCase() === 'input') {
                inputField = fieldElement;
            } else {
                // Look for an input field within the date picker
                try {
                    inputField = await fieldElement.findElement(By.css('input'));
                } catch (error) {
                    // Not found, try to find by association
                    const id = await fieldElement.getAttribute('id');
                    
                    if (id) {
                        try {
                            inputField = await this.element.findElement(By.css(`input[aria-labelledby="${id}"], input[aria-describedby="${id}"]`));
                        } catch (error) {
                            // Still not found
                        }
                    }
                }
            }
        } catch (error) {
            // Ignore errors, we'll handle missing input field below
        }
        
        // If we found an input field, set its value directly
        if (inputField) {
            // Clear the field first
            if (this.clearBeforeFill && !fieldConfig?.skipClear) {
                await inputField.clear();
            }
            
            // Set the value
            await inputField.sendKeys(dateValue);
            
            // Press Enter or Tab after filling if specified
            if (fieldConfig?.pressEnter) {
                await inputField.sendKeys(Key.ENTER);
            } else if (fieldConfig?.pressTab) {
                await inputField.sendKeys(Key.TAB);
            }
            
            // Fire custom events if specified
            if (fieldConfig?.fireCustomEvents) {
                await this.fireInputEvents(inputField, fieldConfig.customEvents);
            }
            
            return;
        }
        
        // If no input field found, try setting the date using JavaScript
        try {
            // Check for common date picker libraries
            const classes = await fieldElement.getAttribute('class') || '';
            
            if (classes.includes('datepicker') || 
                classes.includes('date-picker') || 
                classes.includes('calendar')) {
                
                // Try setting the date using common date picker libraries
                await this.driver.executeScript(
                    `
                    const element = arguments[0];
                    const dateValue = arguments[1];
                    
                    // Attempt to set the date for various date picker libraries
                    
                    // jQuery UI Datepicker
                    if (typeof jQuery !== 'undefined' && jQuery(element).datepicker) {
                        jQuery(element).datepicker('setDate', dateValue);
                        return true;
                    }
                    
                    // Bootstrap Datepicker
                    if (typeof jQuery !== 'undefined' && jQuery(element).data('datepicker')) {
                        jQuery(element).datepicker('update', dateValue);
                        return true;
                    }
                    
                    // Flatpickr
                    if (element._flatpickr) {
                        element._flatpickr.setDate(dateValue);
                        return true;
                    }
                    
                    // Pikaday
                    if (element.pikaday) {
                        element.pikaday.setDate(new Date(dateValue));
                        return true;
                    }
                    
                    // Air Datepicker
                    if (typeof jQuery !== 'undefined' && jQuery(element).data('datepicker')) {
                        jQuery(element).data('datepicker').selectDate(new Date(dateValue));
                        return true;
                    }
                    
                    // No known date picker found
                    return false;
                    `,
                    fieldElement,
                    dateValue
                );
            }
        } catch (error) {
            // Ignore errors, we'll try clicking the date picker as a last resort
        }
        
        // As a last resort, try clicking the date picker to open it
        try {
            await fieldElement.click();
            
            // Wait a moment for the date picker to open
            await this.sleep(500);
            
            // Try to find and click the date
            if (value instanceof Date) {
                const year = value.getFullYear();
                const month = value.getMonth() + 1;
                const day = value.getDate();
                
                // Look for day cells in the date picker
                const dayCells = await this.driver.findElements(
                    By.css('.day, .ui-state-default, [data-day], .datepicker-day, .calendar-day')
                );
                
                for (const dayCell of dayCells) {
                    const cellText = await dayCell.getText();
                    
                    if (cellText.trim() === day.toString()) {
                        await dayCell.click();
                        break;
                    }
                }
            }
        } catch (error) {
            // If all else fails, log a warning
            CSLogger.warn(`Could not set date for custom date picker: ${error.message}`);
        }
        
        // Fire custom events if specified
        if (fieldConfig?.fireCustomEvents) {
            await this.fireInputEvents(fieldElement, fieldConfig.customEvents);
        }
    }
    
    /**
     * Formats a date according to the specified format.
     * 
     * @param date The date to format
     * @param format The format string
     * @returns The formatted date string
     */
    private formatDate(date: Date, format: string): string {
        // Simple date formatter supporting common patterns
        const tokens: Record<string, string> = {
            'yyyy': date.getFullYear().toString(),
            'yy': (date.getFullYear() % 100).toString().padStart(2, '0'),
            'MM': (date.getMonth() + 1).toString().padStart(2, '0'),
            'M': (date.getMonth() + 1).toString(),
            'dd': date.getDate().toString().padStart(2, '0'),
            'd': date.getDate().toString(),
            'HH': date.getHours().toString().padStart(2, '0'),
            'H': date.getHours().toString(),
            'hh': (date.getHours() % 12 || 12).toString().padStart(2, '0'),
            'h': (date.getHours() % 12 || 12).toString(),
            'mm': date.getMinutes().toString().padStart(2, '0'),
            'm': date.getMinutes().toString(),
            'ss': date.getSeconds().toString().padStart(2, '0'),
            's': date.getSeconds().toString(),
            'a': date.getHours() < 12 ? 'am' : 'pm',
            'A': date.getHours() < 12 ? 'AM' : 'PM'
        };
        
        // Replace tokens in the format string
        let result = format;
        
        for (const [token, value] of Object.entries(tokens)) {
            result = result.replace(new RegExp(token, 'g'), value);
        }
        
        return result;
    }
    
    /**
     * Clears a field using the backspace key.
     * 
     * @param fieldElement The WebElement representing the field
     * @returns Promise resolving when the field is cleared
     */
    private async clearFieldWithBackspace(fieldElement: WebElement): Promise<void> {
        // Get the current value
        const value = await fieldElement.getAttribute('value');
        
        if (!value) {
            return;
        }
        
        // Focus the field
        await fieldElement.click();
        
        // Select all text (Ctrl+A) and delete
        await this.driver.actions()
            .keyDown(Key.CONTROL)
            .sendKeys('a')
            .keyUp(Key.CONTROL)
            .sendKeys(Key.BACK_SPACE)
            .perform();
    }
    
    /**
     * Fires input events on a field element.
     * 
     * @param fieldElement The WebElement representing the field
     * @param events Optional custom event names to fire
     * @returns Promise resolving when events are fired
     */
    private async fireInputEvents(fieldElement: WebElement, events?: string[]): Promise<void> {
        // Default events
        const eventNames = events || ['input', 'change', 'blur'];
        
        // Fire each event
        for (const eventName of eventNames) {
            await this.driver.executeScript(
                `
                const element = arguments[0];
                const eventName = arguments[1];
                
                // Create and dispatch the event
                const event = new Event(eventName, { bubbles: true, cancelable: true });
                element.dispatchEvent(event);
                `,
                fieldElement,
                eventName
            );
        }
    }
    
    /**
     * Waits for field validation to complete.
     * 
     * @param fieldElement The WebElement representing the field
     * @param fieldConfig Optional field configuration
     * @returns Promise resolving when validation is complete
     */
    private async waitForFieldValidation(
        fieldElement: WebElement, 
        fieldConfig?: FormFieldConfig
    ): Promise<void> {
        // Skip validation wait if disabled
        if (!this.waitForValidation) {
            return;
        }
        
        // Custom validation wait timeout
        const timeout = fieldConfig?.validationTimeout || 500;
        
        // Wait a small amount of time for validation to occur
        await this.sleep(timeout);
        
        // Check validation based on the configured strategy
        switch (this.validationStrategy) {
            case FormValidationStrategy.ATTRIBUTE_AND_CLASS:
                // Wait for validation classes to be applied
                try {
                    await CSWaitFactory.createWait(this.driver)
                        .until(async () => {
                            // Check for validity attribute
                            const validity = await fieldElement.getAttribute('aria-invalid');
                            if (validity === 'true' || validity === 'false') {
                                return true;
                            }
                            
                            // Check for validation classes
                            const classes = await fieldElement.getAttribute('class') || '';
                            
                            return classes.includes('valid') || 
                                classes.includes('invalid') || 
                                classes.includes('error') || 
                                classes.includes('success');
                        })
                        .withTimeout(timeout)
                        .withMessage('Waiting for validation to complete')
                        .wait();
                } catch (error) {
                    // Ignore timeout errors, continue anyway
                }
                break;
            
            case FormValidationStrategy.ERROR_MESSAGE:
                // Wait for error messages to appear
                try {
                    await CSWaitFactory.createWait(this.driver)
                        .until(async () => {
                            return await this.hasValidationMessage(fieldElement);
                        })
                        .withTimeout(timeout)
                        .withMessage('Waiting for validation messages')
                        .wait();
                } catch (error) {
                    // Ignore timeout errors, continue anyway
                }
                break;
            
            case FormValidationStrategy.HTML5_VALIDATION:
                // Check HTML5 validation state
                try {
                    await this.driver.executeScript(
                        `
                        const element = arguments[0];
                        
                        // Force validation check
                        if (typeof element.reportValidity === 'function') {
                            element.reportValidity();
                        }
                        `,
                        fieldElement
                    );
                } catch (error) {
                    // Ignore errors
                }
                break;
            
            case FormValidationStrategy.CUSTOM:
                // Use custom validation check if provided
                if (fieldConfig?.customValidationCheck) {
                    try {
                        await fieldConfig.customValidationCheck(fieldElement, this.driver);
                    } catch (error) {
                        // Ignore errors
                    }
                }
                break;
            
            default:
                // No validation wait
                break;
        }
    }
    
    /**
     * Checks if a field has a validation message.
     * 
     * @param fieldElement The WebElement representing the field
     * @returns Promise resolving to boolean indicating whether the field has a validation message
     */
    private async hasValidationMessage(fieldElement: WebElement): Promise<boolean> {
        try {
            // Try to find the field's form group
            const formGroup = await this.driver.executeScript(
                `
                const element = arguments[0];
                const formGroupSelector = arguments[1];
                
                // Find closest form group
                let group = element;
                
                while (group.parentElement) {
                    if (group.matches(formGroupSelector)) {
                        return group;
                    }
                    
                    group = group.parentElement;
                }
                
                return null;
                `,
                fieldElement,
                this.formGroupSelector
            );
            
            if (formGroup) {
                // Check for validation messages within the form group
                const validationMessages = await formGroup.findElements(
                    By.css(this.validationMessageSelector)
                );
                
                // Check for error messages within the form group
                const errorMessages = await formGroup.findElements(
                    By.css(this.errorMessageSelector)
                );
                
                return validationMessages.length > 0 || errorMessages.length > 0;
            }
            
            return false;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Submits the form.
     * 
     * @returns This form instance for chaining
     * @throws ActionFailedException if the form cannot be submitted
     */
    public async submit(): Promise<CSForm> {
        try {
            // Try to find and click a submit button
            try {
                const submitButton = await this.element.findElement(By.css(this.submitButtonSelector));
                await submitButton.click();
                return this;
            } catch (error) {
                // No submit button found, use the form's submit method
            }
            
            // Use the form's submit method
            await this.driver.executeScript('arguments[0].submit()', this.element);
            
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to submit form: ${error.message}`, error);
        }
    }
    
    /**
     * Resets the form.
     * 
     * @returns This form instance for chaining
     * @throws ActionFailedException if the form cannot be reset
     */
    public async reset(): Promise<CSForm> {
        try {
            // Try to find and click a reset button
            try {
                const resetButton = await this.element.findElement(By.css(this.resetButtonSelector));
                await resetButton.click();
                return this;
            } catch (error) {
                // No reset button found, use the form's reset method
            }
            
            // Use the form's reset method
            await this.driver.executeScript('arguments[0].reset()', this.element);
            
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to reset form: ${error.message}`, error);
        }
    }
    
    /**
     * Gets all form field elements.
     * 
     * @returns Promise resolving to an array of WebElements representing the form fields
     */
    public async getAllFields(): Promise<WebElement[]> {
        return await this.element.findElements(By.css(this.formFieldSelector));
    }
    
    /**
     * Gets all required form field elements.
     * 
     * @returns Promise resolving to an array of WebElements representing the required form fields
     */
    public async getRequiredFields(): Promise<WebElement[]> {
        const requiredFields: WebElement[] = [];
        
        // Get all fields
        const allFields = await this.getAllFields();
        
        // Filter required fields
        for (const field of allFields) {
            // Check required attribute
            const required = await field.getAttribute('required');
            const ariaRequired = await field.getAttribute('aria-required');
            
            if (required === 'true' || required === '' || ariaRequired === 'true') {
                requiredFields.push(field);
                continue;
            }
            
            // Check for required indicator in parent elements
            try {
                const formGroup = await this.driver.executeScript(
                    `
                    const element = arguments[0];
                    const formGroupSelector = arguments[1];
                    
                    // Find closest form group
                    let group = element;
                    
                    while (group.parentElement) {
                        if (group.matches(formGroupSelector)) {
                            return group;
                        }
                        
                        group = group.parentElement;
                    }
                    
                    return null;
                    `,
                    field,
                    this.formGroupSelector
                );
                
                if (formGroup) {
                    // Check for required indicators within the form group
                    const requiredIndicators = await formGroup.findElements(
                        By.css(this.requiredIndicatorSelector)
                    );
                    
                    if (requiredIndicators.length > 0) {
                        requiredFields.push(field);
                    }
                }
            } catch (error) {
                // Ignore errors
            }
        }
        
        return requiredFields;
    }
    
    /**
     * Gets all invalid form field elements.
     * 
     * @returns Promise resolving to an array of WebElements representing the invalid form fields
     */
    public async getInvalidFields(): Promise<WebElement[]> {
        const invalidFields: WebElement[] = [];
        
        // Get all fields
        const allFields = await this.getAllFields();
        
        // Filter invalid fields
        for (const field of allFields) {
            // Check validity attribute
            const validity = await field.getAttribute('aria-invalid');
            
            if (validity === 'true') {
                invalidFields.push(field);
                continue;
            }
            
            // Check for invalid classes
            const classes = await field.getAttribute('class') || '';
            const invalidClassList = this.invalidFieldClass.split(',').map(c => c.trim());
            
            for (const invalidClass of invalidClassList) {
                if (classes.includes(invalidClass)) {
                    invalidFields.push(field);
                    break;
                }
            }
        }
        
        return invalidFields;
    }
    
    /**
     * Gets all validation error messages.
     * 
     * @returns Promise resolving to an array of validation error messages
     */
    public async getValidationErrors(): Promise<string[]> {
        const errorMessages: string[] = [];
        
        // Find all error message elements
        const errorElements = await this.element.findElements(
            By.css(this.errorMessageSelector)
        );
        
        // Find all validation message elements
        const validationElements = await this.element.findElements(
            By.css(this.validationMessageSelector)
        );
        
        // Extract error messages
        for (const errorElement of [...errorElements, ...validationElements]) {
            const text = await errorElement.getText();
            
            if (text && text.trim()) {
                errorMessages.push(text.trim());
            }
        }
        
        return errorMessages;
    }
    
    /**
     * Validates the form without submitting it.
     * 
     * @returns Promise resolving to a validation result object
     */
    public async validate(): Promise<FormValidationResult> {
        // Get all invalid fields
        const invalidFields = await this.getInvalidFields();
        
        // Get all required fields
        const requiredFields = await this.getRequiredFields();
        
        // Get all validation errors
        const validationErrors = await this.getValidationErrors();
        
        // Check form validity using HTML5 validation API
        const isValid = await this.driver.executeScript(
            `
            const form = arguments[0];
            
            // Use HTML5 validation API if available
            if (typeof form.checkValidity === 'function') {
                return form.checkValidity();
            }
            
            // Fallback: check for invalid fields
            return form.querySelectorAll(':invalid').length === 0;
            `,
            this.element
        );
        
        return {
            isValid: !!isValid && invalidFields.length === 0 && validationErrors.length === 0,
            invalidFields,
            requiredFields,
            validationErrors
        };
    }
    
    /**
     * Waits for a specified amount of time.
     * 
     * @param ms The number of milliseconds to wait
     * @returns Promise resolving when the wait is complete
     */
    private async sleep(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    /**
     * Creates a new CSForm instance with convenient static factory methods.
     */
    public static create(element: WebElement, options: CSFormOptions = {}): CSForm {
        return new CSForm(element, options);
    }
    
    /**
     * Creates a new CSForm instance for a standard HTML form.
     */
    public static createStandard(element: WebElement): CSForm {
        return new CSForm(element, {
            validationStrategy: FormValidationStrategy.HTML5_VALIDATION
        });
    }
    
    /**
     * Creates a new CSForm instance for a Bootstrap form.
     */
    public static createBootstrapForm(element: WebElement): CSForm {
        return new CSForm(element, {
            formGroupSelector: '.form-group',
            invalidFieldClass: 'is-invalid',
            validFieldClass: 'is-valid',
            errorMessageSelector: '.invalid-feedback, .text-danger',
            validationMessageSelector: '.form-text, .form-feedback',
            validationStrategy: FormValidationStrategy.ATTRIBUTE_AND_CLASS
        });
    }
    
    /**
     * Creates a new CSForm instance for a Material Design form.
     */
    public static createMaterialForm(element: WebElement): CSForm {
        return new CSForm(element, {
            formGroupSelector: '.mat-form-field, .mdc-form-field',
            invalidFieldClass: 'mat-form-field-invalid, mdc-text-field--invalid',
            validFieldClass: 'mat-form-field-valid',
            errorMessageSelector: '.mat-error, .mdc-text-field-helper-text--validation-msg',
            validationMessageSelector: '.mat-hint, .mdc-text-field-helper-text',
            validationStrategy: FormValidationStrategy.ATTRIBUTE_AND_CLASS
        });
    }
    
    /**
     * Creates a new CSForm instance for a Foundation form.
     */
    public static createFoundationForm(element: WebElement): CSForm {
        return new CSForm(element, {
            formGroupSelector: '.form-group, .grid-x, .cell',
            invalidFieldClass: 'is-invalid-input',
            validFieldClass: 'is-valid-input',
            errorMessageSelector: '.form-error',
            validationMessageSelector: '.help-text',
            validationStrategy: FormValidationStrategy.ATTRIBUTE_AND_CLASS
        });
    }
    
    /**
     * Creates a new CSForm instance for a Semantic UI form.
     */
    public static createSemanticUIForm(element: WebElement): CSForm {
        return new CSForm(element, {
            formGroupSelector: '.field',
            invalidFieldClass: 'error',
            validFieldClass: 'success',
            errorMessageSelector: '.ui.error.message, .ui.red.label',
            validationMessageSelector: '.ui.message',
            validationStrategy: FormValidationStrategy.ATTRIBUTE_AND_CLASS
        });
    }
    
    /**
     * Creates a new CSForm instance for an Angular reactive form.
     */
    public static createAngularReactiveForm(element: WebElement): CSForm {
        return new CSForm(element, {
            formGroupSelector: '.form-group, [formGroupName], [formGroup]',
            invalidFieldClass: 'ng-invalid, mat-form-field-invalid',
            validFieldClass: 'ng-valid',
            errorMessageSelector: '.text-danger, mat-error, .error-message',
            validationMessageSelector: '.form-text, mat-hint',
            fieldDataAttributeName: 'formcontrolname',
            validationStrategy: FormValidationStrategy.ATTRIBUTE_AND_CLASS
        });
    }
    
    /**
     * Creates a new CSForm instance from an existing CSElement.
     * 
     * @param element The CSElement to wrap
     * @param options Additional options for the form element
     * @returns A new CSForm instance
     */
    public static fromCSElement(element: CSElement, options: CSFormOptions = {}): CSForm {
        return new CSForm(element.getWebElement(), options);
    }
    
    /**
     * Creates a CSForm wrapper for a form element based on its class attributes.
     * 
     * @param element WebElement representing a form
     * @returns Promise resolving to a new CSForm instance
     */
    public static async fromFormElement(element: WebElement): Promise<CSForm> {
        // Check the form's classes to determine the appropriate wrapper
        const classes = await element.getAttribute('class') || '';
        
        if (classes.includes('mat-form') || classes.includes('mdc-form')) {
            return CSForm.createMaterialForm(element);
        } else if (classes.includes('ui form')) {
            return CSForm.createSemanticUIForm(element);
        } else if (classes.includes('ng-form') || element.getAttribute('formGroup') !== null) {
            return CSForm.createAngularReactiveForm(element);
        } else if (classes.includes('bootstrap')) {
            return CSForm.createBootstrapForm(element);
        } else if (classes.includes('foundation')) {
            return CSForm.createFoundationForm(element);
        } else {
            // Default to standard form
            return CSForm.createStandard(element);
        }
    }
}

/**
 * Enum for form field types.
 */
export enum FormFieldType {
    TEXT = 'text',
    NUMBER = 'number',
    EMAIL = 'email',
    PASSWORD = 'password',
    TEXTAREA = 'textarea',
    SELECT = 'select',
    MULTI_SELECT = 'multiSelect',
    CHECKBOX = 'checkbox',
    RADIO = 'radio',
    DATE = 'date',
    TIME = 'time',
    DATETIME = 'datetime',
    FILE = 'file',
    RANGE = 'range',
    COLOR = 'color',
    TELEPHONE = 'tel',
    URL = 'url',
    SEARCH = 'search',
    WEEK = 'week',
    MONTH = 'month',
    HIDDEN = 'hidden',
    RICH_TEXT = 'richText',
    CUSTOM_SELECT = 'customSelect',
    CUSTOM_CHECKBOX = 'customCheckbox',
    CUSTOM_RADIO = 'customRadio',
    CUSTOM_DATE = 'customDate',
    CUSTOM = 'custom'
}

/**
 * Enum for form validation strategies.
 */
export enum FormValidationStrategy {
    NONE = 'none',
    HTML5_VALIDATION = 'html5',
    ATTRIBUTE_AND_CLASS = 'attributeAndClass',
    ERROR_MESSAGE = 'errorMessage',
    CUSTOM = 'custom'
}

/**
 * Interface for form field configuration.
 */
export interface FormFieldConfig {
    /**
     * The type of the field.
     */
    type?: FormFieldType;
    
    /**
     * Custom selector to find the field.
     */
    selector?: By;
    
    /**
     * Whether to select by value (true) or by text (false).
     */
    selectByValue?: boolean;
    
    /**
     * Whether to select by text.
     */
    selectByText?: boolean;
    
    /**
     * Whether to require an exact match for text selection.
     */
    exactMatch?: boolean;
    
    /**
     * Whether to deselect all options before selecting new ones (for multi-select).
     */
    deselectAllFirst?: boolean;
    
    /**
     * Whether to include seconds in time/datetime fields.
     */
    includeSeconds?: boolean;
    
    /**
     * Custom date format.
     */
    dateFormat?: string;
    
    /**
     * Whether to skip clearing the field before filling.
     */
    skipClear?: boolean;
    
    /**
     * Whether to use backspace to clear the field.
     */
    useBackspace?: boolean;
    
    /**
     * Whether to send characters one by one.
     */
    sendCharByChar?: boolean;
    
    /**
     * Delay between characters in milliseconds.
     */
    charDelay?: number;
    
    /**
     * Whether to press Enter after filling.
     */
    pressEnter?: boolean;
    
    /**
     * Whether to press Tab after filling.
     */
    pressTab?: boolean;
    
    /**
     * Whether to fire custom events after filling.
     */
    fireCustomEvents?: boolean;
    
    /**
     * Custom events to fire.
     */
    customEvents?: string[];
    
    /**
     * Whether to fill the field even if it's disabled or readonly.
     */
    fillWhenDisabled?: boolean;
    
    /**
     * Whether to use innerHTML instead of textContent for rich text fields.
     */
    useInnerHTML?: boolean;
    
    /**
     * Timeout for validation in milliseconds.
     */
    validationTimeout?: number;
    
    /**
     * Custom function to fill a custom field.
     */
    customFillFunction?: (element: WebElement, value: any, driver: WebDriver) => Promise<void>;
    
    /**
     * Custom function to check validation for a custom field.
     */
    customValidationCheck?: (element: WebElement, driver: WebDriver) => Promise<void>;
    
    /**
     * Configuration for custom select fields.
     */
    customSelectConfig?: Partial<import('./CSSelect').CustomSelectConfig>;
}

/**
 * Interface for form validation results.
 */
export interface FormValidationResult {
    /**
     * Whether the form is valid.
     */
    isValid: boolean;
    
    /**
     * Array of invalid field elements.
     */
    invalidFields: WebElement[];
    
    /**
     * Array of required field elements.
     */
    requiredFields: WebElement[];
    
    /**
     * Array of validation error messages.
     */
    validationErrors: string[];
}

/**
 * Interface for form configuration options.
 */
export interface CSFormOptions {
    /**
     * Map of field names to field configurations.
     */
    fields?: Record<string, FormFieldConfig>;
    
    /**
     * CSS selector for the submit button.
     */
    submitButtonSelector?: string;
    
    /**
     * CSS selector for the reset button.
     */
    resetButtonSelector?: string;
    
    /**
     * CSS selector for validation message elements.
     */
    validationMessageSelector?: string;
    
    /**
     * CSS selector for error message elements.
     */
    errorMessageSelector?: string;
    
    /**
     * CSS selector for form group elements.
     */
    formGroupSelector?: string;
    
    /**
     * CSS selector for form field elements.
     */
    formFieldSelector?: string;
    
    /**
     * CSS selector for label elements.
     */
    labelSelector?: string;
    
    /**
     * CSS selector for required field indicators.
     */
    requiredIndicatorSelector?: string;
    
    /**
     * CSS class names for invalid fields (comma-separated).
     */
    invalidFieldClass?: string;
    
    /**
     * CSS class names for valid fields (comma-separated).
     */
    validFieldClass?: string;
    
    /**
     * Validation strategy to use.
     */
    validationStrategy?: FormValidationStrategy;
    
    /**
     * Name of the data attribute to use for finding fields.
     */
    fieldDataAttributeName?: string;
    
    /**
     * Whether to automatically submit the form after filling all fields.
     */
    autoSubmit?: boolean;
    
    /**
     * Whether to automatically reset the form after filling all fields.
     */
    autoReset?: boolean;
    
    /**
     * Whether to clear fields before filling them.
     */
    clearBeforeFill?: boolean;
    
    /**
     * Whether to wait for validation to complete after filling a field.
     */
    waitForValidation?: boolean;
    
    /**
     * Whether to throw errors for missing fields.
     */
    strictMode?: boolean;
}



CSTable.ts
------------------------

import { By, WebElement, WebDriver } from 'selenium-webdriver';
import { CSElement } from './CSElement';
import { CSElementList } from './CSElementList';
import { CSWaitFactory } from '../wait/CSWaitFactory';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSConstants } from '../../core/utils/CSConstants';
import { CSTextUtils } from '../../core/utils/CSTextUtils';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';
import { ActionFailedException } from '../../core/exceptions/ActionFailedException';
import { InvalidStateException } from '../../core/exceptions/InvalidStateException';

/**
 * Enhanced table element wrapper with advanced table interaction capabilities.
 * Provides methods for reading, navigating, and interacting with table data.
 */
export class CSTable extends CSElement {
    private readonly headerRowSelector: string;
    private readonly bodyRowSelector: string;
    private readonly footerRowSelector: string;
    private readonly cellSelector: string;
    private readonly headerCellSelector: string;
    private readonly headerRowIndex: number;
    private readonly paginationSelector: string;
    private readonly nextPageSelector: string;
    private readonly previousPageSelector: string;
    private readonly sortableHeaderSelector: string;
    private readonly checkboxSelector: string;
    private readonly expandRowSelector: string;
    private readonly rowDetailsSelector: string;
    private readonly searchInputSelector: string;
    private readonly emptyTableSelector: string;
    private readonly loadingIndicatorSelector: string;
    private readonly tableType: TableType;
    private cachedHeaderValues: string[] | null = null;
    private cachedColumnCount: number | null = null;
    private headerIndexMap: Map<string, number> = new Map();
    private readonly waitForTableLoad: boolean;
    private readonly strictColumnMatching: boolean;
    private readonly caseSensitiveHeaders: boolean;
    private readonly normalizeText: boolean;
    private readonly trimText: boolean;
    
    /**
     * Creates a new table element wrapper.
     * 
     * @param element The WebElement representing the table element
     * @param options Configuration options for the table element
     */
    constructor(element: WebElement, options: CSTableOptions = {}) {
        super(element);
        
        this.headerRowSelector = options.headerRowSelector || 'thead tr, tr:first-child, [role="row"]:first-child';
        this.bodyRowSelector = options.bodyRowSelector || 'tbody tr, tr:not(:first-child):not(:last-child), [role="row"]:not(:first-child)';
        this.footerRowSelector = options.footerRowSelector || 'tfoot tr, tr:last-child, [role="row"]:last-child';
        this.cellSelector = options.cellSelector || 'td, th, [role="cell"], [role="gridcell"]';
        this.headerCellSelector = options.headerCellSelector || 'th, [role="columnheader"]';
        this.headerRowIndex = options.headerRowIndex !== undefined ? options.headerRowIndex : 0;
        this.paginationSelector = options.paginationSelector || '.pagination, .pager, .dataTables_paginate, [role="navigation"]';
        this.nextPageSelector = options.nextPageSelector || '.next, .next-page, [aria-label="Next page"], [aria-label="next"]';
        this.previousPageSelector = options.previousPageSelector || '.previous, .prev-page, [aria-label="Previous page"], [aria-label="previous"]';
        this.sortableHeaderSelector = options.sortableHeaderSelector || '.sortable, [data-sort], [aria-sort]';
        this.checkboxSelector = options.checkboxSelector || 'input[type="checkbox"], .checkbox, [role="checkbox"]';
        this.expandRowSelector = options.expandRowSelector || '.expandable, .expandable-row, [aria-expanded]';
        this.rowDetailsSelector = options.rowDetailsSelector || '.row-details, .details, .expanded-row-content';
        this.searchInputSelector = options.searchInputSelector || '.search, input[type="search"], [role="search"]';
        this.emptyTableSelector = options.emptyTableSelector || '.empty-table, .no-data, .no-results';
        this.loadingIndicatorSelector = options.loadingIndicatorSelector || '.loading, .spinner, [aria-busy="true"]';
        this.tableType = options.tableType || TableType.STANDARD;
        this.waitForTableLoad = options.waitForTableLoad !== undefined ? options.waitForTableLoad : true;
        this.strictColumnMatching = options.strictColumnMatching !== undefined ? options.strictColumnMatching : false;
        this.caseSensitiveHeaders = options.caseSensitiveHeaders !== undefined ? options.caseSensitiveHeaders : false;
        this.normalizeText = options.normalizeText !== undefined ? options.normalizeText : true;
        this.trimText = options.trimText !== undefined ? options.trimText : true;
    }

    /**
     * Gets the header row element.
     * 
     * @returns Promise resolving to the WebElement representing the header row
     * @throws ElementNotFoundException if the header row cannot be found
     */
    public async getHeaderRow(): Promise<WebElement> {
        try {
            if (this.waitForTableLoad) {
                await this.waitForLoading();
            }
            
            const headerRows = await this.element.findElements(By.css(this.headerRowSelector));
            
            if (headerRows.length === 0) {
                throw new ElementNotFoundException('Header row not found');
            }
            
            // Use the specified header row index or default to the first row
            const rowIndex = Math.min(this.headerRowIndex, headerRows.length - 1);
            
            return headerRows[rowIndex];
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get header row: ${error.message}`);
        }
    }
    
    /**
     * Gets all body row elements.
     * 
     * @returns Promise resolving to an array of WebElements representing the body rows
     * @throws ElementNotFoundException if no body rows can be found
     */
    public async getBodyRows(): Promise<WebElement[]> {
        try {
            if (this.waitForTableLoad) {
                await this.waitForLoading();
            }
            
            const bodyRows = await this.element.findElements(By.css(this.bodyRowSelector));
            
            if (bodyRows.length === 0) {
                // Check if the table is empty
                const isEmpty = await this.isEmpty();
                
                if (isEmpty) {
                    return [];
                }
                
                throw new ElementNotFoundException('No body rows found');
            }
            
            return bodyRows;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get body rows: ${error.message}`);
        }
    }
    
    /**
     * Gets the footer row element.
     * 
     * @returns Promise resolving to the WebElement representing the footer row or null if not found
     */
    public async getFooterRow(): Promise<WebElement | null> {
        try {
            const footerRows = await this.element.findElements(By.css(this.footerRowSelector));
            
            if (footerRows.length === 0) {
                return null;
            }
            
            return footerRows[0];
        } catch (error) {
            return null;
        }
    }
    
    /**
     * Gets all header cell elements.
     * 
     * @returns Promise resolving to an array of WebElements representing the header cells
     * @throws ElementNotFoundException if the header cells cannot be found
     */
    public async getHeaderCells(): Promise<WebElement[]> {
        try {
            const headerRow = await this.getHeaderRow();
            
            // Try to find header cells using the specific header cell selector
            let headerCells = await headerRow.findElements(By.css(this.headerCellSelector));
            
            // If no header cells found, use the general cell selector
            if (headerCells.length === 0) {
                headerCells = await headerRow.findElements(By.css(this.cellSelector));
            }
            
            if (headerCells.length === 0) {
                throw new ElementNotFoundException('No header cells found');
            }
            
            return headerCells;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get header cells: ${error.message}`);
        }
    }
    
    /**
     * Gets the header values (column names).
     * 
     * @param refresh Whether to refresh the cache
     * @returns Promise resolving to an array of strings representing the header values
     * @throws ElementNotFoundException if the header values cannot be retrieved
     */
    public async getHeaderValues(refresh: boolean = false): Promise<string[]> {
        if (this.cachedHeaderValues && !refresh) {
            return this.cachedHeaderValues;
        }
        
        try {
            const headerCells = await this.getHeaderCells();
            const headerValues: string[] = [];
            
            // Reset the header index map
            this.headerIndexMap.clear();
            
            for (let i = 0; i < headerCells.length; i++) {
                const headerText = await this.getElementText(headerCells[i]);
                headerValues.push(headerText);
                
                // Store the column index in the map (both with and without normalization)
                this.headerIndexMap.set(headerText, i);
                
                if (this.normalizeText) {
                    const normalizedText = this.normalizeString(headerText);
                    if (normalizedText !== headerText) {
                        this.headerIndexMap.set(normalizedText, i);
                    }
                }
            }
            
            this.cachedHeaderValues = headerValues;
            this.cachedColumnCount = headerValues.length;
            
            return headerValues;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get header values: ${error.message}`);
        }
    }
    
    /**
     * Gets a specific row.
     * 
     * @param rowIndex The zero-based index of the row
     * @returns Promise resolving to the WebElement representing the row
     * @throws ElementNotFoundException if the row cannot be found
     */
    public async getRow(rowIndex: number): Promise<WebElement> {
        try {
            const rows = await this.getBodyRows();
            
            if (rowIndex < 0 || rowIndex >= rows.length) {
                throw new ElementNotFoundException(`Row index ${rowIndex} is out of bounds (0-${rows.length - 1})`);
            }
            
            return rows[rowIndex];
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get row at index ${rowIndex}: ${error.message}`);
        }
    }
    
    /**
     * Gets all cells in a row.
     * 
     * @param row The row element
     * @returns Promise resolving to an array of WebElements representing the cells
     * @throws ElementNotFoundException if the cells cannot be found
     */
    public async getRowCells(row: WebElement): Promise<WebElement[]> {
        try {
            const cells = await row.findElements(By.css(this.cellSelector));
            
            if (cells.length === 0) {
                throw new ElementNotFoundException('No cells found in row');
            }
            
            return cells;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get row cells: ${error.message}`);
        }
    }
    
    /**
     * Gets a specific cell by row and column indices.
     * 
     * @param rowIndex The zero-based row index
     * @param columnIndex The zero-based column index
     * @returns Promise resolving to the WebElement representing the cell
     * @throws ElementNotFoundException if the cell cannot be found
     */
    public async getCell(rowIndex: number, columnIndex: number): Promise<WebElement> {
        try {
            const row = await this.getRow(rowIndex);
            const cells = await this.getRowCells(row);
            
            if (columnIndex < 0 || columnIndex >= cells.length) {
                throw new ElementNotFoundException(`Column index ${columnIndex} is out of bounds (0-${cells.length - 1})`);
            }
            
            return cells[columnIndex];
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get cell at row ${rowIndex}, column ${columnIndex}: ${error.message}`);
        }
    }
    
    /**
     * Gets a specific cell by row index and column name.
     * 
     * @param rowIndex The zero-based row index
     * @param columnName The name of the column
     * @returns Promise resolving to the WebElement representing the cell
     * @throws ElementNotFoundException if the cell cannot be found
     */
    public async getCellByColumnName(rowIndex: number, columnName: string): Promise<WebElement> {
        try {
            // Ensure we have the header values
            if (!this.cachedHeaderValues) {
                await this.getHeaderValues();
            }
            
            // Get the column index
            const columnIndex = await this.getColumnIndex(columnName);
            
            if (columnIndex === -1) {
                throw new ElementNotFoundException(`Column "${columnName}" not found`);
            }
            
            return await this.getCell(rowIndex, columnIndex);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get cell at row ${rowIndex}, column "${columnName}": ${error.message}`);
        }
    }
    
    /**
     * Gets the text content of a cell.
     * 
     * @param rowIndex The zero-based row index
     * @param columnIndex The zero-based column index
     * @returns Promise resolving to the text content of the cell
     * @throws ElementNotFoundException if the cell cannot be found
     */
    public async getCellText(rowIndex: number, columnIndex: number): Promise<string> {
        try {
            const cell = await this.getCell(rowIndex, columnIndex);
            return await this.getElementText(cell);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get cell text at row ${rowIndex}, column ${columnIndex}: ${error.message}`);
        }
    }
    
    /**
     * Gets the text content of a cell by column name.
     * 
     * @param rowIndex The zero-based row index
     * @param columnName The name of the column
     * @returns Promise resolving to the text content of the cell
     * @throws ElementNotFoundException if the cell cannot be found
     */
    public async getCellTextByColumnName(rowIndex: number, columnName: string): Promise<string> {
        try {
            const cell = await this.getCellByColumnName(rowIndex, columnName);
            return await this.getElementText(cell);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get cell text at row ${rowIndex}, column "${columnName}": ${error.message}`);
        }
    }
    
    /**
     * Gets the column index for a column name.
     * 
     * @param columnName The name of the column
     * @returns Promise resolving to the column index or -1 if not found
     */
    public async getColumnIndex(columnName: string): Promise<number> {
        // Ensure we have the header values
        if (!this.cachedHeaderValues) {
            await this.getHeaderValues();
        }
        
        // Normalize the column name if needed
        const normalizedColumnName = this.caseSensitiveHeaders
            ? columnName
            : (this.normalizeText ? this.normalizeString(columnName) : columnName.toLowerCase());
        
        // Check if we have the column index in the map
        if (this.headerIndexMap.has(normalizedColumnName)) {
            return this.headerIndexMap.get(normalizedColumnName)!;
        }
        
        // If strict matching is enabled, return -1 if no exact match
        if (this.strictColumnMatching) {
            return -1;
        }
        
        // Try to find a partial match
        for (const [header, index] of this.headerIndexMap.entries()) {
            const normalizedHeader = this.caseSensitiveHeaders
                ? header
                : (this.normalizeText ? header : header.toLowerCase());
            
            if (normalizedHeader.includes(normalizedColumnName) || normalizedColumnName.includes(normalizedHeader)) {
                return index;
            }
        }
        
        return -1;
    }
    
    /**
     * Gets all text values in a row.
     * 
     * @param rowIndex The zero-based row index
     * @returns Promise resolving to an array of strings representing the row values
     * @throws ElementNotFoundException if the row cannot be found
     */
    public async getRowValues(rowIndex: number): Promise<string[]> {
        try {
            const row = await this.getRow(rowIndex);
            const cells = await this.getRowCells(row);
            const values: string[] = [];
            
            for (const cell of cells) {
                values.push(await this.getElementText(cell));
            }
            
            return values;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get row values at index ${rowIndex}: ${error.message}`);
        }
    }
    
    /**
     * Gets all text values in a column.
     * 
     * @param columnIndex The zero-based column index
     * @returns Promise resolving to an array of strings representing the column values
     * @throws ElementNotFoundException if the column cannot be found
     */
    public async getColumnValues(columnIndex: number): Promise<string[]> {
        try {
            // Ensure the column index is valid
            if (this.cachedColumnCount !== null && (columnIndex < 0 || columnIndex >= this.cachedColumnCount)) {
                throw new ElementNotFoundException(`Column index ${columnIndex} is out of bounds (0-${this.cachedColumnCount - 1})`);
            }
            
            const rows = await this.getBodyRows();
            const values: string[] = [];
            
            for (const row of rows) {
                const cells = await this.getRowCells(row);
                
                if (columnIndex < cells.length) {
                    values.push(await this.getElementText(cells[columnIndex]));
                } else {
                    // If the row doesn't have enough cells, add an empty string
                    values.push('');
                }
            }
            
            return values;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get column values at index ${columnIndex}: ${error.message}`);
        }
    }
    
    /**
     * Gets all text values in a column by column name.
     * 
     * @param columnName The name of the column
     * @returns Promise resolving to an array of strings representing the column values
     * @throws ElementNotFoundException if the column cannot be found
     */
    public async getColumnValuesByName(columnName: string): Promise<string[]> {
        try {
            // Get the column index
            const columnIndex = await this.getColumnIndex(columnName);
            
            if (columnIndex === -1) {
                throw new ElementNotFoundException(`Column "${columnName}" not found`);
            }
            
            return await this.getColumnValues(columnIndex);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get column values for "${columnName}": ${error.message}`);
        }
    }
    
    /**
     * Gets the table data as a two-dimensional array of strings.
     * 
     * @returns Promise resolving to a two-dimensional array of strings representing the table data
     * @throws ElementNotFoundException if the table data cannot be retrieved
     */
    public async getTableData(): Promise<string[][]> {
        try {
            const rows = await this.getBodyRows();
            const data: string[][] = [];
            
            for (const row of rows) {
                const cells = await this.getRowCells(row);
                const rowData: string[] = [];
                
                for (const cell of cells) {
                    rowData.push(await this.getElementText(cell));
                }
                
                data.push(rowData);
            }
            
            return data;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get table data: ${error.message}`);
        }
    }
    
    /**
     * Gets the table data as an array of objects, where each object represents a row
     * and the properties are the column names.
     * 
     * @returns Promise resolving to an array of objects representing the table data
     * @throws ElementNotFoundException if the table data cannot be retrieved
     */
    public async getTableDataAsObjects(): Promise<Record<string, string>[]> {
        try {
            // Get the header values
            const headers = await this.getHeaderValues();
            
            // Get the body rows
            const rows = await this.getBodyRows();
            const data: Record<string, string>[] = [];
            
            for (const row of rows) {
                const cells = await this.getRowCells(row);
                const rowData: Record<string, string> = {};
                
                // Add cell values to the object using the header names as keys
                for (let i = 0; i < cells.length && i < headers.length; i++) {
                    rowData[headers[i]] = await this.getElementText(cells[i]);
                }
                
                data.push(rowData);
            }
            
            return data;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(`Failed to get table data as objects: ${error.message}`);
        }
    }
    
    /**
     * Finds a row that contains a specific text value.
     * 
     * @param text The text to search for
     * @param exactMatch Whether to match the text exactly
     * @returns Promise resolving to the index of the first matching row, or -1 if not found
     */
    public async findRowByText(text: string, exactMatch: boolean = false): Promise<number> {
        try {
            const rows = await this.getBodyRows();
            
            for (let i = 0; i < rows.length; i++) {
                const rowText = await rows[i].getText();
                
                if (exactMatch) {
                    if (rowText === text) {
                        return i;
                    }
                } else {
                    if (rowText.includes(text)) {
                        return i;
                    }
                }
            }
            
            return -1;
        } catch (error) {
            return -1;
        }
    }
    
    /**
     * Finds a row that contains a specific value in a specific column.
     * 
     * @param columnIndex The zero-based column index
     * @param text The text to search for
     * @param exactMatch Whether to match the text exactly
     * @returns Promise resolving to the index of the first matching row, or -1 if not found
     */
    public async findRowByText(text: string, exactMatch: boolean = false): Promise<number> {
        try {
            const rows = await this.getBodyRows();
            
            for (let i = 0; i < rows.length; i++) {
                const rowText = await rows[i].getText();
                
                if (exactMatch) {
                    if (rowText === text) {
                        return i;
                    }
                } else {
                    if (rowText.includes(text)) {
                        return i;
                    }
                }
            }
            
            return -1;
        } catch (error) {
            return -1;
        }
    }
    
    /**
     * Finds a row that contains a specific value in a specific column.
     * 
     * @param columnIndex The zero-based column index
     * @param text The text to search for
     * @param exactMatch Whether to match the text exactly
     * @returns Promise resolving to the index of the first matching row, or -1 if not found
     */
    public async findRowByColumnValue(
        columnIndex: number, 
        text: string, 
        exactMatch: boolean = false
    ): Promise<number> {
        try {
            const rows = await this.getBodyRows();
            
            for (let i = 0; i < rows.length; i++) {
                const cells = await this.getRowCells(rows[i]);
                
                if (columnIndex < cells.length) {
                    const cellText = await this.getElementText(cells[columnIndex]);
                    
                    if (exactMatch) {
                        if (cellText === text) {
                            return i;
                        }
                    } else {
                        if (cellText.includes(text)) {
                            return i;
                        }
                    }
                }
            }
            
            return -1;
        } catch (error) {
            return -1;
        }
    }
    
    /**
     * Finds a row that contains a specific value in a specific column by column name.
     * 
     * @param columnName The name of the column
     * @param text The text to search for
     * @param exactMatch Whether to match the text exactly
     * @returns Promise resolving to the index of the first matching row, or -1 if not found
     */
    public async findRowByColumnName(
        columnName: string, 
        text: string, 
        exactMatch: boolean = false
    ): Promise<number> {
        try {
            // Get the column index
            const columnIndex = await this.getColumnIndex(columnName);
            
            if (columnIndex === -1) {
                return -1;
            }
            
            return await this.findRowByColumnValue(columnIndex, text, exactMatch);
        } catch (error) {
            return -1;
        }
    }
    
    /**
     * Finds all rows that contain a specific value in a specific column.
     * 
     * @param columnIndex The zero-based column index
     * @param text The text to search for
     * @param exactMatch Whether to match the text exactly
     * @returns Promise resolving to an array of indices of the matching rows
     */
    public async findAllRowsByColumnValue(
        columnIndex: number, 
        text: string, 
        exactMatch: boolean = false
    ): Promise<number[]> {
        try {
            const rows = await this.getBodyRows();
            const matchingRows: number[] = [];
            
            for (let i = 0; i < rows.length; i++) {
                const cells = await this.getRowCells(rows[i]);
                
                if (columnIndex < cells.length) {
                    const cellText = await this.getElementText(cells[columnIndex]);
                    
                    if (exactMatch) {
                        if (cellText === text) {
                            matchingRows.push(i);
                        }
                    } else {
                        if (cellText.includes(text)) {
                            matchingRows.push(i);
                        }
                    }
                }
            }
            
            return matchingRows;
        } catch (error) {
            return [];
        }
    }
    
    /**
     * Finds all rows that contain a specific value in a specific column by column name.
     * 
     * @param columnName The name of the column
     * @param text The text to search for
     * @param exactMatch Whether to match the text exactly
     * @returns Promise resolving to an array of indices of the matching rows
     */
    public async findAllRowsByColumnName(
        columnName: string, 
        text: string, 
        exactMatch: boolean = false
    ): Promise<number[]> {
        try {
            // Get the column index
            const columnIndex = await this.getColumnIndex(columnName);
            
            if (columnIndex === -1) {
                return [];
            }
            
            return await this.findAllRowsByColumnValue(columnIndex, text, exactMatch);
        } catch (error) {
            return [];
        }
    }
    
    /**
     * Clicks a cell.
     * 
     * @param rowIndex The zero-based row index
     * @param columnIndex The zero-based column index
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the cell cannot be found
     * @throws ActionFailedException if the cell cannot be clicked
     */
    public async clickCell(rowIndex: number, columnIndex: number): Promise<CSTable> {
        try {
            const cell = await this.getCell(rowIndex, columnIndex);
            await cell.click();
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to click cell at row ${rowIndex}, column ${columnIndex}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Clicks a cell by column name.
     * 
     * @param rowIndex The zero-based row index
     * @param columnName The name of the column
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the cell cannot be found
     * @throws ActionFailedException if the cell cannot be clicked
     */
    public async clickCellByColumnName(rowIndex: number, columnName: string): Promise<CSTable> {
        try {
            const cell = await this.getCellByColumnName(rowIndex, columnName);
            await cell.click();
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to click cell at row ${rowIndex}, column "${columnName}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Clicks a row.
     * 
     * @param rowIndex The zero-based row index
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the row cannot be found
     * @throws ActionFailedException if the row cannot be clicked
     */
    public async clickRow(rowIndex: number): Promise<CSTable> {
        try {
            const row = await this.getRow(rowIndex);
            await row.click();
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to click row at index ${rowIndex}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Clicks a header cell.
     * 
     * @param columnIndex The zero-based column index
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the header cell cannot be found
     * @throws ActionFailedException if the header cell cannot be clicked
     */
    public async clickHeaderCell(columnIndex: number): Promise<CSTable> {
        try {
            const headerCells = await this.getHeaderCells();
            
            if (columnIndex < 0 || columnIndex >= headerCells.length) {
                throw new ElementNotFoundException(`Column index ${columnIndex} is out of bounds (0-${headerCells.length - 1})`);
            }
            
            await headerCells[columnIndex].click();
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to click header cell at column ${columnIndex}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Clicks a header cell by column name.
     * 
     * @param columnName The name of the column
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the header cell cannot be found
     * @throws ActionFailedException if the header cell cannot be clicked
     */
    public async clickHeaderByName(columnName: string): Promise<CSTable> {
        try {
            // Get the column index
            const columnIndex = await this.getColumnIndex(columnName);
            
            if (columnIndex === -1) {
                throw new ElementNotFoundException(`Column "${columnName}" not found`);
            }
            
            return await this.clickHeaderCell(columnIndex);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to click header cell for column "${columnName}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets a checkbox in a cell.
     * 
     * @param rowIndex The zero-based row index
     * @param columnIndex The zero-based column index
     * @returns Promise resolving to the WebElement representing the checkbox
     * @throws ElementNotFoundException if the checkbox cannot be found
     */
    public async getCellCheckbox(rowIndex: number, columnIndex: number): Promise<WebElement> {
        try {
            const cell = await this.getCell(rowIndex, columnIndex);
            
            // Try to find a checkbox in the cell
            const checkboxes = await cell.findElements(By.css(this.checkboxSelector));
            
            if (checkboxes.length === 0) {
                throw new ElementNotFoundException('No checkbox found in cell');
            }
            
            return checkboxes[0];
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(
                `Failed to get checkbox in cell at row ${rowIndex}, column ${columnIndex}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Gets a checkbox in a cell by column name.
     * 
     * @param rowIndex The zero-based row index
     * @param columnName The name of the column
     * @returns Promise resolving to the WebElement representing the checkbox
     * @throws ElementNotFoundException if the checkbox cannot be found
     */
    public async getCellCheckboxByColumnName(rowIndex: number, columnName: string): Promise<WebElement> {
        try {
            // Get the column index
            const columnIndex = await this.getColumnIndex(columnName);
            
            if (columnIndex === -1) {
                throw new ElementNotFoundException(`Column "${columnName}" not found`);
            }
            
            return await this.getCellCheckbox(rowIndex, columnIndex);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ElementNotFoundException(
                `Failed to get checkbox in cell at row ${rowIndex}, column "${columnName}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Checks or unchecks a checkbox in a cell.
     * 
     * @param rowIndex The zero-based row index
     * @param columnIndex The zero-based column index
     * @param check Whether to check or uncheck the checkbox
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the checkbox cannot be found
     * @throws ActionFailedException if the checkbox cannot be checked or unchecked
     */
    public async checkCell(rowIndex: number, columnIndex: number, check: boolean): Promise<CSTable> {
        try {
            const checkbox = await this.getCellCheckbox(rowIndex, columnIndex);
            const isChecked = await checkbox.isSelected();
            
            // Only click if the current state doesn't match the desired state
            if (isChecked !== check) {
                await checkbox.click();
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to ${check ? 'check' : 'uncheck'} checkbox in cell at row ${rowIndex}, column ${columnIndex}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Checks or unchecks a checkbox in a cell by column name.
     * 
     * @param rowIndex The zero-based row index
     * @param columnName The name of the column
     * @param check Whether to check or uncheck the checkbox
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the checkbox cannot be found
     * @throws ActionFailedException if the checkbox cannot be checked or unchecked
     */
    public async checkCellByColumnName(rowIndex: number, columnName: string, check: boolean): Promise<CSTable> {
        try {
            // Get the column index
            const columnIndex = await this.getColumnIndex(columnName);
            
            if (columnIndex === -1) {
                throw new ElementNotFoundException(`Column "${columnName}" not found`);
            }
            
            return await this.checkCell(rowIndex, columnIndex, check);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to ${check ? 'check' : 'uncheck'} checkbox in cell at row ${rowIndex}, column "${columnName}": ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Expands or collapses a row.
     * 
     * @param rowIndex The zero-based row index
     * @param expand Whether to expand or collapse the row
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the row cannot be found
     * @throws ActionFailedException if the row cannot be expanded or collapsed
     */
    public async expandRow(rowIndex: number, expand: boolean): Promise<CSTable> {
        try {
            const row = await this.getRow(rowIndex);
            
            // Try to find the expand/collapse button
            const expandButtons = await row.findElements(By.css(this.expandRowSelector));
            
            if (expandButtons.length === 0) {
                throw new ElementNotFoundException('No expand/collapse button found in row');
            }
            
            // Check if the row is already expanded/collapsed
            const isExpanded = await this.isRowExpanded(row);
            
            // Only click if the current state doesn't match the desired state
            if (isExpanded !== expand) {
                await expandButtons[0].click();
                
                // Wait for the row details to appear or disappear
                if (expand) {
                    await this.waitForRowDetails(row);
                } else {
                    await this.waitForRowDetailsToDisappear(row);
                }
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to ${expand ? 'expand' : 'collapse'} row at index ${rowIndex}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Checks if a row is expanded.
     * 
     * @param row The row element
     * @returns Promise resolving to boolean indicating whether the row is expanded
     */
    private async isRowExpanded(row: WebElement): Promise<boolean> {
        try {
            // Check for aria-expanded attribute
            const ariaExpanded = await row.getAttribute('aria-expanded');
            
            if (ariaExpanded) {
                return ariaExpanded === 'true';
            }
            
            // Check for expanded class
            const classes = await row.getAttribute('class') || '';
            
            if (classes.includes('expanded') || classes.includes('open')) {
                return true;
            }
            
            // Check for expanded icon
            const expandIcon = await row.findElement(By.css(this.expandRowSelector));
            const iconClasses = await expandIcon.getAttribute('class') || '';
            
            if (iconClasses.includes('expanded') || iconClasses.includes('open') || iconClasses.includes('up')) {
                return true;
            }
            
            // Check for row details element
            try {
                const rowDetails = await this.findRowDetails(row);
                return rowDetails !== null;
            } catch (error) {
                return false;
            }
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Finds the row details element for an expanded row.
     * 
     * @param row The row element
     * @returns Promise resolving to the WebElement representing the row details or null if not found
     */
    private async findRowDetails(row: WebElement): Promise<WebElement | null> {
        try {
            // Try to find the row details element within the row
            try {
                const rowDetails = await row.findElement(By.css(this.rowDetailsSelector));
                return rowDetails;
            } catch (error) {
                // Not found within the row
            }
            
            // Try to find the row details element in the next sibling
            const nextSibling = await this.driver.executeScript(
                'return arguments[0].nextElementSibling',
                row
            );
            
            if (nextSibling) {
                const classes = await nextSibling.getAttribute('class') || '';
                
                if (classes.includes('details') || classes.includes('expanded') || classes.includes('child')) {
                    return nextSibling;
                }
            }
            
            // Try to find the row details element by ID reference
            const rowId = await row.getAttribute('id');
            
            if (rowId) {
                try {
                    const rowDetailsById = await this.element.findElement(By.css(`[aria-labelledby="${rowId}"]`));
                    return rowDetailsById;
                } catch (error) {
                    // Not found by ID reference
                }
            }
            
            return null;
        } catch (error) {
            return null;
        }
    }
    
    /**
     * Waits for row details to appear after expanding a row.
     * 
     * @param row The row element
     * @returns Promise resolving when the row details appear
     */
    private async waitForRowDetails(row: WebElement): Promise<void> {
        try {
            await CSWaitFactory.createWait(this.driver)
                .until(async () => {
                    const rowDetails = await this.findRowDetails(row);
                    return rowDetails !== null;
                })
                .withTimeout(CSConstants.DEFAULT_TIMEOUT)
                .withMessage('Waiting for row details to appear')
                .wait();
        } catch (error) {
            // Ignore timeout errors
        }
    }
    
    /**
     * Waits for row details to disappear after collapsing a row.
     * 
     * @param row The row element
     * @returns Promise resolving when the row details disappear
     */
    private async waitForRowDetailsToDisappear(row: WebElement): Promise<void> {
        try {
            await CSWaitFactory.createWait(this.driver)
                .until(async () => {
                    const rowDetails = await this.findRowDetails(row);
                    return rowDetails === null;
                })
                .withTimeout(CSConstants.DEFAULT_TIMEOUT)
                .withMessage('Waiting for row details to disappear')
                .wait();
        } catch (error) {
            // Ignore timeout errors
        }
    }
    
    /**
     * Sorts a column.
     * 
     * @param columnIndex The zero-based column index
     * @param direction The sort direction (ASC or DESC)
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the header cell cannot be found
     * @throws ActionFailedException if the column cannot be sorted
     */
    public async sortColumn(columnIndex: number, direction: SortDirection): Promise<CSTable> {
        try {
            const headerCells = await this.getHeaderCells();
            
            if (columnIndex < 0 || columnIndex >= headerCells.length) {
                throw new ElementNotFoundException(`Column index ${columnIndex} is out of bounds (0-${headerCells.length - 1})`);
            }
            
            const headerCell = headerCells[columnIndex];
            
            // Check if the header cell is sortable
            const isSortable = await this.isHeaderCellSortable(headerCell);
            
            if (!isSortable) {
                throw new ActionFailedException(`Column at index ${columnIndex} is not sortable`);
            }
            
            // Get the current sort direction
            const currentDirection = await this.getHeaderCellSortDirection(headerCell);
            
            // Determine how many clicks are needed to get to the desired direction
            let clicks = 0;
            
            if (currentDirection === SortDirection.NONE) {
                clicks = direction === SortDirection.ASC ? 1 : 2;
            } else if (currentDirection === SortDirection.ASC) {
                clicks = direction === SortDirection.ASC ? 0 : 1;
            } else if (currentDirection === SortDirection.DESC) {
                clicks = direction === SortDirection.ASC ? 2 : 0;
            }
            
            // Click the header cell the required number of times
            for (let i = 0; i < clicks; i++) {
                await headerCell.click();
                
                // Wait for sorting to complete
                await this.waitForTableLoad;
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to sort column at index ${columnIndex} in direction ${direction}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Sorts a column by column name.
     * 
     * @param columnName The name of the column
     * @param direction The sort direction (ASC or DESC)
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the header cell cannot be found
     * @throws ActionFailedException if the column cannot be sorted
     */
    public async sortColumnByName(columnName: string, direction: SortDirection): Promise<CSTable> {
        try {
            // Get the column index
            const columnIndex = await this.getColumnIndex(columnName);
            
            if (columnIndex === -1) {
                throw new ElementNotFoundException(`Column "${columnName}" not found`);
            }
            
            return await this.sortColumn(columnIndex, direction);
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(
                `Failed to sort column "${columnName}" in direction ${direction}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Checks if a header cell is sortable.
     * 
     * @param headerCell The header cell element
     * @returns Promise resolving to boolean indicating whether the header cell is sortable
     */
    private async isHeaderCellSortable(headerCell: WebElement): Promise<boolean> {
        try {
            // Check for sortable class
            const classes = await headerCell.getAttribute('class') || '';
            
            if (classes.includes('sortable') || classes.includes('sort')) {
                return true;
            }
            
            // Check for sort icons
            const sortIcons = await headerCell.findElements(By.css('.sort, .sort-icon, .fa-sort'));
            
            if (sortIcons.length > 0) {
                return true;
            }
            
            // Check for aria-sort attribute
            const ariaSort = await headerCell.getAttribute('aria-sort');
            
            if (ariaSort) {
                return true;
            }
            
            // Check for data-sort attribute
            const dataSort = await headerCell.getAttribute('data-sort');
            
            if (dataSort !== null) {
                return true;
            }
            
            return false;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Gets the current sort direction of a header cell.
     * 
     * @param headerCell The header cell element
     * @returns Promise resolving to the current sort direction
     */
    private async getHeaderCellSortDirection(headerCell: WebElement): Promise<SortDirection> {
        try {
            // Check for aria-sort attribute
            const ariaSort = await headerCell.getAttribute('aria-sort');
            
            if (ariaSort) {
                if (ariaSort === 'ascending') {
                    return SortDirection.ASC;
                } else if (ariaSort === 'descending') {
                    return SortDirection.DESC;
                }
            }
            
            // Check for classes
            const classes = await headerCell.getAttribute('class') || '';
            
            if (classes.includes('asc') || classes.includes('ascending') || classes.includes('sort-up')) {
                return SortDirection.ASC;
            }
            
            if (classes.includes('desc') || classes.includes('descending') || classes.includes('sort-down')) {
                return SortDirection.DESC;
            }
            
            // Check for sort icons
            try {
                // Look for icons with specific classes
                const ascIcon = await headerCell.findElement(By.css('.asc, .ascending, .sort-up, .fa-sort-up'));
                return SortDirection.ASC;
            } catch (error) {
                // No ascending icon found
            }
            
            try {
                const descIcon = await headerCell.findElement(By.css('.desc, .descending, .sort-down, .fa-sort-down'));
                return SortDirection.DESC;
            } catch (error) {
                // No descending icon found
            }
            
            return SortDirection.NONE;
        } catch (error) {
            return SortDirection.NONE;
        }
    }
    
    /**
     * Navigates to the next page.
     * 
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the pagination controls cannot be found
     * @throws ActionFailedException if navigation fails
     */
    public async nextPage(): Promise<CSTable> {
        try {
            // Find pagination controls
            const pagination = await this.findPagination();
            
            if (!pagination) {
                throw new ElementNotFoundException('Pagination controls not found');
            }
            
            // Find next page button
            const nextButton = await pagination.findElement(By.css(this.nextPageSelector));
            
            // Check if the button is disabled
            const isDisabled = await nextButton.getAttribute('disabled') !== null || 
                (await nextButton.getAttribute('class') || '').includes('disabled');
            
            if (isDisabled) {
                throw new ActionFailedException('Next page button is disabled');
            }
            
            // Click the button
            await nextButton.click();
            
            // Wait for the table to load
            if (this.waitForTableLoad) {
                await this.waitForLoading();
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(`Failed to navigate to next page: ${error.message}`, error);
        }
    }
    
    /**
     * Navigates to the previous page.
     * 
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the pagination controls cannot be found
     * @throws ActionFailedException if navigation fails
     */
    public async previousPage(): Promise<CSTable> {
        try {
            // Find pagination controls
            const pagination = await this.findPagination();
            
            if (!pagination) {
                throw new ElementNotFoundException('Pagination controls not found');
            }
            
            // Find previous page button
            const prevButton = await pagination.findElement(By.css(this.previousPageSelector));
            
            // Check if the button is disabled
            const isDisabled = await prevButton.getAttribute('disabled') !== null || 
                (await prevButton.getAttribute('class') || '').includes('disabled');
            
            if (isDisabled) {
                throw new ActionFailedException('Previous page button is disabled');
            }
            
            // Click the button
            await prevButton.click();
            
            // Wait for the table to load
            if (this.waitForTableLoad) {
                await this.waitForLoading();
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(`Failed to navigate to previous page: ${error.message}`, error);
        }
    }
    
    /**
     * Navigates to a specific page by page number.
     * 
     * @param pageNumber The page number (1-based)
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the pagination controls cannot be found
     * @throws ActionFailedException if navigation fails
     */
    public async goToPage(pageNumber: number): Promise<CSTable> {
        try {
            // Find pagination controls
            const pagination = await this.findPagination();
            
            if (!pagination) {
                throw new ElementNotFoundException('Pagination controls not found');
            }
            
            // Look for a link with the page number
            const pageLinks = await pagination.findElements(By.css('a, button, [role="button"]'));
            
            for (const link of pageLinks) {
                const linkText = await link.getText();
                
                if (linkText.trim() === pageNumber.toString()) {
                    // Check if the link is disabled or already active
                    const isDisabled = await link.getAttribute('disabled') !== null;
                    const isActive = (await link.getAttribute('class') || '').includes('active');
                    
                    if (isDisabled) {
                        throw new ActionFailedException(`Page ${pageNumber} link is disabled`);
                    }
                    
                    if (isActive) {
                        // Already on this page
                        return this;
                    }
                    
                    // Click the link
                    await link.click();
                    
                    // Wait for the table to load
                    if (this.waitForTableLoad) {
                        await this.waitForLoading();
                    }
                    
                    return this;
                }
            }
            
            // If we didn't find a direct link, we might need to navigate through the pages
            const currentPage = await this.getCurrentPage();
            
            if (currentPage === pageNumber) {
                // Already on this page
                return this;
            }
            
            if (currentPage < pageNumber) {
                // Need to go forward
                await this.nextPage();
                return await this.goToPage(pageNumber);
            } else {
                // Need to go backward
                await this.previousPage();
                return await this.goToPage(pageNumber);
            }
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(`Failed to navigate to page ${pageNumber}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the current page number.
     * 
     * @returns Promise resolving to the current page number or 1 if pagination is not found
     */
    public async getCurrentPage(): Promise<number> {
        try {
            // Find pagination controls
            const pagination = await this.findPagination();
            
            if (!pagination) {
                return 1;
            }
            
            // Look for an active link
            try {
                const activeLink = await pagination.findElement(By.css('.active, .current, [aria-current="page"]'));
                const linkText = await activeLink.getText();
                
                const pageNumber = parseInt(linkText.trim(), 10);
                
                if (!isNaN(pageNumber)) {
                    return pageNumber;
                }
            } catch (error) {
                // No active link found
            }
            
            // Try to find the current page from an input field
            try {
                const pageInput = await pagination.findElement(By.css('input[type="number"], input.page'));
                const value = await pageInput.getAttribute('value');
                
                const pageNumber = parseInt(value.trim(), 10);
                
                if (!isNaN(pageNumber)) {
                    return pageNumber;
                }
            } catch (error) {
                // No page input found
            }
            
            return 1;
        } catch (error) {
            return 1;
        }
    }
    
    /**
     * Finds the pagination controls.
     * 
     * @returns Promise resolving to the WebElement representing the pagination controls or null if not found
     */
    private async findPagination(): Promise<WebElement | null> {
        try {
            // First, look for a pagination element within the table
            try {
                const pagination = await this.element.findElement(By.css(this.paginationSelector));
                return pagination;
            } catch (error) {
                // No pagination found within the table
            }
            
            // Then, look for a pagination element that follows the table
            const tableId = await this.element.getAttribute('id');
            
            if (tableId) {
                try {
                    const pagination = await this.driver.findElement(By.css(`#${tableId}_pagination, #${tableId}-pagination, [aria-controls="${tableId}"]`));
                    return pagination;
                } catch (error) {
                    // No ID-associated pagination found
                }
            }
            
            // Finally, look for any pagination element nearby
            const pagination = await this.driver.executeScript(
                `
                const table = arguments[0];
                const paginationSelector = arguments[1];
                
                // Look for pagination in the same container
                let parent = table.parentElement;
                
                while (parent) {
                    const pagination = parent.querySelector(paginationSelector);
                    
                    if (pagination) {
                        return pagination;
                    }
                    
                    parent = parent.parentElement;
                    
                    // Don't go too far up
                    if (parent === document.body) {
                        break;
                    }
                }
                
                // Look for pagination following the table
                let sibling = table.nextElementSibling;
                
                while (sibling) {
                    if (sibling.matches(paginationSelector) || sibling.querySelector(paginationSelector)) {
                        return sibling.matches(paginationSelector) ? sibling : sibling.querySelector(paginationSelector);
                    }
                    
                    sibling = sibling.nextElementSibling;
                    
                    // Don't check too many siblings
                    if (!sibling || sibling.tagName === 'TABLE') {
                        break;
                    }
                }
                
                return null;
                `,
                this.element,
                this.paginationSelector
            );
            
            return pagination;
        } catch (error) {
            return null;
        }
    }
    
    /**
     * Searches for a value in the table.
     * 
     * @param searchText The text to search for
     * @returns This table instance for chaining
     * @throws ElementNotFoundException if the search input cannot be found
     * @throws ActionFailedException if the search fails
     */
    public async search(searchText: string): Promise<CSTable> {
        try {
            // Find search input
            const searchInput = await this.findSearchInput();
            
            if (!searchInput) {
                throw new ElementNotFoundException('Search input not found');
            }
            
            // Clear the input and enter the search text
            await searchInput.clear();
            await searchInput.sendKeys(searchText);
            
            // Press Enter to submit the search
            await searchInput.sendKeys('\n');
            
            // Wait for the table to load
            if (this.waitForTableLoad) {
                await this.waitForLoading();
            }
            
            return this;
        } catch (error) {
            if (error instanceof ElementNotFoundException) {
                throw error;
            }
            
            throw new ActionFailedException(`Failed to search for "${searchText}": ${error.message}`, error);
        }
    }
    
    /**
     * Finds the search input.
     * 
     * @returns Promise resolving to the WebElement representing the search input or null if not found
     */
    private async findSearchInput(): Promise<WebElement | null> {
        try {
            // First, look for a search input within the table
            try {
                const searchInput = await this.element.findElement(By.css(this.searchInputSelector));
                return searchInput;
            } catch (error) {
                // No search input found within the table
            }
            
            // Then, look for a search input associated with the table
            const tableId = await this.element.getAttribute('id');
            
            if (tableId) {
                try {
                    const searchInput = await this.driver.findElement(By.css(`#${tableId}_search, #${tableId}-search, [aria-controls="${tableId}"]${this.searchInputSelector}`));
                    return searchInput;
                } catch (error) {
                    // No ID-associated search input found
                }
            }
            
            // Finally, look for any search input nearby
            const searchInput = await this.driver.executeScript(
                `
                const table = arguments[0];
                const searchSelector = arguments[1];
                
                // Look for search input in the same container
                let parent = table.parentElement;
                
                while (parent) {
                    const search = parent.querySelector(searchSelector);
                    
                    if (search) {
                        return search;
                    }
                    
                    parent = parent.parentElement;
                    
                    // Don't go too far up
                    if (parent === document.body) {
                        break;
                    }
                }
                
                // Look for search input preceding the table
                let sibling = table.previousElementSibling;
                
                while (sibling) {
                    if (sibling.matches(searchSelector) || sibling.querySelector(searchSelector)) {
                        return sibling.matches(searchSelector) ? sibling : sibling.querySelector(searchSelector);
                    }
                    
                    sibling = sibling.previousElementSibling;
                    
                    // Don't check too many siblings
                    if (!sibling || sibling.tagName === 'TABLE') {
                        break;
                    }
                }
                
                return null;
                `,
                this.element,
                this.searchInputSelector
            );
            
            return searchInput;
        } catch (error) {
            return null;
        }
    }
    
    /**
     * Checks if the table is empty.
     * 
     * @returns Promise resolving to boolean indicating whether the table is empty
     */
    public async isEmpty(): Promise<boolean> {
        try {
            // Check for empty table indicators
            try {
                const emptyIndicator = await this.element.findElement(By.css(this.emptyTableSelector));
                return true;
            } catch (error) {
                // No empty indicator found
            }
            
            // Check if there are any body rows
            const rows = await this.element.findElements(By.css(this.bodyRowSelector));
            
            if (rows.length === 0) {
                return true;
            }
            
            // Check if there's a single row with no data or a "no data" message
            if (rows.length === 1) {
                const singleRow = rows[0];
                const cells = await singleRow.findElements(By.css(this.cellSelector));
                
                if (cells.length === 1) {
                    const cellText = await cells[0].getText();
                    const cellColSpan = await cells[0].getAttribute('colspan');
                    
                    // Check if this is a "no data" cell (typically spans all columns)
                    if (cellColSpan && parseInt(cellColSpan, 10) > 1) {
                        const normalizedText = this.normalizeString(cellText).toLowerCase();
                        
                        if (normalizedText.includes('no data') || 
                            normalizedText.includes('no results') || 
                            normalizedText.includes('no items') || 
                            normalizedText.includes('empty') || 
                            normalizedText.includes('not found')) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        } catch (error) {
            // If anything goes wrong, assume the table is not empty
            return false;
        }
    }
    
    /**
     * Checks if the table is loading.
     * 
     * @returns Promise resolving to boolean indicating whether the table is loading
     */
    public async isLoading(): Promise<boolean> {
        try {
            // Check for loading indicators
            try {
                const loadingIndicator = await this.element.findElement(By.css(this.loadingIndicatorSelector));
                const isDisplayed = await loadingIndicator.isDisplayed();
                return isDisplayed;
            } catch (error) {
                // No loading indicator found
            }
            
            // Check for aria-busy attribute
            const ariaBusy = await this.element.getAttribute('aria-busy');
            
            if (ariaBusy === 'true') {
                return true;
            }
            
            return false;
        } catch (error) {
            // If anything goes wrong, assume the table is not loading
            return false;
        }
    }
    
    /**
     * Waits for the table to finish loading.
     * 
     * @param timeout Timeout in milliseconds
     * @returns Promise resolving when the table has finished loading
     */
    public async waitForLoading(timeout: number = CSConstants.DEFAULT_TIMEOUT): Promise<void> {
        try {
            await CSWaitFactory.createWait(this.driver)
                .until(async () => {
                    return !(await this.isLoading());
                })
                .withTimeout(timeout)
                .withMessage('Waiting for table to finish loading')
                .wait();
        } catch (error) {
            // Ignore timeout errors
        }
    }
    
    /**
     * Gets the text content of an element.
     * 
     * @param element The WebElement
     * @returns Promise resolving to the text content of the element
     */
    private async getElementText(element: WebElement): Promise<string> {
        let text = await element.getText();
        
        // Apply text normalization if enabled
        if (this.normalizeText) {
            text = this.normalizeString(text);
        }
        
        // Trim the text if enabled
        if (this.trimText) {
            text = text.trim();
        }
        
        return text;
    }
    
    /**
     * Normalizes a string by removing extra whitespace and replacing special characters.
     * 
     * @param text The text to normalize
     * @returns The normalized text
     */
    private normalizeString(text: string): string {
        // Replace multiple whitespace characters with a single space
        let normalized = text.replace(/\s+/g, ' ');
        
        // Replace non-breaking spaces with regular spaces
        normalized = normalized.replace(/\u00A0/g, ' ');
        
        // Replace other common special characters
        normalized = normalized.replace(/[\u2013\u2014]/g, '-'); // Em and En dashes
        normalized = normalized.replace(/[\u2018\u2019]/g, "'"); // Single quotes
        normalized = normalized.replace(/[\u201C\u201D]/g, '"'); // Double quotes
        
        // Trim the result
        normalized = normalized.trim();
        
        return normalized;
    }
    
    /**
     * Creates a new CSTable instance with convenient static factory methods.
     */
    public static create(element: WebElement, options: CSTableOptions = {}): CSTable {
        return new CSTable(element, options);
    }
    
    /**
     * Creates a new CSTable instance for a standard HTML table.
     */
    public static createStandard(element: WebElement): CSTable {
        return new CSTable(element, {
            tableType: TableType.STANDARD
        });
    }
    
    /**
     * Creates a new CSTable instance for a DataTables table.
     */
    public static createDataTable(element: WebElement): CSTable {
        return new CSTable(element, {
            tableType: TableType.DATATABLES,
            headerRowSelector: 'thead tr, .dataTable tr:first-child',
            bodyRowSelector: 'tbody tr, .dataTable tr:not(:first-child)',
            paginationSelector: '.dataTables_paginate',
            nextPageSelector: '.next, .paginate_button.next',
            previousPageSelector: '.previous, .paginate_button.previous',
            searchInputSelector: '.dataTables_filter input',
            loadingIndicatorSelector: '.dataTables_processing',
            waitForTableLoad: true
        });
    }
    
    /**
     * Creates a new CSTable instance for a Bootstrap table.
     */
    public static createBootstrapTable(element: WebElement): CSTable {
        return new CSTable(element, {
            tableType: TableType.BOOTSTRAP,
            headerRowSelector: 'thead tr, .table tr:first-child',
            bodyRowSelector: 'tbody tr, .table tr:not(:first-child)',
            paginationSelector: '.pagination',
            nextPageSelector: '.page-item.next, .page-item:last-child',
            previousPageSelector: '.page-item.prev, .page-item:first-child',
            loadingIndicatorSelector: '.table-loading, .spinner-border',
            waitForTableLoad: true
        });
    }
    
    /**
     * Creates a new CSTable instance for a Material Design table.
     */
    public static createMaterialTable(element: WebElement): CSTable {
        return new CSTable(element, {
            tableType: TableType.MATERIAL,
            headerRowSelector: '.mat-header-row, mat-header-row, thead tr',
            bodyRowSelector: '.mat-row, mat-row, tbody tr',
            cellSelector: '.mat-cell, mat-cell, .mat-header-cell, mat-header-cell, td, th',
            headerCellSelector: '.mat-header-cell, mat-header-cell, th',
            sortableHeaderSelector: '.mat-sort-header, [mat-sort-header]',
            paginationSelector: 'mat-paginator, .mat-paginator',
            loadingIndicatorSelector: 'mat-progress-bar, .mat-progress-bar, mat-spinner, .mat-spinner',
            waitForTableLoad: true
        });
    }
    
    /**
     * Creates a new CSTable instance from an existing CSElement.
     * 
     * @param element The CSElement to wrap
     * @param options Additional options for the table
     * @returns A new CSTable instance
     */
    public static fromCSElement(element: CSElement, options: CSTableOptions = {}): CSTable {
        return new CSTable(element.getWebElement(), options);
    }
    
    /**
     * Creates a CSTable wrapper for a table element based on its class attributes.
     * 
     * @param element WebElement representing a table
     * @returns Promise resolving to a new CSTable instance
     */
    public static async fromTableElement(element: WebElement): Promise<CSTable> {
        // Check the table's classes to determine the appropriate wrapper
        const classes = await element.getAttribute('class') || '';
        
        if (classes.includes('dataTable') || classes.includes('datatable') || classes.includes('dt-')) {
            return CSTable.createDataTable(element);
        } else if (classes.includes('mat-table') || element.findElement(By.css('mat-table'))) {
            return CSTable.createMaterialTable(element);
        } else if (classes.includes('table-bootstrap') || classes.includes('table')) {
            return CSTable.createBootstrapTable(element);
        } else {
            // Default to standard table
            return CSTable.createStandard(element);
        }
    }
}

/**
 * Enum for table types.
 */
export enum TableType {
    STANDARD = 'standard',
    DATATABLES = 'dataTables',
    BOOTSTRAP = 'bootstrap',
    MATERIAL = 'material',
    CUSTOM = 'custom'
}

/**
 * Enum for sort directions.
 */
export enum SortDirection {
    NONE = 'none',
    ASC = 'asc',
    DESC = 'desc'
}

/**
 * Interface for table configuration options.
 */
export interface CSTableOptions {
    /**
     * CSS selector for header rows.
     */
    headerRowSelector?: string;
    
    /**
     * CSS selector for body rows.
     */
    bodyRowSelector?: string;
    
    /**
     * CSS selector for footer rows.
     */
    footerRowSelector?: string;
    
    /**
     * CSS selector for cells.
     */
    cellSelector?: string;
    
    /**
     * CSS selector for header cells.
     */
    headerCellSelector?: string;
    
    /**
     * Index of the header row (zero-based).
     */
    headerRowIndex?: number;
    
    /**
     * CSS selector for pagination controls.
     */
    paginationSelector?: string;
    
    /**
     * CSS selector for the next page button.
     */
    nextPageSelector?: string;
    
    /**
     * CSS selector for the previous page button.
     */
    previousPageSelector?: string;
    
    /**
     * CSS selector for sortable header cells.
     */
    sortableHeaderSelector?: string;
    
    /**
     * CSS selector for checkboxes.
     */
    checkboxSelector?: string;
    
    /**
     * CSS selector for expand row buttons.
     */
    expandRowSelector?: string;
    
    /**
     * CSS selector for row details.
     */
    rowDetailsSelector?: string;
    
    /**
     * CSS selector for search input.
     */
    searchInputSelector?: string;
    
    /**
     * CSS selector for empty table indicators.
     */
    emptyTableSelector?: string;
    
    /**
     * CSS selector for loading indicators.
     */
    loadingIndicatorSelector?: string;
    
    /**
     * Type of the table.
     */
    tableType?: TableType;
    
    /**
     * Whether to wait for the table to load after actions.
     */
    waitForTableLoad?: boolean;
    
    /**
     * Whether to use strict column name matching.
     */
    strictColumnMatching?: boolean;
    
    /**
     * Whether to use case-sensitive header matching.
     */
    caseSensitiveHeaders?: boolean;
    
    /**
     * Whether to normalize text by removing extra whitespace and replacing special characters.
     */
    normalizeText?: boolean;
    
    /**
     * Whether to trim text.
     */
    trimText?: boolean;
}


CSBaseTest.ts
--------------------------

import { Builder, WebDriver, Capabilities, logging } from 'selenium-webdriver';
import * as chrome from 'selenium-webdriver/chrome';
import * as firefox from 'selenium-webdriver/firefox';
import * as edge from 'selenium-webdriver/edge';
import * as safari from 'selenium-webdriver/safari';
import { CSElement } from '../element/CSElement';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSScreenshotManager } from '../../core/utils/CSScreenshotManager';
import { CSVideoRecorder } from '../../core/utils/CSVideoRecorder';
import { CSConfigurationManager } from '../../core/config/ConfigurationManager';
import { CSConstants } from '../../core/utils/CSConstants';
import { CSDateUtils } from '../../core/utils/CSDateUtils';
import { CSFileUtils } from '../../core/utils/CSFileUtils';
import { CSPathUtils } from '../../core/utils/CSPathUtils';
import { CSTestListener } from '../../core/reporting/listener/CSTestListener';
import { CSReporter } from '../../core/reporting/CSReporter';
import { CSHtmlReportGenerator } from '../../core/reporting/CSHtmlReportGenerator';
import { CSTestResult } from '../../core/reporting/CSTestResult';
import { CSTestStatus } from '../../core/reporting/CSTestStatus';
import { CSTestStep } from '../../core/reporting/CSTestStep';
import { CSScreenshot } from '../../core/reporting/CSScreenshot';
import { CSLogLevel } from '../../core/reporting/CSLogLevel';
import { CSTestMetadata } from '../../core/reporting/CSTestMetadata';
import { DriverNotInitializedException } from '../../core/exceptions/DriverNotInitializedException';
import { ConfigurationException } from '../../core/exceptions/ConfigurationException';
import { TestExecutionException } from '../../core/exceptions/TestExecutionException';

/**
 * Base class for all Selenium TestNG-style tests.
 * Provides common test lifecycle management, driver configuration,
 * reporting, and utility methods.
 */
export abstract class CSBaseTest {
    /**
     * The WebDriver instance for the test.
     * @protected
     */
    protected driver: WebDriver | null = null;
    
    /**
     * The browser name for the test.
     * @protected
     */
    protected browserName: string = '';
    
    /**
     * The current test name.
     * @protected
     */
    protected testName: string = '';
    
    /**
     * The current test class name.
     * @protected
     */
    protected testClassName: string = '';
    
    /**
     * Timestamp when the test started.
     * @protected
     */
    protected testStartTime: number = 0;
    
    /**
     * Test result object for reporting.
     * @protected
     */
    protected testResult: CSTestResult | null = null;
    
    /**
     * Configuration manager instance.
     * @protected
     */
    protected config: CSConfigurationManager;
    
    /**
     * Screenshot manager instance.
     * @protected
     */
    protected screenshotManager: CSScreenshotManager;
    
    /**
     * Video recorder instance.
     * @protected
     */
    protected videoRecorder: CSVideoRecorder | null = null;
    
    /**
     * Reporter instance.
     * @protected
     */
    protected reporter: CSReporter;
    
    /**
     * Test listener instance.
     * @protected
     */
    protected testListener: CSTestListener | null = null;
    
    /**
     * Whether the test is running in headless mode.
     * @protected
     */
    protected headless: boolean = false;
    
    /**
     * Whether to maximize the browser window.
     * @protected
     */
    protected maximizeBrowser: boolean = true;
    
    /**
     * Browser window width.
     * @protected
     */
    protected browserWidth: number = 1920;
    
    /**
     * Browser window height.
     * @protected
     */
    protected browserHeight: number = 1080;
    
    /**
     * Screenshot directory path.
     * @protected
     */
    protected screenshotDir: string = '';
    
    /**
     * Video directory path.
     * @protected
     */
    protected videoDir: string = '';
    
    /**
     * Report directory path.
     * @protected
     */
    protected reportDir: string = '';
    
    /**
     * Whether to capture screenshots on test failure.
     * @protected
     */
    protected captureScreenshotOnFailure: boolean = true;
    
    /**
     * Whether to capture screenshots for each test step.
     * @protected
     */
    protected captureScreenshotForSteps: boolean = false;
    
    /**
     * Whether to record video of the test execution.
     * @protected
     */
    protected recordVideo: boolean = false;
    
    /**
     * Whether to create an HTML report.
     * @protected
     */
    protected createHtmlReport: boolean = true;
    
    /**
     * Whether to clean up old test reports.
     * @protected
     */
    protected cleanupOldReports: boolean = true;
    
    /**
     * Number of days to keep old reports.
     * @protected
     */
    protected reportRetentionDays: number = 30;
    
    /**
     * Timeout for page loads in milliseconds.
     * @protected
     */
    protected pageLoadTimeout: number = 60000;
    
    /**
     * Timeout for script execution in milliseconds.
     * @protected
     */
    protected scriptTimeout: number = 30000;
    
    /**
     * Implicit wait timeout in milliseconds.
     * @protected
     */
    protected implicitWaitTimeout: number = 0; // Default to zero - we prefer explicit waits
    
    /**
     * Default explicit wait timeout in milliseconds.
     * @protected
     */
    protected explicitWaitTimeout: number = 30000;
    
    /**
     * Base URL for the application under test.
     * @protected
     */
    protected baseUrl: string = '';
    
    /**
     * Browser capabilities dictionary for different browsers.
     * @protected
     */
    protected browserCapabilities: Map<string, Capabilities> = new Map();
    
    /**
     * Browser options dictionary for different browsers.
     * @protected
     */
    protected browserOptions: Map<string, any> = new Map();
    
    /**
     * Remote WebDriver URL.
     * @protected
     */
    protected remoteUrl: string = '';
    
    /**
     * Whether to use a remote WebDriver.
     * @protected
     */
    protected useRemoteDriver: boolean = false;
    
    /**
     * Test retry count.
     * @protected
     */
    protected retryCount: number = 0;
    
    /**
     * Current attempt number.
     * @protected
     */
    protected currentAttempt: number = 1;
    
    /**
     * The currently executing method name.
     * @protected
     */
    protected currentMethodName: string = '';
    
    /**
     * Dictionary of test data values.
     * @protected
     */
    protected testData: Map<string, any> = new Map();
    
    /**
     * Custom test attributes.
     * @protected
     */
    protected testAttributes: Map<string, string> = new Map();
    
    /**
     * Test groups (categories).
     * @protected
     */
    protected testGroups: string[] = [];
    
    /**
     * Creates a new instance of the CSBaseTest class.
     */
    constructor() {
        // Initialize configuration manager
        this.config = CSConfigurationManager.getInstance();
        
        // Initialize screenshot manager
        this.screenshotManager = new CSScreenshotManager();
        
        // Initialize reporter
        this.reporter = new CSHtmlReportGenerator();
        
        // Set test class name
        this.testClassName = this.constructor.name;
        
        // Load configuration
        this.loadConfiguration();
        
        // Initialize browser capabilities and options
        this.initializeBrowserCapabilities();
    }
    
    /**
     * Loads configuration from the configuration manager.
     * @protected
     */
    protected loadConfiguration(): void {
        // Load browser configuration
        this.browserName = this.config.getString('browser.name', 'chrome');
        this.headless = this.config.getBoolean('browser.headless', false);
        this.maximizeBrowser = this.config.getBoolean('browser.maximize', true);
        this.browserWidth = this.config.getNumber('browser.width', 1920);
        this.browserHeight = this.config.getNumber('browser.height', 1080);
        
        // Load timeout configuration
        this.pageLoadTimeout = this.config.getNumber('timeouts.pageLoad', 60000);
        this.scriptTimeout = this.config.getNumber('timeouts.script', 30000);
        this.implicitWaitTimeout = this.config.getNumber('timeouts.implicitWait', 0);
        this.explicitWaitTimeout = this.config.getNumber('timeouts.explicitWait', 30000);
        
        // Load WebDriver configuration
        this.useRemoteDriver = this.config.getBoolean('webdriver.remote.enabled', false);
        this.remoteUrl = this.config.getString('webdriver.remote.url', 'http://localhost:4444/wd/hub');
        
        // Load base URL
        this.baseUrl = this.config.getString('application.baseUrl', '');
        
        // Load reporting configuration
        this.screenshotDir = this.config.getString('reporting.screenshot.dir', './screenshots');
        this.videoDir = this.config.getString('reporting.video.dir', './videos');
        this.reportDir = this.config.getString('reporting.html.dir', './reports');
        this.captureScreenshotOnFailure = this.config.getBoolean('reporting.screenshot.captureOnFailure', true);
        this.captureScreenshotForSteps = this.config.getBoolean('reporting.screenshot.captureForSteps', false);
        this.recordVideo = this.config.getBoolean('reporting.video.enabled', false);
        this.createHtmlReport = this.config.getBoolean('reporting.html.enabled', true);
        this.cleanupOldReports = this.config.getBoolean('reporting.cleanup.enabled', true);
        this.reportRetentionDays = this.config.getNumber('reporting.cleanup.retentionDays', 30);
        
        // Load retry configuration
        this.retryCount = this.config.getNumber('test.retry.count', 0);
        
        // Override with environment variables if present
        if (process.env.BROWSER) {
            this.browserName = process.env.BROWSER;
        }
        
        if (process.env.HEADLESS === 'true') {
            this.headless = true;
        } else if (process.env.HEADLESS === 'false') {
            this.headless = false;
        }
        
        if (process.env.BASE_URL) {
            this.baseUrl = process.env.BASE_URL;
        }
        
        if (process.env.REMOTE_URL) {
            this.remoteUrl = process.env.REMOTE_URL;
            this.useRemoteDriver = true;
        }
    }
    
    /**
     * Initializes browser capabilities and options for different browsers.
     * @protected
     */
    protected initializeBrowserCapabilities(): void {
        // Chrome capabilities and options
        const chromeCapabilities = Capabilities.chrome();
        const chromeOptions = new chrome.Options();
        
        if (this.headless) {
            chromeOptions.headless();
        }
        
        chromeOptions.windowSize({
            width: this.browserWidth,
            height: this.browserHeight
        });
        
        // Add common Chrome arguments
        chromeOptions.addArguments('--disable-infobars');
        chromeOptions.addArguments('--disable-notifications');
        chromeOptions.addArguments('--disable-extensions');
        chromeOptions.addArguments('--disable-gpu'); // Recommended for headless
        chromeOptions.addArguments('--no-sandbox'); // Required for Docker/CI environments
        chromeOptions.addArguments('--disable-dev-shm-usage'); // Recommended for CI environments
        
        // Set Chrome preferences
        chromeOptions.setUserPreferences({
            'download.default_directory': CSPathUtils.resolvePath('./downloads'),
            'download.prompt_for_download': false,
            'download.directory_upgrade': true,
            'safebrowsing.enabled': false
        });
        
        // Add Chrome capabilities
        chromeCapabilities.set('goog:loggingPrefs', {
            browser: logging.Level.ALL,
            driver: logging.Level.INFO
        });
        
        // Store Chrome capabilities and options
        this.browserCapabilities.set('chrome', chromeCapabilities);
        this.browserOptions.set('chrome', chromeOptions);
        
        // Firefox capabilities and options
        const firefoxCapabilities = Capabilities.firefox();
        const firefoxOptions = new firefox.Options();
        
        if (this.headless) {
            firefoxOptions.headless();
        }
        
        firefoxOptions.windowSize({
            width: this.browserWidth,
            height: this.browserHeight
        });
        
        // Add Firefox preferences
        firefoxOptions.setPreference('browser.download.folderList', 2);
        firefoxOptions.setPreference('browser.download.manager.showWhenStarting', false);
        firefoxOptions.setPreference('browser.download.dir', CSPathUtils.resolvePath('./downloads'));
        firefoxOptions.setPreference('browser.helperApps.neverAsk.saveToDisk', 'application/octet-stream,application/pdf,application/vnd.ms-excel,text/csv');
        
        // Add Firefox capabilities
        firefoxCapabilities.set('moz:loggingPrefs', {
            browser: logging.Level.ALL,
            driver: logging.Level.INFO
        });
        
        // Store Firefox capabilities and options
        this.browserCapabilities.set('firefox', firefoxCapabilities);
        this.browserOptions.set('firefox', firefoxOptions);
        
        // Edge capabilities and options
        const edgeCapabilities = Capabilities.edge();
        const edgeOptions = new edge.Options();
        
        if (this.headless) {
            edgeOptions.headless();
        }
        
        edgeOptions.windowSize({
            width: this.browserWidth,
            height: this.browserHeight
        });
        
        // Add Edge arguments (similar to Chrome as they're both Chromium-based)
        edgeOptions.addArguments('--disable-infobars');
        edgeOptions.addArguments('--disable-notifications');
        edgeOptions.addArguments('--disable-extensions');
        
        // Store Edge capabilities and options
        this.browserCapabilities.set('edge', edgeCapabilities);
        this.browserOptions.set('edge', edgeOptions);
        
        // Safari capabilities and options
        const safariCapabilities = Capabilities.safari();
        const safariOptions = new safari.Options();
        
        // Safari doesn't support headless mode, but we can set some options
        safariOptions.setTechnologyPreview(false); // Use regular Safari, not tech preview
        
        // Store Safari capabilities and options
        this.browserCapabilities.set('safari', safariCapabilities);
        this.browserOptions.set('safari', safariOptions);
    }
    
    /**
     * Sets up the test environment before test execution.
     * This method is called before any test methods are executed.
     */
    public async beforeSuite(): Promise<void> {
        try {
            // Create directories if they don't exist
            await CSFileUtils.createDirectoryIfNotExists(this.screenshotDir);
            await CSFileUtils.createDirectoryIfNotExists(this.reportDir);
            
            if (this.recordVideo) {
                await CSFileUtils.createDirectoryIfNotExists(this.videoDir);
            }
            
            // Clean up old reports if enabled
            if (this.cleanupOldReports) {
                await this.cleanupOldReportFiles();
            }
            
            // Initialize test listener if using reporting
            if (this.createHtmlReport) {
                this.testListener = new CSTestListener(this.reporter);
            }
            
            // Set up WebDriver logging
            CSLogger.info(`Setting up test suite: ${this.testClassName}`);
            CSLogger.info(`Browser: ${this.browserName}`);
            CSLogger.info(`Headless mode: ${this.headless}`);
            CSLogger.info(`Base URL: ${this.baseUrl}`);
            
            // Execute user-defined before suite logic
            await this.beforeSuiteHook();
        } catch (error) {
            CSLogger.error(`Error in beforeSuite: ${error.message}`);
            throw new TestExecutionException(`Failed to set up test suite: ${error.message}`, error);
        }
    }
    
    /**
     * Tears down the test environment after test execution.
     * This method is called after all test methods are executed.
     */
    public async afterSuite(): Promise<void> {
        try {
            // Execute user-defined after suite logic
            await this.afterSuiteHook();
            
            // Generate HTML report if enabled
            if (this.createHtmlReport && this.testListener) {
                await this.reporter.generateReport();
            }
            
            CSLogger.info(`Test suite completed: ${this.testClassName}`);
        } catch (error) {
            CSLogger.error(`Error in afterSuite: ${error.message}`);
            throw new TestExecutionException(`Failed to tear down test suite: ${error.message}`, error);
        }
    }
    
    /**
     * Sets up the test method before execution.
     * This method is called before each test method is executed.
     * 
     * @param testName The name of the test method
     * @param testGroups The groups (categories) the test belongs to
     */
    public async beforeTest(testName: string, testGroups: string[] = []): Promise<void> {
        try {
            this.testName = testName;
            this.testGroups = testGroups;
            this.testStartTime = Date.now();
            this.currentMethodName = testName;
            
            CSLogger.info(`Starting test: ${this.testName}`);
            
            // Create a new test result
            this.testResult = new CSTestResult(
                this.testName,
                this.testClassName,
                this.testGroups
            );
            
            // Add test metadata
            const metadata = new CSTestMetadata();
            metadata.setBrowser(this.browserName);
            metadata.setHeadless(this.headless);
            metadata.setEnvironment(process.env.NODE_ENV || 'development');
            metadata.setTimestamp(this.testStartTime);
            
            // Add custom attributes
            this.testAttributes.forEach((value, key) => {
                metadata.setAttribute(key, value);
            });
            
            this.testResult.setMetadata(metadata);
            
            // Initialize test listener if using reporting
            if (this.createHtmlReport && this.testListener) {
                this.testListener.onTestStart(this.testResult);
            }
            
            // Initialize WebDriver
            await this.initializeDriver();
            
            // Start video recording if enabled
            if (this.recordVideo) {
                this.videoRecorder = new CSVideoRecorder(this.driver!, this.videoDir);
                await this.videoRecorder.start(`${this.testClassName}_${this.testName}`);
            }
            
            // Navigate to base URL if specified
            if (this.baseUrl) {
                await this.driver!.get(this.baseUrl);
            }
            
            // Execute user-defined before test logic
            await this.beforeTestHook();
        } catch (error) {
            CSLogger.error(`Error in beforeTest: ${error.message}`);
            
            // Record test failure
            if (this.testResult) {
                this.testResult.setStatus(CSTestStatus.FAILED);
                this.testResult.setEndTime(Date.now());
                this.testResult.setErrorMessage(`Failed to set up test: ${error.message}`);
                this.testResult.setStackTrace(error.stack || '');
                
                if (this.createHtmlReport && this.testListener) {
                    this.testListener.onTestFailure(this.testResult, error);
                }
            }
            
            throw new TestExecutionException(`Failed to set up test ${this.testName}: ${error.message}`, error);
        }
    }
    
    /**
     * Tears down the test method after execution.
     * This method is called after each test method is executed.
     * 
     * @param status The test status (PASSED, FAILED, SKIPPED)
     * @param error The error that caused the test to fail (if applicable)
     */
    public async afterTest(status: CSTestStatus, error?: Error): Promise<void> {
        try {
            // Set test result status and end time
            if (this.testResult) {
                this.testResult.setStatus(status);
                this.testResult.setEndTime(Date.now());
                
                if (error) {
                    this.testResult.setErrorMessage(error.message);
                    this.testResult.setStackTrace(error.stack || '');
                    
                    // Capture screenshot on failure if enabled
                    if (this.captureScreenshotOnFailure && this.driver) {
                        try {
                            const screenshotPath = await this.captureScreenshot(`${this.testName}_FAILED`);
                            
                            if (screenshotPath) {
                                const screenshot = new CSScreenshot(screenshotPath);
                                this.testResult.addScreenshot(screenshot);
                            }
                        } catch (screenshotError) {
                            CSLogger.error(`Failed to capture failure screenshot: ${screenshotError.message}`);
                        }
                    }
                }
            }
            
            // Execute user-defined after test logic
            try {
                await this.afterTestHook();
            } catch (hookError) {
                CSLogger.error(`Error in afterTestHook: ${hookError.message}`);
            }
            
            // Stop video recording if enabled
            if (this.videoRecorder) {
                try {
                    const videoPath = await this.videoRecorder.stop();
                    
                    if (this.testResult && videoPath) {
                        this.testResult.setVideoPath(videoPath);
                    }
                } catch (videoError) {
                    CSLogger.error(`Failed to stop video recording: ${videoError.message}`);
                }
                
                this.videoRecorder = null;
            }
            
            // Notify test listener
            if (this.createHtmlReport && this.testListener && this.testResult) {
                switch (status) {
                    case CSTestStatus.PASSED:
                        this.testListener.onTestSuccess(this.testResult);
                        break;
                    case CSTestStatus.FAILED:
                        this.testListener.onTestFailure(this.testResult, error);
                        break;
                    case CSTestStatus.SKIPPED:
                        this.testListener.onTestSkipped(this.testResult);
                        break;
                }
            }
            
            // Close WebDriver
            await this.closeDriver();
            
            CSLogger.info(`Finished test: ${this.testName}`);
            CSLogger.info(`Status: ${status}`);
            
            // Reset test state
            this.currentMethodName = '';
        } catch (error) {
            CSLogger.error(`Error in afterTest: ${error.message}`);
            throw new TestExecutionException(`Failed to tear down test ${this.testName}: ${error.message}`, error);
        }
    }
    
    /**
     * Initializes the WebDriver instance.
     * @protected
     */
    protected async initializeDriver(): Promise<void> {
        try {
            CSLogger.info(`Initializing WebDriver for ${this.browserName}`);
            
            const capabilities = this.browserCapabilities.get(this.browserName.toLowerCase());
            const options = this.browserOptions.get(this.browserName.toLowerCase());
            
            if (!capabilities || !options) {
                throw new ConfigurationException(`Unsupported browser: ${this.browserName}`);
            }
            
            // Create a new Builder
            const builder = new Builder()
                .withCapabilities(capabilities);
            
            // Apply browser-specific options
            switch (this.browserName.toLowerCase()) {
                case 'chrome':
                    builder.setChromeOptions(options);
                    break;
                case 'firefox':
                    builder.setFirefoxOptions(options);
                    break;
                case 'edge':
                    builder.setEdgeOptions(options);
                    break;
                case 'safari':
                    builder.setSafariOptions(options);
                    break;
            }
            
            // Use remote driver if configured
            if (this.useRemoteDriver) {
                CSLogger.info(`Using remote WebDriver at ${this.remoteUrl}`);
                builder.usingServer(this.remoteUrl);
            }
            
            // Build the WebDriver
            this.driver = await builder.build();
            
            // Configure driver timeouts
            await this.driver.manage().setTimeouts({
                implicit: this.implicitWaitTimeout,
                pageLoad: this.pageLoadTimeout,
                script: this.scriptTimeout
            });
            
            // Maximize browser window if configured
            if (this.maximizeBrowser) {
                await this.driver.manage().window().maximize();
            } else {
                await this.driver.manage().window().setRect({
                    width: this.browserWidth,
                    height: this.browserHeight
                });
            }
            
            CSLogger.info('WebDriver initialized successfully');
        } catch (error) {
            CSLogger.error(`Failed to initialize WebDriver: ${error.message}`);
            throw error;
        }
    }
    
    /**
     * Closes the WebDriver instance.
     * @protected
     */
    protected async closeDriver(): Promise<void> {
        if (this.driver) {
            try {
                CSLogger.info('Closing WebDriver');
                await this.driver.quit();
            } catch (error) {
                CSLogger.error(`Error closing WebDriver: ${error.message}`);
            } finally {
                this.driver = null;
            }
        }
    }
    
    /**
     * Captures a screenshot.
     * 
     * @param name The name of the screenshot
     * @returns Promise resolving to the screenshot file path or null if capture failed
     * @protected
     */
    protected async captureScreenshot(name: string): Promise<string | null> {
        if (!this.driver) {
            CSLogger.warn('Cannot capture screenshot: WebDriver not initialized');
            return null;
        }
        
        try {
            const screenshotPath = await this.screenshotManager.captureScreenshot(
                this.driver,
                this.screenshotDir,
                name
            );
            
            CSLogger.info(`Screenshot captured: ${screenshotPath}`);
            return screenshotPath;
        } catch (error) {
            CSLogger.error(`Failed to capture screenshot: ${error.message}`);
            return null;
        }
    }
    
    /**
     * Cleans up old report files.
     * @protected
     */
    protected async cleanupOldReportFiles(): Promise<void> {
        try {
            const cutoffDate = CSDateUtils.addDays(new Date(), -this.reportRetentionDays);
            
            // Clean up old screenshots
            await CSFileUtils.deleteOldFiles(this.screenshotDir, cutoffDate);
            
            // Clean up old videos
            if (this.recordVideo) {
                await CSFileUtils.deleteOldFiles(this.videoDir, cutoffDate);
            }
            
            // Clean up old reports
            await CSFileUtils.deleteOldFiles(this.reportDir, cutoffDate);
            
            CSLogger.info(`Cleaned up report files older than ${this.reportRetentionDays} days`);
        } catch (error) {
            CSLogger.error(`Failed to clean up old report files: ${error.message}`);
        }
    }
    
    /**
     * Performs an action as a test step.
     * 
     * @param stepName The name of the step
     * @param action The action to perform
     * @param takeScreenshot Whether to take a screenshot after the step
     * @returns Promise resolving to the result of the action
     */
    public async step<T>(stepName: string, action: () => Promise<T>, takeScreenshot: boolean = false): Promise<T> {
        if (!this.driver) {
            throw new DriverNotInitializedException('WebDriver not initialized');
        }
        
        CSLogger.info(`Step: ${stepName}`);
        
        const step = new CSTestStep(stepName);
        step.setStartTime(Date.now());
        
        try {
            // Execute the action
            const result = await action();
            
            // Mark step as passed
            step.setStatus(CSTestStatus.PASSED);
            step.setEndTime(Date.now());
            
            // Capture screenshot if requested
            if ((takeScreenshot || this.captureScreenshotForSteps) && this.driver) {
                try {
                    const screenshotPath = await this.captureScreenshot(`${this.testName}_${stepName.replace(/\s+/g, '_')}`);
                    
                    if (screenshotPath) {
                        const screenshot = new CSScreenshot(screenshotPath);
                        step.addScreenshot(screenshot);
                    }
                } catch (screenshotError) {
                    CSLogger.error(`Failed to capture step screenshot: ${screenshotError.message}`);
                }
            }
            
            // Add step to test result
            if (this.testResult) {
                this.testResult.addStep(step);
            }
            
            return result;
        } catch (error) {
            // Mark step as failed
            step.setStatus(CSTestStatus.FAILED);
            step.setEndTime(Date.now());
            step.setErrorMessage(error.message);
            step.setStackTrace(error.stack || '');
            
            // Capture failure screenshot
            if (this.driver) {
                try {
                    const screenshotPath = await this.captureScreenshot(`${this.testName}_${stepName.replace(/\s+/g, '_')}_FAILED`);
                    
                    if (screenshotPath) {
                        const screenshot = new CSScreenshot(screenshotPath);
                        step.addScreenshot(screenshot);
                    }
                } catch (screenshotError) {
                    CSLogger.error(`Failed to capture failure screenshot: ${screenshotError.message}`);
                }
            }
            
            // Add step to test result
            if (this.testResult) {
                this.testResult.addStep(step);
            }
            
            // Log the error and re-throw
            CSLogger.error(`Step failed: ${stepName}`);
            CSLogger.error(`Error: ${error.message}`);
            throw error;
        }
    }
    
    /**
     * Navigates to a URL.
     * 
     * @param url The URL to navigate to
     * @returns Promise resolving when navigation is complete
     */
    public async navigateTo(url: string): Promise<void> {
        if (!this.driver) {
            throw new DriverNotInitializedException('WebDriver not initialized');
        }
        
        return this.step(`Navigate to ${url}`, async () => {
            await this.driver!.get(url);
        });
    }
    
    /**
     * Creates a CSElement from a WebElement.
     * 
     * @param element The WebElement
     * @returns A new CSElement instance
     */
    public createCSElement(element: WebElement): CSElement {
        return new CSElement(element);
    }
    
    /**
     * Creates a CSElement using a locator.
     * 
     * @param locator The locator to find the element
     * @returns Promise resolving to a new CSElement instance
     */
    public async findElement(locator: any): Promise<CSElement> {
        if (!this.driver) {
            throw new DriverNotInitializedException('WebDriver not initialized');
        }
        
        const element = await this.driver.findElement(locator);
        return this.createCSElement(element);
    }
    
    /**
     * Gets the WebDriver instance.
     * 
     * @returns The WebDriver instance or null if not initialized
     */
    public getDriver(): WebDriver | null {
        return this.driver;
    }
    
    /**
     * Gets the current test name.
     * 
     * @returns The current test name
     */
    public getTestName(): string {
        return this.testName;
    }
    
    /**
     * Gets the current test class name.
     * 
     * @returns The current test class name
     */
    public getTestClassName(): string {
        return this.testClassName;
    }
    
    /**
     * Sets a test attribute.
     * 
     * @param key The attribute key
     * @param value The attribute value
     */
    public setTestAttribute(key: string, value: string): void {
        this.testAttributes.set(key, value);
        
        // Update test metadata if test is already running
        if (this.testResult) {
            this.testResult.getMetadata().setAttribute(key, value);
        }
    }
    
    /**
     * Sets test data.
     * 
     * @param key The data key
     * @param value The data value
     */
    public setTestData(key: string, value: any): void {
        this.testData.set(key, value);
    }
    
    /**
     * Gets test data.
     * 
     * @param key The data key
     * @returns The data value or undefined if not found
     */
    public getTestData<T>(key: string): T | undefined {
        return this.testData.get(key) as T;
    }
    
    /**
     * Logs a message.
     * 
     * @param level The log level
     * @param message The message to log
     */
    public log(level: CSLogLevel, message: string): void {
        switch (level) {
            case CSLogLevel.DEBUG:
                CSLogger.debug(message);
                break;
            case CSLogLevel.INFO:
                CSLogger.info(message);
                break;
            case CSLogLevel.WARN:
                CSLogger.warn(message);
                break;
            case CSLogLevel.ERROR:
                CSLogger.error(message);
                break;
        }
        
        // Add to test result if available
        if (this.testResult) {
            this.testResult.addLog(level, message);
        }
    }
    
    /**
     * Adds a custom hook that runs before the test suite.
     * Override this method to add custom setup logic.
     */
    protected async beforeSuiteHook(): Promise<void> {
        // Override in subclasses
    }
    
    /**
     * Adds a custom hook that runs after the test suite.
     * Override this method to add custom teardown logic.
     */
    protected async afterSuiteHook(): Promise<void> {
        // Override in subclasses
    }
    
    /**
     * Adds a custom hook that runs before each test.
     * Override this method to add custom setup logic.
     */
    protected async beforeTestHook(): Promise<void> {
        // Override in subclasses
    }
    
    /**
     * Adds a custom hook that runs after each test.
     * Override this method to add custom teardown logic.
     */
    protected async afterTestHook(): Promise<void> {
        // Override in subclasses
    }
}



CSBasePage.ts
---------------------

import { WebDriver, By, WebElement, until } from 'selenium-webdriver';
import { CSElement } from '../element/CSElement';
import { CSElementList } from '../element/CSElementList';
import { CSSelect } from '../element/CSSelect';
import { CSForm } from '../element/CSForm';
import { CSTable } from '../element/CSTable';
import { CSWaitFactory } from '../wait/CSWaitFactory';
import { CSVisibilityWait } from '../wait/CSVisibilityWait';
import { CSClickableWait } from '../wait/CSClickableWait';
import { CSPresenceWait } from '../wait/CSPresenceWait';
import { CSInvisibilityWait } from '../wait/CSInvisibilityWait';
import { CSAttributeWait } from '../wait/CSAttributeWait';
import { CSTextWait } from '../wait/CSTextWait';
import { CSLogger } from '../../core/utils/CSLogger';
import { CSConstants } from '../../core/utils/CSConstants';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';
import { InvalidPageException } from '../../core/exceptions/InvalidPageException';
import { PageLoadTimeoutException } from '../../core/exceptions/PageLoadTimeoutException';
import { JavaScriptExecutionException } from '../../core/exceptions/JavaScriptExecutionException';
import { ActionFailedException } from '../../core/exceptions/ActionFailedException';

/**
 * Base class for all page objects.
 * Provides common functionality for interacting with web pages
 * and implements the Page Object Model pattern.
 */
export abstract class CSBasePage {
    /**
     * The WebDriver instance.
     * @protected
     */
    protected driver: WebDriver;
    
    /**
     * The URL of the page.
     * @protected
     */
    protected url: string;
    
    /**
     * The title of the page.
     * @protected
     */
    protected title: string;
    
    /**
     * Selectors for verifying the page is loaded.
     * @protected
     */
    protected pageLoadedSelectors: By[];
    
    /**
     * Default timeout for page loads.
     * @protected
     */
    protected pageLoadTimeout: number;
    
    /**
     * Default timeout for element actions.
     * @protected
     */
    protected actionTimeout: number;
    
    /**
     * Whether to wait for page load after actions.
     * @protected
     */
    protected waitAfterAction: boolean;
    
    /**
     * The parent page (if this is a component or section).
     * @protected
     */
    protected parentPage: CSBasePage | null;
    
    /**
     * The root element for this page or component.
     * @protected
     */
    protected rootElement: WebElement | null;
    
    /**
     * Creates a new instance of CSBasePage.
     * 
     * @param driver The WebDriver instance
     * @param url The URL of the page (optional)
     * @param title The title of the page (optional)
     */
    constructor(driver: WebDriver, url: string = '', title: string = '') {
        this.driver = driver;
        this.url = url;
        this.title = title;
        this.pageLoadedSelectors = [];
        this.pageLoadTimeout = CSConstants.DEFAULT_PAGE_LOAD_TIMEOUT;
        this.actionTimeout = CSConstants.DEFAULT_TIMEOUT;
        this.waitAfterAction = true;
        this.parentPage = null;
        this.rootElement = null;
    }
    
    /**
     * Opens the page by navigating to its URL.
     * 
     * @returns This page instance for method chaining
     * @throws PageLoadTimeoutException if the page doesn't load within the timeout
     */
    public async open(): Promise<this> {
        if (!this.url) {
            throw new InvalidPageException('Cannot open page: URL is not defined');
        }
        
        try {
            CSLogger.info(`Opening page: ${this.url}`);
            await this.driver.get(this.url);
            await this.waitForPageLoad();
            
            return this;
        } catch (error) {
            if (error instanceof PageLoadTimeoutException) {
                throw error;
            }
            
            throw new PageLoadTimeoutException(`Failed to load page at ${this.url}: ${error.message}`, error);
        }
    }
    
    /**
     * Waits for the page to be fully loaded.
     * 
     * @param timeout Optional timeout in milliseconds
     * @returns This page instance for method chaining
     * @throws PageLoadTimeoutException if the page doesn't load within the timeout
     */
    public async waitForPageLoad(timeout?: number): Promise<this> {
        const actualTimeout = timeout || this.pageLoadTimeout;
        
        try {
            CSLogger.debug(`Waiting for page to load (timeout: ${actualTimeout}ms)`);
            
            // Wait for document ready state
            await this.driver.wait(
                async () => {
                    const readyState = await this.driver.executeScript('return document.readyState');
                    return readyState === 'complete';
                },
                actualTimeout,
                'Document ready state did not become complete'
            );
            
            // Wait for AJAX requests to complete (if jQuery is present)
            await this.driver.wait(
                async () => {
                    try {
                        const jQueryActive = await this.driver.executeScript(
                            'return typeof jQuery !== "undefined" ? jQuery.active === 0 : true'
                        );
                        return jQueryActive;
                    } catch (e) {
                        // jQuery not available, consider it ready
                        return true;
                    }
                },
                actualTimeout,
                'jQuery AJAX requests did not complete'
            );
            
            // Wait for Angular to be stable (if present)
            await this.driver.wait(
                async () => {
                    try {
                        const angularStable = await this.driver.executeScript(`
                            if (window.getAllAngularTestabilities) {
                                let testabilities = window.getAllAngularTestabilities();
                                let allStable = testabilities.length > 0;
                                
                                for (let testability of testabilities) {
                                    allStable = allStable && testability.isStable();
                                }
                                
                                return allStable;
                            }
                            
                            // Angular not detected
                            return true;
                        `);
                        return angularStable;
                    } catch (e) {
                        // Angular not available, consider it ready
                        return true;
                    }
                },
                actualTimeout,
                'Angular did not become stable'
            );
            
            // Wait for any custom load indicators to disappear
            try {
                await this.driver.wait(
                    async () => {
                        const spinners = await this.driver.findElements(
                            By.css('.spinner, .loading, .loader, [aria-busy="true"], .progress, .loading-overlay')
                        );
                        
                        if (spinners.length === 0) {
                            return true;
                        }
                        
                        // Check if all spinners are hidden
                        for (const spinner of spinners) {
                            try {
                                const displayed = await spinner.isDisplayed();
                                
                                if (displayed) {
                                    return false;
                                }
                            } catch (e) {
                                // Element is not in DOM anymore, ignore
                            }
                        }
                        
                        return true;
                    },
                    actualTimeout,
                    'Loading indicators did not disappear'
                );
            } catch (e) {
                // Ignore loading indicator errors
                CSLogger.debug(`Failed to wait for loading indicators: ${e.message}`);
            }
            
            // Wait for page loaded selectors if defined
            if (this.pageLoadedSelectors.length > 0) {
                for (const selector of this.pageLoadedSelectors) {
                    try {
                        await this.driver.wait(
                            until.elementLocated(selector),
                            actualTimeout,
                            `Element with selector ${selector} was not found`
                        );
                    } catch (e) {
                        throw new PageLoadTimeoutException(
                            `Failed to locate page ready element: ${e.message}`,
                            e
                        );
                    }
                }
            }
            
            // Wait for any custom page load validation
            try {
                const isValid = await this.isPageLoaded();
                
                if (!isValid) {
                    throw new PageLoadTimeoutException('Custom page validation failed');
                }
            } catch (e) {
                if (e instanceof PageLoadTimeoutException) {
                    throw e;
                }
                
                throw new PageLoadTimeoutException(`Failed to validate page: ${e.message}`, e);
            }
            
            CSLogger.debug('Page loaded successfully');
            return this;
        } catch (error) {
            if (error instanceof PageLoadTimeoutException) {
                throw error;
            }
            
            throw new PageLoadTimeoutException(`Failed to wait for page load: ${error.message}`, error);
        }
    }
    
    /**
     * Custom validation for page loaded state.
     * Override this method to add custom page load validation logic.
     * 
     * @returns Promise resolving to boolean indicating if the page is fully loaded
     */
    protected async isPageLoaded(): Promise<boolean> {
        return true; // Default implementation returns true
    }
    
    /**
     * Verifies that the current page is the expected page.
     * 
     * @returns This page instance for method chaining
     * @throws InvalidPageException if the current page is not the expected page
     */
    public async verifyPage(): Promise<this> {
        try {
            await this.waitForPageLoad();
            
            // Verify title if defined
            if (this.title) {
                const currentTitle = await this.driver.getTitle();
                
                if (!currentTitle.includes(this.title)) {
                    throw new InvalidPageException(
                        `Wrong page title. Expected "${this.title}", got "${currentTitle}"`
                    );
                }
            }
            
            // Verify URL if defined
            if (this.url) {
                const currentUrl = await this.driver.getCurrentUrl();
                
                if (!currentUrl.includes(this.url)) {
                    throw new InvalidPageException(
                        `Wrong page URL. Expected URL to contain "${this.url}", got "${currentUrl}"`
                    );
                }
            }
            
            // Verify page loaded selectors
            for (const selector of this.pageLoadedSelectors) {
                try {
                    await this.driver.findElement(selector);
                } catch (e) {
                    throw new InvalidPageException(
                        `Failed to find expected page element with selector ${selector}`
                    );
                }
            }
            
            // Custom page verification
            const isValid = await this.isValidPage();
            
            if (!isValid) {
                throw new InvalidPageException('Custom page validation failed');
            }
            
            return this;
        } catch (error) {
            if (error instanceof InvalidPageException) {
                throw error;
            }
            
            throw new InvalidPageException(`Failed to verify page: ${error.message}`, error);
        }
    }
    
    /**
     * Custom validation for page verification.
     * Override this method to add custom page verification logic.
     * 
     * @returns Promise resolving to boolean indicating if this is the correct page
     */
    protected async isValidPage(): Promise<boolean> {
        return true; // Default implementation returns true
    }
    
    /**
     * Refreshes the current page.
     * 
     * @returns This page instance for method chaining
     */
    public async refresh(): Promise<this> {
        await this.driver.navigate().refresh();
        await this.waitForPageLoad();
        return this;
    }
    
    /**
     * Gets the current page URL.
     * 
     * @returns Promise resolving to the current page URL
     */
    public async getCurrentUrl(): Promise<string> {
        return await this.driver.getCurrentUrl();
    }
    
    /**
     * Gets the current page title.
     * 
     * @returns Promise resolving to the current page title
     */
    public async getCurrentTitle(): Promise<string> {
        return await this.driver.getTitle();
    }
    
    /**
     * Gets the page source.
     * 
     * @returns Promise resolving to the page source
     */
    public async getPageSource(): Promise<string> {
        return await this.driver.getPageSource();
    }
    
    /**
     * Executes JavaScript on the page.
     * 
     * @param script The script to execute
     * @param args Optional arguments for the script
     * @returns Promise resolving to the script result
     * @throws JavaScriptExecutionException if the script execution fails
     */
    public async executeScript<T>(script: string | Function, ...args: any[]): Promise<T> {
        try {
            return await this.driver.executeScript(script, ...args) as T;
        } catch (error) {
            throw new JavaScriptExecutionException(`Failed to execute script: ${error.message}`, error);
        }
    }
    
    /**
     * Executes asynchronous JavaScript on the page.
     * 
     * @param script The script to execute
     * @param args Optional arguments for the script
     * @returns Promise resolving to the script result
     * @throws JavaScriptExecutionException if the script execution fails
     */
    public async executeAsyncScript<T>(script: string | Function, ...args: any[]): Promise<T> {
        try {
            return await this.driver.executeAsyncScript(script, ...args) as T;
        } catch (error) {
            throw new JavaScriptExecutionException(`Failed to execute async script: ${error.message}`, error);
        }
    }
    
    /**
     * Finds an element on the page.
     * 
     * @param locator The element locator
     * @returns Promise resolving to a CSElement
     * @throws ElementNotFoundException if the element is not found
     */
    public async findElement(locator: By): Promise<CSElement> {
        try {
            const context = this.rootElement || this.driver;
            const element = await context.findElement(locator);
            return new CSElement(element);
        } catch (error) {
            throw new ElementNotFoundException(`Element not found with locator: ${locator}`, error);
        }
    }
    
    /**
     * Finds all elements matching a locator.
     * 
     * @param locator The element locator
     * @returns Promise resolving to a CSElementList
     */
    public async findElements(locator: By): Promise<CSElementList> {
        const context = this.rootElement || this.driver;
        const elements = await context.findElements(locator);
        return new CSElementList(elements);
    }
    
    /**
     * Finds a select element on the page.
     * 
     * @param locator The element locator
     * @param options Optional configuration for the select element
     * @returns Promise resolving to a CSSelect
     * @throws ElementNotFoundException if the element is not found
     */
    public async findSelect(locator: By, options?: any): Promise<CSSelect> {
        try {
            const element = await this.findElement(locator);
            return new CSSelect(element.getWebElement(), options);
        } catch (error) {
            throw new ElementNotFoundException(`Select element not found with locator: ${locator}`, error);
        }
    }
    
    /**
     * Finds a form element on the page.
     * 
     * @param locator The element locator
     * @param options Optional configuration for the form element
     * @returns Promise resolving to a CSForm
     * @throws ElementNotFoundException if the element is not found
     */
    public async findForm(locator: By, options?: any): Promise<CSForm> {
        try {
            const element = await this.findElement(locator);
            return new CSForm(element.getWebElement(), options);
        } catch (error) {
            throw new ElementNotFoundException(`Form element not found with locator: ${locator}`, error);
        }
    }
    
    /**
     * Finds a table element on the page.
     * 
     * @param locator The element locator
     * @param options Optional configuration for the table element
     * @returns Promise resolving to a CSTable
     * @throws ElementNotFoundException if the element is not found
     */
    public async findTable(locator: By, options?: any): Promise<CSTable> {
        try {
            const element = await this.findElement(locator);
            return new CSTable(element.getWebElement(), options);
        } catch (error) {
            throw new ElementNotFoundException(`Table element not found with locator: ${locator}`, error);
        }
    }
    
    /**
     * Waits for an element to be visible.
     * 
     * @param locator The element locator
     * @param timeout Optional timeout in milliseconds
     * @returns Promise resolving to a CSElement
     * @throws ElementNotFoundException if the element is not found or not visible within the timeout
     */
    public async waitForVisible(locator: By, timeout?: number): Promise<CSElement> {
        try {
            const actualTimeout = timeout || this.actionTimeout;
            const element = await this.driver.wait(
                until.elementLocated(locator),
                actualTimeout,
                `Element not found with locator: ${locator}`
            );
            
            await this.driver.wait(
                until.elementIsVisible(element),
                actualTimeout,
                `Element found but not visible with locator: ${locator}`
            );
            
            return new CSElement(element);
        } catch (error) {
            throw new ElementNotFoundException(`Element not visible with locator: ${locator}`, error);
        }
    }
    
    /**
     * Waits for an element to be clickable.
     * 
     * @param locator The element locator
     * @param timeout Optional timeout in milliseconds
     * @returns Promise resolving to a CSElement
     * @throws ElementNotFoundException if the element is not found or not clickable within the timeout
     */
    public async waitForClickable(locator: By, timeout?: number): Promise<CSElement> {
        try {
            const actualTimeout = timeout || this.actionTimeout;
            const element = await this.driver.wait(
                until.elementLocated(locator),
                actualTimeout,
                `Element not found with locator: ${locator}`
            );
            
            await CSWaitFactory.forElement(element)
                .untilClickable()
                .withTimeout(actualTimeout)
                .withMessage(`Element found but not clickable with locator: ${locator}`)
                .wait();
            
            return new CSElement(element);
        } catch (error) {
            throw new ElementNotFoundException(`Element not clickable with locator: ${locator}`, error);
        }
    }
    
    /**
     * Waits for an element to be present in the DOM.
     * 
     * @param locator The element locator
     * @param timeout Optional timeout in milliseconds
     * @returns Promise resolving to a CSElement
     * @throws ElementNotFoundException if the element is not found within the timeout
     */
    public async waitForPresent(locator: By, timeout?: number): Promise<CSElement> {
        try {
            const actualTimeout = timeout || this.actionTimeout;
            const element = await this.driver.wait(
                until.elementLocated(locator),
                actualTimeout,
                `Element not found with locator: ${locator}`
            );
            
            return new CSElement(element);
        } catch (error) {
            throw new ElementNotFoundException(`Element not present with locator: ${locator}`, error);
        }
    }
    
    /**
     * Waits for an element to be invisible or not present.
     * 
     * @param locator The element locator
     * @param timeout Optional timeout in milliseconds
     * @returns Promise resolving when the element is invisible or not present
     */
    public async waitForNotVisible(locator: By, timeout?: number): Promise<void> {
        const actualTimeout = timeout || this.actionTimeout;
        
        try {
            await this.driver.wait(
                async () => {
                    try {
                        const elements = await this.driver.findElements(locator);
                        
                        if (elements.length === 0) {
                            return true;
                        }
                        
                        const isVisible = await elements[0].isDisplayed();
                        return !isVisible;
                    } catch (e) {
                        // Element not in DOM or stale
                        return true;
                    }
                },
                actualTimeout,
                `Element still visible with locator: ${locator}`
            );
        } catch (error) {
            throw new ElementNotFoundException(`Element still visible with locator: ${locator}`, error);
        }
    }
    
    /**
     * Waits for text to be present in an element.
     * 
     * @param locator The element locator
     * @param text The text to wait for
     * @param timeout Optional timeout in milliseconds
     * @returns Promise resolving to a CSElement
     * @throws ElementNotFoundException if the element is not found or doesn't contain the text within the timeout
     */
    public async waitForText(locator: By, text: string, timeout?: number): Promise<CSElement> {
        try {
            const actualTimeout = timeout || this.actionTimeout;
            const element = await this.driver.wait(
                until.elementLocated(locator),
                actualTimeout,
                `Element not found with locator: ${locator}`
            );
            
            await CSWaitFactory.forElement(element)
                .untilTextContains(text)
                .withTimeout(actualTimeout)
                .withMessage(`Element text doesn't contain "${text}" with locator: ${locator}`)
                .wait();
            
            return new CSElement(element);
        } catch (error) {
            throw new ElementNotFoundException(`Element text doesn't contain "${text}" with locator: ${locator}`, error);
        }
    }
    
    /**
     * Waits for an attribute to have a specific value.
     * 
     * @param locator The element locator
     * @param attribute The attribute name
     * @param value The expected attribute value
     * @param timeout Optional timeout in milliseconds
     * @returns Promise resolving to a CSElement
     * @throws ElementNotFoundException if the element is not found or doesn't have the attribute value within the timeout
     */
    public async waitForAttribute(locator: By, attribute: string, value: string, timeout?: number): Promise<CSElement> {
        try {
            const actualTimeout = timeout || this.actionTimeout;
            const element = await this.driver.wait(
                until.elementLocated(locator),
                actualTimeout,
                `Element not found with locator: ${locator}`
            );
            
            await CSWaitFactory.forElement(element)
                .untilAttributeEquals(attribute, value)
                .withTimeout(actualTimeout)
                .withMessage(`Element attribute ${attribute} doesn't have value "${value}" with locator: ${locator}`)
                .wait();
            
            return new CSElement(element);
        } catch (error) {
            throw new ElementNotFoundException(
                `Element attribute ${attribute} doesn't have value "${value}" with locator: ${locator}`,
                error
            );
        }
    }
    
    /**
     * Waits for a condition to be satisfied.
     * 
     * @param condition The condition to wait for
     * @param message Optional error message if the condition is not satisfied within the timeout
     * @param timeout Optional timeout in milliseconds
     * @returns Promise resolving when the condition is satisfied
     */
    public async waitFor(
        condition: () => Promise<boolean> | boolean,
        message?: string,
        timeout?: number
    ): Promise<void> {
        const actualTimeout = timeout || this.actionTimeout;
        const actualMessage = message || 'Condition not satisfied within timeout';
        
        await this.driver.wait(condition, actualTimeout, actualMessage);
    }
    
    /**
     * Takes a screenshot.
     * 
     * @returns Promise resolving to base64-encoded string of the screenshot
     */
    public async takeScreenshot(): Promise<string> {
        return await this.driver.takeScreenshot();
    }
    
    /**
     * Gets the WebDriver instance associated with this page.
     * 
     * @returns The WebDriver instance
     */
    public getDriver(): WebDriver {
        return this.driver;
    }
    
    /**
     * Sets the URL of the page.
     * 
     * @param url The URL of the page
     * @returns This page instance for method chaining
     */
    public setUrl(url: string): this {
        this.url = url;
        return this;
    }
    
    /**
     * Gets the URL of the page.
     * 
     * @returns The URL of the page
     */
    public getUrl(): string {
        return this.url;
    }
    
    /**
     * Sets the title of the page.
     * 
     * @param title The title of the page
     * @returns This page instance for method chaining
     */
    public setTitle(title: string): this {
        this.title = title;
        return this;
    }
    
    /**
     * Gets the title of the page.
     * 
     * @returns The title of the page
     */
    public getTitle(): string {
        return this.title;
    }
    
    /**
     * Adds a selector that indicates the page is loaded.
     * 
     * @param selector The selector to add
     * @returns This page instance for method chaining
     */
    public addPageLoadedSelector(selector: By): this {
        this.pageLoadedSelectors.push(selector);
        return this;
    }
    
    /**
     * Sets selectors that indicate the page is loaded.
     * 
     * @param selectors The selectors to set
     * @returns This page instance for method chaining
     */
    public setPageLoadedSelectors(selectors: By[]): this {
        this.pageLoadedSelectors = selectors;
        return this;
    }
    
    /**
     * Gets selectors that indicate the page is loaded.
     * 
     * @returns The page loaded selectors
     */
    public getPageLoadedSelectors(): By[] {
        return this.pageLoadedSelectors;
    }
    
    /**
     * Sets the page load timeout.
     * 
     * @param timeout The timeout in milliseconds
     * @returns This page instance for method chaining
     */
    public setPageLoadTimeout(timeout: number): this {
        this.pageLoadTimeout = timeout;
        return this;
    }
    
    /**
     * Gets the page load timeout.
     * 
     * @returns The page load timeout in milliseconds
     */
    public getPageLoadTimeout(): number {
        return this.pageLoadTimeout;
    }
    
    /**
     * Sets the action timeout.
     * 
     * @param timeout The timeout in milliseconds
     * @returns This page instance for method chaining
     */
    public setActionTimeout(timeout: number): this {
        this.actionTimeout = timeout;
        return this;
    }
    
    /**
     * Gets the action timeout.
     * 
     * @returns The action timeout in milliseconds
     */
    public getActionTimeout(): number {
        return this.actionTimeout;
    }
    
    /**
     * Sets whether to wait for page load after actions.
     * 
     * @param wait Whether to wait for page load after actions
     * @returns This page instance for method chaining
     */
    public setWaitAfterAction(wait: boolean): this {
        this.waitAfterAction = wait;
        return this;
    }
    
    /**
     * Gets whether to wait for page load after actions.
     * 
     * @returns Whether to wait for page load after actions
     */
    public getWaitAfterAction(): boolean {
        return this.waitAfterAction;
    }
    
    /**
     * Sets the parent page.
     * 
     * @param page The parent page
     * @returns This page instance for method chaining
     */
    public setParentPage(page: CSBasePage | null): this {
        this.parentPage = page;
        return this;
    }
    
    /**
     * Gets the parent page.
     * 
     * @returns The parent page or null if none
     */
    public getParentPage(): CSBasePage | null {
        return this.parentPage;
    }
    
    /**
     * Sets the root element.
     * 
     * @param element The root element
     * @returns This page instance for method chaining
     */
    public setRootElement(element: WebElement | null): this {
        this.rootElement = element;
        return this;
    }
    
    /**
     * Gets the root element.
     * 
     * @returns The root element or null if none
     */
    public getRootElement(): WebElement | null {
        return this.rootElement;
    }
    
    /**
     * Scrolls to an element.
     * 
     * @param element The element to scroll to
     * @param offset Optional offset from the top of the element (in pixels)
     * @returns Promise resolving when scrolling is complete
     */
    public async scrollToElement(element: WebElement | CSElement, offset: number = 0): Promise<void> {
        const webElement = element instanceof CSElement ? element.getWebElement() : element;
        
        await this.executeScript<void>(
            'arguments[0].scrollIntoView(true); window.scrollBy(0, arguments[1]);',
            webElement,
            offset
        );
    }
    
    /**
     * Scrolls the page by a specified amount.
     * 
     * @param x The number of pixels to scroll horizontally
     * @param y The number of pixels to scroll vertically
     * @returns Promise resolving when scrolling is complete
     */
    public async scrollBy(x: number, y: number): Promise<void> {
        await this.executeScript<void>('window.scrollBy(arguments[0], arguments[1]);', x, y);
    }
    
    /**
     * Scrolls the page to specific coordinates.
     * 
     * @param x The x-coordinate to scroll to
     * @param y The y-coordinate to scroll to
     * @returns Promise resolving when scrolling is complete
     */
    public async scrollTo(x: number, y: number): Promise<void> {
        await this.executeScript<void>('window.scrollTo(arguments[0], arguments[1]);', x, y);
    }
    
    /**
     * Scrolls to the top of the page.
     * 
     * @returns Promise resolving when scrolling is complete
     */
    public async scrollToTop(): Promise<void> {
        await this.executeScript<void>('window.scrollTo(0, 0);');
    }
    
    /**
     * Scrolls to the bottom of the page.
     * 
     * @returns Promise resolving when scrolling is complete
     */
    public async scrollToBottom(): Promise<void> {
        await this.executeScript<void>(
            'window.scrollTo(0, document.body.scrollHeight || document.documentElement.scrollHeight);'
        );
    }
    
    /**
     * Accepts the currently displayed alert dialog.
     * 
     * @returns Promise resolving when the alert is accepted
     */
    public async acceptAlert(): Promise<void> {
        try {
            const alert = await this.driver.switchTo().alert();
            await alert.accept();
        } catch (error) {
            throw new ActionFailedException(`Failed to accept alert: ${error.message}`, error);
        }
    }
    
    /**
     * Dismisses the currently displayed alert dialog.
     * 
     * @returns Promise resolving when the alert is dismissed
     */
    public async dismissAlert(): Promise<void> {
        try {
            const alert = await this.driver.switchTo().alert();
            await alert.dismiss();
        } catch (error) {
            throw new ActionFailedException(`Failed to dismiss alert: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the text of the currently displayed alert dialog.
     * 
     * @returns Promise resolving to the alert text
     */
    public async getAlertText(): Promise<string> {
        try {
            const alert = await this.driver.switchTo().alert();
            return await alert.getText();
        } catch (error) {
            throw new ActionFailedException(`Failed to get alert text: ${error.message}`, error);
        }
    }
    
   /**
     * Sends text to the currently displayed prompt dialog.
     * 
     * @param text The text to send
     * @returns Promise resolving when the text is sent
     */
    public async sendAlertText(text: string): Promise<void> {
        try {
            const alert = await this.driver.switchTo().alert();
            await alert.sendKeys(text);
        } catch (error) {
            throw new ActionFailedException(`Failed to send alert text: ${error.message}`, error);
        }
    }
    
    /**
     * Switches to a frame by index.
     * 
     * @param index The zero-based index of the frame
     * @returns This page instance for method chaining
     */
    public async switchToFrame(index: number): Promise<this> {
        try {
            await this.driver.switchTo().frame(index);
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to switch to frame with index ${index}: ${error.message}`, error);
        }
    }
    
    /**
     * Switches to a frame by locator.
     * 
     * @param locator The locator of the frame element
     * @returns This page instance for method chaining
     */
    public async switchToFrameByLocator(locator: By): Promise<this> {
        try {
            const frameElement = await this.driver.findElement(locator);
            await this.driver.switchTo().frame(frameElement);
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to switch to frame with locator ${locator}: ${error.message}`, error);
        }
    }
    
    /**
     * Switches to a frame by name or ID.
     * 
     * @param nameOrId The name or ID of the frame
     * @returns This page instance for method chaining
     */
    public async switchToFrameByNameOrId(nameOrId: string): Promise<this> {
        try {
            await this.driver.switchTo().frame(nameOrId);
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to switch to frame with name or ID ${nameOrId}: ${error.message}`, error);
        }
    }
    
    /**
     * Switches to the parent frame.
     * 
     * @returns This page instance for method chaining
     */
    public async switchToParentFrame(): Promise<this> {
        try {
            await this.driver.switchTo().parentFrame();
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to switch to parent frame: ${error.message}`, error);
        }
    }
    
    /**
     * Switches to the default content (top-level document).
     * 
     * @returns This page instance for method chaining
     */
    public async switchToDefaultContent(): Promise<this> {
        try {
            await this.driver.switchTo().defaultContent();
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to switch to default content: ${error.message}`, error);
        }
    }
    
    /**
     * Switches to a window by handle.
     * 
     * @param handle The window handle
     * @returns This page instance for method chaining
     */
    public async switchToWindow(handle: string): Promise<this> {
        try {
            await this.driver.switchTo().window(handle);
            await this.waitForPageLoad();
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to switch to window with handle ${handle}: ${error.message}`, error);
        }
    }
    
    /**
     * Switches to a window by matching part of the URL.
     * 
     * @param urlPart The URL part to match
     * @returns This page instance for method chaining
     * @throws ActionFailedException if no window matches the URL part
     */
    public async switchToWindowByUrl(urlPart: string): Promise<this> {
        try {
            const currentHandle = await this.driver.getWindowHandle();
            const handles = await this.driver.getAllWindowHandles();
            
            for (const handle of handles) {
                // Skip the current window handle
                if (handle === currentHandle) {
                    continue;
                }
                
                // Switch to the window
                await this.driver.switchTo().window(handle);
                
                // Check the URL
                const url = await this.driver.getCurrentUrl();
                
                if (url.includes(urlPart)) {
                    // Found the window
                    await this.waitForPageLoad();
                    return this;
                }
            }
            
            // If we get here, no window matched
            // Switch back to the original window
            await this.driver.switchTo().window(currentHandle);
            
            throw new ActionFailedException(`No window found with URL containing ${urlPart}`);
        } catch (error) {
            throw new ActionFailedException(`Failed to switch to window with URL containing ${urlPart}: ${error.message}`, error);
        }
    }
    
    /**
     * Switches to a window by matching the title.
     * 
     * @param titlePart The title part to match
     * @returns This page instance for method chaining
     * @throws ActionFailedException if no window matches the title
     */
    public async switchToWindowByTitle(titlePart: string): Promise<this> {
        try {
            const currentHandle = await this.driver.getWindowHandle();
            const handles = await this.driver.getAllWindowHandles();
            
            for (const handle of handles) {
                // Skip the current window handle
                if (handle === currentHandle) {
                    continue;
                }
                
                // Switch to the window
                await this.driver.switchTo().window(handle);
                
                // Check the title
                const title = await this.driver.getTitle();
                
                if (title.includes(titlePart)) {
                    // Found the window
                    await this.waitForPageLoad();
                    return this;
                }
            }
            
            // If we get here, no window matched
            // Switch back to the original window
            await this.driver.switchTo().window(currentHandle);
            
            throw new ActionFailedException(`No window found with title containing ${titlePart}`);
        } catch (error) {
            throw new ActionFailedException(`Failed to switch to window with title containing ${titlePart}: ${error.message}`, error);
        }
    }
    
    /**
     * Closes the current window.
     * 
     * @returns This page instance for method chaining
     */
    public async closeWindow(): Promise<this> {
        try {
            await this.driver.close();
            
            // Switch to the first available window
            const handles = await this.driver.getAllWindowHandles();
            
            if (handles.length > 0) {
                await this.driver.switchTo().window(handles[0]);
                await this.waitForPageLoad();
            }
            
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to close window: ${error.message}`, error);
        }
    }
    
    /**
     * Gets all window handles.
     * 
     * @returns Promise resolving to an array of window handles
     */
    public async getWindowHandles(): Promise<string[]> {
        try {
            return await this.driver.getAllWindowHandles();
        } catch (error) {
            throw new ActionFailedException(`Failed to get window handles: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the current window handle.
     * 
     * @returns Promise resolving to the current window handle
     */
    public async getWindowHandle(): Promise<string> {
        try {
            return await this.driver.getWindowHandle();
        } catch (error) {
            throw new ActionFailedException(`Failed to get current window handle: ${error.message}`, error);
        }
    }
    
    /**
     * Maximizes the current window.
     * 
     * @returns This page instance for method chaining
     */
    public async maximizeWindow(): Promise<this> {
        try {
            await this.driver.manage().window().maximize();
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to maximize window: ${error.message}`, error);
        }
    }
    
    /**
     * Sets the size of the current window.
     * 
     * @param width The width in pixels
     * @param height The height in pixels
     * @returns This page instance for method chaining
     */
    public async setWindowSize(width: number, height: number): Promise<this> {
        try {
            await this.driver.manage().window().setRect({ width, height });
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to set window size: ${error.message}`, error);
        }
    }
    
    /**
     * Sets the position of the current window.
     * 
     * @param x The x-coordinate
     * @param y The y-coordinate
     * @returns This page instance for method chaining
     */
    public async setWindowPosition(x: number, y: number): Promise<this> {
        try {
            await this.driver.manage().window().setRect({ x, y });
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to set window position: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the size of the current window.
     * 
     * @returns Promise resolving to an object with width and height properties
     */
    public async getWindowSize(): Promise<{ width: number; height: number }> {
        try {
            const rect = await this.driver.manage().window().getRect();
            return { width: rect.width, height: rect.height };
        } catch (error) {
            throw new ActionFailedException(`Failed to get window size: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the position of the current window.
     * 
     * @returns Promise resolving to an object with x and y properties
     */
    public async getWindowPosition(): Promise<{ x: number; y: number }> {
        try {
            const rect = await this.driver.manage().window().getRect();
            return { x: rect.x, y: rect.y };
        } catch (error) {
            throw new ActionFailedException(`Failed to get window position: ${error.message}`, error);
        }
    }
    
    /**
     * Navigates back in the browser history.
     * 
     * @returns This page instance for method chaining
     */
    public async back(): Promise<this> {
        try {
            await this.driver.navigate().back();
            
            if (this.waitAfterAction) {
                await this.waitForPageLoad();
            }
            
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to navigate back: ${error.message}`, error);
        }
    }
    
    /**
     * Navigates forward in the browser history.
     * 
     * @returns This page instance for method chaining
     */
    public async forward(): Promise<this> {
        try {
            await this.driver.navigate().forward();
            
            if (this.waitAfterAction) {
                await this.waitForPageLoad();
            }
            
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to navigate forward: ${error.message}`, error);
        }
    }
    
    /**
     * Deletes all cookies.
     * 
     * @returns This page instance for method chaining
     */
    public async deleteAllCookies(): Promise<this> {
        try {
            await this.driver.manage().deleteAllCookies();
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to delete all cookies: ${error.message}`, error);
        }
    }
    
    /**
     * Deletes a specific cookie.
     * 
     * @param name The name of the cookie to delete
     * @returns This page instance for method chaining
     */
    public async deleteCookie(name: string): Promise<this> {
        try {
            await this.driver.manage().deleteCookie(name);
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to delete cookie ${name}: ${error.message}`, error);
        }
    }
    
    /**
     * Gets all cookies.
     * 
     * @returns Promise resolving to an array of cookies
     */
    public async getAllCookies(): Promise<any[]> {
        try {
            return await this.driver.manage().getCookies();
        } catch (error) {
            throw new ActionFailedException(`Failed to get all cookies: ${error.message}`, error);
        }
    }
    
    /**
     * Gets a specific cookie.
     * 
     * @param name The name of the cookie to get
     * @returns Promise resolving to the cookie or null if not found
     */
    public async getCookie(name: string): Promise<any | null> {
        try {
            return await this.driver.manage().getCookie(name);
        } catch (error) {
            throw new ActionFailedException(`Failed to get cookie ${name}: ${error.message}`, error);
        }
    }
    
    /**
     * Adds a cookie.
     * 
     * @param cookie The cookie to add
     * @returns This page instance for method chaining
     */
    public async addCookie(cookie: any): Promise<this> {
        try {
            await this.driver.manage().addCookie(cookie);
            return this;
        } catch (error) {
            throw new ActionFailedException(`Failed to add cookie: ${error.message}`, error);
        }
    }
    
    /**
     * Waits for download to complete by monitoring a specific download directory.
     * 
     * @param downloadDir The download directory to monitor
     * @param fileExtension The file extension to wait for
     * @param timeout Optional timeout in milliseconds
     * @returns Promise resolving to the path of the downloaded file
     * @throws ActionFailedException if the download does not complete within the timeout
     */
    public async waitForDownload(downloadDir: string, fileExtension: string, timeout?: number): Promise<string> {
        const actualTimeout = timeout || this.actionTimeout;
        const pollingInterval = 500; // 0.5 seconds
        const startTime = Date.now();
        let downloadedFileName = '';
        
        try {
            await this.waitFor(
                async () => {
                    // Check if download is in progress (look for .crdownload, .part, or partial files)
                    const inProgressFiles = await this.executeScript<string[]>(`
                        return (function() {
                            const fs = require('fs');
                            const path = require('path');
                            const dir = arguments[0];
                            
                            try {
                                return fs.readdirSync(dir).filter(file => 
                                    file.endsWith('.crdownload') || 
                                    file.endsWith('.part') || 
                                    file.endsWith('.download')
                                );
                            } catch (e) {
                                return [];
                            }
                        })();
                    `, downloadDir);
                    
                    if (inProgressFiles.length > 0) {
                        return false; // Download still in progress
                    }
                    
                    // Check for completed downloads
                    const files = await this.executeScript<string[]>(`
                        return (function() {
                            const fs = require('fs');
                            const path = require('path');
                            const dir = arguments[0];
                            const ext = arguments[1];
                            
                            try {
                                return fs.readdirSync(dir).filter(file => 
                                    file.endsWith(ext) && 
                                    fs.statSync(path.join(dir, file)).size > 0
                                );
                            } catch (e) {
                                return [];
                            }
                        })();
                    `, downloadDir, fileExtension);
                    
                    if (files.length > 0) {
                        // Sort files by creation time (descending)
                        const fileStats = await this.executeScript<Array<{ name: string; time: number }>>(`
                            return (function() {
                                const fs = require('fs');
                                const path = require('path');
                                const dir = arguments[0];
                                const files = arguments[1];
                                
                                return files.map(file => {
                                    const filePath = path.join(dir, file);
                                    try {
                                        const stats = fs.statSync(filePath);
                                        return {
                                            name: file,
                                            time: stats.mtimeMs
                                        };
                                    } catch (e) {
                                        return {
                                            name: file,
                                            time: 0
                                        };
                                    }
                                }).sort((a, b) => b.time - a.time);
                            })();
                        `, downloadDir, files);
                        
                        if (fileStats.length > 0) {
                            downloadedFileName = fileStats[0].name;
                            return true;
                        }
                    }
                    
                    return false;
                },
                `Download did not complete within ${actualTimeout}ms`,
                actualTimeout
            );
            
            return downloadedFileName;
        } catch (error) {
            throw new ActionFailedException(`Failed to wait for download: ${error.message}`, error);
        }
    }
    
    /**
     * Creates a new instance of a page object.
     * 
     * @template T The type of the page object
     * @param pageClass The page class constructor
     * @param args Optional arguments for the page constructor
     * @returns New instance of the page object
     */
    public createPage<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T,
        ...args: any[]
    ): T {
        const page = new pageClass(this.driver, ...args);
        return page;
    }
    
    /**
     * Navigates to a page and creates a page object for it.
     * 
     * @template T The type of the page object
     * @param pageClass The page class constructor
     * @param args Optional arguments for the page constructor
     * @returns Promise resolving to a new instance of the page object
     */
    public async navigateToPage<T extends CSBasePage>(
        pageClass: new (driver: WebDriver, ...args: any[]) => T,
        ...args: any[]
    ): Promise<T> {
        const page = this.createPage(pageClass, ...args);
        await page.open();
        return page;
    }
    
    /**
     * Creates a component within the page.
     * 
     * @template T The type of the component
     * @param componentClass The component class constructor
     * @param rootLocator The locator for the component's root element
     * @param args Optional arguments for the component constructor
     * @returns Promise resolving to a new instance of the component
     * @throws ElementNotFoundException if the component's root element is not found
     */
    public async createComponent<T extends CSBasePage>(
        componentClass: new (driver: WebDriver, rootElement: WebElement, ...args: any[]) => T,
        rootLocator: By,
        ...args: any[]
    ): Promise<T> {
        try {
            const rootElement = await this.driver.findElement(rootLocator);
            const component = new componentClass(this.driver, rootElement, ...args);
            
            // Set this page as the parent of the component
            component.setParentPage(this);
            
            // Set the root element for the component
            component.setRootElement(rootElement);
            
            return component;
        } catch (error) {
            throw new ElementNotFoundException(`Failed to create component: Component root element not found with locator ${rootLocator}`, error);
        }
    }
    
    /**
     * Waits for a new window to open.
     * 
     * @param currentHandles The current window handles before the new window opens
     * @param timeout Optional timeout in milliseconds
     * @returns Promise resolving to the handle of the new window
     * @throws ActionFailedException if no new window opens within the timeout
     */
    public async waitForNewWindow(currentHandles: string[], timeout?: number): Promise<string> {
        const actualTimeout = timeout || this.actionTimeout;
        
        try {
            let newWindowHandle: string | null = null;
            
            await this.waitFor(
                async () => {
                    const handles = await this.driver.getAllWindowHandles();
                    
                    if (handles.length > currentHandles.length) {
                        // Find the new handle
                        for (const handle of handles) {
                            if (!currentHandles.includes(handle)) {
                                newWindowHandle = handle;
                                return true;
                            }
                        }
                    }
                    
                    return false;
                },
                `No new window opened within ${actualTimeout}ms`,
                actualTimeout
            );
            
            if (!newWindowHandle) {
                throw new ActionFailedException('Failed to identify new window handle');
            }
            
            return newWindowHandle;
        } catch (error) {
            throw new ActionFailedException(`Failed to wait for new window: ${error.message}`, error);
        }
    }
    
    /**
     * Waits for an element to be visible, then clicks it.
     * 
     * @param locator The element locator
     * @param timeout Optional timeout in milliseconds
     * @returns This page instance for method chaining
     * @throws ElementNotFoundException if the element is not found or not clickable within the timeout
     */
    public async clickWhenVisible(locator: By, timeout?: number): Promise<this> {
        try {
            const element = await this.waitForVisible(locator, timeout);
            await element.click();
            
            if (this.waitAfterAction) {
                await this.waitForPageLoad();
            }
            
            return this;
        } catch (error) {
            throw new ElementNotFoundException(`Failed to click element: ${error.message}`, error);
        }
    }
    
    /**
     * Waits for an element to be clickable, then clicks it.
     * 
     * @param locator The element locator
     * @param timeout Optional timeout in milliseconds
     * @returns This page instance for method chaining
     * @throws ElementNotFoundException if the element is not found or not clickable within the timeout
     */
    public async clickWhenClickable(locator: By, timeout?: number): Promise<this> {
        try {
            const element = await this.waitForClickable(locator, timeout);
            await element.click();
            
            if (this.waitAfterAction) {
                await this.waitForPageLoad();
            }
            
            return this;
        } catch (error) {
            throw new ElementNotFoundException(`Failed to click element: ${error.message}`, error);
        }
    }
    
    /**
     * Waits for an element to be visible, then enters text into it.
     * 
     * @param locator The element locator
     * @param text The text to enter
     * @param clear Whether to clear the field before entering text
     * @param timeout Optional timeout in milliseconds
     * @returns This page instance for method chaining
     * @throws ElementNotFoundException if the element is not found or not visible within the timeout
     */
    public async enterTextWhenVisible(locator: By, text: string, clear: boolean = true, timeout?: number): Promise<this> {
        try {
            const element = await this.waitForVisible(locator, timeout);
            
            if (clear) {
                await element.clear();
            }
            
            await element.sendKeys(text);
            
            return this;
        } catch (error) {
            throw new ElementNotFoundException(`Failed to enter text: ${error.message}`, error);
        }
    }
    
    /**
     * Checks if an element is present in the DOM.
     * 
     * @param locator The element locator
     * @returns Promise resolving to boolean indicating whether the element is present
     */
    public async isElementPresent(locator: By): Promise<boolean> {
        try {
            const elements = await this.driver.findElements(locator);
            return elements.length > 0;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Checks if an element is visible.
     * 
     * @param locator The element locator
     * @returns Promise resolving to boolean indicating whether the element is visible
     */
    public async isElementVisible(locator: By): Promise<boolean> {
        try {
            const element = await this.driver.findElement(locator);
            return await element.isDisplayed();
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Checks if an element is enabled.
     * 
     * @param locator The element locator
     * @returns Promise resolving to boolean indicating whether the element is enabled
     */
    public async isElementEnabled(locator: By): Promise<boolean> {
        try {
            const element = await this.driver.findElement(locator);
            return await element.isEnabled();
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Checks if an element is selected.
     * 
     * @param locator The element locator
     * @returns Promise resolving to boolean indicating whether the element is selected
     */
    public async isElementSelected(locator: By): Promise<boolean> {
        try {
            const element = await this.driver.findElement(locator);
            return await element.isSelected();
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Gets the text of an element.
     * 
     * @param locator The element locator
     * @returns Promise resolving to the element text
     * @throws ElementNotFoundException if the element is not found
     */
    public async getElementText(locator: By): Promise<string> {
        try {
            const element = await this.driver.findElement(locator);
            return await element.getText();
        } catch (error) {
            throw new ElementNotFoundException(`Failed to get element text: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the value of an element's attribute.
     * 
     * @param locator The element locator
     * @param attribute The attribute name
     * @returns Promise resolving to the attribute value
     * @throws ElementNotFoundException if the element is not found
     */
    public async getElementAttribute(locator: By, attribute: string): Promise<string | null> {
        try {
            const element = await this.driver.findElement(locator);
            return await element.getAttribute(attribute);
        } catch (error) {
            throw new ElementNotFoundException(`Failed to get element attribute: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the value of an element's CSS property.
     * 
     * @param locator The element locator
     * @param property The CSS property name
     * @returns Promise resolving to the CSS property value
     * @throws ElementNotFoundException if the element is not found
     */
    public async getElementCssValue(locator: By, property: string): Promise<string> {
        try {
            const element = await this.driver.findElement(locator);
            return await element.getCssValue(property);
        } catch (error) {
            throw new ElementNotFoundException(`Failed to get element CSS value: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the location of an element.
     * 
     * @param locator The element locator
     * @returns Promise resolving to the element location
     * @throws ElementNotFoundException if the element is not found
     */
    public async getElementLocation(locator: By): Promise<{ x: number; y: number }> {
        try {
            const element = await this.driver.findElement(locator);
            const rect = await element.getRect();
            return { x: rect.x, y: rect.y };
        } catch (error) {
            throw new ElementNotFoundException(`Failed to get element location: ${error.message}`, error);
        }
    }
    
    /**
     * Gets the size of an element.
     * 
     * @param locator The element locator
     * @returns Promise resolving to the element size
     * @throws ElementNotFoundException if the element is not found
     */
    public async getElementSize(locator: By): Promise<{ width: number; height: number }> {
        try {
            const element = await this.driver.findElement(locator);
            const rect = await element.getRect();
            return { width: rect.width, height: rect.height };
        } catch (error) {
            throw new ElementNotFoundException(`Failed to get element size: ${error.message}`, error);
        }
    }
    
    /**
     * Takes a screenshot of a specific element.
     * 
     * @param locator The element locator
     * @returns Promise resolving to base64-encoded string of the screenshot
     * @throws ElementNotFoundException if the element is not found
     */
    public async takeElementScreenshot(locator: By): Promise<string> {
        try {
            const element = await this.driver.findElement(locator);
            return await element.takeScreenshot();
        } catch (error) {
            throw new ElementNotFoundException(`Failed to take element screenshot: ${error.message}`, error);
        }
    }
    
    /**
     * Hovers over an element.
     * 
     * @param locator The element locator
     * @returns This page instance for method chaining
     * @throws ElementNotFoundException if the element is not found
     */
    public async hoverElement(locator: By): Promise<this> {
        try {
            const element = await this.driver.findElement(locator);
            
            const actions = this.driver.actions({ async: true });
            await actions.move({ origin: element }).perform();
            
            return this;
        } catch (error) {
            throw new ElementNotFoundException(`Failed to hover element: ${error.message}`, error);
        }
    }
    
    /**
     * Performs a drag-and-drop operation.
     * 
     * @param sourceLocator The source element locator
     * @param targetLocator The target element locator
     * @returns This page instance for method chaining
     * @throws ElementNotFoundException if any element is not found
     */
    public async dragAndDrop(sourceLocator: By, targetLocator: By): Promise<this> {
        try {
            const sourceElement = await this.driver.findElement(sourceLocator);
            const targetElement = await this.driver.findElement(targetLocator);
            
            const actions = this.driver.actions({ async: true });
            await actions
                .dragAndDrop(sourceElement, targetElement)
                .perform();
            
            return this;
        } catch (error) {
            throw new ElementNotFoundException(`Failed to perform drag and drop: ${error.message}`, error);
        }
    }
    
    /**
     * Performs a drag-and-drop operation to a specific offset.
     * 
     * @param sourceLocator The source element locator
     * @param xOffset The x-offset in pixels
     * @param yOffset The y-offset in pixels
     * @returns This page instance for method chaining
     * @throws ElementNotFoundException if the source element is not found
     */
    public async dragAndDropToOffset(sourceLocator: By, xOffset: number, yOffset: number): Promise<this> {
        try {
            const sourceElement = await this.driver.findElement(sourceLocator);
            
            const actions = this.driver.actions({ async: true });
            await actions
                .dragAndDrop(sourceElement, { x: xOffset, y: yOffset })
                .perform();
            
            return this;
        } catch (error) {
            throw new ElementNotFoundException(`Failed to perform drag and drop to offset: ${error.message}`, error);
        }
    }
    
    /**
     * Performs a right-click on an element.
     * 
     * @param locator The element locator
     * @returns This page instance for method chaining
     * @throws ElementNotFoundException if the element is not found
     */
    public async rightClickElement(locator: By): Promise<this> {
        try {
            const element = await this.driver.findElement(locator);
            
            const actions = this.driver.actions({ async: true });
            await actions
                .contextClick(element)
                .perform();
            
            return this;
        } catch (error) {
            throw new ElementNotFoundException(`Failed to right-click element: ${error.message}`, error);
        }
    }
    
    /**
     * Performs a double-click on an element.
     * 
     * @param locator The element locator
     * @returns This page instance for method chaining
     * @throws ElementNotFoundException if the element is not found
     */
    public async doubleClickElement(locator: By): Promise<this> {
        try {
            const element = await this.driver.findElement(locator);
            
            const actions = this.driver.actions({ async: true });
            await actions
                .doubleClick(element)
                .perform();
            
            return this;
        } catch (error) {
            throw new ElementNotFoundException(`Failed to double-click element: ${error.message}`, error);
        }
    }
}


CSFindBy.ts
----------------------------

import { By, WebElement, WebDriver } from 'selenium-webdriver';
import { CSElement } from '../element/CSElement';
import { CSElementList } from '../element/CSElementList';
import { CSSelect } from '../element/CSSelect';
import { CSForm } from '../element/CSForm';
import { CSTable } from '../element/CSTable';
import { CSLogger } from '../../core/utils/CSLogger';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';

/**
 * Interface for CSFindBy decorator configuration.
 */
export interface CSFindByOptions {
    /**
     * Element lookup by ID.
     */
    id?: string;
    
    /**
     * Element lookup by CSS selector.
     */
    css?: string;
    
    /**
     * Element lookup by XPath.
     */
    xpath?: string;
    
    /**
     * Element lookup by name attribute.
     */
    name?: string;
    
    /**
     * Element lookup by linkText.
     */
    linkText?: string;
    
    /**
     * Element lookup by partial link text.
     */
    partialLinkText?: string;
    
    /**
     * Element lookup by tag name.
     */
    tagName?: string;
    
    /**
     * Element lookup by class name.
     */
    className?: string;
    
    /**
     * Whether to perform lookup inside a shadow DOM.
     */
    shadow?: boolean;
    
    /**
     * Selector for the shadow host (when shadow is true).
     */
    shadowHost?: string;
    
    /**
     * Whether to find multiple elements instead of a single element.
     */
    multiple?: boolean;
    
    /**
     * Whether the element is a select element.
     */
    isSelect?: boolean;
    
    /**
     * Whether the element is a form element.
     */
    isForm?: boolean;
    
    /**
     * Whether the element is a table element.
     */
    isTable?: boolean;
    
    /**
     * Options for enhanced element types (select, form, table).
     */
    elementOptions?: any;
    
    /**
     * Cache timeout for the element (in milliseconds).
     * Set to 0 to disable caching.
     */
    cacheTimeout?: number;
    
    /**
     * Description of the element for logging and reporting.
     */
    description?: string;
    
    /**
     * Custom locator function that will be used to find the element.
     */
    customLocator?: (driver: WebDriver) => Promise<WebElement>;
    
    /**
     * CSS selector for iframe containing the element.
     */
    frame?: string;
    
    /**
     * Whether to retry finding the element on StaleElementReference exceptions.
     */
    retryOnStale?: boolean;
    
    /**
     * Number of retries for finding the element.
     */
    retryCount?: number;
    
    /**
     * Delay between retries (in milliseconds).
     */
    retryDelay?: number;
    
    /**
     * Whether to wait for the element to be present.
     */
    waitForPresent?: boolean;
    
    /**
     * Whether to wait for the element to be visible.
     */
    waitForVisible?: boolean;
    
    /**
     * Whether to wait for the element to be clickable.
     */
    waitForClickable?: boolean;
    
    /**
     * Timeout for wait conditions (in milliseconds).
     */
    waitTimeout?: number;
    
    /**
     * Index to select when multiple elements match (for single element lookup).
     */
    index?: number;
    
    /**
     * Attribute that must exist on the element.
     */
    attribute?: string;
    
    /**
     * Expected value of the attribute.
     */
    attributeValue?: string;
    
    /**
     * Text that must be contained in the element.
     */
    text?: string;
    
    /**
     * Whether text matching should be exact.
     */
    exactTextMatch?: boolean;
    
    /**
     * Custom retrieval function for the element.
     */
    retriever?: (driver: WebDriver) => Promise<WebElement | WebElement[] | null>;
}

/**
 * Interface for CSFindAll decorator configuration.
 */
export interface CSFindAllOptions {
    /**
     * Multiple CSFindBy configurations.
     */
    findBy: CSFindByOptions[];
    
    /**
     * Whether to perform an OR operation (default) or AND operation.
     */
    conjunction?: 'OR' | 'AND';
    
    /**
     * Whether to find multiple elements instead of a single element.
     */
    multiple?: boolean;
    
    /**
     * Cache timeout for the element (in milliseconds).
     * Set to 0 to disable caching.
     */
    cacheTimeout?: number;
    
    /**
     * Description of the element for logging and reporting.
     */
    description?: string;
}

/**
 * Cache for located elements.
 */
interface ElementCache {
    element: WebElement | WebElement[];
    timestamp: number;
    timeout: number;
}

/**
 * Map to store element caches.
 */
const elementCacheMap = new Map<string, ElementCache>();

/**
 * Decorator for field values that represent elements in a page object.
 * 
 * @param options The configuration options for finding the element
 * @returns A property decorator function
 */
export function CSFindBy(options: CSFindByOptions): PropertyDecorator {
    return function(target: Object, propertyKey: string | symbol) {
        const cacheKey = `${target.constructor.name}_${String(propertyKey)}`;
        
        // Define property descriptor
        const descriptor: PropertyDescriptor = {
            configurable: true,
            enumerable: true,
            get: async function() {
                // Check cache if caching is enabled
                if (options.cacheTimeout !== 0) {
                    const cached = elementCacheMap.get(cacheKey);
                    const now = Date.now();
                    
                    if (cached && (now - cached.timestamp < cached.timeout)) {
                        // Return cached element if still valid
                        return wrapElement(cached.element, options);
                    }
                }
                
                try {
                    const driver = getDriver(this);
                    
                    // Switch to frame if specified
                    let frameElement: WebElement | null = null;
                    if (options.frame) {
                        try {
                            frameElement = await driver.findElement(By.css(options.frame));
                            await driver.switchTo().frame(frameElement);
                        } catch (error) {
                            CSLogger.warn(`Failed to switch to frame: ${error.message}`);
                        }
                    }
                    
                    // Find the element
                    let element: WebElement | WebElement[];
                    
                    try {
                        element = await findElement(driver, options);
                        
                        // Cache the element if caching is enabled
                        if (options.cacheTimeout !== 0) {
                            elementCacheMap.set(cacheKey, {
                                element,
                                timestamp: Date.now(),
                                timeout: options.cacheTimeout || 5000 // Default to 5 seconds
                            });
                        }
                    } finally {
                        // Switch back to default content if we switched to a frame
                        if (frameElement) {
                            await driver.switchTo().defaultContent();
                        }
                    }
                    
                    // Wrap the element based on the options
                    return wrapElement(element, options);
                } catch (error) {
                    // Handle element retrieval error
                    const elementDesc = options.description || String(propertyKey);
                    
                    if (error instanceof ElementNotFoundException) {
                        throw error;
                    }
                    
                    throw new ElementNotFoundException(
                        `Failed to find element '${elementDesc}': ${error.message}`,
                        error
                    );
                }
            },
            set: function(value) {
                // Remove from cache when explicitly set
                elementCacheMap.delete(cacheKey);
                
                // Store the actual value
                Object.defineProperty(this, propertyKey, {
                    value,
                    configurable: true,
                    enumerable: true,
                    writable: true
                });
            }
        };
        
        Object.defineProperty(target, propertyKey, descriptor);
    };
}

/**
 * Decorator for finding elements using multiple strategies (OR or AND).
 * 
 * @param options The configuration options for finding elements
 * @returns A property decorator function
 */
export function CSFindAll(options: CSFindAllOptions): PropertyDecorator {
    return function(target: Object, propertyKey: string | symbol) {
        const cacheKey = `${target.constructor.name}_${String(propertyKey)}`;
        
        // Define property descriptor
        const descriptor: PropertyDescriptor = {
            configurable: true,
            enumerable: true,
            get: async function() {
                // Check cache if caching is enabled
                if (options.cacheTimeout !== 0) {
                    const cached = elementCacheMap.get(cacheKey);
                    const now = Date.now();
                    
                    if (cached && (now - cached.timestamp < cached.timeout)) {
                        // Return cached element if still valid
                        return wrapElement(cached.element, { multiple: options.multiple });
                    }
                }
                
                try {
                    const driver = getDriver(this);
                    
                    // Find elements using OR or AND conjunction
                    const isAnd = options.conjunction === 'AND';
                    let elements: WebElement[] = [];
                    
                    if (isAnd) {
                        // AND conjunction - elements must match all conditions
                        if (options.findBy.length === 0) {
                            throw new ElementNotFoundException('No find conditions specified');
                        }
                        
                        // Start with all elements from the first condition
                        const firstFindBy = options.findBy[0];
                        let candidateElements = await findElements(driver, firstFindBy);
                        
                        // Filter by each subsequent condition
                        for (let i = 1; i < options.findBy.length; i++) {
                            const findBy = options.findBy[i];
                            const locator = createLocator(findBy);
                            
                            candidateElements = await filterElements(candidateElements, locator, findBy);
                            
                            if (candidateElements.length === 0) {
                                break;
                            }
                        }
                        
                        elements = candidateElements;
                    } else {
                        // OR conjunction - combine elements from all conditions
                        const elementSet = new Set<WebElement>();
                        
                        for (const findBy of options.findBy) {
                            try {
                                const foundElements = await findElements(driver, findBy);
                                
                                for (const element of foundElements) {
                                    elementSet.add(element);
                                }
                            } catch (error) {
                                // Ignore errors for OR conjunction
                                CSLogger.debug(`Error for one findBy condition: ${error.message}`);
                            }
                        }
                        
                        elements = Array.from(elementSet);
                    }
                    
                    // Handle result based on multiple flag
                    let result: WebElement | WebElement[];
                    
                    if (options.multiple !== false) {
                        result = elements;
                    } else {
                        if (elements.length === 0) {
                            throw new ElementNotFoundException('No elements found matching the conditions');
                        }
                        
                        result = elements[0];
                    }
                    
                    // Cache the element if caching is enabled
                    if (options.cacheTimeout !== 0) {
                        elementCacheMap.set(cacheKey, {
                            element: result,
                            timestamp: Date.now(),
                            timeout: options.cacheTimeout || 5000 // Default to 5 seconds
                        });
                    }
                    
                    // Wrap the element based on the options
                    return wrapElement(result, { multiple: options.multiple });
                } catch (error) {
                    // Handle element retrieval error
                    const elementDesc = options.description || String(propertyKey);
                    
                    if (error instanceof ElementNotFoundException) {
                        throw error;
                    }
                    
                    throw new ElementNotFoundException(
                        `Failed to find element(s) '${elementDesc}': ${error.message}`,
                        error
                    );
                }
            },
            set: function(value) {
                // Remove from cache when explicitly set
                elementCacheMap.delete(cacheKey);
                
                // Store the actual value
                Object.defineProperty(this, propertyKey, {
                    value,
                    configurable: true,
                    enumerable: true,
                    writable: true
                });
            }
        };
        
        Object.defineProperty(target, propertyKey, descriptor);
    };
}

/**
 * Decorator for shadow root elements.
 * 
 * @param shadowHost CSS selector for the shadow host
 * @param options The configuration options for finding elements within the shadow root
 * @returns A property decorator function
 */
export function CSShadowBy(shadowHost: string, options: CSFindByOptions): PropertyDecorator {
    const shadowOptions: CSFindByOptions = {
        ...options,
        shadow: true,
        shadowHost: shadowHost
    };
    
    return CSFindBy(shadowOptions);
}

/**
 * Gets the WebDriver instance from a page object.
 * 
 * @param pageObject The page object
 * @returns The WebDriver instance
 * @throws Error if the WebDriver instance cannot be found
 */
function getDriver(pageObject: any): WebDriver {
    // Try different common property names for the driver
    const driverPropNames = ['driver', '_driver', 'webDriver', '_webDriver', 'browser', '_browser'];
    
    for (const propName of driverPropNames) {
        if (pageObject[propName] instanceof WebDriver) {
            return pageObject[propName];
        }
    }
    
    // If not found directly, check if there's a getDriver method
    if (typeof pageObject.getDriver === 'function') {
        const driver = pageObject.getDriver();
        
        if (driver instanceof WebDriver) {
            return driver;
        }
    }
    
    throw new Error('WebDriver instance not found in page object');
}

/**
 * Creates a locator based on the provided options.
 * 
 * @param options The options for creating the locator
 * @returns The locator or null if no valid locator options are provided
 */
function createLocator(options: CSFindByOptions): By | null {
    if (options.id) {
        return By.id(options.id);
    }
    
    if (options.css) {
        return By.css(options.css);
    }
    
    if (options.xpath) {
        return By.xpath(options.xpath);
    }
    
    if (options.name) {
        return By.name(options.name);
    }
    
    if (options.linkText) {
        return By.linkText(options.linkText);
    }
    
    if (options.partialLinkText) {
        return By.partialLinkText(options.partialLinkText);
    }
    
    if (options.tagName) {
        return By.tagName(options.tagName);
    }
    
    if (options.className) {
        return By.className(options.className);
    }
    
    return null;
}

/**
 * Finds an element or elements based on the provided options.
 * 
 * @param driver The WebDriver instance
 * @param options The options for finding the element
 * @returns Promise resolving to WebElement or array of WebElements
 * @throws ElementNotFoundException if the element cannot be found
 */
async function findElement(driver: WebDriver, options: CSFindByOptions): Promise<WebElement | WebElement[]> {
    // Use custom locator if provided
    if (options.customLocator) {
        const element = await options.customLocator(driver);
        return element;
    }
    
    // Use custom retriever if provided
    if (options.retriever) {
        const result = await options.retriever(driver);
        
        if (!result) {
            throw new ElementNotFoundException('Custom retriever returned null');
        }
        
        return result;
    }
    
    // Find in shadow DOM if specified
    if (options.shadow && options.shadowHost) {
        return await findElementInShadow(driver, options);
    }
    
    // Create locator
    const locator = createLocator(options);
    
    if (!locator) {
        throw new ElementNotFoundException('No valid locator options provided');
    }
    
    try {
        // Define retry parameters
        const maxRetries = options.retryOnStale ? (options.retryCount || 3) : 0;
        const retryDelay = options.retryDelay || 500;
        let retries = 0;
        let lastError: Error | null = null;
        
        // Retry loop
        while (retries <= maxRetries) {
            try {
                if (options.multiple) {
                    // Find all elements
                    const elements = await driver.findElements(locator);
                    
                    // Filter by attribute if specified
                    if (options.attribute) {
                        const filteredElements: WebElement[] = [];
                        
                        for (const element of elements) {
                            const attrValue = await element.getAttribute(options.attribute);
                            
                            if (options.attributeValue) {
                                if (attrValue === options.attributeValue) {
                                    filteredElements.push(element);
                                }
                            } else if (attrValue !== null) {
                                filteredElements.push(element);
                            }
                        }
                        
                        return filteredElements;
                    }
                    
                    // Filter by text if specified
                    if (options.text) {
                        const filteredElements: WebElement[] = [];
                        
                        for (const element of elements) {
                            const text = await element.getText();
                            
                            if (options.exactTextMatch) {
                                if (text === options.text) {
                                    filteredElements.push(element);
                                }
                            } else if (text.includes(options.text)) {
                                filteredElements.push(element);
                            }
                        }
                        
                        return filteredElements;
                    }
                    
                    return elements;
                } else {
                    // Handle element with index
                    if (options.index !== undefined && options.index >= 0) {
                        const elements = await driver.findElements(locator);
                        
                        if (elements.length <= options.index) {
                            throw new ElementNotFoundException(
                                `Element at index ${options.index} not found, only ${elements.length} elements available`
                            );
                        }
                        
                        return elements[options.index];
                    }
                    
                    // Wait for element if needed
                    if (options.waitForPresent) {
                        await driver.wait(
                            async () => (await driver.findElements(locator)).length > 0,
                            options.waitTimeout || 10000,
                            `Timed out waiting for element to be present with locator: ${locator}`
                        );
                    }
                    
                    if (options.waitForVisible) {
                        const element = await driver.findElement(locator);
                        
                        await driver.wait(
                            async () => await element.isDisplayed(),
                            options.waitTimeout || 10000,
                            `Timed out waiting for element to be visible with locator: ${locator}`
                        );
                        
                        return element;
                    }
                    
                    if (options.waitForClickable) {
                        const element = await driver.findElement(locator);
                        
                        await driver.wait(
                            async () => {
                                const isDisplayed = await element.isDisplayed();
                                const isEnabled = await element.isEnabled();
                                return isDisplayed && isEnabled;
                            },
                            options.waitTimeout || 10000,
                            `Timed out waiting for element to be clickable with locator: ${locator}`
                        );
                        
                        return element;
                    }
                    
                    // Find single element
                    const element = await driver.findElement(locator);
                    
                    // Check attribute if specified
                    if (options.attribute) {
                        const attrValue = await element.getAttribute(options.attribute);
                        
                        if (options.attributeValue) {
                            if (attrValue !== options.attributeValue) {
                                throw new ElementNotFoundException(
                                    `Element found but attribute ${options.attribute} value "${attrValue}" does not match expected "${options.attributeValue}"`
                                );
                            }
                        } else if (attrValue === null) {
                            throw new ElementNotFoundException(
                                `Element found but attribute ${options.attribute} does not exist`
                            );
                        }
                    }
                    
                    // Check text if specified
                    if (options.text) {
                        const text = await element.getText();
                        
                        if (options.exactTextMatch) {
                            if (text !== options.text) {
                                throw new ElementNotFoundException(
                                    `Element found but text "${text}" does not match expected "${options.text}"`
                                );
                            }
                        } else if (!text.includes(options.text)) {
                            throw new ElementNotFoundException(
                                `Element found but text "${text}" does not contain "${options.text}"`
                            );
                        }
                    }
                    
                    return element;
                }
            } catch (error) {
                // Check if it's a StaleElementReferenceError
                if (error.name === 'StaleElementReferenceError' && options.retryOnStale) {
                    lastError = error;
                    retries++;
                    
                    if (retries <= maxRetries) {
                        // Wait before retrying
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                        continue;
                    }
                }
                
                // Propagate other errors or when max retries exceeded
                throw error;
            }
        }
        
        // If we get here, we've exceeded retries
        throw lastError || new ElementNotFoundException('Max retries exceeded');
    } catch (error) {
        const desc = options.description || Object.entries(options)
            .filter(([key, value]) => value && ['id', 'css', 'xpath', 'name', 'linkText', 'partialLinkText', 'tagName', 'className'].includes(key))
            .map(([key, value]) => `${key}="${value}"`)
            .join(', ');
        
        throw new ElementNotFoundException(
            `Element not found: ${desc}. ${error.message}`,
            error
        );
    }
}

/**
 * Finds multiple elements based on the provided options.
 * 
 * @param driver The WebDriver instance
 * @param options The options for finding the elements
 * @returns Promise resolving to an array of WebElements
 */
async function findElements(driver: WebDriver, options: CSFindByOptions): Promise<WebElement[]> {
    // Use custom retriever if provided
    if (options.retriever) {
        const result = await options.retriever(driver);
        
        if (!result) {
            return [];
        }
        
        if (Array.isArray(result)) {
            return result;
        }
        
        return [result];
    }
    
    // Find in shadow DOM if specified
    if (options.shadow && options.shadowHost) {
        const result = await findElementInShadow(driver, options);
        
        if (Array.isArray(result)) {
            return result;
        }
        
        return [result];
    }
    
    // Create locator
    const locator = createLocator(options);
    
    if (!locator) {
        return [];
    }
    
    // Find elements
    const elements = await driver.findElements(locator);
    
    // Filter by attribute if specified
    if (options.attribute) {
        const filteredElements: WebElement[] = [];
        
        for (const element of elements) {
            try {
                const attrValue = await element.getAttribute(options.attribute);
                
                if (options.attributeValue) {
                    if (attrValue === options.attributeValue) {
                        filteredElements.push(element);
                    }
                } else if (attrValue !== null) {
                    filteredElements.push(element);
                }
            } catch (error) {
                // Skip elements that cause errors
                continue;
            }
        }
        
        return filteredElements;
    }
    
    // Filter by text if specified
    if (options.text) {
        const filteredElements: WebElement[] = [];
        
        for (const element of elements) {
            try {
                const text = await element.getText();
                
                if (options.exactTextMatch) {
                    if (text === options.text) {
                        filteredElements.push(element);
                    }
                } else if (text.includes(options.text)) {
                    filteredElements.push(element);
                }
            } catch (error) {
                // Skip elements that cause errors
                continue;
            }
        }
        
        return filteredElements;
    }
    
    return elements;
}

/**
 * Filters elements based on a locator.
 * 
 * @param elements The elements to filter
 * @param locator The locator to use for filtering
 * @param options The options for filtering
 * @returns Promise resolving to the filtered elements
 */
async function filterElements(elements: WebElement[], locator: By | null, options: CSFindByOptions): Promise<WebElement[]> {
    if (!locator) {
        return elements;
    }
    
    const filteredElements: WebElement[] = [];
    
    for (const element of elements) {
        try {
            // For each element, find children matching the locator
            const matches = await element.findElements(locator);
            
            if (matches.length > 0) {
                // Element has matching children, include it
                filteredElements.push(element);
            }
        } catch (error) {
            // Skip elements that cause errors
            continue;
        }
    }
    
    return filteredElements;
}

/**
 * Finds an element within a shadow DOM.
 * 
 * @param driver The WebDriver instance
 * @param options The options for finding the element
 * @returns Promise resolving to WebElement or array of WebElements
 * @throws ElementNotFoundException if the element cannot be found
 */
async function findElementInShadow(driver: WebDriver, options: CSFindByOptions): Promise<WebElement | WebElement[]> {
    if (!options.shadowHost) {
        throw new ElementNotFoundException('Shadow host selector not provided');
    }
    
    try {
        // Find the shadow host
        const shadowHost = await driver.findElement(By.css(options.shadowHost));
        
        // Create the shadow root query
        const selector = options.css || 
            (options.tagName ? options.tagName : '*') + 
            (options.className ? `.${options.className}` : '') +
            (options.id ? `#${options.id}` : '') +
            (options.name ? `[name="${options.name}"]` : '');
        
        if (!selector) {
            throw new ElementNotFoundException('No valid selector for shadow DOM query');
        }
        
        // Execute script to query within shadow DOM
        const result = await driver.executeScript<WebElement | WebElement[]>(
            `
            const shadowHost = arguments[0];
            const selector = arguments[1];
            const multiple = arguments[2];
            
            // Get the shadow root
            const shadowRoot = shadowHost.shadowRoot;
            
            if (!shadowRoot) {
                throw new Error('No shadow root found on the specified host element');
            }
            
            // Query elements
            return multiple ? 
                Array.from(shadowRoot.querySelectorAll(selector)) : 
                shadowRoot.querySelector(selector);
            `,
            shadowHost,
            selector,
            options.multiple
        );
        
        if (!result) {
            throw new ElementNotFoundException(`No elements found in shadow DOM with selector: ${selector}`);
        }
        
        return result;
    } catch (error) {
        throw new ElementNotFoundException(`Failed to find element in shadow DOM: ${error.message}`, error);
    }
}

/**
 * Wraps a WebElement or array of WebElements based on the provided options.
 * 
 * @param element The element or elements to wrap
 * @param options The options for wrapping
 * @returns CSElement, CSElementList, CSSelect, CSForm, CSTable, or the original element
 */
function wrapElement(element: WebElement | WebElement[], options: any): any {
    if (Array.isArray(element)) {
        // Handle array of elements
        if (options.multiple !== false) {
            return new CSElementList(element);
        } else if (element.length > 0) {
            // If multiple is false but we got an array, take the first element
            element = element[0];
        } else {
            throw new ElementNotFoundException('No elements found');
        }
    }
    
    // Handle single element
    if (options.isSelect) {
        return new CSSelect(element as WebElement, options.elementOptions);
    }
    
    if (options.isForm) {
        return new CSForm(element as WebElement, options.elementOptions);
    }
    
    if (options.isTable) {
        return new CSTable(element as WebElement, options.elementOptions);
    }
    
    return new CSElement(element as WebElement);
}

/**
 * Clears the element cache.
 */
export function clearElementCache(): void {
    elementCacheMap.clear();
}

/**
 * Clears the element cache for a specific page object class.
 * 
 * @param pageObjectClass The page object class
 */
export function clearElementCacheForClass(pageObjectClass: any): void {
    const className = pageObjectClass.name;
    
    for (const key of elementCacheMap.keys()) {
        if (key.startsWith(`${className}_`)) {
            elementCacheMap.delete(key);
        }
    }
}

/**
 * Clears the element cache for a specific property.
 * 
 * @param target The target object
 * @param propertyKey The property key
 */
export function clearElementCacheForProperty(target: any, propertyKey: string | symbol): void {
    const className = target.constructor.name;
    const cacheKey = `${className}_${String(propertyKey)}`;
    
    elementCacheMap.delete(cacheKey);
}

/**
 * Gets the cached element for a property.
 * 
 * @param target The target object
 * @param propertyKey The property key
 * @returns The cached element or null if not cached
 */
export function getCachedElement(target: any, propertyKey: string | symbol): WebElement | WebElement[] | null {
    const className = target.constructor.name;
    const cacheKey = `${className}_${String(propertyKey)}`;
    const cached = elementCacheMap.get(cacheKey);
    
    if (cached && (Date.now() - cached.timestamp < cached.timeout)) {
        return cached.element;
    }
    
    return null;
}

/**
 * Factory class for creating CSFindBy options.
 */
export class CSLocatorBuilder {
    private options: CSFindByOptions = {};
    
    /**
     * Sets the element ID.
     * 
     * @param id The element ID
     * @returns This builder instance for chaining
     */
    public withId(id: string): CSLocatorBuilder {
        this.options.id = id;
        return this;
    }
    
    /**
     * Sets the CSS selector.
     * 
     * @param css The CSS selector
     * @returns This builder instance for chaining
     */
    public withCss(css: string): CSLocatorBuilder {
        this.options.css = css;
        return this;
    }
    
    /**
     * Sets the XPath selector.
     * 
     * @param xpath The XPath selector
     * @returns This builder instance for chaining
     */
    public withXpath(xpath: string): CSLocatorBuilder {
        this.options.xpath = xpath;
        return this;
    }
    
    /**
     * Sets the name attribute.
     * 
     * @param name The name attribute
     * @returns This builder instance for chaining
     */
    public withName(name: string): CSLocatorBuilder {
        this.options.name = name;
        return this;
    }
    
    /**
     * Sets the link text.
     * 
     * @param linkText The link text
     * @returns This builder instance for chaining
     */
    public withLinkText(linkText: string): CSLocatorBuilder {
        this.options.linkText = linkText;
        return this;
    }
    
    /**
     * Sets the partial link text.
     * 
     * @param partialLinkText The partial link text
     * @returns This builder instance for chaining
     */
    public withPartialLinkText(partialLinkText: string): CSLocatorBuilder {
        this.options.partialLinkText = partialLinkText;
        return this;
    }
    
    /**
     * Sets the tag name.
     * 
     * @param tagName The tag name
     * @returns This builder instance for chaining
     */
    public withTagName(tagName: string): CSLocatorBuilder {
        this.options.tagName = tagName;
        return this;
    }
    
    /**
     * Sets the class name.
     * 
     * @param className The class name
     * @returns This builder instance for chaining
     */
    public withClassName(className: string): CSLocatorBuilder {
        this.options.className = className;
        return this;
    }
    
    /**
     * Enables shadow DOM support.
     * 
     * @param shadowHost The shadow host selector
     * @returns This builder instance for chaining
     */
    public inShadowDom(shadowHost: string): CSLocatorBuilder {
        this.options.shadow = true;
        this.options.shadowHost = shadowHost;
        return this;
    }
    
    /**
     * Enables finding multiple elements.
     * 
     * @returns This builder instance for chaining
     */
    public findMultiple(): CSLocatorBuilder {
        this.options.multiple = true;
        return this;
    }
    
    /**
     * Marks the element as a select element.
     * 
     * @param elementOptions Optional options for the select element
     * @returns This builder instance for chaining
     */
    public asSelect(elementOptions?: any): CSLocatorBuilder {
        this.options.isSelect = true;
        this.options.elementOptions = elementOptions;
        return this;
    }
    
    /**
     * Marks the element as a form element.
     * 
     * @param elementOptions Optional options for the form element
     * @returns This builder instance for chaining
     */
    public asForm(elementOptions?: any): CSLocatorBuilder {
        this.options.isForm = true;
        this.options.elementOptions = elementOptions;
        return this;
    }
    
    /**
     * Marks the element as a table element.
     * 
     * @param elementOptions Optional options for the table element
     * @returns This builder instance for chaining
     */
    public asTable(elementOptions?: any): CSLocatorBuilder {
        this.options.isTable = true;
        this.options.elementOptions = elementOptions;
        return this;
    }
    
    /**
     * Sets the cache timeout.
     * 
     * @param timeout The cache timeout in milliseconds
     * @returns This builder instance for chaining
     */
    public withCacheTimeout(timeout: number): CSLocatorBuilder {
        this.options.cacheTimeout = timeout;
        return this;
    }
    
    /**
     * Sets the element description.
     * 
     * @param description The element description
     * @returns This builder instance for chaining
     */
    public withDescription(description: string): CSLocatorBuilder {
        this.options.description = description;
        return this;
    }
    
    /**
     * Sets the custom locator function.
     * 
     * @param locator The custom locator function
     * @returns This builder instance for chaining
     */
    public withCustomLocator(locator: (driver: WebDriver) => Promise<WebElement>): CSLocatorBuilder {
        this.options.customLocator = locator;
        return this;
    }
    
    /**
     * Sets the frame selector.
     * 
     * @param frameSelector The CSS selector for the frame
     * @returns This builder instance for chaining
     */
    public inFrame(frameSelector: string): CSLocatorBuilder {
        this.options.frame = frameSelector;
        return this;
    }
    
    /**
     * Enables retrying on stale element references.
     * 
     * @param retryCount The number of retries
     * @param retryDelay The delay between retries in milliseconds
     * @returns This builder instance for chaining
     */
    public withRetryOnStale(retryCount: number = 3, retryDelay: number = 500): CSLocatorBuilder {
        this.options.retryOnStale = true;
        this.options.retryCount = retryCount;
        this.options.retryDelay = retryDelay;
        return this;
    }
    
    /**
     * Waits for the element to be present.
     * 
     * @param timeout The timeout in milliseconds
     * @returns This builder instance for chaining
     */
    public waitForPresent(timeout?: number): CSLocatorBuilder {
        this.options.waitForPresent = true;
        
        if (timeout !== undefined) {
            this.options.waitTimeout = timeout;
        }
        
        return this;
    }
    
    /**
     * Waits for the element to be visible.
     * 
     * @param timeout The timeout in milliseconds
     * @returns This builder instance for chaining
     */
    public waitForVisible(timeout?: number): CSLocatorBuilder {
        this.options.waitForVisible = true;
        
        if (timeout !== undefined) {
            this.options.waitTimeout = timeout;
        }
        
        return this;
    }
    
    /**
     * Waits for the element to be clickable.
     * 
     * @param timeout The timeout in milliseconds
     * @returns This builder instance for chaining
     */
    public waitForClickable(timeout?: number): CSLocatorBuilder {
        this.options.waitForClickable = true;
        
        if (timeout !== undefined) {
            this.options.waitTimeout = timeout;
        }
        
        return this;
    }
    
    /**
     * Sets the index for selecting a specific element from multiple matches.
     * 
     * @param index The zero-based index
     * @returns This builder instance for chaining
     */
    public withIndex(index: number): CSLocatorBuilder {
        this.options.index = index;
        return this;
    }
    
    /**
     * Filters elements by attribute.
     * 
     * @param attribute The attribute name
     * @param value Optional attribute value
     * @returns This builder instance for chaining
     */
    public withAttribute(attribute: string, value?: string): CSLocatorBuilder {
        this.options.attribute = attribute;
        
        if (value !== undefined) {
            this.options.attributeValue = value;
        }
        
        return this;
    }
    
    /**
     * Filters elements by text.
     * 
     * @param text The text to match
     * @param exactMatch Whether to match exactly
     * @returns This builder instance for chaining
     */
    public withText(text: string, exactMatch: boolean = false): CSLocatorBuilder {
        this.options.text = text;
        this.options.exactTextMatch = exactMatch;
        return this;
    }
    
    /**
     * Sets the custom retriever function.
     * 
     * @param retriever The custom retriever function
     * @returns This builder instance for chaining
     */
    public withRetriever(retriever: (driver: WebDriver) => Promise<WebElement | WebElement[] | null>): CSLocatorBuilder {
        this.options.retriever = retriever;
        return this;
    }
    
    /**
     * Builds the CSFindBy options.
     * 
     * @returns The CSFindBy options
     */
    public build(): CSFindByOptions {
        return this.options;
    }
    
    /**
     * Returns the CSFindBy decorator with the built options.
     * 
     * @returns The CSFindBy decorator
     */
    public buildDecorator(): PropertyDecorator {
        return CSFindBy(this.options);
    }
}

/**
 * Factory class for creating CSFindAll options.
 */
export class CSFindAllBuilder {
    private options: CSFindAllOptions = { findBy: [] };
    
    /**
     * Adds a CSFindBy option to the list.
     * 
     * @param findBy The CSFindBy option
     * @returns This builder instance for chaining
     */
    public addFindBy(findBy: CSFindByOptions): CSFindAllBuilder {
        this.options.findBy.push(findBy);
        return this;
    }
    
    /**
     * Sets the conjunction type.
     * 
     * @param conjunction The conjunction type (OR or AND)
     * @returns This builder instance for chaining
     */
    public withConjunction(conjunction: 'OR' | 'AND'): CSFindAllBuilder {
        this.options.conjunction = conjunction;
        return this;
    }
    
    /**
     * Enables finding multiple elements.
     * 
     * @returns This builder instance for chaining
     */
    public findMultiple(): CSFindAllBuilder {
        this.options.multiple = true;
        return this;
    }
    
    /**
     * Sets the cache timeout.
     * 
     * @param timeout The cache timeout in milliseconds
     * @returns This builder instance for chaining
     */
    public withCacheTimeout(timeout: number): CSFindAllBuilder {
        this.options.cacheTimeout = timeout;
        return this;
    }
    
    /**
     * Sets the element description.
     * 
     * @param description The element description
     * @returns This builder instance for chaining
     */
    public withDescription(description: string): CSFindAllBuilder {
        this.options.description = description;
        return this;
    }
    
    /**
     * Builds the CSFindAll options.
     * 
     * @returns The CSFindAll options
     */
    public build(): CSFindAllOptions {
        return this.options;
    }
    
    /**
     * Returns the CSFindAll decorator with the built options.
     * 
     * @returns The CSFindAll decorator
     */
    public buildDecorator(): PropertyDecorator {
        return CSFindAll(this.options);
    }
}

/**
 * Decorator for elements that should be found by ID.
 * 
 * @param id The element ID
 * @returns A property decorator function
 */
export function CSFindById(id: string): PropertyDecorator {
    return CSFindBy({ id });
}

/**
 * Decorator for elements that should be found by CSS selector.
 * 
 * @param css The CSS selector
 * @returns A property decorator function
 */
export function CSFindByCss(css: string): PropertyDecorator {
    return CSFindBy({ css });
}

/**
 * Decorator for elements that should be found by XPath.
 * 
 * @param xpath The XPath selector
 * @returns A property decorator function
 */
export function CSFindByXPath(xpath: string): PropertyDecorator {
    return CSFindBy({ xpath });
}

/**
 * Decorator for elements that should be found by name attribute.
 * 
 * @param name The name attribute
 * @returns A property decorator function
 */
export function CSFindByName(name: string): PropertyDecorator {
    return CSFindBy({ name });
}

/**
 * Decorator for elements that should be found by link text.
 * 
 * @param linkText The link text
 * @returns A property decorator function
 */
export function CSFindByLinkText(linkText: string): PropertyDecorator {
    return CSFindBy({ linkText });
}

/**
 * Decorator for elements that should be found by partial link text.
 * 
 * @param partialLinkText The partial link text
 * @returns A property decorator function
 */
export function CSFindByPartialLinkText(partialLinkText: string): PropertyDecorator {
    return CSFindBy({ partialLinkText });
}

/**
 * Decorator for elements that should be found by tag name.
 * 
 * @param tagName The tag name
 * @returns A property decorator function
 */
export function CSFindByTagName(tagName: string): PropertyDecorator {
    return CSFindBy({ tagName });
}

/**
 * Decorator for elements that should be found by class name.
 * 
 * @param className The class name
 * @returns A property decorator function
 */
export function CSFindByClassName(className: string): PropertyDecorator {
    return CSFindBy({ className });
}

/**
 * Decorator for elements that should be treated as select elements.
 * 
 * @param locator The element locator
 * @param options Optional configuration for the select element
 * @returns A property decorator function
 */
export function CSFindSelect(locator: CSFindByOptions, options?: any): PropertyDecorator {
    return CSFindBy({
        ...locator,
        isSelect: true,
        elementOptions: options
    });
}

/**
 * Decorator for elements that should be treated as form elements.
 * 
 * @param locator The element locator
 * @param options Optional configuration for the form element
 * @returns A property decorator function
 */
export function CSFindForm(locator: CSFindByOptions, options?: any): PropertyDecorator {
    return CSFindBy({
        ...locator,
        isForm: true,
        elementOptions: options
    });
}

/**
 * Decorator for elements that should be treated as table elements.
 * 
 * @param locator The element locator
 * @param options Optional configuration for the table element
 * @returns A property decorator function
 */
export function CSFindTable(locator: CSFindByOptions, options?: any): PropertyDecorator {
    return CSFindBy({
        ...locator,
        isTable: true,
        elementOptions: options
    });
}

/**
 * Decorator for elements that should be found as a list.
 * 
 * @param locator The element locator
 * @returns A property decorator function
 */
export function CSFindList(locator: CSFindByOptions): PropertyDecorator {
    return CSFindBy({
        ...locator,
        multiple: true
    });
}

/**
 * Creates a new CSLocatorBuilder instance.
 * 
 * @returns A new CSLocatorBuilder instance
 */
export function createLocatorBuilder(): CSLocatorBuilder {
    return new CSLocatorBuilder();
}

/**
 * Creates a new CSFindAllBuilder instance.
 * 
 * @returns A new CSFindAllBuilder instance
 */
export function createFindAllBuilder(): CSFindAllBuilder {
    return new CSFindAllBuilder();
}



CSLocatoryProcessor.ts
--------------------------------

import { By, WebDriver, WebElement } from 'selenium-webdriver';
import { CSElement } from '../element/CSElement';
import { CSElementList } from '../element/CSElementList';
import { CSSelect } from '../element/CSSelect';
import { CSForm } from '../element/CSForm';
import { CSTable } from '../element/CSTable';
import { CSFindByOptions, CSFindAllOptions, clearElementCache } from './CSFindBy';
import { CSLogger } from '../../core/utils/CSLogger';
import { ElementNotFoundException } from '../../core/exceptions/ElementNotFoundException';
import { InitializationException } from '../../core/exceptions/InitializationException';

/**
 * Class for processing locator annotations and initializing page objects.
 */
export class CSLocatorProcessor {
    /**
     * Map of properties to their locator metadata for each class.
     */
    private static metadataMap = new Map<Object, Map<string, any>>();
    
    /**
     * The WebDriver instance.
     */
    private driver: WebDriver;
    
    /**
     * The root element for scoped searches.
     */
    private rootElement: WebElement | null = null;
    
    /**
     * Default timeout for element lookups.
     */
    private defaultTimeout: number = 10000;
    
    /**
     * Creates a new instance of CSLocatorProcessor.
     * 
     * @param driver The WebDriver instance
     */
    constructor(driver: WebDriver) {
        this.driver = driver;
    }
    
    /**
     * Gets the WebDriver instance.
     * 
     * @returns The WebDriver instance
     */
    public getDriver(): WebDriver {
        return this.driver;
    }
    
    /**
     * Sets the WebDriver instance.
     * 
     * @param driver The WebDriver instance
     * @returns This processor instance for chaining
     */
    public setDriver(driver: WebDriver): CSLocatorProcessor {
        this.driver = driver;
        return this;
    }
    
    /**
     * Sets the root element for scoped searches.
     * 
     * @param element The root element
     * @returns This processor instance for chaining
     */
    public setRootElement(element: WebElement | null): CSLocatorProcessor {
        this.rootElement = element;
        return this;
    }
    
    /**
     * Gets the root element for scoped searches.
     * 
     * @returns The root element or null if not set
     */
    public getRootElement(): WebElement | null {
        return this.rootElement;
    }
    
    /**
     * Sets the default timeout for element lookups.
     * 
     * @param timeout The timeout in milliseconds
     * @returns This processor instance for chaining
     */
    public setDefaultTimeout(timeout: number): CSLocatorProcessor {
        this.defaultTimeout = timeout;
        return this;
    }
    
    /**
     * Gets the default timeout for element lookups.
     * 
     * @returns The default timeout in milliseconds
     */
    public getDefaultTimeout(): number {
        return this.defaultTimeout;
    }
    
    /**
     * Initializes a page object by processing locator annotations.
     * 
     * @param pageObject The page object to initialize
     * @returns The initialized page object
     * @throws InitializationException if initialization fails
     */
    public async initializePageObject<T>(pageObject: T): Promise<T> {
        try {
            // Get the class constructor
            const pageObjectClass = pageObject.constructor;
            
            // Get property metadata map for this class
            let propertyMap = CSLocatorProcessor.metadataMap.get(pageObjectClass);
            
            if (!propertyMap) {
                // No metadata found, use reflection to find decorated properties
                propertyMap = await this.discoverAnnotatedProperties(pageObject);
                CSLocatorProcessor.metadataMap.set(pageObjectClass, propertyMap);
            }
            
            // Initialize each property
            for (const [propertyKey, metadata] of propertyMap.entries()) {
                try {
                    if (metadata.findBy) {
                        // Process CSFindBy
                        await this.processCSFindBy(pageObject, propertyKey, metadata.findBy);
                    } else if (metadata.findAll) {
                        // Process CSFindAll
                        await this.processCSFindAll(pageObject, propertyKey, metadata.findAll);
                    }
                } catch (error) {
                    CSLogger.error(`Failed to initialize property ${String(propertyKey)}: ${error.message}`);
                    
                    // Set property to null or empty array
                    if (metadata.findBy?.multiple || metadata.findAll?.multiple) {
                        (pageObject as any)[propertyKey] = [];
                    } else {
                        (pageObject as any)[propertyKey] = null;
                    }
                }
            }
            
            return pageObject;
        } catch (error) {
            throw new InitializationException(`Failed to initialize page object: ${error.message}`, error);
        }
    }
    
    /**
     * Discovers annotated properties in a page object.
     * 
     * @param pageObject The page object
     * @returns Map of property keys to their metadata
     */
    private async discoverAnnotatedProperties(pageObject: any): Promise<Map<string, any>> {
        const propertyMap = new Map<string, any>();
        
        // Get all property descriptors
        const prototype = Object.getPrototypeOf(pageObject);
        const propertyNames = Object.getOwnPropertyNames(prototype);
        
        for (const propertyName of propertyNames) {
            // Skip constructor and methods
            if (propertyName === 'constructor' || typeof prototype[propertyName] === 'function') {
                continue;
            }
            
            const descriptor = Object.getOwnPropertyDescriptor(prototype, propertyName);
            
            if (descriptor && typeof descriptor.get === 'function') {
                // This is a getter, check if it's an annotated property
                try {
                    const getterString = descriptor.get.toString();
                    
                    if (getterString.includes('CSFindBy') || getterString.includes('findBy:')) {
                        // Extract options from getter (simplified approach)
                        const findByMatch = getterString.match(/findBy\s*:\s*({[^}]+})/);
                        
                        if (findByMatch) {
                            try {
                                // Extract and evaluate the options object
                                // Note: This is a simplistic approach and might not work for all cases
                                const optionsString = findByMatch[1]
                                    .replace(/(\w+):/g, '"$1":') // Convert property names to strings
                                    .replace(/'/g, '"'); // Convert single quotes to double quotes
                                
                                const options = JSON.parse(optionsString);
                                
                                propertyMap.set(propertyName, { findBy: options });
                            } catch (error) {
                                CSLogger.warn(`Failed to parse CSFindBy options for property ${propertyName}: ${error.message}`);
                            }
                        } else if (getterString.includes('findAll:')) {
                            // Extract CSFindAll options
                            const findAllMatch = getterString.match(/findAll\s*:\s*({[^}]+})/);
                            
                            if (findAllMatch) {
                                try {
                                    // Extract and evaluate the options object
                                    const optionsString = findAllMatch[1]
                                        .replace(/(\w+):/g, '"$1":') // Convert property names to strings
                                        .replace(/'/g, '"'); // Convert single quotes to double quotes
                                    
                                    const options = JSON.parse(optionsString);
                                    
                                    propertyMap.set(propertyName, { findAll: options });
                                } catch (error) {
                                    CSLogger.warn(`Failed to parse CSFindAll options for property ${propertyName}: ${error.message}`);
                                }
                            }
                        }
                    }
                } catch (error) {
                    // Skip properties that can't be processed
                    CSLogger.debug(`Error analyzing property ${propertyName}: ${error.message}`);
                }
            }
        }
        
        return propertyMap;
    }
    
    /**
     * Processes a CSFindBy annotation.
     * 
     * @param pageObject The page object
     * @param propertyKey The property key
     * @param options The CSFindBy options
     */
    private async processCSFindBy(pageObject: any, propertyKey: string, options: CSFindByOptions): Promise<void> {
        try {
            const element = await this.findElement(options);
            pageObject[propertyKey] = this.wrapElement(element, options);
        } catch (error) {
            throw new ElementNotFoundException(
                `Failed to find element for property ${propertyKey}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Processes a CSFindAll annotation.
     * 
     * @param pageObject The page object
     * @param propertyKey The property key
     * @param options The CSFindAll options
     */
    private async processCSFindAll(pageObject: any, propertyKey: string, options: CSFindAllOptions): Promise<void> {
        try {
            const isAnd = options.conjunction === 'AND';
            let elements: WebElement[] = [];
            
            if (isAnd) {
                // AND conjunction - elements must match all conditions
                if (options.findBy.length === 0) {
                    throw new ElementNotFoundException('No find conditions specified');
                }
                
                // Start with all elements from the first condition
                const firstFindBy = options.findBy[0];
                let candidateElements = await this.findElements(firstFindBy);
                
                // Filter by each subsequent condition
                for (let i = 1; i < options.findBy.length; i++) {
                    const findBy = options.findBy[i];
                    const locator = this.createLocator(findBy);
                    
                    if (!locator) {
                        throw new ElementNotFoundException(`Invalid locator for condition ${i + 1}`);
                    }
                    
                    candidateElements = await this.filterElements(candidateElements, locator, findBy);
                    
                    if (candidateElements.length === 0) {
                        break;
                    }
                }
                
                elements = candidateElements;
            } else {
                // OR conjunction - combine elements from all conditions
                const elementSet = new Set<WebElement>();
                
                for (const findBy of options.findBy) {
                    try {
                        const foundElements = await this.findElements(findBy);
                        
                        for (const element of foundElements) {
                            elementSet.add(element);
                        }
                    } catch (error) {
                        // Ignore errors for OR conjunction
                        CSLogger.debug(`Error for one findBy condition: ${error.message}`);
                    }
                }
                
                elements = Array.from(elementSet);
            }
            
            // Handle result based on multiple flag
            if (options.multiple !== false) {
                pageObject[propertyKey] = new CSElementList(elements);
            } else {
                if (elements.length === 0) {
                    throw new ElementNotFoundException('No elements found matching the conditions');
                }
                
                pageObject[propertyKey] = new CSElement(elements[0]);
            }
        } catch (error) {
            throw new ElementNotFoundException(
                `Failed to find elements for property ${propertyKey}: ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Finds an element based on the provided options.
     * 
     * @param options The options for finding the element
     * @returns Promise resolving to WebElement or array of WebElements
     * @throws ElementNotFoundException if the element cannot be found
     */
    private async findElement(options: CSFindByOptions): Promise<WebElement | WebElement[]> {
        // Use custom locator if provided
        if (options.customLocator) {
            const element = await options.customLocator(this.driver);
            return element;
        }
        
        // Use custom retriever if provided
        if (options.retriever) {
            const result = await options.retriever(this.driver);
            
            if (!result) {
                throw new ElementNotFoundException('Custom retriever returned null');
            }
            
            return result;
        }
        
        // Find in shadow DOM if specified
        if (options.shadow && options.shadowHost) {
            return await this.findElementInShadow(options);
        }
        
        // Create locator
        const locator = this.createLocator(options);
        
        if (!locator) {
            throw new ElementNotFoundException('No valid locator options provided');
        }
        
        try {
            // Define retry parameters
            const maxRetries = options.retryOnStale ? (options.retryCount || 3) : 0;
            const retryDelay = options.retryDelay || 500;
            let retries = 0;
            let lastError: Error | null = null;
            
            // Retry loop
            while (retries <= maxRetries) {
                try {
                    const context = this.rootElement || this.driver;
                    
                    if (options.multiple) {
                        // Find all elements
                        const elements = await context.findElements(locator);
                        
                        // Filter by attribute if specified
                        if (options.attribute) {
                            const filteredElements: WebElement[] = [];
                            
                            for (const element of elements) {
                                const attrValue = await element.getAttribute(options.attribute);
                                
                                if (options.attributeValue) {
                                    if (attrValue === options.attributeValue) {
                                        filteredElements.push(element);
                                    }
                                } else if (attrValue !== null) {
                                    filteredElements.push(element);
                                }
                            }
                            
                            return filteredElements;
                        }
                        
                        // Filter by text if specified
                        if (options.text) {
                            const filteredElements: WebElement[] = [];
                            
                            for (const element of elements) {
                                const text = await element.getText();
                                
                                if (options.exactTextMatch) {
                                    if (text === options.text) {
                                        filteredElements.push(element);
                                    }
                                } else if (text.includes(options.text)) {
                                    filteredElements.push(element);
                                }
                            }
                            
                            return filteredElements;
                        }
                        
                        return elements;
                    } else {
                        // Handle element with index
                        if (options.index !== undefined && options.index >= 0) {
                            const elements = await context.findElements(locator);
                            
                            if (elements.length <= options.index) {
                                throw new ElementNotFoundException(
                                    `Element at index ${options.index} not found, only ${elements.length} elements available`
                                );
                            }
                            
                            return elements[options.index];
                        }
                        
                        // Wait for element if needed
                        if (options.waitForPresent) {
                            await this.driver.wait(
                                async () => (await context.findElements(locator)).length > 0,
                                options.waitTimeout || this.defaultTimeout,
                                `Timed out waiting for element to be present with locator: ${locator}`
                            );
                        }
                        
                        const element = await context.findElement(locator);
                        
                        if (options.waitForVisible) {
                            await this.driver.wait(
                                async () => await element.isDisplayed(),
                                options.waitTimeout || this.defaultTimeout,
                                `Timed out waiting for element to be visible with locator: ${locator}`
                            );
                        }
                        
                        if (options.waitForClickable) {
                            await this.driver.wait(
                                async () => {
                                    const isDisplayed = await element.isDisplayed();
                                    const isEnabled = await element.isEnabled();
                                    return isDisplayed && isEnabled;
                                },
                                options.waitTimeout || this.defaultTimeout,
                                `Timed out waiting for element to be clickable with locator: ${locator}`
                            );
                        }
                        
                        // Check attribute if specified
                        if (options.attribute) {
                            const attrValue = await element.getAttribute(options.attribute);
                            
                            if (options.attributeValue) {
                                if (attrValue !== options.attributeValue) {
                                    throw new ElementNotFoundException(
                                        `Element found but attribute ${options.attribute} value "${attrValue}" does not match expected "${options.attributeValue}"`
                                    );
                                }
                            } else if (attrValue === null) {
                                throw new ElementNotFoundException(
                                    `Element found but attribute ${options.attribute} does not exist`
                                );
                            }
                        }
                        
                        // Check text if specified
                        if (options.text) {
                            const text = await element.getText();
                            
                            if (options.exactTextMatch) {
                                if (text !== options.text) {
                                    throw new ElementNotFoundException(
                                        `Element found but text "${text}" does not match expected "${options.text}"`
                                    );
                                }
                            } else if (!text.includes(options.text)) {
                                throw new ElementNotFoundException(
                                    `Element found but text "${text}" does not contain "${options.text}"`
                                );
                            }
                        }
                        
                        return element;
                    }
                } catch (error) {
                    // Check if it's a StaleElementReferenceError
                    if (error.name === 'StaleElementReferenceError' && options.retryOnStale) {
                        lastError = error;
                        retries++;
                        
                        if (retries <= maxRetries) {
                            // Wait before retrying
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                            continue;
                        }
                    }
                    
                    // Propagate other errors or when max retries exceeded
                    throw error;
                }
            }
            
            // If we get here, we've exceeded retries
            throw lastError || new ElementNotFoundException('Max retries exceeded');
        } catch (error) {
            const desc = options.description || Object.entries(options)
                .filter(([key, value]) => value && ['id', 'css', 'xpath', 'name', 'linkText', 'partialLinkText', 'tagName', 'className'].includes(key))
                .map(([key, value]) => `${key}="${value}"`)
                .join(', ');
            
            throw new ElementNotFoundException(
                `Element not found: ${desc}. ${error.message}`,
                error
            );
        }
    }
    
    /**
     * Finds elements based on the provided options.
     * 
     * @param options The options for finding the elements
     * @returns Promise resolving to an array of WebElements
     */
    private async findElements(options: CSFindByOptions): Promise<WebElement[]> {
        // Use custom retriever if provided
        if (options.retriever) {
            const result = await options.retriever(this.driver);
            
            if (!result) {
                return [];
            }
            
            if (Array.isArray(result)) {
                return result;
            }
            
            return [result];
        }
        
        // Find in shadow DOM if specified
        if (options.shadow && options.shadowHost) {
            const result = await this.findElementInShadow(options);
            
            if (Array.isArray(result)) {
                return result;
            }
            
            return [result];
        }
        
        // Create locator
        const locator = this.createLocator(options);
        
        if (!locator) {
            return [];
        }
        
        const context = this.rootElement || this.driver;
        
        // Find elements
        const elements = await context.findElements(locator);
        
        // Filter by attribute if specified
        if (options.attribute) {
            const filteredElements: WebElement[] = [];
            
            for (const element of elements) {
                try {
                    const attrValue = await element.getAttribute(options.attribute);
                    
                    if (options.attributeValue) {
                        if (attrValue === options.attributeValue) {
                            filteredElements.push(element);
                        }
                    } else if (attrValue !== null) {
                        filteredElements.push(element);
                    }
                } catch (error) {
                    // Skip elements that cause errors
                    continue;
                }
            }
            
            return filteredElements;
        }
        
        // Filter by text if specified
        if (options.text) {
            const filteredElements: WebElement[] = [];
            
            for (const element of elements) {
                try {
                    const text = await element.getText();
                    
                    if (options.exactTextMatch) {
                        if (text === options.text) {
                            filteredElements.push(element);
                        }
                    } else if (text.includes(options.text)) {
                        filteredElements.push(element);
                    }
                } catch (error) {
                    // Skip elements that cause errors
                    continue;
                }
            }
            
            return filteredElements;
        }
        
        return elements;
    }
    
    /**
     * Creates a locator based on the provided options.
     * 
     * @param options The options for creating the locator
     * @returns The locator or null if no valid locator options are provided
     */
    private createLocator(options: CSFindByOptions): By | null {
        if (options.id) {
            return By.id(options.id);
        }
        
        if (options.css) {
            return By.css(options.css);
        }
        
        if (options.xpath) {
            return By.xpath(options.xpath);
        }
        
        if (options.name) {
            return By.name(options.name);
        }
        
        if (options.linkText) {
            return By.linkText(options.linkText);
        }
        
        if (options.partialLinkText) {
            return By.partialLinkText(options.partialLinkText);
        }
        
        if (options.tagName) {
            return By.tagName(options.tagName);
        }
        
        if (options.className) {
            return By.className(options.className);
        }
        
        return null;
    }
    
    /**
     * Finds an element within a shadow DOM.
     * 
     * @param options The options for finding the element
     * @returns Promise resolving to WebElement or array of WebElements
     * @throws ElementNotFoundException if the element cannot be found
     */
    private async findElementInShadow(options: CSFindByOptions): Promise<WebElement | WebElement[]> {
        if (!options.shadowHost) {
            throw new ElementNotFoundException('Shadow host selector not provided');
        }
        
        try {
            // Find the shadow host
            const shadowHost = await this.driver.findElement(By.css(options.shadowHost));
            
            // Create the shadow root query
            const selector = options.css || 
                (options.tagName ? options.tagName : '*') + 
                (options.className ? `.${options.className}` : '') +
                (options.id ? `#${options.id}` : '') +
                (options.name ? `[name="${options.name}"]` : '');
            
            if (!selector) {
                throw new ElementNotFoundException('No valid selector for shadow DOM query');
            }
            
            // Execute script to query within shadow DOM
            const result = await this.driver.executeScript<WebElement | WebElement[]>(
                `
                const shadowHost = arguments[0];
                const selector = arguments[1];
                const multiple = arguments[2];
                
                // Get the shadow root
                const shadowRoot = shadowHost.shadowRoot;
                
                if (!shadowRoot) {
                    throw new Error('No shadow root found on the specified host element');
                }
                
                // Query elements
                return multiple ? 
                    Array.from(shadowRoot.querySelectorAll(selector)) : 
                    shadowRoot.querySelector(selector);
                `,
                shadowHost,
                selector,
                options.multiple
            );
            
            if (!result) {
                throw new ElementNotFoundException(`No elements found in shadow DOM with selector: ${selector}`);
            }
            
            return result;
        } catch (error) {
            throw new ElementNotFoundException(`Failed to find element in shadow DOM: ${error.message}`, error);
        }
    }
    
    /**
     * Filters elements based on a locator.
     * 
     * @param elements The elements to filter
     * @param locator The locator to use for filtering
     * @param options The options for filtering
     * @returns Promise resolving to the filtered elements
     */
    private async filterElements(elements: WebElement[], locator: By, options: CSFindByOptions): Promise<WebElement[]> {
        const filteredElements: WebElement[] = [];
        
        for (const element of elements) {
            try {
                // For each element, find children matching the locator
                const matches = await element.findElements(locator);
                
                if (matches.length > 0) {
                    // Element has matching children, include it
                    filteredElements.push(element);
                }
            } catch (error) {
                // Skip elements that cause errors
                continue;
            }
        }
        
        return filteredElements;
    }
    
    /**
     * Wraps a WebElement or array of WebElements based on the provided options.
     * 
     * @param element The element or elements to wrap
     * @param options The options for wrapping
     * @returns CSElement, CSElementList, CSSelect, CSForm, CSTable, or the original element
     */
    private wrapElement(element: WebElement | WebElement[], options: any): any {
        if (Array.isArray(element)) {
            // Handle array of elements
            if (options.multiple !== false) {
                return new CSElementList(element);
            } else if (element.length > 0) {
                // If multiple is false but we got an array, take the first element
                element = element[0];
            } else {
                throw new ElementNotFoundException('No elements found');
            }
        }
        
        // Handle single element
        if (options.isSelect) {
            return new CSSelect(element as WebElement, options.elementOptions);
        }
        
        if (options.isForm) {
            return new CSForm(element as WebElement, options.elementOptions);
        }
        
        if (options.isTable) {
            return new CSTable(element as WebElement, options.elementOptions);
        }
        
        return new CSElement(element as WebElement);
    }
    
    /**
     * Creates a new instance of CSLocatorProcessor.
     * 
     * @param driver The WebDriver instance
     * @returns A new CSLocatorProcessor instance
     */
    public static create(driver: WebDriver): CSLocatorProcessor {
        return new CSLocatorProcessor(driver);
    }
    
    /**
     * Clears the locator metadata cache.
     */
    public static clearMetadataCache(): void {
        CSLocatorProcessor.metadataMap.clear();
        clearElementCache();
    }
    
    /**
     * Clears the locator metadata cache for a specific class.
     * 
     * @param pageObjectClass The page object class
     */
    public static clearMetadataCacheForClass(pageObjectClass: any): void {
        CSLocatorProcessor.metadataMap.delete(pageObjectClass);
    }
}


