com/cstestforge/framework/core/utils/CSDateUtils.java
----------------------------------------------------------

package com.cstestforge.framework.core.utils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utility class for date and time operations throughout the framework.
 * This class provides methods for date formatting, parsing, comparison, and manipulation.
 */
public class CSDateUtils {
    
    // Common date format patterns
    public static final String ISO_DATE_FORMAT = "yyyy-MM-dd";
    public static final String ISO_DATE_TIME_FORMAT = "yyyy-MM-dd'T'HH:mm:ss";
    public static final String ISO_DATE_TIME_MS_FORMAT = "yyyy-MM-dd'T'HH:mm:ss.SSS";
    public static final String ISO_DATE_TIME_TZ_FORMAT = "yyyy-MM-dd'T'HH:mm:ssXXX";
    public static final String ISO_DATE_TIME_MS_TZ_FORMAT = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX";
    public static final String DEFAULT_DATE_FORMAT = "MM/dd/yyyy";
    public static final String DEFAULT_DATE_TIME_FORMAT = "MM/dd/yyyy HH:mm:ss";
    public static final String LOG_DATE_FORMAT = "yyyy-MM-dd HH:mm:ss.SSS";
    public static final String FILE_NAME_DATE_FORMAT = "yyyyMMdd_HHmmss";
    
    // Regular expressions for date pattern detection
    private static final Pattern ISO_DATE_PATTERN = Pattern.compile(
            "^\\d{4}-\\d{2}-\\d{2}$");
    private static final Pattern ISO_DATE_TIME_PATTERN = Pattern.compile(
            "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d{1,3})?(?:Z|[+-]\\d{2}:?\\d{2})?$");
    private static final Pattern US_DATE_PATTERN = Pattern.compile(
            "^\\d{1,2}/\\d{1,2}/\\d{4}$");
    private static final Pattern US_DATE_TIME_PATTERN = Pattern.compile(
            "^\\d{1,2}/\\d{1,2}/\\d{4}\\s+\\d{1,2}:\\d{1,2}(?::\\d{1,2})?(?:\\s*[AaPp][Mm])?$");
    private static final Pattern EU_DATE_PATTERN = Pattern.compile(
            "^\\d{1,2}\\.\\d{1,2}\\.\\d{4}$");
    private static final Pattern EU_DATE_TIME_PATTERN = Pattern.compile(
            "^\\d{1,2}\\.\\d{1,2}\\.\\d{4}\\s+\\d{1,2}:\\d{1,2}(?::\\d{1,2})?$");
    
    // Cache for date formatters (thread-safe)
    private static final ConcurrentHashMap<String, DateTimeFormatter> FORMATTER_CACHE = 
            new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<String, SimpleDateFormat> SIMPLE_FORMATTER_CACHE = 
            new ConcurrentHashMap<>();
    
    /**
     * Gets the current date as a string in the default format.
     *
     * @return The current date as a string
     */
    public static String getCurrentDate() {
        return getCurrentDate(DEFAULT_DATE_FORMAT);
    }
    
    /**
     * Gets the current date as a string in the specified format.
     *
     * @param format The date format pattern
     * @return The current date as a string
     */
    public static String getCurrentDate(String format) {
        return formatDate(new Date(), format);
    }
    
    /**
     * Gets the current date and time as a string in the default format.
     *
     * @return The current date and time as a string
     */
    public static String getCurrentDateTime() {
        return getCurrentDate(DEFAULT_DATE_TIME_FORMAT);
    }
    
    /**
     * Gets the current date and time for file names (without special characters).
     *
     * @return The current date and time as a string suitable for file names
     */
    public static String getFileNameTimestamp() {
        return getCurrentDate(FILE_NAME_DATE_FORMAT);
    }
    
    /**
     * Gets the current date and time for logging.
     *
     * @return The current date and time as a string suitable for logs
     */
    public static String getLogTimestamp() {
        return getCurrentDate(LOG_DATE_FORMAT);
    }
    
    /**
     * Formats a date object using the specified format.
     *
     * @param date The date to format
     * @param format The date format pattern
     * @return The formatted date string
     */
    public static String formatDate(Date date, String format) {
        if (date == null) {
            return null;
        }
        
        SimpleDateFormat formatter = getSimpleDateFormat(format);
        return formatter.format(date);
    }
    
    /**
     * Formats a LocalDate object using the specified format.
     *
     * @param date The LocalDate to format
     * @param format The date format pattern
     * @return The formatted date string
     */
    public static String formatDate(LocalDate date, String format) {
        if (date == null) {
            return null;
        }
        
        DateTimeFormatter formatter = getDateTimeFormatter(format);
        return date.format(formatter);
    }
    
    /**
     * Formats a LocalDateTime object using the specified format.
     *
     * @param dateTime The LocalDateTime to format
     * @param format The date format pattern
     * @return The formatted date string
     */
    public static String formatDateTime(LocalDateTime dateTime, String format) {
        if (dateTime == null) {
            return null;
        }
        
        DateTimeFormatter formatter = getDateTimeFormatter(format);
        return dateTime.format(formatter);
    }
    
    /**
     * Formats a ZonedDateTime object using the specified format.
     *
     * @param dateTime The ZonedDateTime to format
     * @param format The date format pattern
     * @return The formatted date string
     */
    public static String formatDateTime(ZonedDateTime dateTime, String format) {
        if (dateTime == null) {
            return null;
        }
        
        DateTimeFormatter formatter = getDateTimeFormatter(format);
        return dateTime.format(formatter);
    }
    
    /**
     * Parses a date string using the specified format.
     *
     * @param dateStr The date string to parse
     * @param format The date format pattern
     * @return The parsed Date object
     * @throws ParseException If the date string cannot be parsed
     */
    public static Date parseDate(String dateStr, String format) throws ParseException {
        if (dateStr == null || dateStr.isEmpty()) {
            return null;
        }
        
        SimpleDateFormat formatter = getSimpleDateFormat(format);
        return formatter.parse(dateStr);
    }
    
    /**
     * Parses a date string using the specified format.
     *
     * @param dateStr The date string to parse
     * @param format The date format pattern
     * @return The parsed LocalDate object
     * @throws DateTimeParseException If the date string cannot be parsed
     */
    public static LocalDate parseLocalDate(String dateStr, String format) {
        if (dateStr == null || dateStr.isEmpty()) {
            return null;
        }
        
        DateTimeFormatter formatter = getDateTimeFormatter(format);
        return LocalDate.parse(dateStr, formatter);
    }
    
    /**
     * Parses a date and time string using the specified format.
     *
     * @param dateTimeStr The date and time string to parse
     * @param format The date format pattern
     * @return The parsed LocalDateTime object
     * @throws DateTimeParseException If the date string cannot be parsed
     */
    public static LocalDateTime parseLocalDateTime(String dateTimeStr, String format) {
        if (dateTimeStr == null || dateTimeStr.isEmpty()) {
            return null;
        }
        
        DateTimeFormatter formatter = getDateTimeFormatter(format);
        return LocalDateTime.parse(dateTimeStr, formatter);
    }
    
    /**
     * Parses a date and time string with timezone using the specified format.
     *
     * @param dateTimeStr The date and time string to parse
     * @param format The date format pattern
     * @return The parsed ZonedDateTime object
     * @throws DateTimeParseException If the date string cannot be parsed
     */
    public static ZonedDateTime parseZonedDateTime(String dateTimeStr, String format) {
        if (dateTimeStr == null || dateTimeStr.isEmpty()) {
            return null;
        }
        
        DateTimeFormatter formatter = getDateTimeFormatter(format);
        return ZonedDateTime.parse(dateTimeStr, formatter);
    }
    
    /**
     * Attempts to parse a date string by auto-detecting its format.
     *
     * @param dateStr The date string to parse
     * @return The parsed Date object
     * @throws ParseException If the date string cannot be parsed
     */
    public static Date autoParseDate(String dateStr) throws ParseException {
        if (dateStr == null || dateStr.isEmpty()) {
            return null;
        }
        
        // Try ISO format (yyyy-MM-dd)
        if (ISO_DATE_PATTERN.matcher(dateStr).matches()) {
            return parseDate(dateStr, ISO_DATE_FORMAT);
        }
        
        // Try ISO datetime format
        if (ISO_DATE_TIME_PATTERN.matcher(dateStr).matches()) {
            // Try different ISO datetime formats
            try {
                return Date.from(Instant.parse(dateStr));
            } catch (DateTimeParseException e) {
                // Try other ISO formats
                for (String format : new String[]{
                        ISO_DATE_TIME_FORMAT, 
                        ISO_DATE_TIME_MS_FORMAT,
                        ISO_DATE_TIME_TZ_FORMAT,
                        ISO_DATE_TIME_MS_TZ_FORMAT}) {
                    try {
                        return parseDate(dateStr, format);
                    } catch (ParseException ex) {
                        // Continue trying other formats
                    }
                }
            }
        }
        
        // Try US format (MM/dd/yyyy)
        if (US_DATE_PATTERN.matcher(dateStr).matches()) {
            return parseDate(dateStr, DEFAULT_DATE_FORMAT);
        }
        
        // Try US datetime format (MM/dd/yyyy HH:mm:ss)
        if (US_DATE_TIME_PATTERN.matcher(dateStr).matches()) {
            // Check if AM/PM is included
            if (dateStr.toUpperCase().endsWith("AM") || dateStr.toUpperCase().endsWith("PM")) {
                return parseDate(dateStr, "MM/dd/yyyy hh:mm:ss a");
            } else {
                return parseDate(dateStr, DEFAULT_DATE_TIME_FORMAT);
            }
        }
        
        // Try European format (dd.MM.yyyy)
        if (EU_DATE_PATTERN.matcher(dateStr).matches()) {
            return parseDate(dateStr, "dd.MM.yyyy");
        }
        
        // Try European datetime format (dd.MM.yyyy HH:mm:ss)
        if (EU_DATE_TIME_PATTERN.matcher(dateStr).matches()) {
            return parseDate(dateStr, "dd.MM.yyyy HH:mm:ss");
        }
        
        // If no pattern matches, try the default format as a last resort
        return parseDate(dateStr, DEFAULT_DATE_FORMAT);
    }
    
    /**
     * Adds a specified number of days to a date.
     *
     * @param date The date to add days to
     * @param days The number of days to add
     * @return The new date with added days
     */
    public static Date addDays(Date date, int days) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(Calendar.DAY_OF_MONTH, days);
        return calendar.getTime();
    }
    
    /**
     * Adds a specified number of hours to a date.
     *
     * @param date The date to add hours to
     * @param hours The number of hours to add
     * @return The new date with added hours
     */
    public static Date addHours(Date date, int hours) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(Calendar.HOUR_OF_DAY, hours);
        return calendar.getTime();
    }
    
    /**
     * Adds a specified number of minutes to a date.
     *
     * @param date The date to add minutes to
     * @param minutes The number of minutes to add
     * @return The new date with added minutes
     */
    public static Date addMinutes(Date date, int minutes) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(Calendar.MINUTE, minutes);
        return calendar.getTime();
    }
    
    /**
     * Adds a specified number of seconds to a date.
     *
     * @param date The date to add seconds to
     * @param seconds The number of seconds to add
     * @return The new date with added seconds
     */
    public static Date addSeconds(Date date, int seconds) {
        if (date == null) {
            return null;
        }
        
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(Calendar.SECOND, seconds);
        return calendar.getTime();
    }
    
    /**
     * Adds a specified number of days to a LocalDate.
     *
     * @param date The LocalDate to add days to
     * @param days The number of days to add
     * @return The new LocalDate with added days
     */
    public static LocalDate addDays(LocalDate date, int days) {
        if (date == null) {
            return null;
        }
        
        return date.plusDays(days);
    }
    
    /**
     * Adds a specified number of days to a LocalDateTime.
     *
     * @param dateTime The LocalDateTime to add days to
     * @param days The number of days to add
     * @return The new LocalDateTime with added days
     */
    public static LocalDateTime addDays(LocalDateTime dateTime, int days) {
        if (dateTime == null) {
            return null;
        }
        
        return dateTime.plusDays(days);
    }
    
    /**
     * Adds a specified number of hours to a LocalDateTime.
     *
     * @param dateTime The LocalDateTime to add hours to
     * @param hours The number of hours to add
     * @return The new LocalDateTime with added hours
     */
    public static LocalDateTime addHours(LocalDateTime dateTime, int hours) {
        if (dateTime == null) {
            return null;
        }
        
        return dateTime.plusHours(hours);
    }
    
    /**
     * Adds a specified number of minutes to a LocalDateTime.
     *
     * @param dateTime The LocalDateTime to add minutes to
     * @param minutes The number of minutes to add
     * @return The new LocalDateTime with added minutes
     */
    public static LocalDateTime addMinutes(LocalDateTime dateTime, int minutes) {
        if (dateTime == null) {
            return null;
        }
        
        return dateTime.plusMinutes(minutes);
    }
    
    /**
     * Adds a specified number of seconds to a LocalDateTime.
     *
     * @param dateTime The LocalDateTime to add seconds to
     * @param seconds The number of seconds to add
     * @return The new LocalDateTime with added seconds
     */
    public static LocalDateTime addSeconds(LocalDateTime dateTime, int seconds) {
        if (dateTime == null) {
            return null;
        }
        
        return dateTime.plusSeconds(seconds);
    }
    
    /**
     * Gets the difference in days between two dates.
     *
     * @param date1 The first date
     * @param date2 The second date
     * @return The difference in days
     */
    public static long getDaysBetween(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            throw new IllegalArgumentException("Dates cannot be null");
        }
        
        LocalDate localDate1 = date1.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        LocalDate localDate2 = date2.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        
        return ChronoUnit.DAYS.between(localDate1, localDate2);
    }
    
    /**
     * Gets the difference in days between two LocalDate objects.
     *
     * @param date1 The first LocalDate
     * @param date2 The second LocalDate
     * @return The difference in days
     */
    public static long getDaysBetween(LocalDate date1, LocalDate date2) {
        if (date1 == null || date2 == null) {
            throw new IllegalArgumentException("Dates cannot be null");
        }
        
        return ChronoUnit.DAYS.between(date1, date2);
    }
    
    /**
     * Gets the difference in hours between two LocalDateTime objects.
     *
     * @param dateTime1 The first LocalDateTime
     * @param dateTime2 The second LocalDateTime
     * @return The difference in hours
     */
    public static long getHoursBetween(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (dateTime1 == null || dateTime2 == null) {
            throw new IllegalArgumentException("DateTimes cannot be null");
        }
        
        return ChronoUnit.HOURS.between(dateTime1, dateTime2);
    }
    
    /**
     * Gets the difference in minutes between two LocalDateTime objects.
     *
     * @param dateTime1 The first LocalDateTime
     * @param dateTime2 The second LocalDateTime
     * @return The difference in minutes
     */
    public static long getMinutesBetween(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (dateTime1 == null || dateTime2 == null) {
            throw new IllegalArgumentException("DateTimes cannot be null");
        }
        
        return ChronoUnit.MINUTES.between(dateTime1, dateTime2);
    }
    
    /**
     * Gets the difference in seconds between two LocalDateTime objects.
     *
     * @param dateTime1 The first LocalDateTime
     * @param dateTime2 The second LocalDateTime
     * @return The difference in seconds
     */
    public static long getSecondsBetween(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (dateTime1 == null || dateTime2 == null) {
            throw new IllegalArgumentException("DateTimes cannot be null");
        }
        
        return ChronoUnit.SECONDS.between(dateTime1, dateTime2);
    }
    
    /**
     * Gets the difference in milliseconds between two LocalDateTime objects.
     *
     * @param dateTime1 The first LocalDateTime
     * @param dateTime2 The second LocalDateTime
     * @return The difference in milliseconds
     */
    public static long getMillisBetween(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (dateTime1 == null || dateTime2 == null) {
            throw new IllegalArgumentException("DateTimes cannot be null");
        }
        
        return ChronoUnit.MILLIS.between(dateTime1, dateTime2);
    }
    
    /**
     * Converts a Date to a LocalDate.
     *
     * @param date The Date to convert
     * @return The converted LocalDate
     */
    public static LocalDate toLocalDate(Date date) {
        if (date == null) {
            return null;
        }
        
        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
    }
    
    /**
     * Converts a Date to a LocalDateTime.
     *
     * @param date The Date to convert
     * @return The converted LocalDateTime
     */
    public static LocalDateTime toLocalDateTime(Date date) {
        if (date == null) {
            return null;
        }
        
        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
    }
    
    /**
     * Converts a LocalDate to a Date.
     *
     * @param localDate The LocalDate to convert
     * @return The converted Date
     */
    public static Date toDate(LocalDate localDate) {
        if (localDate == null) {
            return null;
        }
        
        return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());
    }
    
    /**
     * Converts a LocalDateTime to a Date.
     *
     * @param localDateTime The LocalDateTime to convert
     * @return The converted Date
     */
    public static Date toDate(LocalDateTime localDateTime) {
        if (localDateTime == null) {
            return null;
        }
        
        return Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());
    }
    
    /**
     * Formats a duration in milliseconds to a human-readable string (e.g., "2h 3m 45s").
     *
     * @param durationMillis The duration in milliseconds
     * @return The formatted duration string
     */
    public static String formatDuration(long durationMillis) {
        if (durationMillis < 0) {
            return "0s";
        }
        
        Duration duration = Duration.ofMillis(durationMillis);
        
        long hours = duration.toHours();
        long minutes = duration.toMinutesPart();
        long seconds = duration.toSecondsPart();
        long millis = duration.toMillisPart();
        
        StringBuilder sb = new StringBuilder();
        
        if (hours > 0) {
            sb.append(hours).append("h ");
        }
        
        if (hours > 0 || minutes > 0) {
            sb.append(minutes).append("m ");
        }
        
        if (hours > 0 || minutes > 0 || seconds > 0) {
            sb.append(seconds).append("s");
        } else {
            sb.append(millis).append("ms");
        }
        
        return sb.toString().trim();
    }
    
    /**
     * Gets a DateTimeFormatter for the specified format pattern.
     *
     * @param format The date format pattern
     * @return The DateTimeFormatter
     */
    private static DateTimeFormatter getDateTimeFormatter(String format) {
        return FORMATTER_CACHE.computeIfAbsent(format, DateTimeFormatter::ofPattern);
    }
    
    /**
     * Gets a SimpleDateFormat for the specified format pattern.
     *
     * @param format The date format pattern
     * @return The SimpleDateFormat
     */
    private static SimpleDateFormat getSimpleDateFormat(String format) {
        return SIMPLE_FORMATTER_CACHE.computeIfAbsent(format, pattern -> {
            SimpleDateFormat formatter = new SimpleDateFormat(pattern, Locale.US);
            formatter.setTimeZone(TimeZone.getDefault());
            return formatter;
        });
    }
}


com/cstestforge/framework/core/utils/CSFileUtils.java
------------------------------------------------------

package com.cstestforge.framework.core.utils;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.UUID;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

/**
 * Utility class for file operations throughout the framework.
 * This class provides methods for file handling, manipulation, compression, and content operations.
 */
public class CSFileUtils {
    
    // Default buffer size for file operations
    private static final int DEFAULT_BUFFER_SIZE = 8192;
    
    // Default character encoding
    private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
    
    /**
     * Creates a new file if it doesn't exist already.
     *
     * @param filePath The path of the file to create
     * @return true if the file was created, false if it already existed
     * @throws IOException If an I/O error occurs
     */
    public static boolean createFileIfNotExists(String filePath) throws IOException {
        File file = new File(filePath);
        if (!file.exists()) {
            // Create parent directories if they don't exist
            File parent = file.getParentFile();
            if (parent != null && !parent.exists()) {
                parent.mkdirs();
            }
            return file.createNewFile();
        }
        return false;
    }
    
    /**
     * Creates a new directory if it doesn't exist already.
     *
     * @param dirPath The path of the directory to create
     * @return true if the directory was created, false if it already existed
     */
    public static boolean createDirectoryIfNotExists(String dirPath) {
        File dir = new File(dirPath);
        if (!dir.exists()) {
            return dir.mkdirs();
        }
        return false;
    }
    
    /**
     * Deletes a file or directory.
     *
     * @param path The path of the file or directory to delete
     * @return true if the file or directory was deleted, false otherwise
     */
    public static boolean delete(String path) {
        File file = new File(path);
        
        if (!file.exists()) {
            return false;
        }
        
        if (file.isDirectory()) {
            return deleteDirectory(file);
        } else {
            return file.delete();
        }
    }
    
    /**
     * Recursively deletes a directory and all its contents.
     *
     * @param directory The directory to delete
     * @return true if the directory was deleted, false otherwise
     */
    public static boolean deleteDirectory(File directory) {
        if (directory == null || !directory.exists() || !directory.isDirectory()) {
            return false;
        }
        
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    deleteDirectory(file);
                } else {
                    file.delete();
                }
            }
        }
        
        return directory.delete();
    }
    
    /**
     * Lists files in a directory with an optional extension filter.
     *
     * @param dirPath The directory path
     * @param extension The extension to filter by, or null for all files
     * @param recursive Whether to search recursively
     * @return A list of files
     */
    public static List<File> listFiles(String dirPath, String extension, boolean recursive) {
        File dir = new File(dirPath);
        List<File> fileList = new ArrayList<>();
        
        if (!dir.exists() || !dir.isDirectory()) {
            return fileList;
        }
        
        listFilesInternal(dir, extension, recursive, fileList);
        
        return fileList;
    }
    
    /**
     * Internal method to recursively list files.
     *
     * @param dir The directory to list files from
     * @param extension The extension to filter by, or null for all files
     * @param recursive Whether to search recursively
     * @param fileList The list to add files to
     */
    private static void listFilesInternal(File dir, String extension, boolean recursive, List<File> fileList) {
        File[] files = dir.listFiles();
        
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory() && recursive) {
                    listFilesInternal(file, extension, true, fileList);
                } else if (file.isFile()) {
                    if (extension == null || file.getName().toLowerCase().endsWith("." + extension.toLowerCase())) {
                        fileList.add(file);
                    }
                }
            }
        }
    }
    
    /**
     * Copies a file from one location to another.
     *
     * @param sourcePath The source file path
     * @param destPath The destination file path
     * @param overwrite Whether to overwrite the destination file if it exists
     * @throws IOException If an I/O error occurs
     */
    public static void copyFile(String sourcePath, String destPath, boolean overwrite) throws IOException {
        File sourceFile = new File(sourcePath);
        File destFile = new File(destPath);
        
        if (!sourceFile.exists()) {
            throw new IOException("Source file does not exist: " + sourcePath);
        }
        
        if (destFile.exists() && !overwrite) {
            throw new IOException("Destination file already exists: " + destPath);
        }
        
        // Create parent directories if needed
        File destParent = destFile.getParentFile();
        if (destParent != null && !destParent.exists()) {
            destParent.mkdirs();
        }
        
        // Use NIO for efficient file copy
        Path source = sourceFile.toPath();
        Path dest = destFile.toPath();
        
        if (overwrite) {
            Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING);
        } else {
            Files.copy(source, dest);
        }
    }
    
    /**
     * Moves a file from one location to another.
     *
     * @param sourcePath The source file path
     * @param destPath The destination file path
     * @param overwrite Whether to overwrite the destination file if it exists
     * @throws IOException If an I/O error occurs
     */
    public static void moveFile(String sourcePath, String destPath, boolean overwrite) throws IOException {
        File sourceFile = new File(sourcePath);
        File destFile = new File(destPath);
        
        if (!sourceFile.exists()) {
            throw new IOException("Source file does not exist: " + sourcePath);
        }
        
        if (destFile.exists() && !overwrite) {
            throw new IOException("Destination file already exists: " + destPath);
        }
        
        // Create parent directories if needed
        File destParent = destFile.getParentFile();
        if (destParent != null && !destParent.exists()) {
            destParent.mkdirs();
        }
        
        // Use NIO for efficient file move
        Path source = sourceFile.toPath();
        Path dest = destFile.toPath();
        
        if (overwrite) {
            Files.move(source, dest, StandardCopyOption.REPLACE_EXISTING);
        } else {
            Files.move(source, dest);
        }
    }
    
    /**
     * Reads a file as text using the default charset.
     *
     * @param filePath The file path
     * @return The file content as a string
     * @throws IOException If an I/O error occurs
     */
    public static String readFileAsString(String filePath) throws IOException {
        return readFileAsString(filePath, DEFAULT_CHARSET);
    }
    
    /**
     * Reads a file as text using the specified charset.
     *
     * @param filePath The file path
     * @param charset The charset to use
     * @return The file content as a string
     * @throws IOException If an I/O error occurs
     */
    public static String readFileAsString(String filePath, Charset charset) throws IOException {
        File file = new File(filePath);
        
        if (!file.exists()) {
            throw new IOException("File does not exist: " + filePath);
        }
        
        return Files.readString(file.toPath(), charset);
    }
    
    /**
     * Reads a file as bytes.
     *
     * @param filePath The file path
     * @return The file content as a byte array
     * @throws IOException If an I/O error occurs
     */
    public static byte[] readFileAsBytes(String filePath) throws IOException {
        File file = new File(filePath);
        
        if (!file.exists()) {
            throw new IOException("File does not exist: " + filePath);
        }
        
        return Files.readAllBytes(file.toPath());
    }
    
    /**
     * Reads a file as a list of lines.
     *
     * @param filePath The file path
     * @return The file content as a list of lines
     * @throws IOException If an I/O error occurs
     */
    public static List<String> readFileAsLines(String filePath) throws IOException {
        return readFileAsLines(filePath, DEFAULT_CHARSET);
    }
    
    /**
     * Reads a file as a list of lines using the specified charset.
     *
     * @param filePath The file path
     * @param charset The charset to use
     * @return The file content as a list of lines
     * @throws IOException If an I/O error occurs
     */
    public static List<String> readFileAsLines(String filePath, Charset charset) throws IOException {
        File file = new File(filePath);
        
        if (!file.exists()) {
            throw new IOException("File does not exist: " + filePath);
        }
        
        return Files.readAllLines(file.toPath(), charset);
    }
    
    /**
     * Writes a string to a file using the default charset.
     *
     * @param content The content to write
     * @param filePath The file path
     * @param append Whether to append to the file if it exists
     * @throws IOException If an I/O error occurs
     */
    public static void writeStringToFile(String content, String filePath, boolean append) throws IOException {
        writeStringToFile(content, filePath, DEFAULT_CHARSET, append);
    }
    
    /**
     * Writes a string to a file using the specified charset.
     *
     * @param content The content to write
     * @param filePath The file path
     * @param charset The charset to use
     * @param append Whether to append to the file if it exists
     * @throws IOException If an I/O error occurs
     */
    public static void writeStringToFile(String content, String filePath, Charset charset, boolean append) 
            throws IOException {
        File file = new File(filePath);
        
        // Create parent directories if needed
        File parent = file.getParentFile();
        if (parent != null && !parent.exists()) {
            parent.mkdirs();
        }
        
        // Use NIO for efficient write
        Path path = file.toPath();
        
        if (append && file.exists()) {
            Files.writeString(path, content, charset, java.nio.file.StandardOpenOption.APPEND);
        } else {
            Files.writeString(path, content, charset);
        }
    }
    
    /**
     * Writes bytes to a file.
     *
     * @param content The content to write
     * @param filePath The file path
     * @param append Whether to append to the file if it exists
     * @throws IOException If an I/O error occurs
     */
    public static void writeBytesToFile(byte[] content, String filePath, boolean append) throws IOException {
        File file = new File(filePath);
        
        // Create parent directories if needed
        File parent = file.getParentFile();
        if (parent != null && !parent.exists()) {
            parent.mkdirs();
        }
        
        // Use try-with-resources for auto-closing
        try (FileOutputStream fos = new FileOutputStream(file, append);
             BufferedOutputStream bos = new BufferedOutputStream(fos)) {
            bos.write(content);
            bos.flush();
        }
    }
    
    /**
     * Writes lines to a file using the default charset.
     *
     * @param lines The lines to write
     * @param filePath The file path
     * @param append Whether to append to the file if it exists
     * @throws IOException If an I/O error occurs
     */
    public static void writeLinesToFile(List<String> lines, String filePath, boolean append) throws IOException {
        writeLinesToFile(lines, filePath, DEFAULT_CHARSET, append);
    }
    
    /**
     * Writes lines to a file using the specified charset.
     *
     * @param lines The lines to write
     * @param filePath The file path
     * @param charset The charset to use
     * @param append Whether to append to the file if it exists
     * @throws IOException If an I/O error occurs
     */
    public static void writeLinesToFile(List<String> lines, String filePath, Charset charset, boolean append) 
            throws IOException {
        File file = new File(filePath);
        
        // Create parent directories if needed
        File parent = file.getParentFile();
        if (parent != null && !parent.exists()) {
            parent.mkdirs();
        }
        
        // Use try-with-resources for auto-closing
        try (FileWriter fw = new FileWriter(file, charset, append);
             BufferedWriter bw = new BufferedWriter(fw)) {
            
            for (String line : lines) {
                bw.write(line);
                bw.newLine();
            }
            
            bw.flush();
        }
    }
    
    /**
     * Calculates the MD5 hash of a file.
     *
     * @param filePath The file path
     * @return The MD5 hash as a hex string
     * @throws IOException If an I/O error occurs
     * @throws NoSuchAlgorithmException If the MD5 algorithm is not available
     */
    public static String getFileMd5(String filePath) throws IOException, NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("MD5");
        
        try (FileInputStream fis = new FileInputStream(filePath);
             DigestInputStream dis = new DigestInputStream(fis, md)) {
            
            byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
            while (dis.read(buffer) != -1) {
                // Read the entire file
            }
        }
        
        byte[] digest = md.digest();
        
        // Convert to hex string
        StringBuilder sb = new StringBuilder();
        for (byte b : digest) {
            sb.append(String.format("%02x", b));
        }
        
        return sb.toString();
    }
    
    /**
     * Compresses a file using ZIP.
     *
     * @param sourcePath The source file or directory path
     * @param zipPath The path for the ZIP file
     * @throws IOException If an I/O error occurs
     */
    public static void compressToZip(String sourcePath, String zipPath) throws IOException {
        File sourceFile = new File(sourcePath);
        File zipFile = new File(zipPath);
        
        if (!sourceFile.exists()) {
            throw new IOException("Source file or directory does not exist: " + sourcePath);
        }
        
        // Create parent directories if needed
        File zipParent = zipFile.getParentFile();
        if (zipParent != null && !zipParent.exists()) {
            zipParent.mkdirs();
        }
        
        try (FileOutputStream fos = new FileOutputStream(zipFile);
             ZipOutputStream zos = new ZipOutputStream(new BufferedOutputStream(fos))) {
            
            if (sourceFile.isDirectory()) {
                compressDirectoryToZip(sourceFile, sourceFile.getName(), zos);
            } else {
                compressFileToZip(sourceFile, "", zos);
            }
        }
    }
    
    /**
     * Compresses a file to a ZIP entry.
     *
     * @param file The file to compress
     * @param path The path within the ZIP
     * @param zos The ZIP output stream
     * @throws IOException If an I/O error occurs
     */
    private static void compressFileToZip(File file, String path, ZipOutputStream zos) throws IOException {
        if (!file.exists()) {
            return;
        }
        
        String zipEntryName = path.isEmpty() ? file.getName() : path + "/" + file.getName();
        
        try (FileInputStream fis = new FileInputStream(file);
             BufferedInputStream bis = new BufferedInputStream(fis)) {
            
            ZipEntry zipEntry = new ZipEntry(zipEntryName);
            zos.putNextEntry(zipEntry);
            
            byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
            int bytesRead;
            
            while ((bytesRead = bis.read(buffer)) != -1) {
                zos.write(buffer, 0, bytesRead);
            }
            
            zos.closeEntry();
        }
    }
    
    /**
     * Compresses a directory to a ZIP file.
     *
     * @param directory The directory to compress
     * @param path The path within the ZIP
     * @param zos The ZIP output stream
     * @throws IOException If an I/O error occurs
     */
    private static void compressDirectoryToZip(File directory, String path, ZipOutputStream zos) throws IOException {
        File[] files = directory.listFiles();
        
        if (files == null) {
            return;
        }
        
        for (File file : files) {
            if (file.isDirectory()) {
                compressDirectoryToZip(file, path + "/" + file.getName(), zos);
            } else {
                compressFileToZip(file, path, zos);
            }
        }
    }
    
    /**
     * Extracts a ZIP file to a directory.
     *
     * @param zipPath The path to the ZIP file
     * @param destPath The destination directory path
     * @throws IOException If an I/O error occurs
     */
    public static void extractZip(String zipPath, String destPath) throws IOException {
        File zipFile = new File(zipPath);
        File destDir = new File(destPath);
        
        if (!zipFile.exists()) {
            throw new IOException("ZIP file does not exist: " + zipPath);
        }
        
        // Create destination directory if it doesn't exist
        if (!destDir.exists()) {
            destDir.mkdirs();
        }
        
        try (FileInputStream fis = new FileInputStream(zipFile);
             ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis))) {
            
            ZipEntry entry;
            
            while ((entry = zis.getNextEntry()) != null) {
                String entryName = entry.getName();
                File entryFile = new File(destDir, entryName);
                
                // Create parent directories if needed
                File entryParent = entryFile.getParentFile();
                if (entryParent != null && !entryParent.exists()) {
                    entryParent.mkdirs();
                }
                
                if (entry.isDirectory()) {
                    entryFile.mkdirs();
                } else {
                    // Extract file
                    try (FileOutputStream fos = new FileOutputStream(entryFile);
                         BufferedOutputStream bos = new BufferedOutputStream(fos)) {
                        
                        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
                        int bytesRead;
                        
                        while ((bytesRead = zis.read(buffer)) != -1) {
                            bos.write(buffer, 0, bytesRead);
                        }
                        
                        bos.flush();
                    }
                }
                
                zis.closeEntry();
            }
        }
    }
    
    /**
     * Gets a file lock for file access synchronization.
     *
     * @param filePath The file path
     * @param shared Whether the lock should be shared (read) or exclusive (write)
     * @return The file channel and lock
     * @throws IOException If an I/O error occurs
     */
    public static FileLockWrapper getFileLock(String filePath, boolean shared) throws IOException {
        File file = new File(filePath);
        
        // Create parent directories if needed
        File parent = file.getParentFile();
        if (parent != null && !parent.exists()) {
            parent.mkdirs();
        }
        
        // Create the file if it doesn't exist
        if (!file.exists()) {
            file.createNewFile();
        }
        
        RandomAccessFile raf = new RandomAccessFile(file, shared ? "r" : "rw");
        FileChannel channel = raf.getChannel();
        FileLock lock = channel.lock(0, Long.MAX_VALUE, shared);
        
        return new FileLockWrapper(channel, lock, raf);
    }
    
    /**
     * Wrapper class for file lock resources.
     */
    public static class FileLockWrapper implements AutoCloseable {
        private final FileChannel channel;
        private final FileLock lock;
        private final RandomAccessFile raf;
        
        /**
         * Constructs a new FileLockWrapper.
         *
         * @param channel The file channel
         * @param lock The file lock
         * @param raf The random access file
         */
        public FileLockWrapper(FileChannel channel, FileLock lock, RandomAccessFile raf) {
            this.channel = channel;
            this.lock = lock;
            this.raf = raf;
        }
        
        /**
         * Gets the file channel.
         *
         * @return The file channel
         */
        public FileChannel getChannel() {
            return channel;
        }
        
        /**
         * Gets the file lock.
         *
         * @return The file lock
         */
        public FileLock getLock() {
            return lock;
        }
        
        /**
         * Gets the random access file.
         *
         * @return The random access file
         */
        public RandomAccessFile getRandomAccessFile() {
            return raf;
        }
        
        /**
         * Releases the lock and closes resources.
         *
         * @throws IOException If an I/O error occurs
         */
        @Override
        public void close() throws IOException {
            if (lock != null && lock.isValid()) {
                lock.release();
            }
            
            if (channel != null && channel.isOpen()) {
                channel.close();
            }
            
            if (raf != null) {
                raf.close();
            }
        }
    }
    
    /**
     * Encodes a file to Base64.
     *
     * @param filePath The file path
     * @return The Base64-encoded string
     * @throws IOException If an I/O error occurs
     */
    public static String fileToBase64(String filePath) throws IOException {
        byte[] fileBytes = readFileAsBytes(filePath);
        return Base64.getEncoder().encodeToString(fileBytes);
    }
    
    /**
     * Saves a Base64-encoded string to a file.
     *
     * @param base64Content The Base64-encoded content
     * @param filePath The file path
     * @throws IOException If an I/O error occurs
     */
    public static void base64ToFile(String base64Content, String filePath) throws IOException {
        byte[] decodedBytes = Base64.getDecoder().decode(base64Content);
        writeBytesToFile(decodedBytes, filePath, false);
    }
    
    /**
     * Creates a temporary file.
     *
     * @param prefix The file name prefix
     * @param suffix The file name suffix
     * @return The temporary file
     * @throws IOException If an I/O error occurs
     */
    public static File createTempFile(String prefix, String suffix) throws IOException {
        if (prefix == null || prefix.isEmpty()) {
            prefix = "cstestforge_";
        }
        
        if (suffix == null) {
            suffix = ".tmp";
        }
        
        return File.createTempFile(prefix, suffix);
    }
    
    /**
     * Creates a temporary directory.
     *
     * @param prefix The directory name prefix
     * @return The temporary directory
     * @throws IOException If an I/O error occurs
     */
    public static File createTempDirectory(String prefix) throws IOException {
        if (prefix == null || prefix.isEmpty()) {
            prefix = "cstestforge_";
        }
        
        Path tempDir = Files.createTempDirectory(prefix);
        return tempDir.toFile();
    }
    
    /**
     * Generates a unique file name.
     *
     * @param extension The file extension (without the dot)
     * @return The unique file name
     */
    public static String generateUniqueFileName(String extension) {
        String uuid = UUID.randomUUID().toString();
        String timestamp = CSDateUtils.getFileNameTimestamp();
        
        String ext = extension != null && !extension.isEmpty() ? "." + extension : "";
        return timestamp + "_" + uuid + ext;
    }
    
    /**
     * Gets the file name without extension from a path.
     *
     * @param filePath The file path
     * @return The file name without extension
     */
    public static String getFileNameWithoutExtension(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return "";
        }
        
        // Get file name from path
        String fileName = new File(filePath).getName();
        
        // Remove extension
        int dotIndex = fileName.lastIndexOf('.');
        return dotIndex > 0 ? fileName.substring(0, dotIndex) : fileName;
    }
    
    /**
     * Gets the file extension from a path.
     *
     * @param filePath The file path
     * @return The file extension
     */
    public static String getFileExtension(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return "";
        }
        
        String fileName = new File(filePath).getName();
        int dotIndex = fileName.lastIndexOf('.');
        return dotIndex > 0 ? fileName.substring(dotIndex + 1) : "";
    }
    
    /**
     * Gets the file size in bytes.
     *
     * @param filePath The file path
     * @return The file size in bytes
     * @throws IOException If an I/O error occurs
     */
    public static long getFileSize(String filePath) throws IOException {
        File file = new File(filePath);
        
        if (!file.exists() || !file.isFile()) {
            throw new IOException("File does not exist or is not a file: " + filePath);
        }
        
        return file.length();
    }
    
    * Gets a formatted file size string (e.g., "1.5 MB").
     *
     * @param filePath The file path
     * @return The formatted file size string
     * @throws IOException If an I/O error occurs
     */
    public static String getFormattedFileSize(String filePath) throws IOException {
        long sizeInBytes = getFileSize(filePath);
        return formatFileSize(sizeInBytes);
    }
    
    /**
     * Formats a file size in bytes to a human-readable string.
     *
     * @param sizeInBytes The file size in bytes
     * @return The formatted file size string
     */
    public static String formatFileSize(long sizeInBytes) {
        if (sizeInBytes < 1024) {
            return sizeInBytes + " B";
        } else if (sizeInBytes < 1024 * 1024) {
            return String.format("%.2f KB", sizeInBytes / 1024.0);
        } else if (sizeInBytes < 1024 * 1024 * 1024) {
            return String.format("%.2f MB", sizeInBytes / (1024.0 * 1024.0));
        } else {
            return String.format("%.2f GB", sizeInBytes / (1024.0 * 1024.0 * 1024.0));
        }
    }
    
    /**
     * Gets the mime type of a file based on its extension.
     *
     * @param filePath The file path
     * @return The mime type
     */
    public static String getMimeType(String filePath) {
        String extension = getFileExtension(filePath).toLowerCase();
        
        switch (extension) {
            case "html":
            case "htm":
                return "text/html";
            case "css":
                return "text/css";
            case "js":
                return "application/javascript";
            case "json":
                return "application/json";
            case "xml":
                return "application/xml";
            case "txt":
                return "text/plain";
            case "pdf":
                return "application/pdf";
            case "jpg":
            case "jpeg":
                return "image/jpeg";
            case "png":
                return "image/png";
            case "gif":
                return "image/gif";
            case "svg":
                return "image/svg+xml";
            case "mp3":
                return "audio/mpeg";
            case "mp4":
                return "video/mp4";
            case "wav":
                return "audio/wav";
            case "avi":
                return "video/x-msvideo";
            case "zip":
                return "application/zip";
            case "doc":
                return "application/msword";
            case "docx":
                return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
            case "xls":
                return "application/vnd.ms-excel";
            case "xlsx":
                return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            case "ppt":
                return "application/vnd.ms-powerpoint";
            case "pptx":
                return "application/vnd.openxmlformats-officedocument.presentationml.presentation";
            default:
                return "application/octet-stream";
        }
    }
    
    /**
     * Normalizes a path by resolving relative paths and standardizing separators.
     *
     * @param path The path to normalize
     * @return The normalized path
     */
    public static String normalizePath(String path) {
        if (path == null || path.isEmpty()) {
            return path;
        }
        
        // Standardize path separators to match the OS
        String normalizedPath = path.replace('\\', File.separatorChar).replace('/', File.separatorChar);
        
        // Resolve relative paths
        Path resolvedPath = Paths.get(normalizedPath).normalize();
        return resolvedPath.toString();
    }
    
    /**
     * Joins path components with the correct separator.
     *
     * @param basePath The base path
     * @param paths Additional path components
     * @return The joined path
     */
    public static String joinPaths(String basePath, String... paths) {
        if (basePath == null) {
            basePath = "";
        }
        
        StringBuilder joinedPath = new StringBuilder(basePath);
        
        for (String path : paths) {
            if (path == null || path.isEmpty()) {
                continue;
            }
            
            if (joinedPath.length() > 0 && joinedPath.charAt(joinedPath.length() - 1) != File.separatorChar) {
                joinedPath.append(File.separatorChar);
            }
            
            joinedPath.append(path.startsWith(File.separator) ? path.substring(1) : path);
        }
        
        return joinedPath.toString();
    }
    
    /**
     * Gets the relative path from one absolute path to another.
     *
     * @param from The base path
     * @param to The target path
     * @return The relative path
     */
    public static String getRelativePath(String from, String to) {
        Path pathFrom = Paths.get(from).toAbsolutePath();
        Path pathTo = Paths.get(to).toAbsolutePath();
        
        Path relativePath = pathFrom.relativize(pathTo);
        return relativePath.toString();
    }
    
    /**
     * Creates a directory structure from a path.
     *
     * @param dirPath The directory path
     * @return true if the directory structure was created, false otherwise
     */
    public static boolean createDirectories(String dirPath) {
        File dir = new File(dirPath);
        return dir.mkdirs();
    }
    
    /**
     * Checks if a file is empty.
     *
     * @param filePath The file path
     * @return true if the file is empty, false otherwise
     * @throws IOException If an I/O error occurs
     */
    public static boolean isFileEmpty(String filePath) throws IOException {
        File file = new File(filePath);
        
        if (!file.exists() || !file.isFile()) {
            throw new IOException("File does not exist or is not a file: " + filePath);
        }
        
        return file.length() == 0;
    }
    
    /**
     * Checks if a file exists.
     *
     * @param filePath The file path
     * @return true if the file exists, false otherwise
     */
    public static boolean fileExists(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return false;
        }
        
        File file = new File(filePath);
        return file.exists() && file.isFile();
    }
    
    /**
     * Checks if a directory exists.
     *
     * @param dirPath The directory path
     * @return true if the directory exists, false otherwise
     */
    public static boolean directoryExists(String dirPath) {
        if (dirPath == null || dirPath.isEmpty()) {
            return false;
        }
        
        File dir = new File(dirPath);
        return dir.exists() && dir.isDirectory();
    }
    
    /**
     * Gets file attributes such as creation time, last modified time, and size.
     *
     * @param filePath The file path
     * @return A map of file attributes
     * @throws IOException If an I/O error occurs
     */
    public static Map<String, Object> getFileAttributes(String filePath) throws IOException {
        File file = new File(filePath);
        
        if (!file.exists()) {
            throw new IOException("File does not exist: " + filePath);
        }
        
        Map<String, Object> attributes = new HashMap<>();
        
        attributes.put("name", file.getName());
        attributes.put("path", file.getAbsolutePath());
        attributes.put("size", file.length());
        attributes.put("sizeFormatted", formatFileSize(file.length()));
        attributes.put("isDirectory", file.isDirectory());
        attributes.put("isFile", file.isFile());
        attributes.put("isHidden", file.isHidden());
        attributes.put("canRead", file.canRead());
        attributes.put("canWrite", file.canWrite());
        attributes.put("canExecute", file.canExecute());
        attributes.put("lastModified", file.lastModified());
        attributes.put("lastModifiedDate", new Date(file.lastModified()));
        
        // Use Java NIO for additional attributes
        Path path = file.toPath();
        try {
            attributes.put("creationTime", Files.getAttribute(path, "creationTime"));
            attributes.put("lastAccessTime", Files.getAttribute(path, "lastAccessTime"));
            attributes.put("lastModifiedTime", Files.getAttribute(path, "lastModifiedTime"));
        } catch (UnsupportedOperationException e) {
            // Some file systems might not support these attributes
        }
        
        return attributes;
    }
    
    /**
     * Finds files containing specific text.
     *
     * @param directory The directory to search in
     * @param searchText The text to search for
     * @param extension The file extension to filter by, or null for all files
     * @param recursive Whether to search recursively
     * @return A list of files containing the search text
     * @throws IOException If an I/O error occurs
     */
    public static List<File> findFilesContainingText(String directory, String searchText, 
                                                   String extension, boolean recursive) throws IOException {
        List<File> matchingFiles = new ArrayList<>();
        
        if (searchText == null || searchText.isEmpty()) {
            return matchingFiles;
        }
        
        List<File> files = listFiles(directory, extension, recursive);
        
        for (File file : files) {
            if (file.isFile() && file.length() > 0) {
                // Check if the file is binary
                if (isBinaryFile(file)) {
                    continue;
                }
                
                // Search for text in the file
                try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                    String line;
                    boolean found = false;
                    
                    while ((line = reader.readLine()) != null) {
                        if (line.contains(searchText)) {
                            found = true;
                            break;
                        }
                    }
                    
                    if (found) {
                        matchingFiles.add(file);
                    }
                }
            }
        }
        
        return matchingFiles;
    }
    
    /**
     * Checks if a file is a binary file.
     *
     * @param file The file to check
     * @return true if the file is binary, false otherwise
     * @throws IOException If an I/O error occurs
     */
    public static boolean isBinaryFile(File file) throws IOException {
        if (!file.exists() || file.isDirectory() || file.length() == 0) {
            return false;
        }
        
        // Check file extension first
        String extension = getFileExtension(file.getName()).toLowerCase();
        if (isCommonBinaryExtension(extension)) {
            return true;
        }
        
        // Read the first 8KB of the file and check for binary content
        try (InputStream in = new FileInputStream(file)) {
            byte[] buffer = new byte[8192];
            int bytesRead = in.read(buffer);
            
            // If we couldn't read anything, it's not binary
            if (bytesRead <= 0) {
                return false;
            }
            
            // Check for null bytes and control characters
            int textChars = 0;
            int binaryChars = 0;
            
            for (int i = 0; i < bytesRead; i++) {
                byte b = buffer[i];
                
                // Null byte is a strong indicator of binary content
                if (b == 0) {
                    return true;
                }
                
                // Check for control characters (except common text file control chars)
                if (b < 32 && b != 9 && b != 10 && b != 13) {
                    binaryChars++;
                } else {
                    textChars++;
                }
                
                // If we have a significant number of binary characters, consider it binary
                if (binaryChars > 5 || (bytesRead > 20 && binaryChars > bytesRead * 0.1)) {
                    return true;
                }
            }
            
            // If we have more binary characters than text, it's likely binary
            return binaryChars > textChars;
        }
    }
    
    /**
     * Checks if a file extension is commonly associated with binary files.
     *
     * @param extension The file extension
     * @return true if the extension is commonly binary, false otherwise
     */
    private static boolean isCommonBinaryExtension(String extension) {
        if (extension == null || extension.isEmpty()) {
            return false;
        }
        
        // Common binary file extensions
        Set<String> binaryExtensions = new HashSet<>(Arrays.asList(
            "pdf", "doc", "docx", "xls", "xlsx", "ppt", "pptx",
            "zip", "rar", "tar", "gz", "7z", "jar", "war", "ear",
            "exe", "dll", "so", "dylib", "obj", "o", "class",
            "jpg", "jpeg", "png", "gif", "bmp", "ico", "tif", "tiff",
            "mp3", "mp4", "wav", "avi", "mov", "mkv", "flv", "wmv",
            "iso", "bin", "dat", "db", "sqlite", "mdb", "accdb",
            "psd", "ai", "indd", "eps"
        ));
        
        return binaryExtensions.contains(extension.toLowerCase());
    }
    
    /**
     * Copies a directory and its contents.
     *
     * @param sourceDir The source directory
     * @param destDir The destination directory
     * @param overwrite Whether to overwrite existing files
     * @throws IOException If an I/O error occurs
     */
    public static void copyDirectory(String sourceDir, String destDir, boolean overwrite) throws IOException {
        File srcDir = new File(sourceDir);
        File dstDir = new File(destDir);
        
        if (!srcDir.exists() || !srcDir.isDirectory()) {
            throw new IOException("Source directory does not exist or is not a directory: " + sourceDir);
        }
        
        // Create destination directory if it doesn't exist
        if (!dstDir.exists()) {
            dstDir.mkdirs();
        } else if (!dstDir.isDirectory()) {
            throw new IOException("Destination is not a directory: " + destDir);
        }
        
        // Copy files and subdirectories
        File[] files = srcDir.listFiles();
        if (files == null) {
            return;
        }
        
        for (File file : files) {
            File destFile = new File(dstDir, file.getName());
            
            if (file.isDirectory()) {
                copyDirectory(file.getAbsolutePath(), destFile.getAbsolutePath(), overwrite);
            } else {
                copyFile(file.getAbsolutePath(), destFile.getAbsolutePath(), overwrite);
            }
        }
    }
    
    /**
     * Gets a resource as an input stream from the classpath.
     *
     * @param resourcePath The resource path
     * @return The input stream, or null if the resource does not exist
     */
    public static InputStream getResourceAsStream(String resourcePath) {
        if (resourcePath == null || resourcePath.isEmpty()) {
            return null;
        }
        
        // Remove leading slash if present
        if (resourcePath.startsWith("/")) {
            resourcePath = resourcePath.substring(1);
        }
        
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        return classLoader.getResourceAsStream(resourcePath);
    }
    
    /**
     * Gets a resource as a string from the classpath.
     *
     * @param resourcePath The resource path
     * @return The resource content as a string, or null if the resource does not exist
     * @throws IOException If an I/O error occurs
     */
    public static String getResourceAsString(String resourcePath) throws IOException {
        return getResourceAsString(resourcePath, DEFAULT_CHARSET);
    }
    
    /**
     * Gets a resource as a string from the classpath using the specified charset.
     *
     * @param resourcePath The resource path
     * @param charset The charset to use
     * @return The resource content as a string, or null if the resource does not exist
     * @throws IOException If an I/O error occurs
     */
    public static String getResourceAsString(String resourcePath, Charset charset) throws IOException {
        InputStream is = getResourceAsStream(resourcePath);
        
        if (is == null) {
            return null;
        }
        
        try (BufferedInputStream bis = new BufferedInputStream(is);
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            
            byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
            int bytesRead;
            
            while ((bytesRead = bis.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesRead);
            }
            
            return new String(baos.toByteArray(), charset);
        }
    }
    
    /**
     * Gets a resource as bytes from the classpath.
     *
     * @param resourcePath The resource path
     * @return The resource content as bytes, or null if the resource does not exist
     * @throws IOException If an I/O error occurs
     */
    public static byte[] getResourceAsBytes(String resourcePath) throws IOException {
        InputStream is = getResourceAsStream(resourcePath);
        
        if (is == null) {
            return null;
        }
        
        try (BufferedInputStream bis = new BufferedInputStream(is);
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            
            byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
            int bytesRead;
            
            while ((bytesRead = bis.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesRead);
            }
            
            return baos.toByteArray();
        }
    }
    
    /**
     * Gets the parent directory of a file path.
     *
     * @param filePath The file path
     * @return The parent directory path
     */
    public static String getParentDirectory(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return null;
        }
        
        File file = new File(filePath);
        File parent = file.getParentFile();
        
        return parent != null ? parent.getAbsolutePath() : null;
    }
    
    /**
     * Gets the application directory.
     *
     * @return The application directory path
     */
    public static String getApplicationDirectory() {
        return System.getProperty("user.dir");
    }
    
    /**
     * Gets the user's home directory.
     *
     * @return The user's home directory path
     */
    public static String getUserHomeDirectory() {
        return System.getProperty("user.home");
    }
    
    /**
     * Gets the system temporary directory.
     *
     * @return The system temporary directory path
     */
    public static String getTempDirectory() {
        return System.getProperty("java.io.tmpdir");
    }
    
    /**
     * Creates a new file with the specified content.
     *
     * @param filePath The file path
     * @param content The file content
     * @throws IOException If an I/O error occurs
     */
    public static void createFile(String filePath, String content) throws IOException {
        writeStringToFile(content, filePath, DEFAULT_CHARSET, false);
    }
    
    /**
     * Creates a new file with the specified content and charset.
     *
     * @param filePath The file path
     * @param content The file content
     * @param charset The charset to use
     * @throws IOException If an I/O error occurs
     */
    public static void createFile(String filePath, String content, Charset charset) throws IOException {
        writeStringToFile(content, filePath, charset, false);
    }
    
    /**
     * Touches a file, creating it if it doesn't exist or updating its last modified time if it does.
     *
     * @param filePath The file path
     * @return true if the file was touched, false otherwise
     * @throws IOException If an I/O error occurs
     */
    public static boolean touch(String filePath) throws IOException {
        File file = new File(filePath);
        
        if (!file.exists()) {
            // Create parent directories if needed
            File parent = file.getParentFile();
            if (parent != null && !parent.exists()) {
                parent.mkdirs();
            }
            
            return file.createNewFile();
        } else {
            return file.setLastModified(System.currentTimeMillis());
        }
    }
}


com/cstestforge/framework/core/utils/CSTextUtils.java
----------------------------------------------------------

package com.cstestforge.framework.core.utils;

import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.Normalizer;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utility class for text operations throughout the framework.
 * This class provides methods for text manipulation, validation, and generation.
 */
public class CSTextUtils {
    
    private static final Random RANDOM = new Random();
    
    /**
     * Checks if a string is null or empty.
     *
     * @param str The string to check
     * @return true if the string is null or empty, false otherwise
     */
    public static boolean isNullOrEmpty(String str) {
        return str == null || str.isEmpty();
    }
    
    /**
     * Checks if a string is null, empty, or contains only whitespace.
     *
     * @param str The string to check
     * @return true if the string is null, empty, or contains only whitespace, false otherwise
     */
    public static boolean isNullOrBlank(String str) {
        return str == null || str.trim().isEmpty();
    }
    
    /**
     * Returns a default value if the string is null or empty.
     *
     * @param str The string to check
     * @param defaultValue The default value to return if the string is null or empty
     * @return The original string, or the default value if the string is null or empty
     */
    public static String defaultIfEmpty(String str, String defaultValue) {
        return isNullOrEmpty(str) ? defaultValue : str;
    }
    
    /**
     * Returns a default value if the string is null, empty, or contains only whitespace.
     *
     * @param str The string to check
     * @param defaultValue The default value to return if the string is null, empty, or contains only whitespace
     * @return The original string, or the default value if the string is null, empty, or contains only whitespace
     */
    public static String defaultIfBlank(String str, String defaultValue) {
        return isNullOrBlank(str) ? defaultValue : str;
    }
    
    /**
     * Truncates a string to a maximum length.
     *
     * @param str The string to truncate
     * @param maxLength The maximum length
     * @return The truncated string
     */
    public static String truncate(String str, int maxLength) {
        if (str == null || str.length() <= maxLength) {
            return str;
        }
        return str.substring(0, maxLength);
    }
    
    /**
     * Truncates a string to a maximum length and adds an ellipsis if truncated.
     *
     * @param str The string to truncate
     * @param maxLength The maximum length
     * @return The truncated string with an ellipsis if truncated
     */
    public static String truncateWithEllipsis(String str, int maxLength) {
        if (str == null || str.length() <= maxLength) {
            return str;
        }
        
        if (maxLength <= 3) {
            return str.substring(0, maxLength);
        }
        
        return str.substring(0, maxLength - 3) + "...";
    }
    
    /**
     * Removes all whitespace from a string.
     *
     * @param str The string to process
     * @return The string with all whitespace removed
     */
    public static String removeWhitespace(String str) {
        if (str == null) {
            return null;
        }
        return str.replaceAll("\\s+", "");
    }
    
    /**
     * Normalizes whitespace in a string by replacing multiple whitespace characters with a single space.
     *
     * @param str The string to normalize
     * @return The normalized string
     */
    public static String normalizeWhitespace(String str) {
        if (str == null) {
            return null;
        }
        return str.trim().replaceAll("\\s+", " ");
    }
    
    /**
     * Replaces multiple occurrences of a substring with a replacement.
     *
     * @param str The string to process
     * @param target The substring to replace
     * @param replacement The replacement string
     * @return The processed string
     */
    public static String replace(String str, String target, String replacement) {
        if (str == null || target == null || replacement == null) {
            return str;
        }
        return str.replace(target, replacement);
    }
    
    /**
     * Replaces multiple occurrences of multiple substrings with replacements.
     *
     * @param str The string to process
     * @param replacements A map of target substrings to replacement strings
     * @return The processed string
     */
    public static String replaceAll(String str, Map<String, String> replacements) {
        if (str == null || replacements == null || replacements.isEmpty()) {
            return str;
        }
        
        String result = str;
        for (Map.Entry<String, String> entry : replacements.entrySet()) {
            result = result.replace(entry.getKey(), entry.getValue());
        }
        return result;
    }
    
    /**
     * Joins a collection of strings with a delimiter.
     *
     * @param collection The collection of strings to join
     * @param delimiter The delimiter
     * @return The joined string
     */
    public static String join(Collection<String> collection, String delimiter) {
        if (collection == null || collection.isEmpty()) {
            return "";
        }
        
        if (delimiter == null) {
            delimiter = "";
        }
        
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        
        for (String item : collection) {
            if (!first) {
                sb.append(delimiter);
            }
            sb.append(item);
            first = false;
        }
        
        return sb.toString();
    }
    
    /**
     * Joins an array of strings with a delimiter.
     *
     * @param array The array of strings to join
     * @param delimiter The delimiter
     * @return The joined string
     */
    public static String join(String[] array, String delimiter) {
        if (array == null || array.length == 0) {
            return "";
        }
        
        if (delimiter == null) {
            delimiter = "";
        }
        
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        
        for (String item : array) {
            if (!first) {
                sb.append(delimiter);
            }
            sb.append(item);
            first = false;
        }
        
        return sb.toString();
    }
    
    /**
     * Splits a string by a delimiter and trims the resulting parts.
     *
     * @param str The string to split
     * @param delimiter The delimiter
     * @return An array of the split and trimmed parts
     */
    public static String[] splitAndTrim(String str, String delimiter) {
        if (str == null) {
            return new String[0];
        }
        
        String[] parts = str.split(delimiter);
        for (int i = 0; i < parts.length; i++) {
            parts[i] = parts[i].trim();
        }
        
        return parts;
    }
    
    /**
     * Converts a string to camel case.
     *
     * @param str The string to convert
     * @return The camel case string
     */
    public static String toCamelCase(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        
        StringBuilder sb = new StringBuilder();
        boolean capitalizeNext = false;
        
        for (char c : str.toCharArray()) {
            if (Character.isWhitespace(c) || c == '_' || c == '-') {
                capitalizeNext = true;
            } else if (capitalizeNext) {
                sb.append(Character.toUpperCase(c));
                capitalizeNext = false;
            } else if (sb.length() == 0) {
                sb.append(Character.toLowerCase(c));
            } else {
                sb.append(c);
            }
        }
        
        return sb.toString();
    }
    
    /**
     * Converts a string to pascal case.
     *
     * @param str The string to convert
     * @return The pascal case string
     */
    public static String toPascalCase(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        
        StringBuilder sb = new StringBuilder();
        boolean capitalizeNext = true;
        
        for (char c : str.toCharArray()) {
            if (Character.isWhitespace(c) || c == '_' || c == '-') {
                capitalizeNext = true;
            } else if (capitalizeNext) {
                sb.append(Character.toUpperCase(c));
                capitalizeNext = false;
            } else {
                sb.append(c);
            }
        }
        
        return sb.toString();
    }
    
    /**
     * Converts a string to snake case.
     *
     * @param str The string to convert
     * @return The snake case string
     */
    public static String toSnakeCase(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        
        // Replace non-alphanumeric characters with underscores
        String result = str.replaceAll("[^a-zA-Z0-9]", "_");
        
        // Replace uppercase with underscore + lowercase
        result = result.replaceAll("([A-Z])", "_$1").toLowerCase();
        
        // Replace multiple underscores with a single underscore
        result = result.replaceAll("_+", "_");
        
        // Remove leading and trailing underscores
        result = result.replaceAll("^_+|_+$", "");
        
        return result;
    }
    
    /**
     * Converts a string to kebab case.
     *
     * @param str The string to convert
     * @return The kebab case string
     */
    public static String toKebabCase(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        
        // Replace non-alphanumeric characters with hyphens
        String result = str.replaceAll("[^a-zA-Z0-9]", "-");
        
        // Replace uppercase with hyphen + lowercase
        result = result.replaceAll("([A-Z])", "-$1").toLowerCase();
        
        // Replace multiple hyphens with a single hyphen
        result = result.replaceAll("-+", "-");
        
        // Remove leading and trailing hyphens
        result = result.replaceAll("^-+|-+$", "");
        
        return result;
    }
    
    /**
     * Capitalizes the first letter of a string.
     *
     * @param str The string to capitalize
     * @return The capitalized string
     */
    public static String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        
        return Character.toUpperCase(str.charAt(0)) + str.substring(1);
    }
    
    /**
     * Uncapitalizes the first letter of a string.
     *
     * @param str The string to uncapitalize
     * @return The uncapitalized string
     */
    public static String uncapitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        
        return Character.toLowerCase(str.charAt(0)) + str.substring(1);
    }
    
    /**
     * Checks if a string contains only alphabetic characters.
     *
     * @param str The string to check
     * @return true if the string contains only alphabetic characters, false otherwise
     */
    public static boolean isAlpha(String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }
        
        for (char c : str.toCharArray()) {
            if (!Character.isLetter(c)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Checks if a string contains only alphabetic and whitespace characters.
     *
     * @param str The string to check
     * @return true if the string contains only alphabetic and whitespace characters, false otherwise
     */
    public static boolean isAlphaSpace(String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }
        
        for (char c : str.toCharArray()) {
            if (!Character.isLetter(c) && !Character.isWhitespace(c)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Checks if a string contains only alphanumeric characters.
     *
     * @param str The string to check
     * @return true if the string contains only alphanumeric characters, false otherwise
     */
    public static boolean isAlphaNumeric(String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }
        
        for (char c : str.toCharArray()) {
            if (!Character.isLetterOrDigit(c)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Checks if a string contains only alphanumeric and whitespace characters.
     *
     * @param str The string to check
     * @return true if the string contains only alphanumeric and whitespace characters, false otherwise
     */
    public static boolean isAlphaNumericSpace(String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }
        
        for (char c : str.toCharArray()) {
            if (!Character.isLetterOrDigit(c) && !Character.isWhitespace(c)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Checks if a string contains only numeric characters.
     *
     * @param str The string to check
     * @return true if the string contains only numeric characters, false otherwise
     */
    public static boolean isNumeric(String str) {
        if (str == null || str.isEmpty()) {
            return false;
        }
        
        for (char c : str.toCharArray()) {
            if (!Character.isDigit(c)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Reverses a string.
     *
     * @param str The string to reverse
     * @return The reversed string
     */
    public static String reverse(String str) {
        if (str == null) {
            return null;
        }
        
        return new StringBuilder(str).reverse().toString();
    }
    
    /**
     * Repeats a string a specified number of times.
     *
     * @param str The string to repeat
     * @param times The number of times to repeat
     * @return The repeated string
     */
    public static String repeat(String str, int times) {
        if (str == null) {
            return null;
        }
        
        if (times <= 0) {
            return "";
        }
        
        return str.repeat(times);
    }
    
    /**
     * Centers a string in a field of a specified width, padded with a specified character.
     *
     * @param str The string to center
     * @param width The width of the field
     * @param padChar The character to pad with
     * @return The centered string
     */
    public static String center(String str, int width, char padChar) {
        if (str == null) {
            return null;
        }
        
        if (width <= str.length()) {
            return str;
        }
        
        int padSize = width - str.length();
        int padStart = padSize / 2;
        int padEnd = padSize - padStart;
        
        return repeat(String.valueOf(padChar), padStart) + str + repeat(String.valueOf(padChar), padEnd);
    }
    
    /**
     * Left-pads a string to a specified width with a specified character.
     *
     * @param str The string to pad
     * @param width The width to pad to
     * @param padChar The character to pad with
     * @return The padded string
     */
    public static String leftPad(String str, int width, char padChar) {
        if (str == null) {
            return null;
        }
        
        if (width <= str.length()) {
            return str;
        }
        
        int padSize = width - str.length();
        return repeat(String.valueOf(padChar), padSize) + str;
    }
    
    /**
     * Right-pads a string to a specified width with a specified character.
     *
     * @param str The string to pad
     * @param width The width to pad to
     * @param padChar The character to pad with
     * @return The padded string
     */
    public static String rightPad(String str, int width, char padChar) {
        if (str == null) {
            return null;
        }
        
        if (width <= str.length()) {
            return str;
        }
        
        int padSize = width - str.length();
        return str + repeat(String.valueOf(padChar), padSize);
    }
    
    /**
     * Escapes HTML special characters in a string.
     *
     * @param str The string to escape
     * @return The escaped string
     */
    public static String escapeHtml(String str) {
        if (str == null) {
            return null;
        }
        
        return str.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&#39;");
    }
    
    /**
     * Unescapes HTML special characters in a string.
     *
     * @param str The string to unescape
     * @return The unescaped string
     */
    public static String unescapeHtml(String str) {
        if (str == null) {
            return null;
        }
        
        return str.replace("&amp;", "&")
                .replace("&lt;", "<")
                .replace("&gt;", ">")
                .replace("&quot;", "\"")
                .replace("&#39;", "'");
    }
    
    /**
     * Escapes XML special characters in a string.
     *
     * @param str The string to escape
     * @return The escaped string
     */
    public static String escapeXml(String str) {
        if (str == null) {
            return null;
        }
        
        return str.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&apos;");
    }
    
    /**
     * Unescapes XML special characters in a string.
     *
     * @param str The string to unescape
     * @return The unescaped string
     */
    public static String unescapeXml(String str) {
        if (str == null) {
            return null;
        }
        
        return str.replace("&amp;", "&")
                .replace("&lt;", "<")
                .replace("&gt;", ">")
                .replace("&quot;", "\"")
                .replace("&apos;", "'");
    }
    
    /**
     * Escapes JSON special characters in a string.
     *
     * @param str The string to escape
     * @return The escaped string
     */
    public static String escapeJson(String str) {
        if (str == null) {
            return null;
        }
        
        return str.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\b", "\\b")
                .replace("\f", "\\f")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
    
    /**
     * Generates a random string of a specified length.
     *
     * @param length The length of the string to generate
     * @return The random string
     */
    public static String randomString(int length) {
        if (length <= 0) {
            return "";
        }
        
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        StringBuilder sb = new StringBuilder(length);
        
        for (int i = 0; i < length; i++) {
            int index = RANDOM.nextInt(chars.length());
            sb.append(chars.charAt(index));
        }
        
        return sb.toString();
    }
    
    /**
     * Generates a random alphabetic string of a specified length.
     *
     * @param length The length of the string to generate
     * @return The random alphabetic string
     */
    public static String randomAlphabetic(int length) {
        if (length <= 0) {
            return "";
        }
        
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        StringBuilder sb = new StringBuilder(length);
        
        for (int i = 0; i < length; i++) {
            int index = RANDOM.nextInt(chars.length());
            sb.append(chars.charAt(index));
        }
        
        return sb.toString();
    }
    
    /**
     * Generates a random alphanumeric string of a specified length.
     *
     * @param length The length of the string to generate
     * @return The random alphanumeric string
     */
    public static String randomAlphanumeric(int length) {
        if (length <= 0) {
            return "";
        }
        
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        StringBuilder sb = new StringBuilder(length);
        
        for (int i = 0; i < length; i++) {
            int index = RANDOM.nextInt(chars.length());
            sb.append(chars.charAt(index));
        }
        
        return sb.toString();
    }
    
    /**
     * Generates a random numeric string of a specified length.
     *
     * @param length The length of the string to generate
     * @return The random numeric string
     */
    public static String randomNumeric(int length) {
        if (length <= 0) {
            return "";
        }
        
        String chars = "0123456789";
        StringBuilder sb = new StringBuilder(length);
        
        for (int i = 0; i < length; i++) {
            int index = RANDOM.nextInt(chars.length());
            sb.append(chars.charAt(index));
        }
        
        return sb.toString();
    }
    
    /**
     * Generates a random string using a specified set of characters and a specified length.
     *
     * @param length The length of the string to generate
     * @param chars The characters to use
     * @return The random string
     */
    public static String randomString(int length, String chars) {
        if (length <= 0) {
            return "";
        }
        
        if (isNullOrEmpty(chars)) {
            return "";
        }
        
        StringBuilder sb = new StringBuilder(length);
        
        for (int i = 0; i < length; i++) {
            int index = RANDOM.nextInt(chars.length());
            sb.append(chars.charAt(index));
        }
        
        return sb.toString();
    }
    
    /**
     * Generates a UUID string.
     *
     * @return The UUID string
     */
    public static String uuid() {
        return UUID.randomUUID().toString();
    }
    
    /**
     * Formats a string with placeholders using an array of values.
     *
     * @param format The format string with placeholders (e.g., "{0}, {1}")
     * @param args The values to use for the placeholders
     * @return The formatted string
     */
    public static String format(String format, Object... args) {
        if (format == null) {
            return null;
        }
        
        if (args == null || args.length == 0) {
            return format;
        }
        
        String result = format;
        for (int i = 0; i < args.length; i++) {
            String placeholder = "{" + i + "}";
            result = result.replace(placeholder, args[i] == null ? "null" : args[i].toString());
        }
        
        return result;
    }
    
    /**
     * Formats a string with named placeholders using a map of values.
     *
     * @param format The format string with named placeholders (e.g., "{name}, {age}")
     * @param args The map of names to values
     * @return The formatted string
     */
    public static String format(String format, Map<String, Object> args) {
        if (format == null) {
            return null;
        }
        
        if (args == null || args.isEmpty()) {
            return format;
        }
        
        String result = format;
        for (Map.Entry<String, Object> entry : args.entrySet()) {
            String placeholder = "{" + entry.getKey() + "}";
            result = result.replace(placeholder, entry.getValue() == null ? "null" : entry.getValue().toString());
        }
        
        return result;
    }
    
    /**
     * Removes accents and diacritics from a string.
     *
     * @param str The string to process
     * @return The string with accents and diacritics removed
     */
    public static String removeAccents(String str) {
        if (str == null) {
            return null;
        }
        
        String normalized = Normalizer.normalize(str, Normalizer.Form.NFD);
        Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");
        return pattern.matcher(normalized).replaceAll("");
    }
    
    /**
     * Removes non-printable characters from a string.
     *
     * @param str The string to process
     * @return The string with non-printable characters removed
     */
    public static String removeNonPrintable(String str) {
        if (str == null) {
            return null;
        }
        
        return str.replaceAll("[^\\p{Print}]", "");
    }
    
    /**
     * Removes all characters that match a regular expression pattern from a string.
     *
     * @param str The string to process
     * @param pattern The regular expression pattern
     * @return The string with matching characters removed
     */
    public static String removePattern(String str, String pattern) {
        if (str == null) {
            return null;
        }
        
        if (pattern == null) {
            return str;
        }
        
        return str.replaceAll(pattern, "");
    }
    
    /**
     * Gets the Levenshtein distance between two strings.
     *
     * @param str1 The first string
     * @param str2 The second string
     * @return The Levenshtein distance
     */
    public static int levenshteinDistance(String str1, String str2) {
        if (str1 == null && str2 == null) {
            return 0;
        }
        
        if (str1 == null) {
            return str2.length();
        }
        
        if (str2 == null) {
            return str1.length();
        }
        
        int len1 = str1.length();
        int len2 = str2.length();
        
        // Create the distance matrix
        int[][] distance = new int[len1 + 1][len2 + 1];
        
        // Initialize the first row and column
        for (int i = 0; i <= len1; i++) {
            distance[i][0] = i;
        }
        
        for (int j = 0; j <= len2; j++) {
            distance[0][j] = j;
        }
        
        // Fill the distance matrix
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                int cost = (str1.charAt(i - 1) == str2.charAt(j - 1)) ? 0 : 1;
                distance[i][j] = Math.min(Math.min(
                        distance[i - 1][j] + 1,     // Deletion
                        distance[i][j - 1] + 1),    // Insertion
                        distance[i - 1][j - 1] + cost); // Substitution
            }
        }
        
        return distance[len1][len2];
    }
    
    /**
     * Gets the similarity between two strings as a percentage (0-100).
     *
     * @param str1 The first string
     * @param str2 The second string
     * @return The similarity percentage
     */
    public static double similarity(String str1, String str2) {
        if (str1 == null && str2 == null) {
            return 100.0;
        }
        
        if (str1 == null || str2 == null) {
            return 0.0;
        }
        
        if (str1.equals(str2)) {
            return 100.0;
        }
        
        int maxLength = Math.max(str1.length(), str2.length());
        if (maxLength == 0) {
            return 100.0;
        }
        
        int distance = levenshteinDistance(str1, str2);
        return (1.0 - (double) distance / maxLength) * 100.0;
    }
    
    /**
     * Computes the Jaro-Winkler similarity between two strings.
     * 
     * @param str1 The first string
     * @param str2 The second string
     * @return The Jaro-Winkler similarity (0.0 - 1.0)
     */
    public static double jaroWinklerSimilarity(String str1, String str2) {
        if (str1 == null && str2 == null) {
            return 1.0;
        }
        
        if (str1 == null || str2 == null) {
            return 0.0;
        }
        
        if (str1.equals(str2)) {
            return 1.0;
        }
        
        // Calculate Jaro similarity
        int len1 = str1.length();
        int len2 = str2.length();
        
        // The distance is half the length of the longer string
        int matchDistance = Math.max(len1, len2) / 2 - 1;
        if (matchDistance < 0) {
            matchDistance = 0;
        }
        
        boolean[] matches1 = new boolean[len1];
        boolean[] matches2 = new boolean[len2];
        
        // Calculate matching characters
        int matchingChars = 0;
        for (int i = 0; i < len1; i++) {
            int start = Math.max(0, i - matchDistance);
            int end = Math.min(i + matchDistance + 1, len2);
            
            for (int j = start; j < end; j++) {
                if (!matches2[j] && str1.charAt(i) == str2.charAt(j)) {
                    matches1[i] = true;
                    matches2[j] = true;
                    matchingChars++;
                    break;
                }
            }
        }
        
        if (matchingChars == 0) {
            return 0.0;
        }
        
        // Calculate transpositions
        int transpositions = 0;
        int k = 0;
        
        for (int i = 0; i < len1; i++) {
            if (matches1[i]) {
                while (!matches2[k]) {
                    k++;
                }
                
                if (str1.charAt(i) != str2.charAt(k)) {
                    transpositions++;
                }
                
                k++;
            }
        }
        
        // Calculate Jaro similarity
        double jaro = ((double) matchingChars / len1 + 
                       (double) matchingChars / len2 + 
                       (double) (matchingChars - transpositions / 2) / matchingChars) / 3.0;
        
        // Calculate Jaro-Winkler similarity
        double prefixLength = 0;
        int maxPrefixLength = 4;
        
        for (int i = 0; i < Math.min(len1, len2, maxPrefixLength); i++) {
            if (str1.charAt(i) == str2.charAt(i)) {
                prefixLength++;
            } else {
                break;
            }
        }
        
        return jaro + (prefixLength * 0.1 * (1.0 - jaro));
    }
    
    /**
     * Extracts all matches of a regular expression pattern from a string.
     * 
     * @param str The string to extract from
     * @param pattern The regular expression pattern
     * @return A list of all matches
     */
    public static List<String> extractAll(String str, String pattern) {
        if (str == null || pattern == null) {
            return Collections.emptyList();
        }
        
        List<String> matches = new ArrayList<>();
        Pattern regex = Pattern.compile(pattern);
        Matcher matcher = regex.matcher(str);
        
        while (matcher.find()) {
            matches.add(matcher.group());
        }
        
        return matches;
    }
    
    /**
     * Extracts all capture groups of a regular expression pattern from a string.
     * 
     * @param str The string to extract from
     * @param pattern The regular expression pattern with capture groups
     * @return A list of maps containing the capture groups for each match
     */
    public static List<Map<Integer, String>> extractGroups(String str, String pattern) {
        if (str == null || pattern == null) {
            return Collections.emptyList();
        }
        
        List<Map<Integer, String>> matches = new ArrayList<>();
        Pattern regex = Pattern.compile(pattern);
        Matcher matcher = regex.matcher(str);
        
        while (matcher.find()) {
            Map<Integer, String> groups = new HashMap<>();
            for (int i = 0; i <= matcher.groupCount(); i++) {
                groups.put(i, matcher.group(i));
            }
            matches.add(groups);
        }
        
        return matches;
    }
    
    /**
     * Extracts all named capture groups of a regular expression pattern from a string.
     * 
     * @param str The string to extract from
     * @param pattern The regular expression pattern with named capture groups
     * @return A list of maps containing the named capture groups for each match
     */
    public static List<Map<String, String>> extractNamedGroups(String str, String pattern) {
        if (str == null || pattern == null) {
            return Collections.emptyList();
        }
        
        List<Map<String, String>> matches = new ArrayList<>();
        Pattern regex = Pattern.compile(pattern);
        Matcher matcher = regex.matcher(str);
        
        while (matcher.find()) {
            Map<String, String> groups = new HashMap<>();
            for (int i = 0; i <= matcher.groupCount(); i++) {
                String groupName = getGroupName(pattern, i);
                if (groupName != null) {
                    groups.put(groupName, matcher.group(i));
                }
            }
            matches.add(groups);
        }
        
        return matches;
    }
    
    /**
     * Gets the name of a capture group in a regular expression pattern.
     * 
     * @param pattern The regular expression pattern
     * @param groupIndex The group index
     * @return The group name, or null if the group is not named or does not exist
     */
    private static String getGroupName(String pattern, int groupIndex) {
        // Extract named group from pattern (e.g., "(?<name>...)")
        Pattern namedGroupPattern = Pattern.compile("\\(\\?<([a-zA-Z][a-zA-Z0-9]*)>");
        Matcher matcher = namedGroupPattern.matcher(pattern);
        
        int count = 0;
        while (matcher.find()) {
            count++;
            if (count == groupIndex) {
                return matcher.group(1);
            }
        }
        
        return null;
    }
    
    /**
     * Performs Base64 encoding of a string.
     * 
     * @param str The string to encode
     * @return The Base64-encoded string
     */
    public static String base64Encode(String str) {
        if (str == null) {
            return null;
        }
        
        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);
        return Base64.getEncoder().encodeToString(bytes);
    }
    
    /**
     * Performs Base64 decoding of a string.
     * 
     * @param str The Base64-encoded string to decode
     * @return The decoded string
     */
    public static String base64Decode(String str) {
        if (str == null) {
            return null;
        }
        
        byte[] bytes = Base64.getDecoder().decode(str);
        return new String(bytes, StandardCharsets.UTF_8);
    }
    
    /**
     * Computes the MD5 hash of a string.
     * 
     * @param str The string to hash
     * @return The MD5 hash as a hexadecimal string
     * @throws NoSuchAlgorithmException If the MD5 algorithm is not available
     */
    public static String md5(String str) throws NoSuchAlgorithmException {
        if (str == null) {
            return null;
        }
        
        MessageDigest md = MessageDigest.getInstance("MD5");
        byte[] digest = md.digest(str.getBytes(StandardCharsets.UTF_8));
        
        StringBuilder sb = new StringBuilder();
        for (byte b : digest) {
            sb.append(String.format("%02x", b));
        }
        
        return sb.toString();
    }
    
    /**
     * Computes the SHA-256 hash of a string.
     * 
     * @param str The string to hash
     * @return The SHA-256 hash as a hexadecimal string
     * @throws NoSuchAlgorithmException If the SHA-256 algorithm is not available
     */
    public static String sha256(String str) throws NoSuchAlgorithmException {
        if (str == null) {
            return null;
        }
        
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] digest = md.digest(str.getBytes(StandardCharsets.UTF_8));
        
        StringBuilder sb = new StringBuilder();
        for (byte b : digest) {
            sb.append(String.format("%02x", b));
        }
        
        return sb.toString();
    }
    
    /**
     * Wraps a string to a specified width.
     * 
     * @param str The string to wrap
     * @param width The maximum width of each line
     * @return The wrapped string
     */
    public static String wordWrap(String str, int width) {
        if (str == null) {
            return null;
        }
        
        if (width <= 0) {
            return str;
        }
        
        StringBuilder sb = new StringBuilder();
        String[] words = str.split("\\s+");
        int lineLength = 0;
        
        for (String word : words) {
            if (lineLength + word.length() > width) {
                // Start a new line
                sb.append("\n");
                lineLength = 0;
            } else if (lineLength > 0) {
                // Add a space between words
                sb.append(" ");
                lineLength++;
            }
            
            sb.append(word);
            lineLength += word.length();
        }
        
        return sb.toString();
    }
    
    /**
     * Gets the most common words in a string.
     * 
     * @param str The string to analyze
     * @param limit The maximum number of words to return
     * @return A map of words to their frequencies, sorted by frequency (descending)
     */
    public static Map<String, Integer> getMostCommonWords(String str, int limit) {
        if (str == null || limit <= 0) {
            return Collections.emptyMap();
        }
        
        // Split the string into words
        String[] words = str.toLowerCase().split("\\W+");
        
        // Count word frequencies
        Map<String, Integer> wordCounts = new HashMap<>();
        for (String word : words) {
            if (!word.isEmpty()) {
                wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);
            }
        }
        
        // Sort by frequency (descending)
        List<Map.Entry<String, Integer>> sortedEntries = new ArrayList<>(wordCounts.entrySet());
        sortedEntries.sort((e1, e2) -> e2.getValue().compareTo(e1.getValue()));
        
        // Create a LinkedHashMap to preserve order
        Map<String, Integer> result = new HashMap<>();
        for (int i = 0; i < Math.min(limit, sortedEntries.size())); i++) {
            Map.Entry<String, Integer> entry = sortedEntries.get(i);
            result.put(entry.getKey(), entry.getValue());
        }
        
        return result;
    }
    
    /**
     * Counts the occurrences of a substring in a string.
     * 
     * @param str The string to search in
     * @param substr The substring to count
     * @return The number of occurrences
     */
    public static int countOccurrences(String str, String substr) {
        if (str == null || substr == null || substr.isEmpty()) {
            return 0;
        }
        
        int count = 0;
        int index = 0;
        
        while ((index = str.indexOf(substr, index)) != -1) {
            count++;
            index += substr.length();
        }
        
        return count;
    }
    
    /**
     * Counts the words in a string.
     * 
     * @param str The string to count words in
     * @return The number of words
     */
    public static int countWords(String str) {
        if (str == null || str.isEmpty()) {
            return 0;
        }
        
        String trimmed = str.trim();
        if (trimmed.isEmpty()) {
            return 0;
        }
        
        // Split by whitespace and count non-empty words
        String[] words = trimmed.split("\\s+");
        return words.length;
    }
    
    /**
     * Counts the characters in a string.
     * 
     * @param str The string to count characters in
     * @return The number of characters
     */
    public static int countChars(String str) {
        if (str == null) {
            return 0;
        }
        
        return str.length();
    }
    
    /**
     * Swaps the case of a string (uppercase to lowercase and vice versa).
     * 
     * @param str The string to swap case
     * @return The string with swapped case
     */
    public static String swapCase(String str) {
        if (str == null) {
            return null;
        }
        
        char[] chars = str.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            char c = chars[i];
            if (Character.isUpperCase(c)) {
                chars[i] = Character.toLowerCase(c);
            } else if (Character.isLowerCase(c)) {
                chars[i] = Character.toUpperCase(c);
            }
        }
        
        return new String(chars);
    }
    
    /**
     * Converts a string to title case (capitalize the first letter of each word).
     * 
     * @param str The string to convert
     * @return The title case string
     */
    public static String toTitleCase(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        
        StringBuilder sb = new StringBuilder();
        boolean capitalizeNext = true;
        
        for (char c : str.toCharArray()) {
            if (Character.isWhitespace(c) || c == '-' || c == '_') {
                capitalizeNext = true;
                sb.append(c);
            } else if (capitalizeNext) {
                sb.append(Character.toUpperCase(c));
                capitalizeNext = false;
            } else {
                sb.append(Character.toLowerCase(c));
            }
        }
        
        return sb.toString();
    }
    
    /**
     * Checks if a string is a valid email address.
     * 
     * @param email The email address to validate
     * @return true if the email address is valid, false otherwise
     */
    public static boolean isValidEmail(String email) {
        if (email == null || email.isEmpty()) {
            return false;
        }
        
        String emailRegex = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
        return email.matches(emailRegex);
    }
    
    /**
     * Checks if a string is a valid URL.
     * 
     * @param url The URL to validate
     * @return true if the URL is valid, false otherwise
     */
    public static boolean isValidUrl(String url) {
        if (url == null || url.isEmpty()) {
            return false;
        }
        
        String urlRegex = "^(https?|ftp)://[a-zA-Z0-9]+(\\.[a-zA-Z0-9]+)*(:[0-9]+)?(/[^\\s]*)?$";
        return url.matches(urlRegex);
    }
    
    /**
     * Checks if a string is a valid IP address (IPv4 or IPv6).
     * 
     * @param ip The IP address to validate
     * @return true if the IP address is valid, false otherwise
     */
    public static boolean isValidIpAddress(String ip) {
        if (ip == null || ip.isEmpty()) {
            return false;
        }
        
        // IPv4 regex
        String ipv4Regex = "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
        
        // IPv6 regex (simplified)
        String ipv6Regex = "^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$";
        
        return ip.matches(ipv4Regex) || ip.matches(ipv6Regex);
    }
    
    /**
     * Abbreviates a string to a specified maximum width with an ellipsis.
     * 
     * @param str The string to abbreviate
     * @param maxWidth The maximum width
     * @return The abbreviated string
     */
    public static String abbreviate(String str, int maxWidth) {
        if (str == null) {
            return null;
        }
        
        if (str.length() <= maxWidth) {
            return str;
        }
        
        if (maxWidth < 4) {
            // Not enough room for an abbreviation
            return str.substring(0, maxWidth);
        }
        
        return str.substring(0, maxWidth - 3) + "...";
    }
    
    /**
     * Checks if a string contains another string, ignoring case.
     * 
     * @param str The string to search in
     * @param searchStr The string to search for
     * @return true if the string contains the search string, false otherwise
     */
    public static boolean containsIgnoreCase(String str, String searchStr) {
        if (str == null || searchStr == null) {
            return false;
        }
        
        return str.toLowerCase().contains(searchStr.toLowerCase());
    }
    
    /**
     * Gets the first n characters of a string.
     * 
     * @param str The string to get characters from
     * @param n The number of characters to get
     * @return The first n characters of the string
     */
    public static String firstChars(String str, int n) {
        if (str == null) {
            return null;
        }
        
        if (n <= 0) {
            return "";
        }
        
        return str.substring(0, Math.min(n, str.length()));
    }
    
    /**
     * Gets the last n characters of a string.
     * 
     * @param str The string to get characters from
     * @param n The number of characters to get
     * @return The last n characters of the string
     */
    public static String lastChars(String str, int n) {
        if (str == null) {
            return null;
        }
        
        if (n <= 0) {
            return "";
        }
        
        return str.substring(Math.max(0, str.length() - n));
    }
    
    /**
     * Checks if a string contains only ASCII characters.
     * 
     * @param str The string to check
     * @return true if the string contains only ASCII characters, false otherwise
     */
    public static boolean isAscii(String str) {
        if (str == null) {
            return false;
        }
        
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) > 127) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Encodes a string for use in HTML attribute values.
     * 
     * @param str The string to encode
     * @return The encoded string
     */
    public static String encodeHtmlAttribute(String str) {
        if (str == null) {
            return null;
        }
        
        return str.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&#39;");
    }
    
    /**
     * Encodes a string for use in URLs.
     * 
     * @param str The string to encode
     * @return The encoded string
     * @throws UnsupportedEncodingException If the encoding is not supported
     */
    public static String encodeUrl(String str) throws UnsupportedEncodingException {
        if (str == null) {
            return null;
        }
        
        return java.net.URLEncoder.encode(str, StandardCharsets.UTF_8.name());
    }
    
    /**
     * Decodes a URL-encoded string.
     * 
     * @param str The string to decode
     * @return The decoded string
     * @throws UnsupportedEncodingException If the encoding is not supported
     */
    public static String decodeUrl(String str) throws UnsupportedEncodingException {
        if (str == null) {
            return null;
        }
        
        return java.net.URLDecoder.decode(str, StandardCharsets.UTF_8.name());
    }
    
    /**
     * Checks if a string is a palindrome (reads the same forwards and backwards).
     * 
     * @param str The string to check
     * @return true if the string is a palindrome, false otherwise
     */
    public static boolean isPalindrome(String str) {
        if (str == null) {
            return false;
        }
        
        String normalized = str.toLowerCase().replaceAll("[^a-z0-9]", "");
        return normalized.equals(new StringBuilder(normalized).reverse().toString());
    }
    
    /**
     * Gets the index of the nth occurrence of a substring in a string.
     * 
     * @param str The string to search in
     * @param substr The substring to search for
     * @param n The occurrence to find (1-based)
     * @return The index of the nth occurrence, or -1 if not found
     */
    public static int indexOfNth(String str, String substr, int n) {
        if (str == null || substr == null || n <= 0) {
            return -1;
        }
        
        int index = -1;
        
        for (int i = 0; i < n; i++) {
            index = str.indexOf(substr, index + 1);
            if (index == -1) {
                return -1;
            }
        }
        
        return index;
    }
    
    /**
     * Gets the index of the nth last occurrence of a substring in a string.
     * 
     * @param str The string to search in
     * @param substr The substring to search for
     * @param n The occurrence to find from the end (1-based)
     * @return The index of the nth last occurrence, or -1 if not found
     */
    public static int lastIndexOfNth(String str, String substr, int n) {
        if (str == null || substr == null || n <= 0) {
            return -1;
        }
        
        int index = str.length();
        
        for (int i = 0; i < n; i++) {
            index = str.lastIndexOf(substr, index - 1);
            if (index == -1) {
                return -1;
            }
        }
        
        return index;
    }
    
    /**
     * Rotates a string by a specified number of positions.
     * 
     * @param str The string to rotate
     * @param shift The number of positions to shift (positive for right, negative for left)
     * @return The rotated string
     */
    public static String rotate(String str, int shift) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        
        int length = str.length();
        shift = shift % length;
        
        if (shift < 0) {
            shift = length + shift;
        }
        
        if (shift == 0) {
            return str;
        }
        
        return str.substring(length - shift) + str.substring(0, length - shift);
    }
    
    /**
     * Shuffles the characters in a string randomly.
     * 
     * @param str The string to shuffle
     * @return The shuffled string
     */
    public static String shuffle(String str) {
        if (str == null) {
            return null;
        }
        
        char[] chars = str.toCharArray();
        for (int i = chars.length - 1; i > 0; i--) {
            int index = RANDOM.nextInt(i + 1);
            char temp = chars[index];
            chars[index] = chars[i];
            chars[i] = temp;
        }
        
        return new String(chars);
    }
    
    /**
     * Gets the longest common prefix of multiple strings.
     * 
     * @param strings The strings to find the common prefix of
     * @return The longest common prefix
     */
    public static String longestCommonPrefix(String[] strings) {
        if (strings == null || strings.length == 0) {
            return "";
        }
        
        if (strings.length == 1) {
            return strings[0];
        }
        
        String first = strings[0];
        int maxPrefixLength = first.length();
        
        for (int i = 1; i < strings.length; i++) {
            String current = strings[i];
            int j = 0;
            
            while (j < maxPrefixLength && j < current.length() && first.charAt(j) == current.charAt(j)) {
                j++;
            }
            
            maxPrefixLength = j;
            
            if (maxPrefixLength == 0) {
                return "";
            }
        }
        
        return first.substring(0, maxPrefixLength);
    }
    
    /**
     * Gets the longest common suffix of multiple strings.
     * 
     * @param strings The strings to find the common suffix of
     * @return The longest common suffix
     */
    public static String longestCommonSuffix(String[] strings) {
        if (strings == null || strings.length == 0) {
            return "";
        }
        
        if (strings.length == 1) {
            return strings[0];
        }
        
        String first = strings[0];
        int maxSuffixLength = first.length();
        
        for (int i = 1; i < strings.length; i++) {
            String current = strings[i];
            int firstPos = first.length() - 1;
            int currentPos = current.length() - 1;
            int count = 0;
            
            while (firstPos >= 0 && currentPos >= 0 && first.charAt(firstPos) == current.charAt(currentPos)) {
                firstPos--;
                currentPos--;
                count++;
            }
            
            maxSuffixLength = Math.min(maxSuffixLength, count);
            
            if (maxSuffixLength == 0) {
                return "";
            }
        }
        
        return first.substring(first.length() - maxSuffixLength);
    }
    
    /**
     * Replaces all occurrences of multiple substrings with a single replacement.
     * 
     * @param str The string to process
     * @param searchStrings The substrings to search for
     * @param replacement The replacement string
     * @return The processed string
     */
    public static String replaceEach(String str, String[] searchStrings, String replacement) {
        if (str == null || searchStrings == null || replacement == null) {
            return str;
        }
        
        Map<String, String> replacements = new HashMap<>();
        for (String searchString : searchStrings) {
            replacements.put(searchString, replacement);
        }
        
        return replaceAll(str, replacements);
    }
    
    /**
     * Masks a string by replacing characters with a mask character.
     * 
     * @param str The string to mask
     * @param start The start index (inclusive)
     * @param end The end index (exclusive)
     * @param maskChar The mask character
     * @return The masked string
     */
    public static String mask(String str, int start, int end, char maskChar) {
        if (str == null) {
            return null;
        }
        
        if (start < 0) {
            start = 0;
        }
        
        if (end > str.length()) {
            end = str.length();
        }
        
        if (start >= end) {
            return str;
        }
        
        StringBuilder sb = new StringBuilder(str);
        for (int i = start; i < end; i++) {
            sb.setCharAt(i, maskChar);
        }
        
        return sb.toString();
    }
    
    /**
     * Removes the first n characters from a string.
     * 
     * @param str The string to process
     * @param n The number of characters to remove
     * @return The processed string
     */
    public static String removeFirstChars(String str, int n) {
        if (str == null) {
            return null;
        }
        
        if (n <= 0) {
            return str;
        }
        
        if (n >= str.length()) {
            return "";
        }
        
        return str.substring(n);
    }
    
    /**
     * Removes the last n characters from a string.
     * 
     * @param str The string to process
     * @param n The number of characters to remove
     * @return The processed string
     */
    public static String removeLastChars(String str, int n) {
        if (str == null) {
            return null;
        }
        
        if (n <= 0) {
            return str;
        }
        
        if (n >= str.length()) {
            return "";
        }
        
        return str.substring(0, str.length() - n);
    }
    
    /**
     * Checks if a string starts with any of the specified prefixes.
     * 
     * @param str The string to check
     * @param prefixes The prefixes to check for
     * @return true if the string starts with any of the prefixes, false otherwise
     */
    public static boolean startsWithAny(String str, String... prefixes) {
        if (str == null || prefixes == null) {
            return false;
        }
        
        for (String prefix : prefixes) {
            if (prefix != null && str.startsWith(prefix)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Checks if a string ends with any of the specified suffixes.
     * 
     * @param str The string to check
     * @param suffixes The suffixes to check for
     * @return true if the string ends with any of the suffixes, false otherwise
     */
    public static boolean endsWithAny(String str, String... suffixes) {
        if (str == null || suffixes == null) {
            return false;
        }
        
        for (String suffix : suffixes) {
            if (suffix != null && str.endsWith(suffix)) {
                return true;
            }
        }
        
        return false;
    }
}

package com.cstestforge.framework.core.utils;

import java.awt.AWTException;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.Robot;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Base64;
import java.util.concurrent.atomic.AtomicLong;
import javax.imageio.ImageIO;

/**
 * Manages screenshot capture, storage, and manipulation for the framework.
 * This class provides methods for capturing screenshots in various formats
 * and performing operations on them.
 */
public class CSScreenshotManager {
    
    // Default screenshot format
    private static final String DEFAULT_FORMAT = "png";
    
    // Default screenshot quality (0.0 to 1.0)
    private static final float DEFAULT_QUALITY = 0.9f;
    
    // Screenshot counter for generating unique filenames
    private static final AtomicLong SCREENSHOT_COUNTER = new AtomicLong(0);
    
    // Path to the screenshot directory
    private String screenshotDir;
    
    /**
     * Constructs a new CSScreenshotManager with the default screenshot directory.
     */
    public CSScreenshotManager() {
        this(null);
    }
    
    /**
     * Constructs a new CSScreenshotManager with the specified screenshot directory.
     * 
     * @param screenshotDir The screenshot directory path
     */
    public CSScreenshotManager(String screenshotDir) {
        if (screenshotDir == null || screenshotDir.isEmpty()) {
            this.screenshotDir = System.getProperty("user.dir") + File.separator + "screenshots";
        } else {
            this.screenshotDir = screenshotDir;
        }
        
        // Create the screenshot directory if it doesn't exist
        createScreenshotDir();
    }
    
    /**
     * Gets the screenshot directory path.
     * 
     * @return The screenshot directory path
     */
    public String getScreenshotDir() {
        return screenshotDir;
    }
    
    /**
     * Sets the screenshot directory path.
     * 
     * @param screenshotDir The screenshot directory path
     */
    public void setScreenshotDir(String screenshotDir) {
        if (screenshotDir != null && !screenshotDir.isEmpty()) {
            this.screenshotDir = screenshotDir;
            createScreenshotDir();
        }
    }
    
    /**
     * Creates the screenshot directory if it doesn't exist.
     */
    private void createScreenshotDir() {
        File dir = new File(screenshotDir);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }
    
    /**
     * Captures a screenshot of the entire screen.
     * 
     * @return The screenshot as a BufferedImage
     * @throws AWTException If an error occurs during screenshot capture
     */
    public BufferedImage captureScreen() throws AWTException {
        Robot robot = new Robot();
        Rectangle screenRect = new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());
        return robot.createScreenCapture(screenRect);
    }
    
    /**
     * Captures a screenshot of a specific monitor.
     * 
     * @param monitorIndex The index of the monitor (0-based)
     * @return The screenshot as a BufferedImage
     * @throws AWTException If an error occurs during screenshot capture
     * @throws IllegalArgumentException If the monitor index is invalid
     */
    public BufferedImage captureMonitor(int monitorIndex) throws AWTException {
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice[] screens = ge.getScreenDevices();
        
        if (monitorIndex < 0 || monitorIndex >= screens.length) {
            throw new IllegalArgumentException("Invalid monitor index: " + monitorIndex + 
                                             ". Valid range is 0 to " + (screens.length - 1));
        }
        
        Robot robot = new Robot(screens[monitorIndex]);
        Rectangle screenRect = screens[monitorIndex].getDefaultConfiguration().getBounds();
        return robot.createScreenCapture(screenRect);
    }
    
    /**
     * Captures a screenshot of a specific region.
     * 
     * @param x The x-coordinate of the top-left corner
     * @param y The y-coordinate of the top-left corner
     * @param width The width of the region
     * @param height The height of the region
     * @return The screenshot as a BufferedImage
     * @throws AWTException If an error occurs during screenshot capture
     */
    public BufferedImage captureRegion(int x, int y, int width, int height) throws AWTException {
        Robot robot = new Robot();
        Rectangle region = new Rectangle(x, y, width, height);
        return robot.createScreenCapture(region);
    }
    
    /**
     * Saves a screenshot to a file with the default format (PNG).
     * 
     * @param image The screenshot to save
     * @param filePath The file path
     * @throws IOException If an error occurs saving the screenshot
     */
    public void saveScreenshot(BufferedImage image, String filePath) throws IOException {
        saveScreenshot(image, filePath, DEFAULT_FORMAT);
    }
    
    /**
     * Saves a screenshot to a file with the specified format.
     * 
     * @param image The screenshot to save
     * @param filePath The file path
     * @param format The image format (e.g., "png", "jpg")
     * @throws IOException If an error occurs saving the screenshot
     */
    public void saveScreenshot(BufferedImage image, String filePath, String format) throws IOException {
        if (image == null) {
            throw new IllegalArgumentException("Screenshot image cannot be null");
        }
        
        if (filePath == null || filePath.isEmpty()) {
            throw new IllegalArgumentException("File path cannot be null or empty");
        }
        
        if (format == null || format.isEmpty()) {
            format = DEFAULT_FORMAT;
        }
        
        // Create parent directories if needed
        File file = new File(filePath);
        File parent = file.getParentFile();
        if (parent != null && !parent.exists()) {
            parent.mkdirs();
        }
        
        // Save the image
        ImageIO.write(image, format, file);
    }
    
    /**
     * Captures a screenshot of the entire screen and saves it to a file.
     * 
     * @param filePath The file path
     * @return The full path to the saved screenshot
     * @throws AWTException If an error occurs during screenshot capture
     * @throws IOException If an error occurs saving the screenshot
     */
    public String captureAndSaveScreen(String filePath) throws AWTException, IOException {
        BufferedImage screenshot = captureScreen();
        saveScreenshot(screenshot, filePath);
        return new File(filePath).getAbsolutePath();
    }
    
    /**
     * Captures a screenshot of the entire screen and saves it to a file with a generated name.
     * 
     * @param prefix The filename prefix
     * @param format The image format (e.g., "png", "jpg")
     * @return The full path to the saved screenshot
     * @throws AWTException If an error occurs during screenshot capture
     * @throws IOException If an error occurs saving the screenshot
     */
    public String captureAndSaveScreen(String prefix, String format) throws AWTException, IOException {
        if (prefix == null || prefix.isEmpty()) {
            prefix = "screenshot";
        }
        
        if (format == null || format.isEmpty()) {
            format = DEFAULT_FORMAT;
        }
        
        // Generate a unique filename
        String timestamp = CSDateUtils.getFileNameTimestamp();
        String counter = String.format("%05d", SCREENSHOT_COUNTER.incrementAndGet());
        String filename = prefix + "_" + timestamp + "_" + counter + "." + format;
        String filePath = screenshotDir + File.separator + filename;
        
        // Capture and save the screenshot
        BufferedImage screenshot = captureScreen();
        saveScreenshot(screenshot, filePath, format);
        
        return new File(filePath).getAbsolutePath();
    }
    
    /**
     * Captures a screenshot of the entire screen and returns it as a Base64-encoded string.
     * 
     * @param format The image format (e.g., "png", "jpg")
     * @return The Base64-encoded screenshot
     * @throws AWTException If an error occurs during screenshot capture
     * @throws IOException If an error occurs encoding the screenshot
     */
    public String captureScreenAsBase64(String format) throws AWTException, IOException {
        BufferedImage screenshot = captureScreen();
        return imageToBase64(screenshot, format);
    }
    
    /**
     * Converts a BufferedImage to a Base64-encoded string.
     * 
     * @param image The image to convert
     * @param format The image format (e.g., "png", "jpg")
     * @return The Base64-encoded image
     * @throws IOException If an error occurs encoding the image
     */
    public String imageToBase64(BufferedImage image, String format) throws IOException {
        if (image == null) {
            throw new IllegalArgumentException("Image cannot be null");
        }
        
        if (format == null || format.isEmpty()) {
            format = DEFAULT_FORMAT;
        }
        
        // Create a temporary file to save the image
        Path tempFile = Files.createTempFile("screenshot", "." + format);
        
        try {
            // Save the image to the temporary file
            ImageIO.write(image, format, tempFile.toFile());
            
            // Read the file as bytes and encode to Base64
            byte[] fileBytes = Files.readAllBytes(tempFile);
            return Base64.getEncoder().encodeToString(fileBytes);
        } finally {
            // Delete the temporary file
            Files.deleteIfExists(tempFile);
        }
    }
    
    /**
     * Converts a Base64-encoded image to a BufferedImage.
     * 
     * @param base64Image The Base64-encoded image
     * @return The BufferedImage
     * @throws IOException If an error occurs decoding the image
     */
    public BufferedImage base64ToImage(String base64Image) throws IOException {
        if (base64Image == null || base64Image.isEmpty()) {
            throw new IllegalArgumentException("Base64 image cannot be null or empty");
        }
        
        // Decode the Base64 string to bytes
        byte[] imageBytes = Base64.getDecoder().decode(base64Image);
        
        // Create a temporary file to save the bytes
        Path tempFile = Files.createTempFile("image", ".tmp");
        
        try {
            // Write the bytes to the temporary file
            Files.write(tempFile, imageBytes);
            
            // Read the image from the temporary file
            return ImageIO.read(tempFile.toFile());
        } finally {
            // Delete the temporary file
            Files.deleteIfExists(tempFile);
        }
    }
    
    /**
     * Resizes a BufferedImage to the specified width and height.
     * 
     * @param image The image to resize
     * @param width The target width
     * @param height The target height
     * @return The resized image
     */
    public BufferedImage resizeImage(BufferedImage image, int width, int height) {
        if (image == null) {
            throw new IllegalArgumentException("Image cannot be null");
        }
        
        if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Width and height must be positive");
        }
        
        BufferedImage resizedImage = new BufferedImage(width, height, image.getType());
        java.awt.Graphics2D g = resizedImage.createGraphics();
        g.drawImage(image, 0, 0, width, height, null);
        g.dispose();
        
        return resizedImage;
    }
    
    /**
     * Creates a thumbnail of a BufferedImage.
     * 
     * @param image The image to create a thumbnail from
     * @param maxWidth The maximum width of the thumbnail
     * @param maxHeight The maximum height of the thumbnail
     * @return The thumbnail image
     */
    public BufferedImage createThumbnail(BufferedImage image, int maxWidth, int maxHeight) {
        if (image == null) {
            throw new IllegalArgumentException("Image cannot be null");
        }
        
        if (maxWidth <= 0 || maxHeight <= 0) {
            throw new IllegalArgumentException("Maximum width and height must be positive");
        }
        
        int originalWidth = image.getWidth();
        int originalHeight = image.getHeight();
        
        // Calculate the thumbnail dimensions while maintaining the aspect ratio
        double widthRatio = (double) maxWidth / originalWidth;
        double heightRatio = (double) maxHeight / originalHeight;
        double ratio = Math.min(widthRatio, heightRatio);
        
        int thumbnailWidth = (int) (originalWidth * ratio);
        int thumbnailHeight = (int) (originalHeight * ratio);
        
        return resizeImage(image, thumbnailWidth, thumbnailHeight);
    }
    
    /**
     * Crops a BufferedImage to the specified region.
     * 
     * @param image The image to crop
     * @param x The x-coordinate of the top-left corner
     * @param y The y-coordinate of the top-left corner
     * @param width The width of the region
     * @param height The height of the region
     * @return The cropped image
     */
    public BufferedImage cropImage(BufferedImage image, int x, int y, int width, int height) {
        if (image == null) {
            throw new IllegalArgumentException("Image cannot be null");
        }
        
        // Validate the crop region
        if (x < 0 || y < 0 || width <= 0 || height <= 0 || 
            x + width > image.getWidth() || y + height > image.getHeight()) {
            throw new IllegalArgumentException("Invalid crop region");
        }
        
        return image.getSubimage(x, y, width, height);
    }
    
    /**
     * Compares two BufferedImages for equality.
     * 
     * @param image1 The first image
     * @param image2 The second image
     * @return true if the images are equal, false otherwise
     */
    public boolean compareImages(BufferedImage image1, BufferedImage image2) {
        if (image1 == null || image2 == null) {
            return false;
        }
        
        // Check dimensions
        if (image1.getWidth() != image2.getWidth() || image1.getHeight() != image2.getHeight()) {
            return false;
        }
        
        // Compare pixel by pixel
        for (int x = 0; x < image1.getWidth(); x++) {
            for (int y = 0; y < image1.getHeight(); y++) {
                if (image1.getRGB(x, y) != image2.getRGB(x, y)) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    /**
     * Calculates the difference percentage between two BufferedImages.
     * 
     * @param image1 The first image
     * @param image2 The second image
     * @return The difference percentage (0.0 to 100.0)
     */
    public double getImageDifferencePercentage(BufferedImage image1, BufferedImage image2) {
        if (image1 == null || image2 == null) {
            return 100.0;
        }
        
        // Check dimensions
        if (image1.getWidth() != image2.getWidth() || image1.getHeight() != image2.getHeight()) {
            return 100.0;
        }
        
        // Count different pixels
        int width = image1.getWidth();
        int height = image1.getHeight();
        int totalPixels = width * height;
        int differentPixels = 0;
        
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                if (image1.getRGB(x, y) != image2.getRGB(x, y)) {
                    differentPixels++;
                }
            }
        }
        
        return (double) differentPixels / totalPixels * 100.0;
    }
    
    /**
     * Creates a difference image highlighting the differences between two BufferedImages.
     * 
     * @param image1 The first image
     * @param image2 The second image
     * @param highlightColor The color to use for highlighting differences (e.g., 0xFF0000 for red)
     * @return The difference image
     */
    public BufferedImage createDifferenceImage(BufferedImage image1, BufferedImage image2, int highlightColor) {
        if (image1 == null || image2 == null) {
            throw new IllegalArgumentException("Images cannot be null");
        }
        
        // Check dimensions
        if (image1.getWidth() != image2.getWidth() || image1.getHeight() != image2.getHeight()) {
            throw new IllegalArgumentException("Images must have the same dimensions");
        }
        
        int width = image1.getWidth();
        int height = image1.getHeight();
        
        // Create a new image to highlight differences
        BufferedImage differenceImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                if (image1.getRGB(x, y) != image2.getRGB(x, y)) {
                    // Highlight the difference
                    differenceImage.setRGB(x, y, highlightColor);
                } else {
                    // Copy the original pixel
                    differenceImage.setRGB(x, y, image1.getRGB(x, y));
                }
            }
        }
        
        return differenceImage;
    }
    
    /**
     * Gets information about a BufferedImage.
     * 
     * @param image The image to get information about
     * @return A map containing image information
     */
    public Map<String, Object> getImageInfo(BufferedImage image) {
        if (image == null) {
            throw new IllegalArgumentException("Image cannot be null");
        }
        
        Map<String, Object> info = new HashMap<>();
        
        info.put("width", image.getWidth());
        info.put("height", image.getHeight());
        info.put("type", getImageTypeName(image.getType()));
        info.put("colorModel", image.getColorModel().toString());
        info.put("aspectRatio", (double) image.getWidth() / image.getHeight());
        
        return info;
    }
    
    /**
     * Gets the name of an image type.
     * 
     * @param type The image type
     * @return The type name
     */
    private String getImageTypeName(int type) {
        switch (type) {
            case BufferedImage.TYPE_INT_RGB:
                return "RGB";
            case BufferedImage.TYPE_INT_ARGB:
                return "ARGB";
            case BufferedImage.TYPE_INT_ARGB_PRE:
                return "ARGB_PRE";
            case BufferedImage.TYPE_INT_BGR:
                return "BGR";
            case BufferedImage.TYPE_3BYTE_BGR:
                return "3BYTE_BGR";
            case BufferedImage.TYPE_4BYTE_ABGR:
                return "4BYTE_ABGR";
            case BufferedImage.TYPE_4BYTE_ABGR_PRE:
                return "4BYTE_ABGR_PRE";
            case BufferedImage.TYPE_USHORT_565_RGB:
                return "USHORT_565_RGB";
            case BufferedImage.TYPE_USHORT_555_RGB:
                return "USHORT_555_RGB";
            case BufferedImage.TYPE_BYTE_GRAY:
                return "BYTE_GRAY";
            case BufferedImage.TYPE_USHORT_GRAY:
                return "USHORT_GRAY";
            case BufferedImage.TYPE_BYTE_BINARY:
                return "BYTE_BINARY";
            case BufferedImage.TYPE_BYTE_INDEXED:
                return "BYTE_INDEXED";
            case BufferedImage.TYPE_CUSTOM:
                return "CUSTOM";
            default:
                return "UNKNOWN";
        }
    }
    
    /**
     * Loads a BufferedImage from a file.
     * 
     * @param filePath The file path
     * @return The loaded image
     * @throws IOException If an error occurs loading the image
     */
    public BufferedImage loadImage(String filePath) throws IOException {
        if (filePath == null || filePath.isEmpty()) {
            throw new IllegalArgumentException("File path cannot be null or empty");
        }
        
        File file = new File(filePath);
        if (!file.exists() || !file.isFile()) {
            throw new IOException("File does not exist or is not a file: " + filePath);
        }
        
        return ImageIO.read(file);
    }
    
    /**
     * Loads a BufferedImage from a Base64-encoded string.
     * 
     * @param base64Image The Base64-encoded image
     * @return The loaded image
     * @throws IOException If an error occurs loading the image
     */
    public BufferedImage loadImageFromBase64(String base64Image) throws IOException {
        return base64ToImage(base64Image);
    }
    
    /**
     * Gets the number of screens (monitors) available.
     * 
     * @return The number of screens
     */
    public int getScreenCount() {
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice[] screens = ge.getScreenDevices();
        return screens.length;
    }
    
    /**
     * Gets the bounds of a specific screen (monitor).
     * 
     * @param screenIndex The index of the screen (0-based)
     * @return The screen bounds
     * @throws IllegalArgumentException If the screen index is invalid
     */
    public Rectangle getScreenBounds(int screenIndex) {
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice[] screens = ge.getScreenDevices();
        
        if (screenIndex < 0 || screenIndex >= screens.length) {
            throw new IllegalArgumentException("Invalid screen index: " + screenIndex + 
                                             ". Valid range is 0 to " + (screens.length - 1));
        }
        
        return screens[screenIndex].getDefaultConfiguration().getBounds();
    }
    
    /**
     * Gets the bounds of the entire screen area (across all monitors).
     * 
     * @return The entire screen bounds
     */
    public Rectangle getEntireScreenBounds() {
        return new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());
    }
    
    /**
     * Auto-cleans the screenshot directory by removing screenshots older than a specified age.
     * 
     * @param maxAgeDays The maximum age of screenshots to keep (in days)
     * @return The number of screenshots deleted
     * @throws IOException If an error occurs during cleanup
     */
    public int cleanOldScreenshots(int maxAgeDays) throws IOException {
        if (maxAgeDays <= 0) {
            throw new IllegalArgumentException("Maximum age must be positive");
        }
        
        File dir = new File(screenshotDir);
        if (!dir.exists() || !dir.isDirectory()) {
            return 0;
        }
        
        long cutoffTime = System.currentTimeMillis() - (maxAgeDays * 24L * 60L * 60L * 1000L);
        File[] files = dir.listFiles();
        
        if (files == null) {
            return 0;
        }
        
        int deletedCount = 0;
        
        for (File file : files) {
            if (file.isFile() && file.lastModified() < cutoffTime) {
                if (file.delete()) {
                    deletedCount++;
                }
            }
        }
        
        return deletedCount;
    }
    
    /**
     * Creates an HTML report with all screenshots in the screenshot directory.
     * 
     * @param reportPath The path to save the report
     * @return The full path to the saved report
     * @throws IOException If an error occurs creating the report
     */
    public String createScreenshotReport(String reportPath) throws IOException {
        if (reportPath == null || reportPath.isEmpty()) {
            reportPath = screenshotDir + File.separator + "screenshot_report.html";
        }
        
        File dir = new File(screenshotDir);
        if (!dir.exists() || !dir.isDirectory()) {
            throw new IOException("Screenshot directory does not exist: " + screenshotDir);
        }
        
        File[] files = dir.listFiles((d, name) -> name.toLowerCase().endsWith(".png") || 
                                                name.toLowerCase().endsWith(".jpg") || 
                                                name.toLowerCase().endsWith(".jpeg") || 
                                                name.toLowerCase().endsWith(".gif"));
        
        if (files == null || files.length == 0) {
            throw new IOException("No screenshots found in directory: " + screenshotDir);
        }
        
        StringBuilder html = new StringBuilder();
        html.append("<!DOCTYPE html>\n");
        html.append("<html>\n");
        html.append("<head>\n");
        html.append("    <title>Screenshot Report</title>\n");
        html.append("    <style>\n");
        html.append("        body { font-family: Arial, sans-serif; margin: 20px; }\n");
        html.append("        h1 { color: #333; }\n");
        html.append("        .screenshot { margin-bottom: 20px; border: 1px solid #ddd; padding: 10px; }\n");
        html.append("        .screenshot img { max-width: 100%; height: auto; }\n");
        html.append("        .screenshot-info { margin-top: 5px; color: #666; }\n");
        html.append("    </style>\n");
        html.append("</head>\n");
        html.append("<body>\n");
        html.append("    <h1>Screenshot Report</h1>\n");
        html.append("    <p>Generated on: ").append(CSDateUtils.getCurrentDateTime()).append("</p>\n");
        html.append("    <p>Total screenshots: ").append(files.length).append("</p>\n");
        
        // Sort files by last modified time (newest first)
        Arrays.sort(files, (f1, f2) -> Long.compare(f2.lastModified(), f1.lastModified()));
        
        for (File file : files) {
            String fileName = file.getName();
            String filePath = file.getAbsolutePath();
            long fileSize = file.length();
            String formattedSize = CSFileUtils.formatFileSize(fileSize);
            String lastModified = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date(file.lastModified()));
            
            // Get image dimensions
            BufferedImage image = ImageIO.read(file);
            int width = image.getWidth();
            int height = image.getHeight();
            
            html.append("    <div class=\"screenshot\">\n");
            html.append("        <h2>").append(fileName).append("</h2>\n");
            html.append("        <div class=\"screenshot-info\">\n");
            html.append("            <p>Path: ").append(filePath).append("</p>\n");
            html.append("            <p>Size: ").append(formattedSize).append("</p>\n");
            html.append("            <p>Dimensions: ").append(width).append(" x ").append(height).append("</p>\n");
            html.append("            <p>Last Modified: ").append(lastModified).append("</p>\n");
            html.append("        </div>\n");
            html.append("        <img src=\"").append(file.toURI().toString()).append("\" alt=\"").append(fileName).append("\">\n");
            html.append("    </div>\n");
        }
        
        html.append("</body>\n");
        html.append("</html>");
        
        // Save the report
        File reportFile = new File(reportPath);
        File reportParent = reportFile.getParentFile();
        if (reportParent != null && !reportParent.exists()) {
            reportParent.mkdirs();
        }
        
        Files.write(Paths.get(reportPath), html.toString().getBytes());
        
        return reportFile.getAbsolutePath();
    }
}

package com.cstestforge.framework.core.utils;

/**
 * Constants used throughout the CSTestForge framework.
 * This class defines various constant values to avoid hardcoding values throughout the codebase.
 */
public final class CSConstants {
    
    // Prevent instantiation
    private CSConstants() {
        throw new UnsupportedOperationException("Utility class cannot be instantiated");
    }
    
    //=========================================================================
    // Framework Constants
    //=========================================================================
    
    /** The framework name */
    public static final String FRAMEWORK_NAME = "CSTestForge";
    
    /** The framework version */
    public static final String FRAMEWORK_VERSION = "1.0.0";
    
    /** The framework website URL */
    public static final String FRAMEWORK_WEBSITE = "https://cstestforge.com";
    
    /** The framework build timestamp */
    public static final String FRAMEWORK_BUILD_TIMESTAMP = "2025-05-04T12:00:00Z";
    
    /** The framework copyright notice */
    public static final String FRAMEWORK_COPYRIGHT = " 2025 CSTestForge Contributors";
    
    /** Primary brand color for the framework */
    public static final String BRAND_COLOR_PRIMARY = "#C54B8C";
    
    /** Secondary brand color for the framework */
    public static final String BRAND_COLOR_SECONDARY = "#4B8CC5";
    
    /** Accent brand color for the framework */
    public static final String BRAND_COLOR_ACCENT = "#8CC54B";
    
    //=========================================================================
    // File System Constants
    //=========================================================================
    
    /** Default directory name for storing framework files */
    public static final String DEFAULT_DIR_NAME = ".cstestforge";
    
    /** Default directory name for storing screenshots */
    public static final String SCREENSHOTS_DIR_NAME = "screenshots";
    
    /** Default directory name for storing test reports */
    public static final String REPORTS_DIR_NAME = "reports";
    
    /** Default directory name for storing logs */
    public static final String LOGS_DIR_NAME = "logs";
    
    /** Default directory name for storing test data */
    public static final String TEST_DATA_DIR_NAME = "test-data";
    
    /** Default directory name for storing configurations */
    public static final String CONFIG_DIR_NAME = "config";
    
    /** Default directory name for storing temporary files */
    public static final String TEMP_DIR_NAME = "temp";
    
    /** Default directory name for storing AI models */
    public static final String MODELS_DIR_NAME = "models";
    
    /** Default directory name for storing exported projects */
    public static final String EXPORTS_DIR_NAME = "exports";
    
    /** Default file encoding */
    public static final String DEFAULT_FILE_ENCODING = "UTF-8";
    
    /** Default newline character */
    public static final String DEFAULT_NEWLINE = System.getProperty("line.separator");
    
    //=========================================================================
    // Configuration Constants
    //=========================================================================
    
    /** Default configuration file name */
    public static final String DEFAULT_CONFIG_FILE = "cstestforge.properties";
    
    /** Environment variable prefix for framework configuration */
    public static final String ENV_CONFIG_PREFIX = "CS_";
    
    /** System property prefix for framework configuration */
    public static final String SYS_CONFIG_PREFIX = "cstestforge.";
    
    /** Default configuration directory path */
    public static final String DEFAULT_CONFIG_DIR_PATH = System.getProperty("user.home") + 
                                                     System.getProperty("file.separator") + 
                                                     DEFAULT_DIR_NAME + 
                                                     System.getProperty("file.separator") + 
                                                     "config";
    
    /** Default environment name */
    public static final String DEFAULT_ENVIRONMENT = "default";
    
    /** Development environment name */
    public static final String DEV_ENVIRONMENT = "dev";
    
    /** Testing environment name */
    public static final String TEST_ENVIRONMENT = "test";
    
    /** Staging environment name */
    public static final String STAGE_ENVIRONMENT = "stage";
    
    /** Production environment name */
    public static final String PROD_ENVIRONMENT = "prod";
    
    //=========================================================================
    // Browser Constants
    //=========================================================================
    
    /** Chrome browser name */
    public static final String BROWSER_CHROME = "chrome";
    
    /** Firefox browser name */
    public static final String BROWSER_FIREFOX = "firefox";
    
    /** Edge browser name */
    public static final String BROWSER_EDGE = "edge";
    
    /** Safari browser name */
    public static final String BROWSER_SAFARI = "safari";
    
    /** Internet Explorer browser name */
    public static final String BROWSER_IE = "ie";
    
    /** Default browser name */
    public static final String DEFAULT_BROWSER = BROWSER_CHROME;
    
    /** Default headless mode flag */
    public static final boolean DEFAULT_HEADLESS_MODE = false;
    
    /** Default page load timeout in seconds */
    public static final int DEFAULT_PAGE_LOAD_TIMEOUT = 30;
    
    /** Default element wait timeout in seconds */
    public static final int DEFAULT_ELEMENT_TIMEOUT = 10;
    
    /** Default script timeout in seconds */
    public static final int DEFAULT_SCRIPT_TIMEOUT = 30;
    
    /** Default browser window width */
    public static final int DEFAULT_BROWSER_WIDTH = 1920;
    
    /** Default browser window height */
    public static final int DEFAULT_BROWSER_HEIGHT = 1080;
    
    //=========================================================================
    // Framework Type Constants
    //=========================================================================
    
    /** Selenium framework name */
    public static final String FRAMEWORK_SELENIUM = "selenium";
    
    /** Playwright framework name */
    public static final String FRAMEWORK_PLAYWRIGHT = "playwright";
    
    /** Default framework name */
    public static final String DEFAULT_FRAMEWORK = FRAMEWORK_SELENIUM;
    
    //=========================================================================
    // Language Constants
    //=========================================================================
    
    /** Java language name */
    public static final String LANGUAGE_JAVA = "java";
    
    /** TypeScript language name */
    public static final String LANGUAGE_TYPESCRIPT = "typescript";
    
    /** Default language name */
    public static final String DEFAULT_LANGUAGE = LANGUAGE_JAVA;
    
    //=========================================================================
    // Test Type Constants
    //=========================================================================
    
    /** TestNG test type name */
    public static final String TEST_TYPE_TESTNG = "testng";
    
    /** BDD test type name */
    public static final String TEST_TYPE_BDD = "bdd";
    
    /** Default test type name */
    public static final String DEFAULT_TEST_TYPE = TEST_TYPE_TESTNG;
    
    //=========================================================================
    // Reporting Constants
    //=========================================================================
    
    /** Default report format */
    public static final String DEFAULT_REPORT_FORMAT = "html";
    
    /** Default screenshot format */
    public static final String DEFAULT_SCREENSHOT_FORMAT = "png";
    
    /** Default report title */
    public static final String DEFAULT_REPORT_TITLE = "CSTestForge Test Report";
    
    /** Default report retention period in days */
    public static final int DEFAULT_REPORT_RETENTION_DAYS = 30;
    
    /** Default capture screenshots flag */
    public static final boolean DEFAULT_CAPTURE_SCREENSHOTS = true;
    
    /** Default record videos flag */
    public static final boolean DEFAULT_RECORD_VIDEOS = false;
    
    /** Default screenshot quality (0.0 to 1.0) */
    public static final float DEFAULT_SCREENSHOT_QUALITY = 0.9f;
    
    /** Default date format for reports */
    public static final String DEFAULT_REPORT_DATE_FORMAT = "yyyy-MM-dd HH:mm:ss";
    
    //=========================================================================
    // Parallel Execution Constants
    //=========================================================================
    
    /** Default number of threads for parallel execution */
    public static final int DEFAULT_PARALLEL_THREADS = 1;
    
    /** Default parallel execution mode */
    public static final String DEFAULT_PARALLEL_MODE = "METHODS";
    
    /** Default parallel execution timeout in seconds */
    public static final int DEFAULT_PARALLEL_TIMEOUT = 600;
    
    /** Default data isolation flag for parallel execution */
    public static final boolean DEFAULT_DATA_ISOLATION = true;
    
    //=========================================================================
    // AI Constants
    //=========================================================================
    
    /** Default self-healing locators flag */
    public static final boolean DEFAULT_SELF_HEALING_ENABLED = true;
    
    /** Default locator strategies for AI */
    public static final String DEFAULT_LOCATOR_STRATEGIES = "id,name,css,xpath";
    
    /** Default element dictionary path */
    public static final String DEFAULT_ELEMENT_DICTIONARY_PATH = "dictionaries/elements.json";
    
    /** Default element recognition model path */
    public static final String DEFAULT_ELEMENT_RECOGNITION_MODEL_PATH = "models/element-recognition.model";
    
    /** Default smart locator model path */
    public static final String DEFAULT_SMART_LOCATOR_MODEL_PATH = "models/smart-locator.model";
    
    /** Default self-healing locator model path */
    public static final String DEFAULT_SELF_HEALING_MODEL_PATH = "models/self-healing.model";
    
    /** Default confidence threshold for element recognition (0.0 to 1.0) */
    public static final float DEFAULT_RECOGNITION_CONFIDENCE_THRESHOLD = 0.7f;
    
    //=========================================================================
    // WebSocket Constants
    //=========================================================================
    
    /** Default WebSocket endpoint */
    public static final String DEFAULT_WEBSOCKET_ENDPOINT = "/cstestforge-ws";
    
    /** Default heartbeat interval in milliseconds */
    public static final int DEFAULT_HEARTBEAT_INTERVAL = 30000;
    
    /** Default connection timeout in milliseconds */
    public static final int DEFAULT_CONNECTION_TIMEOUT = 5000;
    
    /** Default retry interval in milliseconds */
    public static final int DEFAULT_RETRY_INTERVAL = 5000;
    
    /** Default maximum number of retry attempts */
    public static final int DEFAULT_MAX_RETRY_ATTEMPTS = 5;
    
    //=========================================================================
    // HTTP Constants
    //=========================================================================
    
    /** Default HTTP connection timeout in milliseconds */
    public static final int DEFAULT_HTTP_CONNECTION_TIMEOUT = 5000;
    
    /** Default HTTP read timeout in milliseconds */
    public static final int DEFAULT_HTTP_READ_TIMEOUT = 30000;
    
    /** Default HTTP user agent */
    public static final String DEFAULT_HTTP_USER_AGENT = FRAMEWORK_NAME + "/" + FRAMEWORK_VERSION;
    
    /** Default HTTP content type */
    public static final String DEFAULT_HTTP_CONTENT_TYPE = "application/json";
    
    /** Default HTTP accept header */
    public static final String DEFAULT_HTTP_ACCEPT = "application/json";
    
    //=========================================================================
    // Data Provider Constants
    //=========================================================================
    
    /** Excel data source type */
    public static final String DATA_SOURCE_EXCEL = "excel";
    
    /** CSV data source type */
    public static final String DATA_SOURCE_CSV = "csv";
    
    /** JSON data source type */
    public static final String DATA_SOURCE_JSON = "json";
    
    /** Database data source type */
    public static final String DATA_SOURCE_DATABASE = "database";
    
    /** Default data source type */
    public static final String DEFAULT_DATA_SOURCE = DATA_SOURCE_EXCEL;
    
    //=========================================================================
    // Export Constants
    //=========================================================================
    
    /** Default export template path */
    public static final String DEFAULT_EXPORT_TEMPLATE_PATH = "templates/exports";
    
    /** Default Maven POM template path */
    public static final String DEFAULT_POM_TEMPLATE_PATH = "templates/projects/maven/pom.xml.template";
    
    /** Default NPM package.json template path */
    public static final String DEFAULT_PACKAGE_JSON_TEMPLATE_PATH = "templates/projects/npm/package.json.template";
    
    /** Default README template path */
    public static final String DEFAULT_README_TEMPLATE_PATH = "templates/projects/README.md.template";
    
    /** Default Azure DevOps pipeline template path */
    public static final String DEFAULT_AZURE_PIPELINE_TEMPLATE_PATH = "templates/pipeline/azure-pipelines.yml.template";
    
    /** Default Jenkins pipeline template path */
    public static final String DEFAULT_JENKINS_PIPELINE_TEMPLATE_PATH = "templates/pipeline/Jenkinsfile.template";
    
    /** Default GitHub Actions workflow template path */
    public static final String DEFAULT_GITHUB_ACTIONS_TEMPLATE_PATH = "templates/pipeline/github-actions.yml.template";
    
    //=========================================================================
    // Injection Script Constants
    //=========================================================================
    
    /** Base injector script path */
    public static final String BASE_INJECTOR_SCRIPT_PATH = "recorder/common/base-injector.js";
    
    /** Event capture script path */
    public static final String EVENT_CAPTURE_SCRIPT_PATH = "recorder/common/event-capture.js";
    
    /** DOM observer script path */
    public static final String DOM_OBSERVER_SCRIPT_PATH = "recorder/common/dom-observer.js";
    
    /** Element identifier script path */
    public static final String ELEMENT_IDENTIFIER_SCRIPT_PATH = "recorder/common/element-identifier.js";
    
    /** Network monitor script path */
    public static final String NETWORK_MONITOR_SCRIPT_PATH = "recorder/common/network-monitor.js";
    
    /** Timing collector script path */
    public static final String TIMING_COLLECTOR_SCRIPT_PATH = "recorder/common/timing-collector.js";
    
    /** Polyfills script path */
    public static final String POLYFILLS_SCRIPT_PATH = "recorder/common/polyfills.js";
    
    /** Version detector script path */
    public static final String VERSION_DETECTOR_SCRIPT_PATH = "recorder/common/version-detector.js";
    
    /** Feature detector script path */
    public static final String FEATURE_DETECTOR_SCRIPT_PATH = "recorder/common/feature-detector.js";
    
    //=========================================================================
    // Logging Constants
    //=========================================================================
    
    /** Error log level */
    public static final String LOG_LEVEL_ERROR = "ERROR";
    
    /** Warning log level */
    public static final String LOG_LEVEL_WARN = "WARN";
    
    /** Info log level */
    public static final String LOG_LEVEL_INFO = "INFO";
    
    /** Debug log level */
    public static final String LOG_LEVEL_DEBUG = "DEBUG";
    
    /** Trace log level */
    public static final String LOG_LEVEL_TRACE = "TRACE";
    
    /** Off log level */
    public static final String LOG_LEVEL_OFF = "OFF";
    
    /** Default log level */
    public static final String DEFAULT_LOG_LEVEL = LOG_LEVEL_INFO;
    
    /** Default log file name pattern */
    public static final String DEFAULT_LOG_FILE_PATTERN = "cstestforge-%d{yyyy-MM-dd}.log";
    
    /** Default log retention period in days */
    public static final int DEFAULT_LOG_RETENTION_DAYS = 30;
    
    /** Default log date format */
    public static final String DEFAULT_LOG_DATE_FORMAT = "yyyy-MM-dd HH:mm:ss.SSS";
    
    /** Default log pattern */
    public static final String DEFAULT_LOG_PATTERN = "%d{" + DEFAULT_LOG_DATE_FORMAT + "} [%thread] %-5level %logger{36} - %msg%n";
    
    //=========================================================================
    // Character Set Constants
    //=========================================================================
    
    /** Alphanumeric character set */
    public static final String CHAR_SET_ALPHANUMERIC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    
    /** Alphabetic character set */
    public static final String CHAR_SET_ALPHABETIC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    
    /** Numeric character set */
    public static final String CHAR_SET_NUMERIC = "0123456789";
    
    /** Uppercase alphabetic character set */
    public static final String CHAR_SET_UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    
    /** Lowercase alphabetic character set */
    public static final String CHAR_SET_LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
    
    /** Special character set */
    public static final String CHAR_SET_SPECIAL = "!@#$%^&*()_+-=[]{}|;:,.<>?";
    
    /** Hexadecimal character set */
    public static final String CHAR_SET_HEX = "0123456789ABCDEF";
    
    //=========================================================================
    // Regular Expression Constants
    //=========================================================================
    
    /** Regular expression for email validation */
    public static final String REGEX_EMAIL = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
    
    /** Regular expression for URL validation */
    public static final String REGEX_URL = "^(https?|ftp)://[a-zA-Z0-9]+(\\.[a-zA-Z0-9]+)*(:[0-9]+)?(/[^\\s]*)?$";
    
    /** Regular expression for IPv4 validation */
    public static final String REGEX_IPV4 = "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
    
    /** Regular expression for IPv6 validation (simplified) */
    public static final String REGEX_IPV6 = "^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$";
    
    /** Regular expression for date validation (yyyy-MM-dd) */
    public static final String REGEX_DATE_ISO = "^\\d{4}-\\d{2}-\\d{2}$";
    
    /** Regular expression for time validation (HH:mm:ss) */
    public static final String REGEX_TIME = "^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$";
    
    /** Regular expression for date-time validation (yyyy-MM-dd HH:mm:ss) */
    public static final String REGEX_DATETIME = "^\\d{4}-\\d{2}-\\d{2} ([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$";
    
    /** Regular expression for alphanumeric validation */
    public static final String REGEX_ALPHANUMERIC = "^[a-zA-Z0-9]+$";
    
    /** Regular expression for alphabetic validation */
    public static final String REGEX_ALPHABETIC = "^[a-zA-Z]+$";
    
    /** Regular expression for numeric validation */
    public static final String REGEX_NUMERIC = "^[0-9]+$";
    
    //=========================================================================
    // MIME Type Constants
    //=========================================================================
    
    /** MIME type for HTML */
    public static final String MIME_TYPE_HTML = "text/html";
    
    /** MIME type for CSS */
    public static final String MIME_TYPE_CSS = "text/css";
    
    /** MIME type for JavaScript */
    public static final String MIME_TYPE_JS = "application/javascript";
    
    /** MIME type for JSON */
    public static final String MIME_TYPE_JSON = "application/json";
    
    /** MIME type for XML */
    public static final String MIME_TYPE_XML = "application/xml";
    
    /** MIME type for plain text */
    public static final String MIME_TYPE_TEXT = "text/plain";
    
    /** MIME type for PDF */
    public static final String MIME_TYPE_PDF = "application/pdf";
    
    /** MIME type for JPEG */
    public static final String MIME_TYPE_JPEG = "image/jpeg";
    
    /** MIME type for PNG */
    public static final String MIME_TYPE_PNG = "image/png";
    
    /** MIME type for GIF */
    public static final String MIME_TYPE_GIF = "image/gif";
    
    /** MIME type for SVG */
    public static final String MIME_TYPE_SVG = "image/svg+xml";
    
    /** MIME type for ZIP */
    public static final String MIME_TYPE_ZIP = "application/zip";
    
    //=========================================================================
    // Element Locator Constants
    //=========================================================================
    
    /** ID locator type */
    public static final String LOCATOR_ID = "id";
    
    /** Name locator type */
    public static final String LOCATOR_NAME = "name";
    
    /** CSS selector locator type */
    public static final String LOCATOR_CSS = "css";
    
    /** XPath locator type */
    public static final String LOCATOR_XPATH = "xpath";
    
    /** Tag name locator type */
    public static final String LOCATOR_TAG_NAME = "tagName";
    
    /** Class name locator type */
    public static final String LOCATOR_CLASS_NAME = "className";
    
    /** Link text locator type */
    public static final String LOCATOR_LINK_TEXT = "linkText";
    
    /** Partial link text locator type */
    public static final String LOCATOR_PARTIAL_LINK_TEXT = "partialLinkText";
    
    //=========================================================================
    // Action Type Constants
    //=========================================================================
    
    /** Click action type */
    public static final String ACTION_CLICK = "click";
    
    /** Type action type */
    public static final String ACTION_TYPE = "type";
    
    /** Clear action type */
    public static final String ACTION_CLEAR = "clear";
    
    /** Select action type */
    public static final String ACTION_SELECT = "select";
    
    /** Navigate action type */
    public static final String ACTION_NAVIGATE = "navigate";
    
    /** Wait action type */
    public static final String ACTION_WAIT = "wait";
    
    /** Assert action type */
    public static final String ACTION_ASSERT = "assert";
    
    /** Store action type */
    public static final String ACTION_STORE = "store";
    
    /** Execute script action type */
    public static final String ACTION_EXECUTE_SCRIPT = "executeScript";
    
    /** Conditional action type */
    public static final String ACTION_CONDITIONAL = "conditional";
    
    /** Loop action type */
    public static final String ACTION_LOOP = "loop";
    
    /** Data provider action type */
    public static final String ACTION_DATA_PROVIDER = "dataProvider";
    
    /** Screenshot action type */
    public static final String ACTION_SCREENSHOT = "screenshot";
    
    /** Custom action type */
    public static final String ACTION_CUSTOM = "custom";
}

package com.cstestforge.framework.core.utils;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Supplier;

import com.cstestforge.framework.core.config.ConfigurationManager;

/**
 * Advanced logging utility for the CSTestForge framework.
 * This class provides configurable logging capabilities with support for
 * different log levels, file and console output, log rotation, and more.
 */
public class CSLogger {
    
    /**
     * The Log Level enumeration defines the available logging levels.
     */
    public enum LogLevel {
        ERROR(1, "ERROR"),
        WARN(2, "WARN"),
        INFO(3, "INFO"),
        DEBUG(4, "DEBUG"),
        TRACE(5, "TRACE");
        
        private final int value;
        private final String name;
        
        LogLevel(int value, String name) {
            this.value = value;
            this.name = name;
        }
        
        public int getValue() {
            return value;
        }
        
        public String getName() {
            return name;
        }
        
        /**
         * Converts a string to a LogLevel enum value.
         *
         * @param level The log level as a string
         * @return The LogLevel enum value, or null if not found
         */
        public static LogLevel fromString(String level) {
            if (level == null) {
                return null;
            }
            
            for (LogLevel logLevel : LogLevel.values()) {
                if (logLevel.getName().equalsIgnoreCase(level)) {
                    return logLevel;
                }
            }
            
            return null;
        }
    }
    
    // Static registry of loggers
    private static final ConcurrentHashMap<String, CSLogger> LOGGERS = new ConcurrentHashMap<>();
    
    // Global log level
    private static LogLevel globalLogLevel = LogLevel.INFO;
    
    // Global console logging flag
    private static boolean globalConsoleLogging = true;
    
    // Global file logging flag
    private static boolean globalFileLogging = true;
    
    // Log file directory
    private static String logFileDirectory = System.getProperty("user.dir") + File.separator + "logs";
    
    // Log file name pattern
    private static String logFileNamePattern = "cstestforge-%d.log";
    
    // Log date format
    private static String logDateFormat = "yyyy-MM-dd HH:mm:ss.SSS";
    
    // Log message counter
    private static final AtomicLong LOG_COUNTER = new AtomicLong(0);
    
    // Maximum log file size in bytes
    private static long maxLogFileSize = 10 * 1024 * 1024; // 10 MB
    
    // Maximum number of log files to keep
    private static int maxLogFiles = 10;
    
    // Current log file
    private static File currentLogFile;
    
    // Current log file writer
    private static FileOutputStream currentLogFileWriter;
    
    // Logger name
    private final String name;
    
    // Logger-specific log level
    private LogLevel logLevel;
    
    // Logger-specific context
    private final Map<String, String> context = new HashMap<>();
    
    // Static initializer to set up logging directory
    static {
        initializeLogger();
    }
    
    /**
     * Initializes the logging system.
     */
    private static void initializeLogger() {
        try {
            // Get configuration values if available
            ConfigurationManager configManager = ConfigurationManager.getInstance();
            
            // Set log level
            String configLogLevel = configManager.getStringConfig("framework.logging.level");
            if (configLogLevel != null && !configLogLevel.isEmpty()) {
                LogLevel level = LogLevel.fromString(configLogLevel);
                if (level != null) {
                    globalLogLevel = level;
                }
            }
            
            // Set console logging flag
            String configConsoleLogging = configManager.getStringConfig("framework.logging.console");
            if (configConsoleLogging != null && !configConsoleLogging.isEmpty()) {
                globalConsoleLogging = Boolean.parseBoolean(configConsoleLogging);
            }
            
            // Set file logging flag
            String configFileLogging = configManager.getStringConfig("framework.logging.file");
            if (configFileLogging != null && !configFileLogging.isEmpty()) {
                globalFileLogging = Boolean.parseBoolean(configFileLogging);
            }
            
            // Set log file directory
            String configLogDir = configManager.getStringConfig("framework.logging.dir");
            if (configLogDir != null && !configLogDir.isEmpty()) {
                logFileDirectory = configLogDir;
            }
            
            // Set log file name pattern
            String configLogPattern = configManager.getStringConfig("framework.logging.file.pattern");
            if (configLogPattern != null && !configLogPattern.isEmpty()) {
                logFileNamePattern = configLogPattern;
            }
            
            // Set log date format
            String configDateFormat = configManager.getStringConfig("framework.logging.date.format");
            if (configDateFormat != null && !configDateFormat.isEmpty()) {
                logDateFormat = configDateFormat;
            }
            
            // Set max log file size
            String configMaxSize = configManager.getStringConfig("framework.logging.max.size");
            if (configMaxSize != null && !configMaxSize.isEmpty()) {
                try {
                    maxLogFileSize = Long.parseLong(configMaxSize);
                } catch (NumberFormatException e) {
                    // Ignore and use default
                }
            }
            
            // Set max log files
            String configMaxFiles = configManager.getStringConfig("framework.logging.max.files");
            if (configMaxFiles != null && !configMaxFiles.isEmpty()) {
                try {
                    maxLogFiles = Integer.parseInt(configMaxFiles);
                } catch (NumberFormatException e) {
                    // Ignore and use default
                }
            }
            
        } catch (Exception e) {
            // Fallback to defaults if configuration fails
            System.err.println("Failed to initialize logger from configuration: " + e.getMessage());
        }
        
        // Create log directory if it doesn't exist
        try {
            Files.createDirectories(Paths.get(logFileDirectory));
        } catch (IOException e) {
            System.err.println("Failed to create log directory: " + e.getMessage());
        }
        
        // Initialize log file
        if (globalFileLogging) {
            initializeLogFile();
        }
    }
    
    /**
     * Initializes the current log file.
     */
    private static synchronized void initializeLogFile() {
        try {
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd");
            String fileName = logFileNamePattern.replace("%d", dateFormat.format(new Date()));
            File logFile = new File(logFileDirectory, fileName);
            
            // Check if file exists and needs rotation
            if (logFile.exists() && logFile.length() >= maxLogFileSize) {
                rotateLogFiles(logFile);
            } else {
                // Create parent directories if needed
                Files.createDirectories(Paths.get(logFileDirectory));
            }
            
            // Close existing writer if open
            if (currentLogFileWriter != null) {
                try {
                    currentLogFileWriter.close();
                } catch (IOException e) {
                    // Ignore
                }
            }
            
            // Open new writer in append mode
            currentLogFileWriter = new FileOutputStream(logFile, true);
            currentLogFile = logFile;
            
        } catch (IOException e) {
            System.err.println("Failed to initialize log file: " + e.getMessage());
            globalFileLogging = false;
        }
    }
    
    /**
     * Rotates log files when the current log file exceeds the maximum size.
     *
     * @param logFile The current log file
     * @throws IOException If an I/O error occurs
     */
    private static void rotateLogFiles(File logFile) throws IOException {
        // Close current writer if open
        if (currentLogFileWriter != null) {
            currentLogFileWriter.close();
            currentLogFileWriter = null;
        }
        
        // Get base file name and extension
        String fileName = logFile.getName();
        int dotIndex = fileName.lastIndexOf('.');
        String baseName = (dotIndex > 0) ? fileName.substring(0, dotIndex) : fileName;
        String extension = (dotIndex > 0) ? fileName.substring(dotIndex) : "";
        
        // Delete oldest log file if maximum number of files is reached
        File oldestFile = new File(logFileDirectory, baseName + "." + maxLogFiles + extension);
        if (oldestFile.exists()) {
            oldestFile.delete();
        }
        
        // Shift existing log files
        for (int i = maxLogFiles - 1; i > 0; i--) {
            File sourceFile = new File(logFileDirectory, baseName + "." + i + extension);
            File targetFile = new File(logFileDirectory, baseName + "." + (i + 1) + extension);
            
            if (sourceFile.exists()) {
                Files.move(sourceFile.toPath(), targetFile.toPath());
            }
        }
        
        // Rename current log file
        File targetFile = new File(logFileDirectory, baseName + ".1" + extension);
        Files.move(logFile.toPath(), targetFile.toPath());
        
        // Create new log file
        Files.createFile(logFile.toPath());
    }
    
    /**
     * Gets a CSLogger instance for the specified name.
     *
     * @param name The logger name
     * @return The CSLogger instance
     */
    public static CSLogger getLogger(String name) {
        return LOGGERS.computeIfAbsent(name, CSLogger::new);
    }
    
    /**
     * Gets a CSLogger instance for the specified class.
     *
     * @param clazz The class
     * @return The CSLogger instance
     */
    public static CSLogger getLogger(Class<?> clazz) {
        return getLogger(clazz.getName());
    }
    
    /**
     * Gets the root logger.
     *
     * @return The root logger
     */
    public static CSLogger getRootLogger() {
        return getLogger("root");
    }
    
    /**
     * Sets the global log level.
     *
     * @param level The log level
     */
    public static void setGlobalLogLevel(LogLevel level) {
        if (level != null) {
            globalLogLevel = level;
        }
    }
    
    /**
     * Sets the global log level from a string.
     *
     * @param level The log level as a string
     */
    public static void setGlobalLogLevel(String level) {
        LogLevel logLevel = LogLevel.fromString(level);
        if (logLevel != null) {
            globalLogLevel = logLevel;
        }
    }
    
    /**
     * Gets the global log level.
     *
     * @return The global log level
     */
    public static LogLevel getGlobalLogLevel() {
        return globalLogLevel;
    }
    
    /**
     * Enables or disables console logging globally.
     *
     * @param enabled Whether console logging is enabled
     */
    public static void setConsoleLogging(boolean enabled) {
        globalConsoleLogging = enabled;
    }
    
    /**
     * Enables or disables file logging globally.
     *
     * @param enabled Whether file logging is enabled
     */
    public static void setFileLogging(boolean enabled) {
        globalFileLogging = enabled;
        
        if (enabled && currentLogFileWriter == null) {
            initializeLogFile();
        } else if (!enabled && currentLogFileWriter != null) {
            try {
                currentLogFileWriter.close();
                currentLogFileWriter = null;
            } catch (IOException e) {
                // Ignore
            }
        }
    }
    
    /**
     * Sets the log file directory.
     *
     * @param directory The log file directory
     */
    public static void setLogFileDirectory(String directory) {
        if (directory != null && !directory.isEmpty()) {
            logFileDirectory = directory;
            
            // Re-initialize log file if file logging is enabled
            if (globalFileLogging) {
                initializeLogFile();
            }
        }
    }
    
    /**
     * Sets the log file name pattern.
     *
     * @param pattern The log file name pattern
     */
    public static void setLogFileNamePattern(String pattern) {
        if (pattern != null && !pattern.isEmpty()) {
            logFileNamePattern = pattern;
            
            // Re-initialize log file if file logging is enabled
            if (globalFileLogging) {
                initializeLogFile();
            }
        }
    }
    
    /**
     * Sets the log date format.
     *
     * @param format The log date format
     */
    public static void setLogDateFormat(String format) {
        if (format != null && !format.isEmpty()) {
            logDateFormat = format;
        }
    }
    
    /**
     * Sets the maximum log file size.
     *
     * @param size The maximum log file size in bytes
     */
    public static void setMaxLogFileSize(long size) {
        if (size > 0) {
            maxLogFileSize = size;
        }
    }
    
    /**
     * Sets the maximum number of log files to keep.
     *
     * @param count The maximum number of log files
     */
    public static void setMaxLogFiles(int count) {
        if (count > 0) {
            maxLogFiles = count;
        }
    }
    
    /**
     * Flushes all log writers to ensure that log messages are written to disk.
     */
    public static void flushAll() {
        if (globalFileLogging && currentLogFileWriter != null) {
            try {
                currentLogFileWriter.flush();
            } catch (IOException e) {
                // Ignore
            }
        }
    }
    
    /**
     * Closes all log writers and releases resources.
     */
    public static void shutdownAll() {
        if (currentLogFileWriter != null) {
            try {
                currentLogFileWriter.flush();
                currentLogFileWriter.close();
                currentLogFileWriter = null;
            } catch (IOException e) {
                // Ignore
            }
        }
    }
    
    /**
     * Gets the current log file path.
     *
     * @return The current log file path, or null if file logging is disabled
     */
    public static String getCurrentLogFilePath() {
        if (globalFileLogging && currentLogFile != null) {
            return currentLogFile.getAbsolutePath();
        }
        
        return null;
    }
    
    /**
     * Cleans up old log files that exceed the retention period.
     *
     * @param retentionDays The retention period in days
     * @return The number of files deleted
     */
    public static int cleanupOldLogFiles(int retentionDays) {
        if (retentionDays <= 0) {
            return 0;
        }
        
        int deletedCount = 0;
        
        try {
            File logDir = new File(logFileDirectory);
            if (!logDir.exists() || !logDir.isDirectory()) {
                return 0;
            }
            
            long cutoffTime = System.currentTimeMillis() - (retentionDays * 24L * 60L * 60L * 1000L);
            File[] logFiles = logDir.listFiles((dir, name) -> name.toLowerCase().endsWith(".log"));
            
            if (logFiles != null) {
                for (File logFile : logFiles) {
                    if (logFile.lastModified() < cutoffTime && !logFile.equals(currentLogFile)) {
                        if (logFile.delete()) {
                            deletedCount++;
                        }
                    }
                }
            }
            
        } catch (Exception e) {
            System.err.println("Failed to clean up old log files: " + e.getMessage());
        }
        
        return deletedCount;
    }
    
    /**
     * Creates a new CSLogger with the specified name.
     *
     * @param name The logger name
     */
    private CSLogger(String name) {
        this.name = name;
        this.logLevel = null; // Use global log level by default
    }
    
    /**
     * Gets the name of this logger.
     *
     * @return The logger name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Sets the log level for this logger.
     *
     * @param level The log level
     * @return This logger instance
     */
    public CSLogger setLogLevel(LogLevel level) {
        this.logLevel = level;
        return this;
    }
    
    /**
     * Sets the log level for this logger from a string.
     *
     * @param level The log level as a string
     * @return This logger instance
     */
    public CSLogger setLogLevel(String level) {
        this.logLevel = LogLevel.fromString(level);
        return this;
    }
    
    /**
     * Gets the log level for this logger.
     *
     * @return The logger-specific log level, or the global log level if not set
     */
    public LogLevel getLogLevel() {
        return (logLevel != null) ? logLevel : globalLogLevel;
    }
    
    /**
     * Adds a context value to this logger.
     *
     * @param key The context key
     * @param value The context value
     * @return This logger instance
     */
    public CSLogger withContext(String key, String value) {
        if (key != null && !key.isEmpty()) {
            context.put(key, value);
        }
        return this;
    }
    
    /**
     * Adds multiple context values to this logger.
     *
     * @param contextMap The context map
     * @return This logger instance
     */
    public CSLogger withContext(Map<String, String> contextMap) {
        if (contextMap != null) {
            context.putAll(contextMap);
        }
        return this;
    }
    
    /**
     * Removes a context value from this logger.
     *
     * @param key The context key
     * @return This logger instance
     */
    public CSLogger removeContext(String key) {
        if (key != null) {
            context.remove(key);
        }
        return this;
    }
    
    /**
     * Clears all context values from this logger.
     *
     * @return This logger instance
     */
    public CSLogger clearContext() {
        context.clear();
        return this;
    }
    
    /**
     * Gets a copy of the context map for this logger.
     *
     * @return The context map
     */
    public Map<String, String> getContext() {
        return new HashMap<>(context);
    }
    
    /**
     * Checks if this logger is enabled for the specified log level.
     *
     * @param level The log level to check
     * @return true if this logger is enabled for the specified log level, false otherwise
     */
    public boolean isEnabled(LogLevel level) {
        if (level == null) {
            return false;
        }
        
        LogLevel currentLevel = getLogLevel();
        return level.getValue() <= currentLevel.getValue();
    }
    
    /**
     * Logs a message at the ERROR level.
     *
     * @param message The message to log
     */
    public void error(String message) {
        if (isEnabled(LogLevel.ERROR)) {
            log(LogLevel.ERROR, message);
        }
    }
    
    /**
     * Logs a message with a throwable at the ERROR level.
     *
     * @param message The message to log
     * @param throwable The throwable to log
     */
    public void error(String message, Throwable throwable) {
        if (isEnabled(LogLevel.ERROR)) {
            log(LogLevel.ERROR, message, throwable);
        }
    }
    
    /**
     * Logs a message supplier at the ERROR level.
     *
     * @param messageSupplier The message supplier
     */
    public void error(Supplier<String> messageSupplier) {
        if (isEnabled(LogLevel.ERROR)) {
            log(LogLevel.ERROR, messageSupplier.get());
        }
    }
    
    /**
     * Logs a message at the WARN level.
     *
     * @param message The message to log
     */
    public void warn(String message) {
        if (isEnabled(LogLevel.WARN)) {
            log(LogLevel.WARN, message);
        }
    }
    
    /**
     * Logs a message with a throwable at the WARN level.
     *
     * @param message The message to log
     * @param throwable The throwable to log
     */
    public void warn(String message, Throwable throwable) {
        if (isEnabled(LogLevel.WARN)) {
            log(LogLevel.WARN, message, throwable);
        }
    }
    
    /**
     * Logs a message supplier at the WARN level.
     *
     * @param messageSupplier The message supplier
     */
    public void warn(Supplier<String> messageSupplier) {
        if (isEnabled(LogLevel.WARN)) {
            log(LogLevel.WARN, messageSupplier.get());
        }
    }
    
    /**
     * Logs a message at the INFO level.
     *
     * @param message The message to log
     */
    public void info(String message) {
        if (isEnabled(LogLevel.INFO)) {
            log(LogLevel.INFO, message);
        }
    }
    
    /**
     * Logs a message with a throwable at the INFO level.
     *
     * @param message The message to log
     * @param throwable The throwable to log
     */
    public void info(String message, Throwable throwable) {
        if (isEnabled(LogLevel.INFO)) {
            log(LogLevel.INFO, message, throwable);
        }
    }
    
    /**
     * Logs a message supplier at the INFO level.
     *
     * @param messageSupplier The message supplier
     */
    public void info(Supplier<String> messageSupplier) {
        if (isEnabled(LogLevel.INFO)) {
            log(LogLevel.INFO, messageSupplier.get());
        }
    }
    
    /**
     * Logs a message at the DEBUG level.
     *
     * @param message The message to log
     */
    public void debug(String message) {
        if (isEnabled(LogLevel.DEBUG)) {
            log(LogLevel.DEBUG, message);
        }
    }
    
    /**
     * Logs a message with a throwable at the DEBUG level.
     *
     * @param message The message to log
     * @param throwable The throwable to log
     */
    public void debug(String message, Throwable throwable) {
        if (isEnabled(LogLevel.DEBUG)) {
            log(LogLevel.DEBUG, message, throwable);
        }
    }
    
    /**
     * Logs a message supplier at the DEBUG level.
     *
     * @param messageSupplier The message supplier
     */
    public void debug(Supplier<String> messageSupplier) {
        if (isEnabled(LogLevel.DEBUG)) {
            log(LogLevel.DEBUG, messageSupplier.get());
        }
    }
    
    /**
     * Logs a message at the TRACE level.
     *
     * @param message The message to log
     */
    public void trace(String message) {
        if (isEnabled(LogLevel.TRACE)) {
            log(LogLevel.TRACE, message);
        }
    }
    
    /**
     * Logs a message with a throwable at the TRACE level.
     *
     * @param message The message to log
     * @param throwable The throwable to log
     */
    public void trace(String message, Throwable throwable) {
        if (isEnabled(LogLevel.TRACE)) {
            log(LogLevel.TRACE, message, throwable);
        }
    }
    
    /**
     * Logs a message supplier at the TRACE level.
     *
     * @param messageSupplier The message supplier
     */
    public void trace(Supplier<String> messageSupplier) {
        if (isEnabled(LogLevel.TRACE)) {
            log(LogLevel.TRACE, messageSupplier.get());
        }
    }
    
    /**
     * Logs a message at the specified level.
     *
     * @param level The log level
     * @param message The message to log
     */
    public void log(LogLevel level, String message) {
        if (level == null || message == null) {
            return;
        }
        
        if (isEnabled(level)) {
            String formattedMessage = formatMessage(level, message);
            writeLog(formattedMessage);
        }
    }
    
    /**
     * Logs a message with a throwable at the specified level.
     *
     * @param level The log level
     * @param messageThe message to log
     * @param throwable The throwable to log
     */
    public void log(LogLevel level, String message, Throwable throwable) {
        if (level == null || message == null) {
            return;
        }
        
        if (isEnabled(level)) {
            StringBuilder sb = new StringBuilder(formatMessage(level, message));
            
            if (throwable != null) {
                StringWriter sw = new StringWriter();
                PrintWriter pw = new PrintWriter(sw);
                throwable.printStackTrace(pw);
                sb.append(System.lineSeparator()).append(sw.toString());
            }
            
            writeLog(sb.toString());
        }
    }
    
    /**
     * Formats a log message with level, timestamp, thread, and context information.
     *
     * @param level The log level
     * @param message The message to format
     * @return The formatted message
     */
    private String formatMessage(LogLevel level, String message) {
        StringBuilder sb = new StringBuilder();
        
        // Add timestamp
        SimpleDateFormat dateFormat = new SimpleDateFormat(logDateFormat);
        sb.append(dateFormat.format(new Date()));
        
        // Add log level
        sb.append(" [").append(level.getName()).append("]");
        
        // Add thread name
        sb.append(" [").append(Thread.currentThread().getName()).append("]");
        
        // Add logger name
        sb.append(" [").append(name).append("]");
        
        // Add context if available
        if (!context.isEmpty()) {
            sb.append(" {");
            boolean first = true;
            for (Map.Entry<String, String> entry : context.entrySet()) {
                if (!first) {
                    sb.append(", ");
                }
                sb.append(entry.getKey()).append("=").append(entry.getValue());
                first = false;
            }
            sb.append("}");
        }
        
        // Add message counter
        sb.append(" (").append(LOG_COUNTER.incrementAndGet()).append(")");
        
        // Add message
        sb.append(" - ").append(message);
        
        return sb.toString();
    }
    
    /**
     * Writes a log message to the configured outputs (console and/or file).
     *
     * @param message The message to write
     */
    private synchronized void writeLog(String message) {
        // Write to console if enabled
        if (globalConsoleLogging) {
            System.out.println(message);
        }
        
        // Write to file if enabled
        if (globalFileLogging && currentLogFileWriter != null) {
            try {
                // Check if log file needs rotation
                if (currentLogFile != null && currentLogFile.length() >= maxLogFileSize) {
                    initializeLogFile();
                }
                
                // Write message with newline
                if (currentLogFileWriter != null) {
                    byte[] bytes = (message + System.lineSeparator()).getBytes(CSConstants.DEFAULT_FILE_ENCODING);
                    currentLogFileWriter.write(bytes);
                    currentLogFileWriter.flush();
                }
                
            } catch (IOException e) {
                // Fallback to console
                System.err.println("Failed to write to log file: " + e.getMessage());
                System.err.println("Original message: " + message);
            }
        }
    }
    
    /**
     * Gets all log files in the log directory.
     *
     * @return An array of log files, or an empty array if no log files exist
     */
    public static File[] getLogFiles() {
        File logDir = new File(logFileDirectory);
        if (!logDir.exists() || !logDir.isDirectory()) {
            return new File[0];
        }
        
        File[] logFiles = logDir.listFiles((dir, name) -> name.toLowerCase().endsWith(".log"));
        return (logFiles != null) ? logFiles : new File[0];
    }
    
    /**
     * Creates a log summary with start/end timestamps, count by log level, etc.
     *
     * @param logFile The log file to summarize
     * @return A map containing summary information
     */
    public static Map<String, Object> summarizeLogFile(File logFile) {
        Map<String, Object> summary = new HashMap<>();
        
        if (logFile == null || !logFile.exists() || !logFile.isFile()) {
            return summary;
        }
        
        summary.put("fileName", logFile.getName());
        summary.put("filePath", logFile.getAbsolutePath());
        summary.put("fileSize", logFile.length());
        summary.put("fileSizeFormatted", CSFileUtils.formatFileSize(logFile.length()));
        summary.put("lastModified", new Date(logFile.lastModified()));
        
        int totalLines = 0;
        int errorCount = 0;
        int warnCount = 0;
        int infoCount = 0;
        int debugCount = 0;
        int traceCount = 0;
        String firstTimestamp = null;
        String lastTimestamp = null;
        
        try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
            String line;
            while ((line = reader.readLine()) != null) {
                totalLines++;
                
                // Extract log level
                if (line.contains(" [ERROR]")) {
                    errorCount++;
                } else if (line.contains(" [WARN]")) {
                    warnCount++;
                } else if (line.contains(" [INFO]")) {
                    infoCount++;
                } else if (line.contains(" [DEBUG]")) {
                    debugCount++;
                } else if (line.contains(" [TRACE]")) {
                    traceCount++;
                }
                
                // Extract timestamp
                if (line.length() > 23) { // Assuming timestamp format like "yyyy-MM-dd HH:mm:ss.SSS"
                    String timestamp = line.substring(0, 23);
                    if (firstTimestamp == null) {
                        firstTimestamp = timestamp;
                    }
                    lastTimestamp = timestamp;
                }
            }
        } catch (IOException e) {
            System.err.println("Failed to summarize log file: " + e.getMessage());
        }
        
        summary.put("totalLines", totalLines);
        summary.put("errorCount", errorCount);
        summary.put("warnCount", warnCount);
        summary.put("infoCount", infoCount);
        summary.put("debugCount", debugCount);
        summary.put("traceCount", traceCount);
        summary.put("firstTimestamp", firstTimestamp);
        summary.put("lastTimestamp", lastTimestamp);
        
        return summary;
    }
    
    /**
     * Gets the contents of a log file as a string.
     *
     * @param logFile The log file to read
     * @return The contents of the log file
     * @throws IOException If an I/O error occurs
     */
    public static String getLogFileContents(File logFile) throws IOException {
        if (logFile == null || !logFile.exists() || !logFile.isFile()) {
            throw new IOException("Log file does not exist or is not a file");
        }
        
        return new String(Files.readAllBytes(logFile.toPath()), CSConstants.DEFAULT_FILE_ENCODING);
    }
    
    /**
     * Gets the lines of a log file matching a specific log level.
     *
     * @param logFile The log file to read
     * @param level The log level to match
     * @return The matching lines
     * @throws IOException If an I/O error occurs
     */
    public static List<String> getLogFileLinesByLevel(File logFile, LogLevel level) throws IOException {
        if (logFile == null || !logFile.exists() || !logFile.isFile()) {
            throw new IOException("Log file does not exist or is not a file");
        }
        
        if (level == null) {
            return Collections.emptyList();
        }
        
        String levelTag = " [" + level.getName() + "]";
        List<String> matchingLines = new ArrayList<>();
        
        try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.contains(levelTag)) {
                    matchingLines.add(line);
                }
            }
        }
        
        return matchingLines;
    }
    
    /**
     * Gets the lines of a log file matching a specific regex pattern.
     *
     * @param logFile The log file to read
     * @param regex The regex pattern to match
     * @return The matching lines
     * @throws IOException If an I/O error occurs
     */
    public static List<String> getLogFileLinesByPattern(File logFile, String regex) throws IOException {
        if (logFile == null || !logFile.exists() || !logFile.isFile()) {
            throw new IOException("Log file does not exist or is not a file");
        }
        
        if (regex == null || regex.isEmpty()) {
            return Collections.emptyList();
        }
        
        Pattern pattern = Pattern.compile(regex);
        List<String> matchingLines = new ArrayList<>();
        
        try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (pattern.matcher(line).find()) {
                    matchingLines.add(line);
                }
            }
        }
        
        return matchingLines;
    }
    
    /**
     * Creates an HTML report of the log files.
     *
     * @param outputPath The output path for the HTML report
     * @return The path to the HTML report
     * @throws IOException If an I/O error occurs
     */
    public static String createLogReport(String outputPath) throws IOException {
        if (outputPath == null || outputPath.isEmpty()) {
            outputPath = logFileDirectory + File.separator + "log-report.html";
        }
        
        File[] logFiles = getLogFiles();
        if (logFiles.length == 0) {
            throw new IOException("No log files found in directory: " + logFileDirectory);
        }
        
        StringBuilder html = new StringBuilder();
        html.append("<!DOCTYPE html>\n");
        html.append("<html>\n");
        html.append("<head>\n");
        html.append("    <title>CSTestForge Log Report</title>\n");
        html.append("    <style>\n");
        html.append("        body { font-family: Arial, sans-serif; margin: 20px; }\n");
        html.append("        h1 { color: ").append(CSConstants.BRAND_COLOR_PRIMARY).append("; }\n");
        html.append("        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }\n");
        html.append("        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n");
        html.append("        th { background-color: ").append(CSConstants.BRAND_COLOR_PRIMARY).append("; color: white; }\n");
        html.append("        tr:nth-child(even) { background-color: #f2f2f2; }\n");
        html.append("        .error { color: red; }\n");
        html.append("        .warn { color: orange; }\n");
        html.append("        .info { color: blue; }\n");
        html.append("        .debug { color: green; }\n");
        html.append("        .trace { color: gray; }\n");
        html.append("    </style>\n");
        html.append("</head>\n");
        html.append("<body>\n");
        html.append("    <h1>CSTestForge Log Report</h1>\n");
        html.append("    <p>Generated on: ").append(CSDateUtils.getCurrentDateTime()).append("</p>\n");
        html.append("    <p>Total log files: ").append(logFiles.length).append("</p>\n");
        
        // Sort log files by last modified time (newest first)
        Arrays.sort(logFiles, (f1, f2) -> Long.compare(f2.lastModified(), f1.lastModified()));
        
        // Log files summary table
        html.append("    <h2>Log Files Summary</h2>\n");
        html.append("    <table>\n");
        html.append("        <tr>\n");
        html.append("            <th>File Name</th>\n");
        html.append("            <th>Size</th>\n");
        html.append("            <th>Last Modified</th>\n");
        html.append("            <th>Total Lines</th>\n");
        html.append("            <th>Error</th>\n");
        html.append("            <th>Warn</th>\n");
        html.append("            <th>Info</th>\n");
        html.append("            <th>Debug</th>\n");
        html.append("            <th>Trace</th>\n");
        html.append("            <th>First Timestamp</th>\n");
        html.append("            <th>Last Timestamp</th>\n");
        html.append("        </tr>\n");
        
        for (File logFile : logFiles) {
            Map<String, Object> summary = summarizeLogFile(logFile);
            
            html.append("        <tr>\n");
            html.append("            <td>").append(summary.get("fileName")).append("</td>\n");
            html.append("            <td>").append(summary.get("fileSizeFormatted")).append("</td>\n");
            html.append("            <td>").append(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(summary.get("lastModified"))).append("</td>\n");
            html.append("            <td>").append(summary.get("totalLines")).append("</td>\n");
            html.append("            <td class=\"error\">").append(summary.get("errorCount")).append("</td>\n");
            html.append("            <td class=\"warn\">").append(summary.get("warnCount")).append("</td>\n");
            html.append("            <td class=\"info\">").append(summary.get("infoCount")).append("</td>\n");
            html.append("            <td class=\"debug\">").append(summary.get("debugCount")).append("</td>\n");
            html.append("            <td class=\"trace\">").append(summary.get("traceCount")).append("</td>\n");
            html.append("            <td>").append(summary.get("firstTimestamp")).append("</td>\n");
            html.append("            <td>").append(summary.get("lastTimestamp")).append("</td>\n");
            html.append("        </tr>\n");
        }
        
        html.append("    </table>\n");
        
        // Error logs from most recent file
        if (logFiles.length > 0) {
            html.append("    <h2>Recent Error Logs</h2>\n");
            List<String> errorLines = getLogFileLinesByLevel(logFiles[0], LogLevel.ERROR);
            
            if (errorLines.isEmpty()) {
                html.append("    <p>No error logs found in the most recent log file.</p>\n");
            } else {
                html.append("    <table>\n");
                html.append("        <tr>\n");
                html.append("            <th>Error Log</th>\n");
                html.append("        </tr>\n");
                
                for (String line : errorLines) {
                    html.append("        <tr>\n");
                    html.append("            <td class=\"error\">").append(escapeHtml(line)).append("</td>\n");
                    html.append("        </tr>\n");
                }
                
                html.append("    </table>\n");
            }
            
            // Warning logs from most recent file
            html.append("    <h2>Recent Warning Logs</h2>\n");
            List<String> warnLines = getLogFileLinesByLevel(logFiles[0], LogLevel.WARN);
            
            if (warnLines.isEmpty()) {
                html.append("    <p>No warning logs found in the most recent log file.</p>\n");
            } else {
                html.append("    <table>\n");
                html.append("        <tr>\n");
                html.append("            <th>Warning Log</th>\n");
                html.append("        </tr>\n");
                
                for (String line : warnLines) {
                    html.append("        <tr>\n");
                    html.append("            <td class=\"warn\">").append(escapeHtml(line)).append("</td>\n");
                    html.append("        </tr>\n");
                }
                
                html.append("    </table>\n");
            }
        }
        
        html.append("</body>\n");
        html.append("</html>");
        
        // Save the report
        File reportFile = new File(outputPath);
        File reportParent = reportFile.getParentFile();
        if (reportParent != null && !reportParent.exists()) {
            reportParent.mkdirs();
        }
        
        Files.write(Paths.get(outputPath), html.toString().getBytes(CSConstants.DEFAULT_FILE_ENCODING));
        
        return reportFile.getAbsolutePath();
    }
    
    /**
     * Escapes HTML special characters in a string.
     *
     * @param str The string to escape
     * @return The escaped string
     */
    private static String escapeHtml(String str) {
        if (str == null) {
            return "";
        }
        
        return str.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&#39;");
    }
}


package com.cstestforge.framework.core.utils;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.util.Arrays;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Utility class for encryption and cryptographic operations.
 * This class provides methods for symmetric encryption, hashing, and other security-related operations.
 */
public final class CSEncryptionUtils {

    // Default encryption algorithm
    private static final String DEFAULT_ENCRYPTION_ALGORITHM = "AES/GCM/NoPadding";
    
    // Default key size in bits
    private static final int DEFAULT_KEY_SIZE = 256;
    
    // Default GCM tag length in bits
    private static final int GCM_TAG_LENGTH = 128;
    
    // Default iterations for password-based key derivation
    private static final int DEFAULT_PBKDF2_ITERATIONS = 65536;
    
    // Default salt size in bytes
    private static final int DEFAULT_SALT_SIZE = 16;
    
    // Default IV size in bytes
    private static final int DEFAULT_IV_SIZE = 12;
    
    // Key cache for password-derived keys to avoid repeated expensive derivation
    private static final ConcurrentHashMap<String, SecretKey> KEY_CACHE = new ConcurrentHashMap<>();
    
    // Maximum size of the key cache
    private static final int MAX_KEY_CACHE_SIZE = 10;
    
    // Secure random generator
    private static final SecureRandom SECURE_RANDOM = new SecureRandom();
    
    // Prevent instantiation
    private CSEncryptionUtils() {
        throw new UnsupportedOperationException("Utility class cannot be instantiated");
    }
    
    /**
     * Encrypts a string using the specified encryption key.
     * Uses AES/GCM/NoPadding encryption by default.
     *
     * @param plaintext The string to encrypt
     * @param key The encryption key
     * @return The encrypted string in Base64 format
     * @throws RuntimeException If encryption fails
     */
    public static String encrypt(String plaintext, String key) {
        try {
            return encrypt(plaintext, key, DEFAULT_ENCRYPTION_ALGORITHM);
        } catch (Exception e) {
            throw new RuntimeException("Encryption failed", e);
        }
    }
    
    /**
     * Encrypts a string using the specified encryption key and algorithm.
     *
     * @param plaintext The string to encrypt
     * @param key The encryption key
     * @param algorithm The encryption algorithm to use
     * @return The encrypted string in Base64 format
     * @throws Exception If encryption fails
     */
    public static String encrypt(String plaintext, String key, String algorithm) throws Exception {
        if (plaintext == null || key == null) {
            throw new IllegalArgumentException("Plaintext and key cannot be null");
        }
        
        // Get the encryption algorithm components
        String[] algorithmParts = algorithm.split("/");
        String baseAlgorithm = algorithmParts[0];
        String mode = (algorithmParts.length > 1) ? algorithmParts[1] : "ECB";
        
        // Get or generate the secret key
        SecretKey secretKey = deriveKeyFromPassword(key, baseAlgorithm);
        
        // Generate a random initialization vector
        byte[] iv = new byte[DEFAULT_IV_SIZE];
        SECURE_RANDOM.nextBytes(iv);
        
        // Initialize cipher
        Cipher cipher = Cipher.getInstance(algorithm);
        if ("GCM".equals(mode)) {
            GCMParameterSpec gcmParams = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, gcmParams);
        } else if ("ECB".equals(mode)) {
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        } else {
            IvParameterSpec ivParams = new IvParameterSpec(iv);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParams);
        }
        
        // Encrypt the plaintext
        byte[] plaintextBytes = plaintext.getBytes(StandardCharsets.UTF_8);
        byte[] encryptedBytes = cipher.doFinal(plaintextBytes);
        
        // Combine IV and encrypted bytes
        byte[] combined = new byte[iv.length + encryptedBytes.length];
        System.arraycopy(iv, 0, combined, 0, iv.length);
        System.arraycopy(encryptedBytes, 0, combined, iv.length, encryptedBytes.length);
        
        // Encode to Base64
        return Base64.getEncoder().encodeToString(combined);
    }
    
    /**
     * Decrypts a Base64-encoded encrypted string using the specified decryption key.
     * Uses AES/GCM/NoPadding encryption by default.
     *
     * @param encrypted The Base64-encoded encrypted string
     * @param key The decryption key
     * @return The decrypted string
     * @throws RuntimeException If decryption fails
     */
    public static String decrypt(String encrypted, String key) {
        try {
            return decrypt(encrypted, key, DEFAULT_ENCRYPTION_ALGORITHM);
        } catch (Exception e) {
            throw new RuntimeException("Decryption failed", e);
        }
    }
    
    /**
     * Decrypts a Base64-encoded encrypted string using the specified decryption key and algorithm.
     *
     * @param encrypted The Base64-encoded encrypted string
     * @param key The decryption key
     * @param algorithm The decryption algorithm to use
     * @return The decrypted string
     * @throws Exception If decryption fails
     */
    public static String decrypt(String encrypted, String key, String algorithm) throws Exception {
        if (encrypted == null || key == null) {
            throw new IllegalArgumentException("Encrypted text and key cannot be null");
        }
        
        // Get the encryption algorithm components
        String[] algorithmParts = algorithm.split("/");
        String baseAlgorithm = algorithmParts[0];
        String mode = (algorithmParts.length > 1) ? algorithmParts[1] : "ECB";
        
        // Get or generate the secret key
        SecretKey secretKey = deriveKeyFromPassword(key, baseAlgorithm);
        
        // Decode from Base64
        byte[] combined = Base64.getDecoder().decode(encrypted);
        
        // Extract IV and encrypted bytes
        byte[] iv = Arrays.copyOfRange(combined, 0, DEFAULT_IV_SIZE);
        byte[] encryptedBytes = Arrays.copyOfRange(combined, DEFAULT_IV_SIZE, combined.length);
        
        // Initialize cipher
        Cipher cipher = Cipher.getInstance(algorithm);
        if ("GCM".equals(mode)) {
            GCMParameterSpec gcmParams = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmParams);
        } else if ("ECB".equals(mode)) {
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
        } else {
            IvParameterSpec ivParams = new IvParameterSpec(iv);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParams);
        }
        
        // Decrypt the encrypted bytes
        byte[] decryptedBytes = cipher.doFinal(encryptedBytes);
        
        // Convert to string
        return new String(decryptedBytes, StandardCharsets.UTF_8);
    }
    
    /**
     * Generates a random encryption key.
     *
     * @param algorithm The encryption algorithm
     * @param keySize The key size in bits
     * @return The Base64-encoded encryption key
     * @throws NoSuchAlgorithmException If the algorithm is not available
     */
    public static String generateKey(String algorithm, int keySize) throws NoSuchAlgorithmException {
        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);
        keyGenerator.init(keySize, SECURE_RANDOM);
        SecretKey secretKey = keyGenerator.generateKey();
        return Base64.getEncoder().encodeToString(secretKey.getEncoded());
    }
    
    /**
     * Generates a random encryption key using the default algorithm and key size.
     *
     * @return The Base64-encoded encryption key
     * @throws RuntimeException If key generation fails
     */
    public static String generateKey() {
        try {
            String algorithm = DEFAULT_ENCRYPTION_ALGORITHM.split("/")[0];
            return generateKey(algorithm, DEFAULT_KEY_SIZE);
        } catch (Exception e) {
            throw new RuntimeException("Key generation failed", e);
        }
    }
    
    /**
     * Derives a secret key from a password using PBKDF2.
     *
     * @param password The password
     * @param algorithm The encryption algorithm
     * @return The secret key
     * @throws NoSuchAlgorithmException If the algorithm is not available
     * @throws InvalidKeySpecException If the key specification is invalid
     */
    private static SecretKey deriveKeyFromPassword(String password, String algorithm) 
            throws NoSuchAlgorithmException, InvalidKeySpecException {
        // Check if key is already in cache
        String cacheKey = password + "|" + algorithm;
        if (KEY_CACHE.containsKey(cacheKey)) {
            return KEY_CACHE.get(cacheKey);
        }
        
        // Generate a salt using the password hash to ensure same salt for same password
        byte[] passwordHash = hashString(password, "SHA-256").getBytes(StandardCharsets.UTF_8);
        byte[] salt = Arrays.copyOf(passwordHash, DEFAULT_SALT_SIZE);
        
        // Derive the key
        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, DEFAULT_PBKDF2_ITERATIONS, DEFAULT_KEY_SIZE);
        SecretKey tmpKey = factory.generateSecret(keySpec);
        SecretKey secretKey = new SecretKeySpec(tmpKey.getEncoded(), algorithm);
        
        // Cache the key if cache is not full
        if (KEY_CACHE.size() < MAX_KEY_CACHE_SIZE) {
            KEY_CACHE.put(cacheKey, secretKey);
        }
        
        return secretKey;
    }
    
    /**
     * Computes the hash of a string using the specified algorithm.
     *
     * @param input The input string
     * @param algorithm The hash algorithm (e.g., "MD5", "SHA-1", "SHA-256")
     * @return The hexadecimal hash string
     * @throws RuntimeException If hashing fails
     */
    public static String hashString(String input, String algorithm) {
        try {
            MessageDigest digest = MessageDigest.getInstance(algorithm);
            byte[] hashBytes = digest.digest(input.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hashBytes);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Hashing failed", e);
        }
    }
    
    /**
     * Computes the MD5 hash of a string.
     *
     * @param input The input string
     * @return The hexadecimal MD5 hash string
     * @throws RuntimeException If hashing fails
     */
    public static String md5(String input) {
        return hashString(input, "MD5");
    }
    
    /**
     * Computes the SHA-1 hash of a string.
     *
     * @param input The input string
     * @return The hexadecimal SHA-1 hash string
     * @throws RuntimeException If hashing fails
     */
    public static String sha1(String input) {
        return hashString(input, "SHA-1");
    }
    
    /**
     * Computes the SHA-256 hash of a string.
     *
     * @param input The input string
     * @return The hexadecimal SHA-256 hash string
     * @throws RuntimeException If hashing fails
     */
    public static String sha256(String input) {
        return hashString(input, "SHA-256");
    }
    
    /**
     * Computes the SHA-512 hash of a string.
     *
     * @param input The input string
     * @return The hexadecimal SHA-512 hash string
     * @throws RuntimeException If hashing fails
     */
    public static String sha512(String input) {
        return hashString(input, "SHA-512");
    }
    
    /**
     * Computes the HMAC of a message using the specified algorithm and key.
     *
     * @param message The message
     * @param key The key
     * @param algorithm The HMAC algorithm (e.g., "HmacSHA256")
     * @return The hexadecimal HMAC string
     * @throws RuntimeException If HMAC computation fails
     */
    public static String hmac(String message, String key, String algorithm) {
        try {
            Mac mac = Mac.getInstance(algorithm);
            SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), algorithm);
            mac.init(keySpec);
            byte[] hmacBytes = mac.doFinal(message.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hmacBytes);
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            throw new RuntimeException("HMAC computation failed", e);
        }
    }
    
    /**
     * Computes the HMAC-SHA256 of a message.
     *
     * @param message The message
     * @param key The key
     * @return The hexadecimal HMAC-SHA256 string
     * @throws RuntimeException If HMAC computation fails
     */
    public static String hmacSha256(String message, String key) {
        return hmac(message, key, "HmacSHA256");
    }
    
    /**
     * Converts bytes to a hexadecimal string.
     *
     * @param bytes The byte array
     * @return The hexadecimal string
     */
    public static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder(2 * bytes.length);
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }
    
    /**
     * Converts a hexadecimal string to bytes.
     *
     * @param hexString The hexadecimal string
     * @return The byte array
     */
    public static byte[] hexToBytes(String hexString) {
        if (hexString == null || hexString.length() % 2 != 0) {
            throw new IllegalArgumentException("Invalid hexadecimal string");
        }
        
        int len = hexString.length();
        byte[] bytes = new byte[len / 2];
        
        for (int i = 0; i < len; i += 2) {
            bytes[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) 
                                 + Character.digit(hexString.charAt(i + 1), 16));
        }
        
        return bytes;
    }
    
    /**
     * Generates a random string of the specified length.
     *
     * @param length The length of the string
     * @return The random string
     */
    public static String generateRandomString(int length) {
        if (length <= 0) {
            throw new IllegalArgumentException("Length must be positive");
        }
        
        byte[] randomBytes = new byte[length];
        SECURE_RANDOM.nextBytes(randomBytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes).substring(0, length);
    }
    
    /**
     * Generates a secure random token of the specified byte length.
     *
     * @param byteLength The length of the token in bytes
     * @return The Base64-encoded token
     */
    public static String generateToken(int byteLength) {
        if (byteLength <= 0) {
            throw new IllegalArgumentException("Byte length must be positive");
        }
        
        byte[] tokenBytes = new byte[byteLength];
        SECURE_RANDOM.nextBytes(tokenBytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(tokenBytes);
    }
    
    /**
     * Generates a secure random UUID.
     *
     * @return The UUID string
     */
    public static String generateUuid() {
        byte[] randomBytes = new byte[16];
        SECURE_RANDOM.nextBytes(randomBytes);
        
        randomBytes[6] &= 0x0f;  // Clear version
        randomBytes[6] |= 0x40;  // Set to version 4
        randomBytes[8] &= 0x3f;  // Clear variant
        randomBytes[8] |= 0x80;  // Set to IETF variant
        
        ByteBuffer byteBuffer = ByteBuffer.wrap(randomBytes);
        long mostSigBits = byteBuffer.getLong();
        long leastSigBits = byteBuffer.getLong();
        
        return new java.util.UUID(mostSigBits, leastSigBits).toString();
    }
    
    /**
     * Checks if a password is strong enough.
     *
     * @param password The password to check
     * @param minLength The minimum required length
     * @param requireUppercase Whether to require at least one uppercase letter
     * @param requireLowercase Whether to require at least one lowercase letter
     * @param requireDigit Whether to require at least one digit
     * @param requireSpecial Whether to require at least one special character
     * @return true if the password is strong enough, false otherwise
     */
    public static boolean isStrongPassword(
            String password, 
            int minLength, 
            boolean requireUppercase, 
            boolean requireLowercase, 
            boolean requireDigit, 
            boolean requireSpecial) {
        
        if (password == null || password.length() < minLength) {
            return false;
        }
        
        boolean hasUppercase = !requireUppercase;
        boolean hasLowercase = !requireLowercase;
        boolean hasDigit = !requireDigit;
        boolean hasSpecial = !requireSpecial;
        
        for (char c : password.toCharArray()) {
            if (Character.isUpperCase(c)) {
                hasUppercase = true;
            } else if (Character.isLowerCase(c)) {
                hasLowercase = true;
            } else if (Character.isDigit(c)) {
                hasDigit = true;
            } else {
                hasSpecial = true;
            }
        }
        
        return hasUppercase && hasLowercase && hasDigit && hasSpecial;
    }
    
    /**
     * Checks if a password is strong enough using default requirements.
     *
     * @param password The password to check
     * @return true if the password is strong enough, false otherwise
     */
    public static boolean isStrongPassword(String password) {
        return isStrongPassword(password, 8, true, true, true, true);
    }
    
    /**
     * Generates a password hash using bcrypt.
     *
     * @param password The password to hash
     * @return The bcrypt hash
     * @throws RuntimeException If password hashing fails
     */
    public static String hashPassword(String password) {
        try {
            // Generate a salt
            byte[] salt = new byte[16];
            SECURE_RANDOM.nextBytes(salt);
            
            // Hash the password with PBKDF2
            SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
            KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, DEFAULT_PBKDF2_ITERATIONS, 256);
            byte[] hash = factory.generateSecret(keySpec).getEncoded();
            
            // Combine salt and hash
            byte[] combined = new byte[salt.length + hash.length];
            System.arraycopy(salt, 0, combined, 0, salt.length);
            System.arraycopy(hash, 0, combined, salt.length, hash.length);
            
            // Encode to Base64
            return Base64.getEncoder().encodeToString(combined);
        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new RuntimeException("Password hashing failed", e);
        }
    }
    
    /**
     * Verifies a password against a bcrypt hash.
     *
     * @param password The password to verify
     * @param hashedPassword The bcrypt hash
     * @return true if the password matches the hash, false otherwise
     * @throws RuntimeException If password verification fails
     */
    public static boolean verifyPassword(String password, String hashedPassword) {
        try {
            // Decode from Base64
            byte[] combined = Base64.getDecoder().decode(hashedPassword);
            
            // Extract salt and hash
            byte[] salt = Arrays.copyOfRange(combined, 0, 16);
            byte[] hash = Arrays.copyOfRange(combined, 16, combined.length);
            
            // Hash the password with the same salt
            SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
            KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, DEFAULT_PBKDF2_ITERATIONS, 256);
            byte[] newHash = factory.generateSecret(keySpec).getEncoded();
            
            // Compare the hashes
            return MessageDigest.isEqual(hash, newHash);
        } catch (Exception e) {
            throw new RuntimeException("Password verification failed", e);
        }
    }
    
    /**
     * Encrypts a map of properties using the specified encryption key.
     *
     * @param properties The map of properties to encrypt
     * @param key The encryption key
     * @return The encrypted properties as a Base64-encoded string
     * @throws RuntimeException If encryption fails
     */
    public static String encryptProperties(Map<String, String> properties, String key) {
        try {
            // Convert properties to a string
            StringBuilder sb = new StringBuilder();
            for (Map.Entry<String, String> entry : properties.entrySet()) {
                sb.append(entry.getKey()).append("=").append(entry.getValue()).append("\n");
            }
            
            // Encrypt the string
            return encrypt(sb.toString(), key);
        } catch (Exception e) {
            throw new RuntimeException("Properties encryption failed", e);
        }
    }
    
    /**
     * Decrypts a Base64-encoded encrypted properties string using the specified decryption key.
     *
     * @param encrypted The Base64-encoded encrypted properties string
     * @param key The decryption key
     * @return The decrypted properties as a map
     * @throws RuntimeException If decryption fails
     */
    public static Map<String, String> decryptProperties(String encrypted, String key) {
        try {
            // Decrypt the string
            String decrypted = decrypt(encrypted, key);
            
            // Parse the properties
            Map<String, String> properties = new HashMap<>();
            String[] lines = decrypted.split("\n");
            
            for (String line : lines) {
                int separatorIndex = line.indexOf('=');
                if (separatorIndex > 0) {
                    String propKey = line.substring(0, separatorIndex);
                    String propValue = line.substring(separatorIndex + 1);
                    properties.put(propKey, propValue);
                }
            }
            
            return properties;
        } catch (Exception e) {
            throw new RuntimeException("Properties decryption failed", e);
        }
    }
    
    /**
     * Clears sensitive data from an array.
     *
     * @param array The array to clear
     */
    public static void clearArray(byte[] array) {
        if (array != null) {
            Arrays.fill(array, (byte) 0);
        }
    }
    
    /**
     * Clears sensitive data from a char array.
     *
     * @param array The array to clear
     */
    public static void clearArray(char[] array) {
        if (array != null) {
            Arrays.fill(array, (char) 0);
        }
    }
    
    /**
     * Clears the key cache.
     */
    public static void clearKeyCache() {
        KEY_CACHE.clear();
    }
    
    /**
     * Performs a constant-time comparison of two strings to prevent timing attacks.
     *
     * @param a The first string
     * @param b The second string
     * @return true if the strings are equal, false otherwise
     */
    public static boolean constantTimeEquals(String a, String b) {
        if (a == null || b == null) {
            return false;
        }
        
        byte[] aBytes = a.getBytes(StandardCharsets.UTF_8);
        byte[] bBytes = b.getBytes(StandardCharsets.UTF_8);
        
        return MessageDigest.isEqual(aBytes, bBytes);
    }
}


package com.cstestforge.framework.core.utils;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Utility class for path operations throughout the framework.
 * This class provides methods for path manipulation, resolution, and validation.
 */
public final class CSPathUtils {
    
    // The path separator for the current system
    public static final String PATH_SEPARATOR = File.separator;
    
    // Pattern for detecting absolute paths on Windows (e.g., "C:\path\to\file")
    private static final Pattern WINDOWS_ABSOLUTE_PATH_PATTERN = Pattern.compile("^[A-Za-z]:\\\\.*");
    
    // Pattern for detecting absolute paths on Unix/Linux/macOS (e.g., "/path/to/file")
    private static final Pattern UNIX_ABSOLUTE_PATH_PATTERN = Pattern.compile("^/.*");
    
    // Prevent instantiation
    private CSPathUtils() {
        throw new UnsupportedOperationException("Utility class cannot be instantiated");
    }
    
    /**
     * Normalizes a path by resolving relative paths and standardizing separators.
     *
     * @param path The path to normalize
     * @return The normalized path
     */
    public static String normalizePath(String path) {
        if (path == null || path.isEmpty()) {
            return path;
        }
        
        // Standardize path separators to match the OS
        String normalizedPath = path.replace('\\', File.separatorChar).replace('/', File.separatorChar);
        
        // Resolve relative paths
        Path resolvedPath = Paths.get(normalizedPath).normalize();
        return resolvedPath.toString();
    }
    
    /**
     * Joins path components with the correct separator.
     *
     * @param basePath The base path
     * @param paths Additional path components
     * @return The joined path
     */
    public static String joinPaths(String basePath, String... paths) {
        if (basePath == null) {
            basePath = "";
        }
        
        StringBuilder joinedPath = new StringBuilder(basePath);
        
        for (String path : paths) {
            if (path == null || path.isEmpty()) {
                continue;
            }
            
            // Check if the path is absolute
            if (isAbsolutePath(path)) {
                joinedPath = new StringBuilder(path);
                continue;
            }
            
            // Add separator if needed
            if (joinedPath.length() > 0 && joinedPath.charAt(joinedPath.length() - 1) != File.separatorChar) {
                joinedPath.append(File.separatorChar);
            }
            
            // Remove leading separator from path if present
            if (path.startsWith(PATH_SEPARATOR)) {
                joinedPath.append(path.substring(1));
            } else {
                joinedPath.append(path);
            }
        }
        
        return joinedPath.toString();
    }
    
    /**
     * Gets the relative path from one absolute path to another.
     *
     * @param from The base path
     * @param to The target path
     * @return The relative path
     */
    public static String getRelativePath(String from, String to) {
        Path pathFrom = Paths.get(normalizePath(from));
        Path pathTo = Paths.get(normalizePath(to));
        
        // If either path is not absolute, make it absolute relative to the current directory
        if (!pathFrom.isAbsolute()) {
            pathFrom = Paths.get(System.getProperty("user.dir")).resolve(pathFrom);
        }
        
        if (!pathTo.isAbsolute()) {
            pathTo = Paths.get(System.getProperty("user.dir")).resolve(pathTo);
        }
        
        Path relativePath = pathFrom.relativize(pathTo);
        return relativePath.toString();
    }
    
    /**
     * Gets the parent directory of a path.
     *
     * @param path The path
     * @return The parent directory, or null if the path has no parent
     */
    public static String getParentDirectory(String path) {
        if (path == null || path.isEmpty()) {
            return null;
        }
        
        Path pathObj = Paths.get(normalizePath(path));
        Path parent = pathObj.getParent();
        return parent != null ? parent.toString() : null;
    }
    
    /**
     * Gets the file name from a path.
     *
     * @param path The path
     * @return The file name, or null if the path is null or empty
     */
    public static String getFileName(String path) {
        if (path == null || path.isEmpty()) {
            return null;
        }
        
        Path pathObj = Paths.get(normalizePath(path));
        Path fileName = pathObj.getFileName();
        return fileName != null ? fileName.toString() : null;
    }
    
    /**
     * Gets the file name without extension from a path.
     *
     * @param path The path
     * @return The file name without extension, or null if the path is null or empty
     */
    public static String getFileNameWithoutExtension(String path) {
        String fileName = getFileName(path);
        if (fileName == null) {
            return null;
        }
        
        int dotIndex = fileName.lastIndexOf('.');
        return dotIndex > 0 ? fileName.substring(0, dotIndex) : fileName;
    }
    
    /**
     * Gets the file extension from a path.
     *
     * @param path The path
     * @return The file extension, or an empty string if the file has no extension
     */
    public static String getFileExtension(String path) {
        String fileName = getFileName(path);
        if (fileName == null) {
            return "";
        }
        
        int dotIndex = fileName.lastIndexOf('.');
        return dotIndex > 0 ? fileName.substring(dotIndex + 1) : "";
    }
    
    /**
     * Adds an extension to a file path if it doesn't already have one.
     *
     * @param path The file path
     * @param extension The extension to add (with or without the dot)
     * @return The file path with the extension
     */
    public static String addExtension(String path, String extension) {
        if (path == null) {
            return null;
        }
        
        if (extension == null || extension.isEmpty()) {
            return path;
        }
        
        // Ensure the extension starts with a dot
        String ext = extension.startsWith(".") ? extension : "." + extension;
        
        // Check if the path already has this extension
        if (path.toLowerCase().endsWith(ext.toLowerCase())) {
            return path;
        }
        
        return path + ext;
    }
    
    /**
     * Changes the extension of a file path.
     *
     * @param path The file path
     * @param newExtension The new extension (with or without the dot)
     * @return The file path with the new extension
     */
    public static String changeExtension(String path, String newExtension) {
        if (path == null) {
            return null;
        }
        
        String fileNameWithoutExt = getFileNameWithoutExtension(path);
        if (fileNameWithoutExt == null) {
            return path;
        }
        
        String parent = getParentDirectory(path);
        String newExt = newExtension != null && !newExtension.isEmpty() 
                      ? (newExtension.startsWith(".") ? newExtension : "." + newExtension) 
                      : "";
        
        return parent != null 
             ? joinPaths(parent, fileNameWithoutExt + newExt) 
             : fileNameWithoutExt + newExt;
    }
    
    /**
     * Gets the file name with a new extension.
     *
     * @param fileName The file name
     * @param newExtension The new extension (with or without the dot)
     * @return The file name with the new extension
     */
    public static String getFileNameWithNewExtension(String fileName, String newExtension) {
        if (fileName == null) {
            return null;
        }
        
        int dotIndex = fileName.lastIndexOf('.');
        String nameWithoutExt = dotIndex > 0 ? fileName.substring(0, dotIndex) : fileName;
        String newExt = newExtension != null && !newExtension.isEmpty() 
                      ? (newExtension.startsWith(".") ? newExtension : "." + newExtension) 
                      : "";
        
        return nameWithoutExt + newExt;
    }
    
    /**
     * Checks if a path is absolute.
     *
     * @param path The path to check
     * @return true if the path is absolute, false otherwise
     */
    public static boolean isAbsolutePath(String path) {
        if (path == null || path.isEmpty()) {
            return false;
        }
        
        // Check for Windows absolute path
        if (WINDOWS_ABSOLUTE_PATH_PATTERN.matcher(path).matches()) {
            return true;
        }
        
        // Check for Unix/Linux/macOS absolute path
        if (UNIX_ABSOLUTE_PATH_PATTERN.matcher(path).matches()) {
            return true;
        }
        
        // Use Java's Path API for additional checks
        return Paths.get(path).isAbsolute();
    }
    
    /**
     * Ensures a path is absolute by resolving it relative to the specified base path if necessary.
     *
     * @param path The path to ensure is absolute
     * @param basePath The base path to use for resolution
     * @return The absolute path
     */
    public static String ensureAbsolutePath(String path, String basePath) {
        if (path == null || path.isEmpty()) {
            return basePath;
        }
        
        if (isAbsolutePath(path)) {
            return path;
        }
        
        return joinPaths(basePath, path);
    }
    
    /**
     * Ensures a path is absolute by resolving it relative to the current directory if necessary.
     *
     * @param path The path to ensure is absolute
     * @return The absolute path
     */
    public static String ensureAbsolutePath(String path) {
        return ensureAbsolutePath(path, System.getProperty("user.dir"));
    }
    
    /**
     * Creates a unique file path by appending a number if the file already exists.
     *
     * @param filePath The original file path
     * @return A unique file path
     */
    public static String createUniqueFilePath(String filePath) {
        if (filePath == null) {
            return null;
        }
        
        File file = new File(filePath);
        if (!file.exists()) {
            return filePath;
        }
        
        String directory = file.getParent();
        String fileName = file.getName();
        String nameWithoutExt = getFileNameWithoutExtension(fileName);
        String extension = getFileExtension(fileName);
        
        int counter = 1;
        String newFilePath;
        
        do {
            String newFileName = nameWithoutExt + "_" + counter + (extension.isEmpty() ? "" : "." + extension);
            newFilePath = directory != null ? joinPaths(directory, newFileName) : newFileName;
            counter++;
        } while (new File(newFilePath).exists());
        
        return newFilePath;
    }
    
    /**
     * Checks if a path is a subdirectory of another path.
     *
     * @param parentPath The parent path
     * @param childPath The child path
     * @return true if the child path is a subdirectory of the parent path, false otherwise
     */
    public static boolean isSubdirectory(String parentPath, String childPath) {
        if (parentPath == null || childPath == null) {
            return false;
        }
        
        // Normalize paths
        String normalizedParentPath = normalizePath(parentPath);
        String normalizedChildPath = normalizePath(childPath);
        
        // Ensure both paths are absolute
        Path absoluteParentPath = Paths.get(normalizedParentPath).toAbsolutePath();
        Path absoluteChildPath = Paths.get(normalizedChildPath).toAbsolutePath();
        
        // Check if the child path starts with the parent path
        return absoluteChildPath.startsWith(absoluteParentPath);
    }
    
    /**
     * Gets a temporary directory path.
     *
     * @param subDirectory An optional subdirectory within the temporary directory
     * @return The temporary directory path
     */
    public static String getTempDirectoryPath(String subDirectory) {
        String tempDir = System.getProperty("java.io.tmpdir");
        return subDirectory != null && !subDirectory.isEmpty() 
             ? joinPaths(tempDir, subDirectory) 
             : tempDir;
    }
    
    /**
     * Gets a temporary file path.
     *
     * @param fileName The file name
     * @param extension The file extension (with or without the dot)
     * @return The temporary file path
     */
    public static String getTempFilePath(String fileName, String extension) {
        String tempDir = System.getProperty("java.io.tmpdir");
        String ext = extension != null && !extension.isEmpty() 
                   ? (extension.startsWith(".") ? extension : "." + extension) 
                   : "";
        return joinPaths(tempDir, fileName + ext);
    }
    
    /**
     * Gets the home directory path.
     *
     * @return The home directory path
     */
    public static String getHomeDirectoryPath() {
        return System.getProperty("user.home");
    }
    
    /**
     * Gets the current working directory path.
     *
     * @return The current working directory path
     */
    public static String getCurrentDirectoryPath() {
        return System.getProperty("user.dir");
    }
    
    /**
     * Creates a directory path if it doesn't exist.
     *
     * @param directoryPath The directory path
     * @return true if the directory was created or already exists, false otherwise
     */
    public static boolean createDirectoryIfNotExists(String directoryPath) {
        if (directoryPath == null || directoryPath.isEmpty()) {
            return false;
        }
        
        File directory = new File(directoryPath);
        if (directory.exists()) {
            return directory.isDirectory();
        }
        
        return directory.mkdirs();
    }
    
    /**
     * Resolves a path that may contain environment variables (e.g., ${HOME}/path/to/file).
     *
     * @param path The path with environment variables
     * @return The resolved path
     */
    public static String resolveEnvironmentVariables(String path) {
        if (path == null || path.isEmpty()) {
            return path;
        }
        
        String result = path;
        
        // Check for ${VAR} format
        Pattern pattern = Pattern.compile("\\$\\{([^}]+)\\}");
        java.util.regex.Matcher matcher = pattern.matcher(path);
        
        while (matcher.find()) {
            String varName = matcher.group(1);
            String varValue = System.getenv(varName);
            
            if (varValue == null) {
                // Try system property
                varValue = System.getProperty(varName);
            }
            
            if (varValue != null) {
                result = result.replace("${" + varName + "}", varValue);
            }
        }
        
        // Check for $VAR format
        pattern = Pattern.compile("\\$(\\w+)");
        matcher = pattern.matcher(result);
        
        while (matcher.find()) {
            String varName = matcher.group(1);
            String varValue = System.getenv(varName);
            
            if (varValue == null) {
                // Try system property
                varValue = System.getProperty(varName);
            }
            
            if (varValue != null) {
                result = result.replace("$" + varName, varValue);
            }
        }
        
        // Normalize the result
        return normalizePath(result);
    }
    
    /**
     * Gets the common parent directory of multiple paths.
     *
     * @param paths The paths
     * @return The common parent directory, or null if the paths have no common parent
     */
    public static String getCommonParentDirectory(String... paths) {
        if (paths == null || paths.length == 0) {
            return null;
        }
        
        if (paths.length == 1) {
            return getParentDirectory(paths[0]);
        }
        
        // Normalize all paths and ensure they are absolute
        Path[] absolutePaths = new Path[paths.length];
        for (int i = 0; i < paths.length; i++) {
            if (paths[i] == null) {
                return null;
            }
            
            absolutePaths[i] = Paths.get(normalizePath(paths[i])).toAbsolutePath();
        }
        
        // Get the first path as a starting point
        Path commonParent = absolutePaths[0];
        
        // Iterate through the paths, finding the common parent
        for (int i = 1; i < absolutePaths.length; i++) {
            while (commonParent != null && !absolutePaths[i].startsWith(commonParent)) {
                commonParent = commonParent.getParent();
            }
            
            if (commonParent == null) {
                return null;
            }
        }
        
        return commonParent.toString();
    }
    
    /**
     * Checks if a path is a valid file path.
     *
     * @param path The path to check
     * @return true if the path is a valid file path, false otherwise
     */
    public static boolean isValidFilePath(String path) {
        if (path == null || path.isEmpty()) {
            return false;
        }
        
        try {
            Paths.get(path);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Finds files recursively in a directory that match a pattern.
     *
     * @param directory The directory to search
     * @param pattern The glob pattern to match (e.g., "*.txt")
     * @param maxDepth The maximum recursion depth (-1 for unlimited)
     * @return A list of matching files
     * @throws IOException If an I/O error occurs
     */
    public static List<Path> findFiles(String directory, String pattern, int maxDepth) throws IOException {
        if (directory == null || pattern == null) {
            return new ArrayList<>();
        }
        
        Path dir = Paths.get(directory);
        if (!Files.exists(dir) || !Files.isDirectory(dir)) {
            return new ArrayList<>();
        }
        
        // Use Java NIO to find files
        try (Stream<Path> pathStream = Files.find(dir, maxDepth >= 0 ? maxDepth : Integer.MAX_VALUE, 
                (path, attrs) -> {
                    // Skip directories
                    if (attrs.isDirectory()) {
                        return false;
                    }
                    
                    // Match by glob pattern
                    Path fileName = path.getFileName();
                    if (fileName == null) {
                        return false;
                    }
                    
                    return fileName.toString().matches(globToRegex(pattern));
                })) {
            
            return pathStream.collect(Collectors.toList());
        }
    }
    
    /**
     * Finds files recursively in a directory that match a pattern, with unlimited recursion depth.
     *
     * @param directory The directory to search
     * @param pattern The glob pattern to match (e.g., "*.txt")
     * @return A list of matching files
     * @throws IOException If an I/O error occurs
     */
    public static List<Path> findFiles(String directory, String pattern) throws IOException {
        return findFiles(directory, pattern, -1);
    }
    
    /**
     * Finds directories recursively in a directory that match a pattern.
     *
     * @param directory The directory to search
     * @param pattern The glob pattern to match (e.g., "test*")
     * @param maxDepth The maximum recursion depth (-1 for unlimited)
     * @return A list of matching directories
     * @throws IOException If an I/O error occurs
     */
    public static List<Path> findDirectories(String directory, String pattern, int maxDepth) throws IOException {
        if (directory == null || pattern == null) {
            return new ArrayList<>();
        }
        
        Path dir = Paths.get(directory);
        if (!Files.exists(dir) || !Files.isDirectory(dir)) {
            return new ArrayList<>();
        }
        
        // Use Java NIO to find directories
        try (Stream<Path> pathStream = Files.find(dir, maxDepth >= 0 ? maxDepth : Integer.MAX_VALUE, 
                (path, attrs) -> {
                    // Skip files
                    if (!attrs.isDirectory()) {
                        return false;
                    }
                    
                    // Match by glob pattern
                    Path dirName = path.getFileName();
                    if (dirName == null) {
                        return false;
                    }
                    
                    return dirName.toString().matches(globToRegex(pattern));
                })) {
            
            return pathStream.collect(Collectors.toList());
        }
    }
    
    /**
     * Finds directories recursively in a directory that match a pattern, with unlimited recursion depth.
     *
     * @param directory The directory to search
     * @param pattern The glob pattern to match (e.g., "test*")
     * @return A list of matching directories
     * @throws IOException If an I/O error occurs
     */
    public static List<Path> findDirectories(String directory, String pattern) throws IOException {
        return findDirectories(directory, pattern, -1);
    }
    
    /**
     * Converts a glob pattern to a regex pattern.
     *
     * @param glob The glob pattern
     * @return The regex pattern
     */
    private static String globToRegex(String glob) {
        if (glob == null) {
            return "";
        }
        
        StringBuilder regex = new StringBuilder();
        boolean inGroup = false;
        
        for (int i = 0; i < glob.length(); i++) {
            char c = glob.charAt(i);
            
            switch (c) {
                case '*':
                    regex.append(inGroup ? ".*" : ".*?");
                    break;
                case '?':
                    regex.append(inGroup ? "." : ".?");
                    break;
                case '[':
                    inGroup = true;
                    regex.append('[');
                    break;
                case ']':
                    inGroup = false;
                    regex.append(']');
                    break;
                case '{':
                    regex.append('(');
                    break;
                case '}':
                    regex.append(')');
                    break;
                case ',':
                    regex.append(inGroup ? ',' : '|');
                    break;
                case '\\':
                    regex.append("\\\\");
                    break;
                case '.':
                case '(':
                case ')':
                case '+':
                case '|':
                case '^':
                case '$':
                    regex.append('\\').append(c);
                    break;
                default:
                    regex.append(c);
            }
        }
        
        return regex.toString();
    }
    
    /**
     * Gets the path depth (number of path components).
     *
     * @param path The path
     * @return The path depth
     */
    public static int getPathDepth(String path) {
        if (path == null || path.isEmpty()) {
            return 0;
        }
        
        String normalizedPath = normalizePath(path);
        
        // Split by separator
        String[] components = normalizedPath.split(Pattern.quote(PATH_SEPARATOR));
        
        // Remove empty components
        int depth = 0;
        for (String component : components) {
            if (!component.isEmpty()) {
                depth++;
            }
        }
        
        return depth;
    }
    
    /**
     * Gets the path components.
     *
     * @param path The path
     * @return The path components
     */
    public static String[] getPathComponents(String path) {
        if (path == null || path.isEmpty()) {
            return new String[0];
        }
        
        String normalizedPath = normalizePath(path);
        
        // Split by separator
        String[] components = normalizedPath.split(Pattern.quote(PATH_SEPARATOR));
        
        // Remove empty components
        List<String> validComponents = new ArrayList<>();
        for (String component : components) {
            if (!component.isEmpty()) {
                validComponents.add(component);
            }
        }
        
        return validComponents.toArray(new String[0]);
    }
    
    /**
     * Gets a path component by index.
     *
     * @param path The path
     * @param index The component index (0-based)
     * @return The path component, or null if the index is out of bounds
     */
    public static String getPathComponent(String path, int index) {
        String[] components = getPathComponents(path);
        
        if (index < 0 || index >= components.length) {
            return null;
        }
        
        return components[index];
    }
    
    /**
     * Gets a subpath from the beginning of a path to a specified depth.
     *
     * @param path The path
     * @param depth The subpath depth
     * @return The subpath
     */
    public static String getSubpath(String path, int depth) {
        if (path == null || path.isEmpty() || depth <= 0) {
            return "";
        }
        
        String[] components = getPathComponents(path);
        
        if (depth >= components.length) {
            return path;
        }
        
        StringBuilder subpath = new StringBuilder();
        boolean isAbsolute = isAbsolutePath(path);
        
        if (isAbsolute) {
            if (PATH_SEPARATOR.equals("\\")) {
                // Windows
                if (components.length > 0) {
                    subpath.append(components[0]).append(PATH_SEPARATOR);
                }
            } else {
                // Unix-like
                subpath.append(PATH_SEPARATOR);
            }
        }
        
        for (int i = isAbsolute && PATH_SEPARATOR.equals("\\") ? 1 : 0; i < depth && i < components.length; i++) {
            if (i > (isAbsolute && PATH_SEPARATOR.equals("\\") ? 1 : 0)) {
                subpath.append(PATH_SEPARATOR);
            }
            subpath.append(components[i]);
        }
        
        return subpath.toString();
    }
    
    /**
     * Creates a path from a list of components.
     *
     * @param components The path components
     * @param isAbsolute Whether the path should be absolute
     * @return The path
     */
    public static String createPath(String[] components, boolean isAbsolute) {
        if (components == null || components.length == 0) {
            return isAbsolute ? PATH_SEPARATOR : "";
        }
        
        StringBuilder path = new StringBuilder();
        
        if (isAbsolute) {
            if (PATH_SEPARATOR.equals("\\") && components.length > 0 && components[0].endsWith(":")) {
                // Windows drive letter
                path.append(components[0]).append(PATH_SEPARATOR);
                for (int i = 1; i < components.length; i++) {
                    if (i > 1) {
                        path.append(PATH_SEPARATOR);
                    }
                    path.append(components[i]);
                }
            } else {
                // Unix-like or Windows without drive letter
                path.append(PATH_SEPARATOR);
                for (int i = 0; i < components.length; i++) {
                    if (i > 0) {
                        path.append(PATH_SEPARATOR);
                    }
                    path.append(components[i]);
                }
            }
        } else {
            // Relative path
            for (int i = 0; i < components.length; i++) {
                if (i > 0) {
                    path.append(PATH_SEPARATOR);
                }
                path.append(components[i]);
            }
        }
        
        return path.toString();
    }
    
    /**
     * Gets a new path with one or more components replaced.
     *
     * @param path The original path
     * @param index The index of the component to replace
     * @param newComponent The new component
     * @return The modified path
     */
    public static String replacePathComponent(String path, int index, String newComponent) {
        if (path == null || path.isEmpty() || newComponent == null) {
            return path;
        }
        
        String[] components = getPathComponents(path);
        
        if (index < 0 || index >= components.length) {
            return path;
        }
        
        components[index] = newComponent;
        return createPath(components, isAbsolutePath(path));
    }
    
    /**
     * Gets a path with one or more components removed.
     *
     * @param path The original path
     * @param index The index of the component to remove
     * @return The modified path
     */
    public static String removePathComponent(String path, int index) {
        if (path == null || path.isEmpty()) {
            return path;
        }
        
        String[] components = getPathComponents(path);
        
        if (index < 0 || index >= components.length) {
            return path;
        }
        
        String[] newComponents = new String[components.length - 1];
        System.arraycopy(components, 0, newComponents, 0, index);
        System.arraycopy(components, index + 1, newComponents, index, components.length - index - 1);
        
        return createPath(newComponents, isAbsolutePath(path));
    }
    
    /**
     * Gets a path with one or more components inserted.
     *
     * @param path The original path
     * @param index The index at which to insert the component
     * @param newComponent The new component
     * @return The modified path
     */
    public static String insertPathComponent(String path, int index, String newComponent) {
        if (path == null || path.isEmpty() || newComponent == null) {
            return path;
        }
        
        String[] components = getPathComponents(path);
        
        if (index < 0 || index > components.length) {
            return path;
        }
        
        String[] newComponents = new String[components.length + 1];
        System.arraycopy(components, 0, newComponents, 0, index);
        newComponents[index] = newComponent;
        System.arraycopy(components, index, newComponents, index + 1, components.length - index);
        
        return createPath(newComponents, isAbsolutePath(path));
    }
    
    /**
     * Gets a path with one or more components appended.
     *
     * @param path The original path
     * @param components The components to append
     * @return The modified path
     */
    public static String appendPathComponents(String path, String... components) {
        return joinPaths(path, components);
    }
    
    /**
     * Gets a path with one or more components prepended.
     *
     * @param path The original path
     * @param components The components to prepend
     * @return The modified path
     */
    public static String prependPathComponents(String path, String... components) {
        if (path == null || path.isEmpty()) {
            return joinPaths("", components);
        }
        
        if (components == null || components.length == 0) {
            return path;
        }
        
        return joinPaths(joinPaths("", components), path);
    }
    
    /**
     * Checks if a path exists.
     *
     * @param path The path to check
     * @return true if the path exists, false otherwise
     */
    public static boolean exists(String path) {
        if (path == null || path.isEmpty()) {
            return false;
        }
        
        return Files.exists(Paths.get(path));
    }
    
    /**
     * Checks if a path is a directory.
     *
     * @param path The path to check
     * @return true if the path is a directory, false otherwise
     */
    public static boolean isDirectory(String path) {
        if (path == null || path.isEmpty()) {
            return false;
        }
        
        return Files.isDirectory(Paths.get(path));
    }
    
    /**
     * Checks if a path is a file.
     *
     * @param path The path to check
     * @return true if the path is a file, false otherwise
     */
    public static boolean isFile(String path) {
        if (path == null || path.isEmpty()) {
            return false;
        }
        
        return Files.isRegularFile(Paths.get(path));
    }
    
    /**
     * Checks if a path is readable.
     *
     * @param path The path to check
     * @return true if the path is readable, false otherwise
     */
    public static boolean isReadable(String path) {
        if (path == null || path.isEmpty()) {
            return false;
        }
        
        return Files.isReadable(Paths.get(path));
    }
    
    /**
     * Checks if a path is writable.
     *
     * @param path The path to check
     * @return true if the path is writable, false otherwise
     */
    public static boolean isWritable(String path) {
        if (path == null || path.isEmpty()) {
            return false;
        }
        
        return Files.isWritable(Paths.get(path));
    }
    
    /**
     * Checks if a path is executable.
     *
     * @param path The path to check
     * @return true if the path is executable, false otherwise
     */
    public static boolean isExecutable(String path) {
        if (path == null || path.isEmpty()) {
            return false;
        }
        
        return Files.isExecutable(Paths.get(path));
    }
    
    /**
     * Converts a path to a file URL.
     *
     * @param path The path to convert
     * @return The file URL
     */
    public static String toFileUrl(String path) {
        if (path == null || path.isEmpty()) {
            return null;
        }
        
        try {
            return Paths.get(path).toUri().toURL().toString();
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * Converts a file URL to a path.
     *
     * @param fileUrl The file URL to convert
     * @return The path
     */
    public static String fromFileUrl(String fileUrl) {
        if (fileUrl == null || fileUrl.isEmpty()) {
            return null;
        }
        
        if (!fileUrl.startsWith("file:")) {
            return null;
        }
        
        try {
            return Paths.get(new java.net.URI(fileUrl)).toString();
        } catch (Exception e) {
            return null;
        }
    }
}



package com.cstestforge.framework.core.data.sources;

import java.util.List;
import java.util.Map;

/**
 * Interface for data sources used in data-driven testing.
 * Provides methods for loading, querying, and manipulating test data.
 */
public interface CSDataSource {
    
    /**
     * Initializes the data source with the specified parameters.
     *
     * @param params The initialization parameters
     * @throws Exception If initialization fails
     */
    void initialize(Map<String, Object> params) throws Exception;
    
    /**
     * Loads data from the data source.
     *
     * @throws Exception If loading fails
     */
    void loadData() throws Exception;
    
    /**
     * Closes the data source and releases resources.
     *
     * @throws Exception If closing fails
     */
    void close() throws Exception;
    
    /**
     * Gets all data as a list of maps, where each map represents a row of data.
     *
     * @return The data as a list of maps
     */
    List<Map<String, Object>> getAllData();
    
    /**
     * Gets a subset of data as a list of maps based on query criteria.
     *
     * @param query The query criteria
     * @return The filtered data as a list of maps
     */
    List<Map<String, Object>> getDataByQuery(Map<String, Object> query);
    
    /**
     * Gets a specific row of data as a map based on the index.
     *
     * @param index The row index (0-based)
     * @return The row data as a map, or null if the index is out of bounds
     */
    Map<String, Object> getDataByIndex(int index);
    
    /**
     * Gets a specific column of data as a list based on the column name.
     *
     * @param columnName The column name
     * @return The column data as a list, or an empty list if the column doesn't exist
     */
    List<Object> getColumnData(String columnName);
    
    /**
     * Gets the column names.
     *
     * @return The column names
     */
    List<String> getColumnNames();
    
    /**
     * Gets the number of rows in the data source.
     *
     * @return The number of rows
     */
    int getRowCount();
    
    /**
     * Gets the number of columns in the data source.
     *
     * @return The number of columns
     */
    int getColumnCount();
    
    /**
     * Gets a specific cell value based on the row index and column name.
     *
     * @param rowIndex The row index (0-based)
     * @param columnName The column name
     * @return The cell value, or null if the row index or column name is invalid
     */
    Object getCellValue(int rowIndex, String columnName);
    
    /**
     * Gets the data source type.
     *
     * @return The data source type
     */
    String getSourceType();
    
    /**
     * Gets the data source location.
     *
     * @return The data source location
     */
    String getSourceLocation();
    
    /**
     * Validates the data source structure and content.
     *
     * @return true if the data source is valid, false otherwise
     */
    boolean validate();
    
    /**
     * Gets validation errors if the data source is invalid.
     *
     * @return The validation errors, or an empty list if the data source is valid
     */
    List<String> getValidationErrors();
    
    /**
     * Checks if the data source is empty.
     *
     * @return true if the data source is empty, false otherwise
     */
    boolean isEmpty();
    
    /**
     * Checks if the data source has a specific column.
     *
     * @param columnName The column name
     * @return true if the data source has the column, false otherwise
     */
    boolean hasColumn(String columnName);
    
    /**
     * Gets a filtered data source based on query criteria.
     *
     * @param query The query criteria
     * @return The filtered data source
     */
    CSDataSource filter(Map<String, Object> query);
    
    /**
     * Gets a transformed data source with the specified column names.
     *
     * @param columnNames The column names to include
     * @return The transformed data source
     */
    CSDataSource select(List<String> columnNames);
    
    /**
     * Gets a transformed data source with sorted data based on the column name.
     *
     * @param columnName The column name to sort by
     * @param ascending Whether to sort in ascending order
     * @return The transformed data source
     */
    CSDataSource sort(String columnName, boolean ascending);
    
    /**
     * Gets a transformed data source with a limited number of rows.
     *
     * @param limit The maximum number of rows
     * @return The transformed data source
     */
    CSDataSource limit(int limit);
    
    /**
     * Gets a transformed data source with rows starting from the specified index.
     *
     * @param offset The row index to start from
     * @return The transformed data source
     */
    CSDataSource offset(int offset);
    
    /**
     * Gets a transformed data source with rows matching the specified filter.
     *
     * @param columnName The column name to filter by
     * @param operator The filter operator (e.g., "=", "<", ">", "LIKE")
     * @param value The filter value
     * @return The transformed data source
     */
    CSDataSource where(String columnName, String operator, Object value);
    
    /**
     * Gets a transformed data source with a new column based on the specified transformation.
     *
     * @param newColumnName The new column name
     * @param transformation The transformation function
     * @param sourceColumnNames The source column names for the transformation
     * @return The transformed data source
     */
    CSDataSource withColumn(String newColumnName, DataTransformation transformation, String... sourceColumnNames);
    
    /**
     * Interface for data transformation functions.
     */
    interface DataTransformation {
        /**
         * Transforms source column values into a new column value.
         *
         * @param values The source column values
         * @return The transformed value
         */
        Object transform(Object... values);
    }
    
    /**
     * Gets a transformed data source with a column renamed.
     *
     * @param oldColumnName The old column name
     * @param newColumnName The new column name
     * @return The transformed data source
     */
    CSDataSource renameColumn(String oldColumnName, String newColumnName);
    
    /**
     * Gets a transformed data source with a column dropped.
     *
     * @param columnName The column name to drop
     * @return The transformed data source
     */
    CSDataSource dropColumn(String columnName);
    
    /**
     * Gets a transformed data source with data aggregated by the specified group columns and aggregation functions.
     *
     * @param groupByColumns The columns to group by
     * @param aggregations The aggregation functions (map of output column name to aggregation function)
     * @return The transformed data source
     */
    CSDataSource aggregate(List<String> groupByColumns, Map<String, AggregateFunction> aggregations);
    
    /**
     * Interface for aggregate functions.
     */
    interface AggregateFunction {
        /**
         * Aggregates values into a single result.
         *
         * @param values The values to aggregate
         * @return The aggregated result
         */
        Object aggregate(List<Object> values);
    }
    
    /**
     * Joins this data source with another data source.
     *
     * @param other The other data source
     * @param joinType The join type (e.g., "INNER", "LEFT", "RIGHT", "FULL")
     * @param joinCondition The join condition
     * @return The joined data source
     */
    CSDataSource join(CSDataSource other, String joinType, JoinCondition joinCondition);
    
    /**
     * Interface for join conditions.
     */
    interface JoinCondition {
        /**
         * Checks if two rows should be joined.
         *
         * @param leftRow The left row
         * @param rightRow The right row
         * @return true if the rows should be joined, false otherwise
         */
        boolean matches(Map<String, Object> leftRow, Map<String, Object> rightRow);
    }
    
    /**
     * Converts this data source to another format.
     *
     * @param format The target format
     * @return The converted data
     */
    Object convertTo(String format);
    
    /**
     * Exports this data source to a file.
     *
     * @param filePath The file path
     * @param format The export format
     * @throws Exception If export fails
     */
    void exportTo(String filePath, String format) throws Exception;
    
    /**
     * Creates a deep copy of this data source.
     *
     * @return The copy
     */
    CSDataSource copy();
}


package com.cstestforge.framework.core.data;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import com.cstestforge.framework.core.config.ConfigurationManager;
import com.cstestforge.framework.core.data.sources.CSDataSource;
import com.cstestforge.framework.core.utils.CSConstants;
import com.cstestforge.framework.core.utils.CSFileUtils;
import com.cstestforge.framework.core.utils.CSLogger;
import com.cstestforge.framework.core.utils.CSPathUtils;

/**
 * Factory for creating data sources for data-driven testing.
 * This class provides methods for creating various types of data sources.
 */
public class CSDataSourceFactory {
    
    // Logger instance
    private static final CSLogger LOGGER = CSLogger.getLogger(CSDataSourceFactory.class);
    
    // Registry of data source providers
    private static final ConcurrentHashMap<String, DataSourceProvider> DATA_SOURCE_PROVIDERS = new ConcurrentHashMap<>();
    
    // Instance cache for data sources
    private static final ConcurrentHashMap<String, CSDataSource> DATA_SOURCE_CACHE = new ConcurrentHashMap<>();
    
    // Maximum cache size
    private static final int MAX_CACHE_SIZE = 10;
    
    /**
     * Interface for data source providers.
     */
    public interface DataSourceProvider {
        /**
         * Creates a data source instance.
         *
         * @param params The data source parameters
         * @return The data source instance
         * @throws Exception If creation fails
         */
        CSDataSource createDataSource(Map<String, Object> params) throws Exception;
        
        /**
         * Gets the data source type supported by this provider.
         *
         * @return The data source type
         */
        String getDataSourceType();
    }
    
    // Static initializer to register default data source providers
    static {
        initializeDataSourceProviders();
    }
    
    /**
     * Initializes the default data source providers.
     */
    private static void initializeDataSourceProviders() {
        try {
            // Register data source providers
            registerDataSourceProvider(new ExcelDataSourceProvider());
            registerDataSourceProvider(new CsvDataSourceProvider());
            registerDataSourceProvider(new JsonDataSourceProvider());
            registerDataSourceProvider(new DatabaseDataSourceProvider());
            
            // Try to get custom data source providers from configuration
            ConfigurationManager configManager = ConfigurationManager.getInstance();
            String customProviders = configManager.getStringConfig("framework.data.custom.providers");
            
            if (customProviders != null && !customProviders.isEmpty()) {
                String[] providerClasses = customProviders.split(",");
                
                for (String providerClass : providerClasses) {
                    try {
                        Class<?> clazz = Class.forName(providerClass.trim());
                        Object instance = clazz.getDeclaredConstructor().newInstance();
                        
                        if (instance instanceof DataSourceProvider) {
                            registerDataSourceProvider((DataSourceProvider) instance);
                        } else {
                            LOGGER.warn("Class is not a DataSourceProvider: " + providerClass);
                        }
                    } catch (Exception e) {
                        LOGGER.error("Failed to load custom data source provider: " + providerClass, e);
                    }
                }
            }
        } catch (Exception e) {
            LOGGER.error("Failed to initialize data source providers", e);
        }
    }
    
    /**
     * Registers a data source provider.
     *
     * @param provider The data source provider
     */
    public static void registerDataSourceProvider(DataSourceProvider provider) {
        if (provider != null) {
            String dataSourceType = provider.getDataSourceType();
            
            if (dataSourceType != null && !dataSourceType.isEmpty()) {
                DATA_SOURCE_PROVIDERS.put(dataSourceType.toLowerCase(), provider);
                LOGGER.info("Registered data source provider for type: " + dataSourceType);
            } else {
                LOGGER.warn("Data source provider has invalid type: " + provider.getClass().getName());
            }
        }
    }
    
    /**
     * Unregisters a data source provider.
     *
     * @param dataSourceType The data source type
     */
    public static void unregisterDataSourceProvider(String dataSourceType) {
        if (dataSourceType != null && !dataSourceType.isEmpty()) {
            DATA_SOURCE_PROVIDERS.remove(dataSourceType.toLowerCase());
            LOGGER.info("Unregistered data source provider for type: " + dataSourceType);
        }
    }
    
    /**
     * Gets a data source provider by type.
     *
     * @param dataSourceType The data source type
     * @return The data source provider, or null if not found
     */
    public static DataSourceProvider getDataSourceProvider(String dataSourceType) {
        if (dataSourceType != null && !dataSourceType.isEmpty()) {
            return DATA_SOURCE_PROVIDERS.get(dataSourceType.toLowerCase());
        }
        return null;
    }
    
    /**
     * Gets all registered data source types.
     *
     * @return The registered data source types
     */
    public static String[] getRegisteredDataSourceTypes() {
        return DATA_SOURCE_PROVIDERS.keySet().toArray(new String[0]);
    }
    
    /**
     * Creates a data source based on the file extension.
     *
     * @param filePath The file path
     * @param params Additional parameters
     * @return The data source instance
     * @throws Exception If creation fails
     */
    public static CSDataSource createDataSource(String filePath, Map<String, Object> params) throws Exception {
        if (filePath == null || filePath.isEmpty()) {
            throw new IllegalArgumentException("File path cannot be null or empty");
        }
        
        if (!CSFileUtils.fileExists(filePath)) {
            throw new IllegalArgumentException("File does not exist: " + filePath);
        }
        
        // Check if data source is already in cache
        String cacheKey = filePath;
        if (DATA_SOURCE_CACHE.containsKey(cacheKey)) {
            LOGGER.debug("Using cached data source for file: " + filePath);
            return DATA_SOURCE_CACHE.get(cacheKey);
        }
        
        // Create a map of parameters if null
        Map<String, Object> parameters = params != null ? new HashMap<>(params) : new HashMap<>();
        
        // Add file path to parameters
        parameters.put("filePath", filePath);
        
        // Determine data source type based on file extension
        String fileExtension = CSPathUtils.getFileExtension(filePath).toLowerCase();
        String dataSourceType;
        
        switch (fileExtension) {
            case "xlsx":
            case "xls":
                dataSourceType = CSConstants.DATA_SOURCE_EXCEL;
                break;
            case "csv":
                dataSourceType = CSConstants.DATA_SOURCE_CSV;
                break;
            case "json":
                dataSourceType = CSConstants.DATA_SOURCE_JSON;
                break;
            default:
                throw new IllegalArgumentException("Unsupported file extension: " + fileExtension);
        }
        
        // Create data source
        CSDataSource dataSource = createDataSource(dataSourceType, parameters);
        
        // Cache the data source if cache is not full
        if (DATA_SOURCE_CACHE.size() < MAX_CACHE_SIZE) {
            DATA_SOURCE_CACHE.put(cacheKey, dataSource);
        }
        
        return dataSource;
    }
    
    /**
     * Creates a data source by type.
     *
     * @param dataSourceType The data source type
     * @param params The data source parameters
     * @return The data source instance
     * @throws Exception If creation fails
     */
    public static CSDataSource createDataSource(String dataSourceType, Map<String, Object> params) throws Exception {
        if (dataSourceType == null || dataSourceType.isEmpty()) {
            throw new IllegalArgumentException("Data source type cannot be null or empty");
        }
        
        DataSourceProvider provider = getDataSourceProvider(dataSourceType.toLowerCase());
        
        if (provider == null) {
            throw new IllegalArgumentException("No provider registered for data source type: " + dataSourceType);
        }
        
        CSDataSource dataSource = provider.createDataSource(params);
        
        if (dataSource == null) {
            throw new IllegalStateException("Provider returned null data source: " + dataSourceType);
        }
        
        // Initialize and load data
        dataSource.initialize(params);
        dataSource.loadData();
        
        return dataSource;
    }
    
    /**
     * Clears the data source cache.
     */
    public static void clearCache() {
        DATA_SOURCE_CACHE.clear();
        LOGGER.info("Data source cache cleared");
    }
    
    /**
     * Provider for Excel data sources.
     */
    private static class ExcelDataSourceProvider implements DataSourceProvider {
        @Override
        public CSDataSource createDataSource(Map<String, Object> params) throws Exception {
            return Class.forName("com.cstestforge.framework.core.data.sources.ExcelDataSource")
                       .getDeclaredConstructor()
                       .newInstance();
        }
        
        @Override
        public String getDataSourceType() {
            return CSConstants.DATA_SOURCE_EXCEL;
        }
    }
    
    /**
     * Provider for CSV data sources.
     */
    private static class CsvDataSourceProvider implements DataSourceProvider {
        @Override
        public CSDataSource createDataSource(Map<String, Object> params) throws Exception {
            return Class.forName("com.cstestforge.framework.core.data.sources.CsvDataSource")
                       .getDeclaredConstructor()
                       .newInstance();
        }
        
        @Override
        public String getDataSourceType() {
            return CSConstants.DATA_SOURCE_CSV;
        }
    }
    
    /**
     * Provider for JSON data sources.
     */
    private static class JsonDataSourceProvider implements DataSourceProvider {
        @Override
        public CSDataSource createDataSource(Map<String, Object> params) throws Exception {
            return Class.forName("com.cstestforge.framework.core.data.sources.JsonDataSource")
                       .getDeclaredConstructor()
                       .newInstance();
        }
        
        @Override
        public String getDataSourceType() {
            return CSConstants.DATA_SOURCE_JSON;
        }
    }
    
    /**
     * Provider for database data sources.
     */
    private static class DatabaseDataSourceProvider implements DataSourceProvider {
        @Override
        public CSDataSource createDataSource(Map<String, Object> params) throws Exception {
            return Class.forName("com.cstestforge.framework.core.data.sources.DatabaseDataSource")
                       .getDeclaredConstructor()
                       .newInstance();
        }
        
        @Override
        public String getDataSourceType() {
            return CSConstants.DATA_SOURCE_DATABASE;
        }
    }
}



package com.cstestforge.framework.core.data;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for data-driven testing.
 * This annotation is used to specify data sources for test methods.
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface CSTestForgeDataProvider {
    
    /**
     * The data source type.
     * 
     * @return The data source type (e.g., "excel", "csv", "json", "database")
     */
    String type() default "excel";
    
    /**
     * The data source path or connection string.
     * 
     * @return The data source path or connection string
     */
    String source();
    
    /**
     * The sheet name (for Excel data sources).
     * 
     * @return The sheet name
     */
    String sheet() default "";
    
    /**
     * The table name (for database data sources).
     * 
     * @return The table name
     */
    String table() default "";
    
    /**
     * The query string (for database data sources).
     * 
     * @return The query string
     */
    String query() default "";
    
    /**
     * The delimiter character (for CSV data sources).
     * 
     * @return The delimiter character
     */
    String delimiter() default ",";
    
    /**
     * Whether the data source has a header row.
     * 
     * @return true if the data source has a header row, false otherwise
     */
    boolean hasHeader() default true;
    
    /**
     * The character encoding.
     * 
     * @return The character encoding
     */
    String encoding() default "UTF-8";
    
    /**
     * The columns to include.
     * 
     * @return The columns to include
     */
    String[] columns() default {};
    
    /**
     * The columns to exclude.
     * 
     * @return The columns to exclude
     */
    String[] excludeColumns() default {};
    
    /**
     * The filters to apply to the data source.
     * Format: "columnName operator value"
     * Example: "age > 18" or "name = 'John'"
     * 
     * @return The filters
     */
    String[] filters() default {};
    
    /**
     * The column to sort by.
     * 
     * @return The sort column
     */
    String sortBy() default "";
    
    /**
     * Whether to sort in ascending order.
     * 
     * @return true to sort in ascending order, false to sort in descending order
     */
    boolean ascending() default true;
    
    /**
     * The maximum number of rows to include.
     * 
     * @return The maximum number of rows
     */
    int limit() default -1;
    
    /**
     * The number of rows to skip.
     * 
     * @return The number of rows to skip
     */
    int offset() default 0;
    
    /**
     * The column mappings.
     * Format: "sourceColumn:targetParameter"
     * Example: "firstName:name" maps the "firstName" column to the "name" parameter
     * 
     * @return The column mappings
     */
    String[] columnMappings() default {};
    
    /**
     * The test instances to run (applicable for TestNG).
     * 
     * @return The test instances
     */
    String[] testInstances() default {};
    
    /**
     * Whether to skip empty rows.
     * 
     * @return true to skip empty rows, false otherwise
     */
    boolean skipEmpty() default true;
    
    /**
     * Whether to skip null values.
     * 
     * @return true to skip null values, false otherwise
     */
    boolean skipNull() default false;
    
    /**
     * Whether to skip test on error.
     * 
     * @return true to skip the test if an error occurs, false otherwise
     */
    boolean skipOnError() default false;
    
    /**
     * Whether to fail the test on error.
     * 
     * @return true to fail the test if an error occurs, false otherwise
     */
    boolean failOnError() default true;
    
    /**
     * Whether to run tests in parallel.
     * 
     * @return true to run tests in parallel, false otherwise
     */
    boolean parallel() default false;
    
    /**
     * The number of threads for parallel execution.
     * 
     * @return The number of threads
     */
    int threads() default 1;
    
    /**
     * Whether to provide data isolation for parallel execution.
     * 
     * @return true to provide data isolation, false otherwise
     */
    boolean dataIsolation() default true;
    
    /**
     * The environment to use for the data source.
     * 
     * @return The environment
     */
    String environment() default "";
    
    /**
     * Whether to cache the data source.
     * 
     * @return true to cache the data source, false otherwise
     */
    boolean cache() default true;
    
    /**
     * The data transformation class.
     * 
     * @return The data transformation class
     */
    Class<?> transformer() default void.class;
    
    /**
     * The data validation class.
     * 
     * @return The data validation class
     */
    Class<?> validator() default void.class;
    
    /**
     * The dependency groups.
     * 
     * @return The dependency groups
     */
    String[] groups() default {};
    
    /**
     * The dependency methods.
     * 
     * @return The dependency methods
     */
    String[] dependsOnMethods() default {};
    
    /**
     * The description.
     * 
     * @return The description
     */
    String description() default "";
    
    /**
     * The test name format.
     * Example: "Test with data: {0} and {1}"
     * 
     * @return The test name format
     */
    String nameFormat() default "";
    
    /**
     * Whether to generate only one test per data row.
     * 
     * @return true to generate only one test per data row, false otherwise
     */
    boolean oneTestPerRow() default true;
    
    /**
     * Whether to generate data provider documentation.
     * 
     * @return true to generate documentation, false otherwise
     */
    boolean generateDoc() default false;
    
    /**
     * The path for data provider documentation.
     * 
     * @return The documentation path
     */
    String docPath() default "";
    
    /**
     * The format for data provider documentation.
     * 
     * @return The documentation format
     */
    String docFormat() default "markdown";
    
    /**
     * Custom parameters for the data source.
     * Format: "key:value"
     * Example: "separator:;" or "timeFormat:HH:mm:ss"
     * 
     * @return The custom parameters
     */
    String[] parameters() default {};
}

